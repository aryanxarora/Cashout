/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(rsc)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Client = __webpack_require__(/*! ./lib/client */ \"(rsc)/./node_modules/undici/lib/client.js\");\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher.js\");\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst Pool = __webpack_require__(/*! ./lib/pool */ \"(rsc)/./node_modules/undici/lib/pool.js\");\nconst BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ \"(rsc)/./node_modules/undici/lib/balanced-pool.js\");\nconst Agent = __webpack_require__(/*! ./lib/agent */ \"(rsc)/./node_modules/undici/lib/agent.js\");\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError } = errors;\nconst api = __webpack_require__(/*! ./lib/api */ \"(rsc)/./node_modules/undici/lib/api/index.js\");\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\");\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(rsc)/./node_modules/undici/lib/mock/mock-agent.js\");\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ \"(rsc)/./node_modules/undici/lib/proxy-agent.js\");\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(rsc)/./node_modules/undici/lib/global.js\");\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/DecoratorHandler */ \"(rsc)/./node_modules/undici/lib/handler/DecoratorHandler.js\");\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/RedirectHandler */ \"(rsc)/./node_modules/undici/lib/handler/RedirectHandler.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirectInterceptor */ \"(rsc)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nlet hasCrypto;\ntry {\n    __webpack_require__(/*! crypto */ \"crypto\");\n    hasCrypto = true;\n} catch  {\n    hasCrypto = false;\n}\nObject.assign(Dispatcher.prototype, api);\nmodule.exports.Dispatcher = Dispatcher;\nmodule.exports.Client = Client;\nmodule.exports.Pool = Pool;\nmodule.exports.BalancedPool = BalancedPool;\nmodule.exports.Agent = Agent;\nmodule.exports.ProxyAgent = ProxyAgent;\nmodule.exports.DecoratorHandler = DecoratorHandler;\nmodule.exports.RedirectHandler = RedirectHandler;\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor;\nmodule.exports.buildConnector = buildConnector;\nmodule.exports.errors = errors;\nfunction makeDispatcher(fn) {\n    return (url, opts, handler)=>{\n        if (typeof opts === \"function\") {\n            handler = opts;\n            opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n            throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n            if (typeof opts.path !== \"string\") {\n                throw new InvalidArgumentError(\"invalid opts.path\");\n            }\n            let path = opts.path;\n            if (!opts.path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            url = new URL(util.parseOrigin(url).origin + path);\n        } else {\n            if (!opts) {\n                opts = typeof url === \"object\" ? url : {};\n            }\n            url = util.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n            throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n            ...opts,\n            origin: url.origin,\n            path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n            method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n    };\n}\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher;\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher;\nif (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {\n    let fetchImpl = null;\n    module.exports.fetch = async function fetch(resource) {\n        if (!fetchImpl) {\n            fetchImpl = (__webpack_require__(/*! ./lib/fetch */ \"(rsc)/./node_modules/undici/lib/fetch/index.js\").fetch);\n        }\n        try {\n            return await fetchImpl(...arguments);\n        } catch (err) {\n            if (typeof err === \"object\") {\n                Error.captureStackTrace(err, this);\n            }\n            throw err;\n        }\n    };\n    module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\").Headers;\n    module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ \"(rsc)/./node_modules/undici/lib/fetch/response.js\").Response;\n    module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ \"(rsc)/./node_modules/undici/lib/fetch/request.js\").Request;\n    module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ \"(rsc)/./node_modules/undici/lib/fetch/formdata.js\").FormData;\n    module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ \"(rsc)/./node_modules/undici/lib/fetch/file.js\").File;\n    module.exports.FileReader = __webpack_require__(/*! ./lib/fileapi/filereader */ \"(rsc)/./node_modules/undici/lib/fileapi/filereader.js\").FileReader;\n    const { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/fetch/global */ \"(rsc)/./node_modules/undici/lib/fetch/global.js\");\n    module.exports.setGlobalOrigin = setGlobalOrigin;\n    module.exports.getGlobalOrigin = getGlobalOrigin;\n    const { CacheStorage } = __webpack_require__(/*! ./lib/cache/cachestorage */ \"(rsc)/./node_modules/undici/lib/cache/cachestorage.js\");\n    const { kConstruct } = __webpack_require__(/*! ./lib/cache/symbols */ \"(rsc)/./node_modules/undici/lib/cache/symbols.js\");\n    // Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n    // in an older version of Node, it doesn't have any use without fetch.\n    module.exports.caches = new CacheStorage(kConstruct);\n}\nif (util.nodeMajor >= 16) {\n    const { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/cookies */ \"(rsc)/./node_modules/undici/lib/cookies/index.js\");\n    module.exports.deleteCookie = deleteCookie;\n    module.exports.getCookies = getCookies;\n    module.exports.getSetCookies = getSetCookies;\n    module.exports.setCookie = setCookie;\n    const { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/fetch/dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\n    module.exports.parseMIMEType = parseMIMEType;\n    module.exports.serializeAMimeType = serializeAMimeType;\n}\nif (util.nodeMajor >= 18 && hasCrypto) {\n    const { WebSocket } = __webpack_require__(/*! ./lib/websocket/websocket */ \"(rsc)/./node_modules/undici/lib/websocket/websocket.js\");\n    module.exports.WebSocket = WebSocket;\n}\nmodule.exports.request = makeDispatcher(api.request);\nmodule.exports.stream = makeDispatcher(api.stream);\nmodule.exports.pipeline = makeDispatcher(api.pipeline);\nmodule.exports.connect = makeDispatcher(api.connect);\nmodule.exports.upgrade = makeDispatcher(api.upgrade);\nmodule.exports.MockClient = MockClient;\nmodule.exports.MockPool = MockPool;\nmodule.exports.MockAgent = MockAgent;\nmodule.exports.mockErrors = mockErrors;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDckIsTUFBTUksZUFBZUosbUJBQU9BLENBQUM7QUFDN0IsTUFBTUssUUFBUUwsbUJBQU9BLENBQUM7QUFDdEIsTUFBTU0sT0FBT04sbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFTyxvQkFBb0IsRUFBRSxHQUFHTDtBQUNqQyxNQUFNTSxNQUFNUixtQkFBT0EsQ0FBQztBQUNwQixNQUFNUyxpQkFBaUJULG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1VLGFBQWFWLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1XLFlBQVlYLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1ZLFdBQVdaLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1hLGFBQWFiLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1jLGFBQWFkLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRWUsbUJBQW1CLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdoQixtQkFBT0EsQ0FBQztBQUM3RCxNQUFNaUIsbUJBQW1CakIsbUJBQU9BLENBQUM7QUFDakMsTUFBTWtCLGtCQUFrQmxCLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1tQiw0QkFBNEJuQixtQkFBT0EsQ0FBQztBQUUxQyxJQUFJb0I7QUFDSixJQUFJO0lBQ0ZwQixtQkFBT0EsQ0FBQztJQUNSb0IsWUFBWTtBQUNkLEVBQUUsT0FBTTtJQUNOQSxZQUFZO0FBQ2Q7QUFFQUMsT0FBT0MsTUFBTSxDQUFDckIsV0FBV3NCLFNBQVMsRUFBRWY7QUFFcENnQix5QkFBeUIsR0FBR3ZCO0FBQzVCdUIscUJBQXFCLEdBQUd6QjtBQUN4QnlCLG1CQUFtQixHQUFHckI7QUFDdEJxQiwyQkFB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T0EsQ0FBQztJQUNqQyxNQUFNLEVBQUU4RCxVQUFVLEVBQUUsR0FBRzlELG1CQUFPQSxDQUFDO0lBRS9CLDBFQUEwRTtJQUMxRSxzRUFBc0U7SUFDdEV3QixxQkFBcUIsR0FBRyxJQUFJcUMsYUFBYUM7QUFDM0M7QUFFQSxJQUFJeEQsS0FBS3NDLFNBQVMsSUFBSSxJQUFJO0lBQ3hCLE1BQU0sRUFBRW9CLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxhQUFhLEVBQUVDLFNBQVMsRUFBRSxHQUFHbkUsbUJBQU9BLENBQUM7SUFFdkV3QiwyQkFBMkIsR0FBR3dDO0lBQzlCeEMseUJBQXlCLEdBQUd5QztJQUM1QnpDLDRCQUE0QixHQUFHMEM7SUFDL0IxQyx3QkFBd0IsR0FBRzJDO0lBRTNCLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHckUsbUJBQU9BLENBQUM7SUFFdER3Qiw0QkFBNEIsR0FBRzRDO0lBQy9CNUMsaUNBQWlDLEdBQUc2QztBQUN0QztBQUVBLElBQUkvRCxLQUFLc0MsU0FBUyxJQUFJLE1BQU14QixXQUFXO0lBQ3JDLE1BQU0sRUFBRWtELFNBQVMsRUFBRSxHQUFHdEUsbUJBQU9BLENBQUM7SUFFOUJ3Qix3QkFBd0IsR0FBRzhDO0FBQzdCO0FBRUE5QyxzQkFBc0IsR0FBR0UsZUFBZWxCLElBQUkrRCxPQUFPO0FBQ25EL0MscUJBQXFCLEdBQUdFLGVBQWVsQixJQUFJZ0UsTUFBTTtBQUNqRGhELHVCQUF1QixHQUFHRSxlQUFlbEIsSUFBSWlFLFFBQVE7QUFDckRqRCxzQkFBc0IsR0FBR0UsZUFBZWxCLElBQUlrRSxPQUFPO0FBQ25EbEQsc0JBQXNCLEdBQUdFLGVBQWVsQixJQUFJbUUsT0FBTztBQUVuRG5ELHlCQUF5QixHQUFHZDtBQUM1QmMsdUJBQXVCLEdBQUdaO0FBQzFCWSx3QkFBd0IsR0FBR2I7QUFDM0JhLHlCQUF5QixHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qcz8xMjRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9jbGllbnQnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvY29yZS9lcnJvcnMnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vbGliL3Bvb2wnKVxuY29uc3QgQmFsYW5jZWRQb29sID0gcmVxdWlyZSgnLi9saWIvYmFsYW5jZWQtcG9vbCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2FnZW50JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2xpYi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2xpYi9hcGknKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Nvbm5lY3QnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja0FnZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWFnZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLXBvb2wnKVxuY29uc3QgbW9ja0Vycm9ycyA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1lcnJvcnMnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL3Byb3h5LWFnZW50JylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciwgc2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9saWIvZ2xvYmFsJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXInKVxuY29uc3QgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9SZWRpcmVjdEhhbmRsZXInKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0SW50ZXJjZXB0b3InKVxuXG5sZXQgaGFzQ3J5cHRvXG50cnkge1xuICByZXF1aXJlKCdjcnlwdG8nKVxuICBoYXNDcnlwdG8gPSB0cnVlXG59IGNhdGNoIHtcbiAgaGFzQ3J5cHRvID0gZmFsc2Vcbn1cblxuT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKVxuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Qb29sID0gUG9vbFxubW9kdWxlLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sXG5tb2R1bGUuZXhwb3J0cy5BZ2VudCA9IEFnZW50XG5tb2R1bGUuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudFxuXG5tb2R1bGUuZXhwb3J0cy5EZWNvcmF0b3JIYW5kbGVyID0gRGVjb3JhdG9ySGFuZGxlclxubW9kdWxlLmV4cG9ydHMuUmVkaXJlY3RIYW5kbGVyID0gUmVkaXJlY3RIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxuXG5tb2R1bGUuZXhwb3J0cy5idWlsZENvbm5lY3RvciA9IGJ1aWxkQ29ubmVjdG9yXG5tb2R1bGUuZXhwb3J0cy5lcnJvcnMgPSBlcnJvcnNcblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIgKGZuKSB7XG4gIHJldHVybiAodXJsLCBvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyID0gb3B0c1xuICAgICAgb3B0cyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzLnBhdGgnKVxuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IG9wdHMucGF0aFxuICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgICB9XG5cbiAgICAgIHVybCA9IG5ldyBVUkwodXRpbC5wYXJzZU9yaWdpbih1cmwpLm9yaWdpbiArIHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyB1cmwgOiB7fVxuICAgICAgfVxuXG4gICAgICB1cmwgPSB1dGlsLnBhcnNlVVJMKHVybClcbiAgICB9XG5cbiAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzXG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgb3B0cy5hZ2VudC4gRGlkIHlvdSBtZWFuIG9wdHMuY2xpZW50PycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IChvcHRzLmJvZHkgPyAnUFVUJyA6ICdHRVQnKVxuICAgIH0sIGhhbmRsZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyXG5cbmlmICh1dGlsLm5vZGVNYWpvciA+IDE2IHx8ICh1dGlsLm5vZGVNYWpvciA9PT0gMTYgJiYgdXRpbC5ub2RlTWlub3IgPj0gOCkpIHtcbiAgbGV0IGZldGNoSW1wbCA9IG51bGxcbiAgbW9kdWxlLmV4cG9ydHMuZmV0Y2ggPSBhc3luYyBmdW5jdGlvbiBmZXRjaCAocmVzb3VyY2UpIHtcbiAgICBpZiAoIWZldGNoSW1wbCkge1xuICAgICAgZmV0Y2hJbXBsID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gnKS5mZXRjaFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKC4uLmFyZ3VtZW50cylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMpXG4gICAgICB9XG5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5IZWFkZXJzID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvaGVhZGVycycpLkhlYWRlcnNcbiAgbW9kdWxlLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9yZXNwb25zZScpLlJlc3BvbnNlXG4gIG1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9mZXRjaC9yZXF1ZXN0JykuUmVxdWVzdFxuICBtb2R1bGUuZXhwb3J0cy5Gb3JtRGF0YSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2Zvcm1kYXRhJykuRm9ybURhdGFcbiAgbW9kdWxlLmV4cG9ydHMuRmlsZSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2ZpbGUnKS5GaWxlXG4gIG1vZHVsZS5leHBvcnRzLkZpbGVSZWFkZXIgPSByZXF1aXJlKCcuL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyXG5cbiAgY29uc3QgeyBzZXRHbG9iYWxPcmlnaW4sIGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9saWIvZmV0Y2gvZ2xvYmFsJylcblxuICBtb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxPcmlnaW4gPSBzZXRHbG9iYWxPcmlnaW5cbiAgbW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsT3JpZ2luID0gZ2V0R2xvYmFsT3JpZ2luXG5cbiAgY29uc3QgeyBDYWNoZVN0b3JhZ2UgfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlL2NhY2hlc3RvcmFnZScpXG4gIGNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUvc3ltYm9scycpXG5cbiAgLy8gQ2FjaGUgJiBDYWNoZVN0b3JhZ2UgYXJlIHRpZ2h0bHkgY291cGxlZCB3aXRoIGZldGNoLiBFdmVuIGlmIGl0IG1heSBydW5cbiAgLy8gaW4gYW4gb2xkZXIgdmVyc2lvbiBvZiBOb2RlLCBpdCBkb2Vzbid0IGhhdmUgYW55IHVzZSB3aXRob3V0IGZldGNoLlxuICBtb2R1bGUuZXhwb3J0cy5jYWNoZXMgPSBuZXcgQ2FjaGVTdG9yYWdlKGtDb25zdHJ1Y3QpXG59XG5cbmlmICh1dGlsLm5vZGVNYWpvciA+PSAxNikge1xuICBjb25zdCB7IGRlbGV0ZUNvb2tpZSwgZ2V0Q29va2llcywgZ2V0U2V0Q29va2llcywgc2V0Q29va2llIH0gPSByZXF1aXJlKCcuL2xpYi9jb29raWVzJylcblxuICBtb2R1bGUuZXhwb3J0cy5kZWxldGVDb29raWUgPSBkZWxldGVDb29raWVcbiAgbW9kdWxlLmV4cG9ydHMuZ2V0Q29va2llcyA9IGdldENvb2tpZXNcbiAgbW9kdWxlLmV4cG9ydHMuZ2V0U2V0Q29va2llcyA9IGdldFNldENvb2tpZXNcbiAgbW9kdWxlLmV4cG9ydHMuc2V0Q29va2llID0gc2V0Q29va2llXG5cbiAgY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL2ZldGNoL2RhdGFVUkwnKVxuXG4gIG1vZHVsZS5leHBvcnRzLnBhcnNlTUlNRVR5cGUgPSBwYXJzZU1JTUVUeXBlXG4gIG1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUFNaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZVxufVxuXG5pZiAodXRpbC5ub2RlTWFqb3IgPj0gMTggJiYgaGFzQ3J5cHRvKSB7XG4gIGNvbnN0IHsgV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0JylcblxuICBtb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5yZXF1ZXN0KVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gbWFrZURpc3BhdGNoZXIoYXBpLnN0cmVhbSlcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gbWFrZURpc3BhdGNoZXIoYXBpLnBpcGVsaW5lKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5jb25uZWN0KVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS51cGdyYWRlKVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2xpZW50ID0gTW9ja0NsaWVudFxubW9kdWxlLmV4cG9ydHMuTW9ja1Bvb2wgPSBNb2NrUG9vbFxubW9kdWxlLmV4cG9ydHMuTW9ja0FnZW50ID0gTW9ja0FnZW50XG5tb2R1bGUuZXhwb3J0cy5tb2NrRXJyb3JzID0gbW9ja0Vycm9yc1xuIl0sIm5hbWVzIjpbIkNsaWVudCIsInJlcXVpcmUiLCJEaXNwYXRjaGVyIiwiZXJyb3JzIiwiUG9vbCIsIkJhbGFuY2VkUG9vbCIsIkFnZW50IiwidXRpbCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiYXBpIiwiYnVpbGRDb25uZWN0b3IiLCJNb2NrQ2xpZW50IiwiTW9ja0FnZW50IiwiTW9ja1Bvb2wiLCJtb2NrRXJyb3JzIiwiUHJveHlBZ2VudCIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJzZXRHbG9iYWxEaXNwYXRjaGVyIiwiRGVjb3JhdG9ySGFuZGxlciIsIlJlZGlyZWN0SGFuZGxlciIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJoYXNDcnlwdG8iLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwibWFrZURpc3BhdGNoZXIiLCJmbiIsInVybCIsIm9wdHMiLCJoYW5kbGVyIiwiVVJMIiwicGF0aCIsInN0YXJ0c1dpdGgiLCJwYXJzZU9yaWdpbiIsIm9yaWdpbiIsInBhcnNlVVJMIiwiYWdlbnQiLCJkaXNwYXRjaGVyIiwiY2FsbCIsInNlYXJjaCIsInBhdGhuYW1lIiwibWV0aG9kIiwiYm9keSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsImZldGNoSW1wbCIsImZldGNoIiwicmVzb3VyY2UiLCJhcmd1bWVudHMiLCJlcnIiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiSGVhZGVycyIsIlJlc3BvbnNlIiwiUmVxdWVzdCIsIkZvcm1EYXRhIiwiRmlsZSIsIkZpbGVSZWFkZXIiLCJzZXRHbG9iYWxPcmlnaW4iLCJnZXRHbG9iYWxPcmlnaW4iLCJDYWNoZVN0b3JhZ2UiLCJrQ29uc3RydWN0IiwiY2FjaGVzIiwiZGVsZXRlQ29va2llIiwiZ2V0Q29va2llcyIsImdldFNldENvb2tpZXMiLCJzZXRDb29raWUiLCJwYXJzZU1JTUVUeXBlIiwic2VyaWFsaXplQU1pbWVUeXBlIiwiV2ViU29ja2V0IiwicmVxdWVzdCIsInN0cmVhbSIsInBpcGVsaW5lIiwiY29ubmVjdCIsInVwZ3JhZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/agent.js":
/*!******************************************!*\
  !*** ./node_modules/undici/lib/agent.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/pool.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/client.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(rsc)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ \"(rsc)/./node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kMaxRedirections = Symbol(\"maxRedirections\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kFactory = Symbol(\"factory\");\nconst kFinalizer = Symbol(\"finalizer\");\nconst kOptions = Symbol(\"options\");\nfunction defaultFactory(origin, opts) {\n    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){\n        super();\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n            connect = {\n                ...connect\n            };\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = new Map();\n        this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ (key)=>{\n            const ref = this[kClients].get(key);\n            if (ref !== undefined && ref.deref() === undefined) {\n                this[kClients].delete(key);\n            }\n        });\n        const agent = this;\n        this[kOnDrain] = (origin, targets)=>{\n            agent.emit(\"drain\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            agent.emit(\"connect\", origin, [\n                agent,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            agent.emit(\"disconnect\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            agent.emit(\"connectionError\", origin, [\n                agent,\n                ...targets\n            ], err);\n        };\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore next: gc is undeterministic */ if (client) {\n                ret += client[kRunning];\n            }\n        }\n        return ret;\n    }\n    [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n            key = String(opts.origin);\n        } else {\n            throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        const ref = this[kClients].get(key);\n        let dispatcher = ref ? ref.deref() : null;\n        if (!dispatcher) {\n            dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n            this[kClients].set(key, new WeakRef(dispatcher));\n            this[kFinalizer].register(dispatcher, key);\n        }\n        return dispatcher.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        const closePromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                closePromises.push(client.close());\n            }\n        }\n        await Promise.all(closePromises);\n    }\n    async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const ref of this[kClients].values()){\n            const client = ref.deref();\n            /* istanbul ignore else: gc is undeterministic */ if (client) {\n                destroyPromises.push(client.destroy(err));\n            }\n        }\n        await Promise.all(destroyPromises);\n    }\n}\nmodule.exports = Agent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsYUFBYSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ25GLE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFDL0IsTUFBTVEsT0FBT1IsbUJBQU9BLENBQUM7QUFDckIsTUFBTVMsU0FBU1QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTVUsT0FBT1YsbUJBQU9BLENBQUM7QUFDckIsTUFBTVcsNEJBQTRCWCxtQkFBT0EsQ0FBQztBQUMxQyxNQUFNLEVBQUVZLE9BQU8sRUFBRUMsb0JBQW9CLEVBQUUsR0FBR2IsbUJBQU9BLENBQUM7QUFFbEQsTUFBTWMsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxnQkFBZ0JELE9BQU87QUFDN0IsTUFBTUUscUJBQXFCRixPQUFPO0FBQ2xDLE1BQU1HLG1CQUFtQkgsT0FBTztBQUNoQyxNQUFNSSxXQUFXSixPQUFPO0FBQ3hCLE1BQU1LLFdBQVdMLE9BQU87QUFDeEIsTUFBTU0sYUFBYU4sT0FBTztBQUMxQixNQUFNTyxXQUFXUCxPQUFPO0FBRXhCLFNBQVNRLGVBQWdCQyxNQUFNLEVBQUVDLElBQUk7SUFDbkMsT0FBT0EsUUFBUUEsS0FBS0MsV0FBVyxLQUFLLElBQ2hDLElBQUlqQixPQUFPZSxRQUFRQyxRQUNuQixJQUFJakIsS0FBS2dCLFFBQVFDO0FBQ3ZCO0FBRUEsTUFBTUUsY0FBY3BCO0lBQ2xCcUIsWUFBYSxFQUFFQyxVQUFVTixjQUFjLEVBQUVPLGtCQUFrQixDQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFHQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDeEYsS0FBSztRQUVMLElBQUksT0FBT0gsWUFBWSxZQUFZO1lBQ2pDLE1BQU0sSUFBSTlCLHFCQUFxQjtRQUNqQztRQUVBLElBQUlnQyxXQUFXLFFBQVEsT0FBT0EsWUFBWSxjQUFjLE9BQU9BLFlBQVksVUFBVTtZQUNuRixNQUFNLElBQUloQyxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNrQyxPQUFPQyxTQUFTLENBQUNKLG9CQUFvQkEsa0JBQWtCLEdBQUc7WUFDN0QsTUFBTSxJQUFJL0IscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSWdDLFdBQVcsT0FBT0EsWUFBWSxZQUFZO1lBQzVDQSxVQUFVO2dCQUFFLEdBQUdBLE9BQU87WUFBQztRQUN6QjtRQUVBLElBQUksQ0FBQ3pCLGNBQWMsR0FBRzBCLFFBQVFHLFlBQVksSUFBSUgsUUFBUUcsWUFBWSxDQUFDUixLQUFLLElBQUlTLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUcsWUFBWSxDQUFDUixLQUFLLElBQ2hISyxRQUFRRyxZQUFZLENBQUNSLEtBQUssR0FDMUI7WUFBQ2hCLDBCQUEwQjtnQkFBRW1CO1lBQWdCO1NBQUc7UUFFcEQsSUFBSSxDQUFDUixTQUFTLEdBQUc7WUFBRSxHQUFHWixLQUFLNEIsU0FBUyxDQUFDTixRQUFRO1lBQUVEO1FBQVE7UUFDdkQsSUFBSSxDQUFDVCxTQUFTLENBQUNhLFlBQVksR0FBR0gsUUFBUUcsWUFBWSxHQUM5QztZQUFFLEdBQUdILFFBQVFHLFlBQVk7UUFBQyxJQUMxQkk7UUFDSixJQUFJLENBQUNyQixpQkFBaUIsR0FBR1k7UUFDekIsSUFBSSxDQUFDVixTQUFTLEdBQUdTO1FBQ2pCLElBQUksQ0FBQzVCLFNBQVMsR0FBRyxJQUFJdUM7UUFDckIsSUFBSSxDQUFDbkIsV0FBVyxHQUFHLElBQUlSLHFCQUFxQiwrQ0FBK0MsR0FBRzRCLENBQUFBO1lBQzVGLE1BQU1DLE1BQU0sSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsR0FBRyxDQUFDRjtZQUMvQixJQUFJQyxRQUFRSCxhQUFhRyxJQUFJRSxLQUFLLE9BQU9MLFdBQVc7Z0JBQ2xELElBQUksQ0FBQ3RDLFNBQVMsQ0FBQzRDLE1BQU0sQ0FBQ0o7WUFDeEI7UUFDRjtRQUVBLE1BQU1LLFFBQVEsSUFBSTtRQUVsQixJQUFJLENBQUMzQixTQUFTLEdBQUcsQ0FBQ0ssUUFBUXVCO1lBQ3hCRCxNQUFNRSxJQUFJLENBQUMsU0FBU3hCLFFBQVE7Z0JBQUNzQjttQkFBVUM7YUFBUTtRQUNqRDtRQUVBLElBQUksQ0FBQ2pDLFdBQVcsR0FBRyxDQUFDVSxRQUFRdUI7WUFDMUJELE1BQU1FLElBQUksQ0FBQyxXQUFXeEIsUUFBUTtnQkFBQ3NCO21CQUFVQzthQUFRO1FBQ25EO1FBRUEsSUFBSSxDQUFDL0IsY0FBYyxHQUFHLENBQUNRLFFBQVF1QixTQUFTRTtZQUN0Q0gsTUFBTUUsSUFBSSxDQUFDLGNBQWN4QixRQUFRO2dCQUFDc0I7bUJBQVVDO2FBQVEsRUFBRUU7UUFDeEQ7UUFFQSxJQUFJLENBQUNoQyxtQkFBbUIsR0FBRyxDQUFDTyxRQUFRdUIsU0FBU0U7WUFDM0NILE1BQU1FLElBQUksQ0FBQyxtQkFBbUJ4QixRQUFRO2dCQUFDc0I7bUJBQVVDO2FBQVEsRUFBRUU7UUFDN0Q7SUFDRjtJQUVBLElBQUksQ0FBQy9DLFNBQVMsR0FBSTtRQUNoQixJQUFJZ0QsTUFBTTtRQUNWLEtBQUssTUFBTVIsT0FBTyxJQUFJLENBQUN6QyxTQUFTLENBQUNrRCxNQUFNLEdBQUk7WUFDekMsTUFBTUMsU0FBU1YsSUFBSUUsS0FBSztZQUN4QiwrQ0FBK0MsR0FDL0MsSUFBSVEsUUFBUTtnQkFDVkYsT0FBT0UsTUFBTSxDQUFDbEQsU0FBUztZQUN6QjtRQUNGO1FBQ0EsT0FBT2dEO0lBQ1Q7SUFFQSxDQUFDN0MsVUFBVSxDQUFFb0IsSUFBSSxFQUFFNEIsT0FBTyxFQUFFO1FBQzFCLElBQUlaO1FBQ0osSUFBSWhCLEtBQUtELE1BQU0sSUFBSyxRQUFPQyxLQUFLRCxNQUFNLEtBQUssWUFBWUMsS0FBS0QsTUFBTSxZQUFZOEIsR0FBRSxHQUFJO1lBQ2xGYixNQUFNYyxPQUFPOUIsS0FBS0QsTUFBTTtRQUMxQixPQUFPO1lBQ0wsTUFBTSxJQUFJekIscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTTJDLE1BQU0sSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsR0FBRyxDQUFDRjtRQUUvQixJQUFJZSxhQUFhZCxNQUFNQSxJQUFJRSxLQUFLLEtBQUs7UUFDckMsSUFBSSxDQUFDWSxZQUFZO1lBQ2ZBLGFBQWEsSUFBSSxDQUFDcEMsU0FBUyxDQUFDSyxLQUFLRCxNQUFNLEVBQUUsSUFBSSxDQUFDRixTQUFTLEVBQ3BEbUMsRUFBRSxDQUFDLFNBQVMsSUFBSSxDQUFDdEMsU0FBUyxFQUMxQnNDLEVBQUUsQ0FBQyxXQUFXLElBQUksQ0FBQzNDLFdBQVcsRUFDOUIyQyxFQUFFLENBQUMsY0FBYyxJQUFJLENBQUN6QyxjQUFjLEVBQ3BDeUMsRUFBRSxDQUFDLG1CQUFtQixJQUFJLENBQUN4QyxtQkFBbUI7WUFFakQsSUFBSSxDQUFDaEIsU0FBUyxDQUFDeUQsR0FBRyxDQUFDakIsS0FBSyxJQUFJN0IsUUFBUTRDO1lBQ3BDLElBQUksQ0FBQ25DLFdBQVcsQ0FBQ3NDLFFBQVEsQ0FBQ0gsWUFBWWY7UUFDeEM7UUFFQSxPQUFPZSxXQUFXSSxRQUFRLENBQUNuQyxNQUFNNEI7SUFDbkM7SUFFQSxNQUFNLENBQUNsRCxPQUFPLEdBQUk7UUFDaEIsTUFBTTBELGdCQUFnQixFQUFFO1FBQ3hCLEtBQUssTUFBTW5CLE9BQU8sSUFBSSxDQUFDekMsU0FBUyxDQUFDa0QsTUFBTSxHQUFJO1lBQ3pDLE1BQU1DLFNBQVNWLElBQUlFLEtBQUs7WUFDeEIsK0NBQStDLEdBQy9DLElBQUlRLFFBQVE7Z0JBQ1ZTLGNBQWNDLElBQUksQ0FBQ1YsT0FBT1csS0FBSztZQUNqQztRQUNGO1FBRUEsTUFBTUMsUUFBUUMsR0FBRyxDQUFDSjtJQUNwQjtJQUVBLE1BQU0sQ0FBQ3pELFNBQVMsQ0FBRTZDLEdBQUcsRUFBRTtRQUNyQixNQUFNaUIsa0JBQWtCLEVBQUU7UUFDMUIsS0FBSyxNQUFNeEIsT0FBTyxJQUFJLENBQUN6QyxTQUFTLENBQUNrRCxNQUFNLEdBQUk7WUFDekMsTUFBTUMsU0FBU1YsSUFBSUUsS0FBSztZQUN4QiwrQ0FBK0MsR0FDL0MsSUFBSVEsUUFBUTtnQkFDVmMsZ0JBQWdCSixJQUFJLENBQUNWLE9BQU9lLE9BQU8sQ0FBQ2xCO1lBQ3RDO1FBQ0Y7UUFFQSxNQUFNZSxRQUFRQyxHQUFHLENBQUNDO0lBQ3BCO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FnZW50LmpzPzQ2NzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrQ2xpZW50cywga1J1bm5pbmcsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yJylcbmNvbnN0IHsgV2Vha1JlZiwgRmluYWxpemF0aW9uUmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4vY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZicpKClcblxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtNYXhSZWRpcmVjdGlvbnMgPSBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpXG5jb25zdCBrT25EcmFpbiA9IFN5bWJvbCgnb25EcmFpbicpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5jb25zdCBrRmluYWxpemVyID0gU3ltYm9sKCdmaW5hbGl6ZXInKVxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIG9wdHMuY29ubmVjdGlvbnMgPT09IDFcbiAgICA/IG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxuICAgIDogbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCBtYXhSZWRpcmVjdGlvbnMgPSAwLCBjb25uZWN0LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRpb25zLmludGVyY2VwdG9ycyAmJiBvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaW50ZXJjZXB0b3JzLkFnZW50KVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudFxuICAgICAgOiBbY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvcih7IG1heFJlZGlyZWN0aW9ucyB9KV1cblxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgY29ubmVjdCB9XG4gICAgdGhpc1trT3B0aW9uc10uaW50ZXJjZXB0b3JzID0gb3B0aW9ucy5pbnRlcmNlcHRvcnNcbiAgICAgID8geyAuLi5vcHRpb25zLmludGVyY2VwdG9ycyB9XG4gICAgICA6IHVuZGVmaW5lZFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcbiAgICB0aGlzW2tDbGllbnRzXSA9IG5ldyBNYXAoKVxuICAgIHRoaXNba0ZpbmFsaXplcl0gPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGdjIGlzIHVuZGV0ZXJtaW5pc3RpYyAqLyBrZXkgPT4ge1xuICAgICAgY29uc3QgcmVmID0gdGhpc1trQ2xpZW50c10uZ2V0KGtleSlcbiAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLmRlbGV0ZShrZXkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGFnZW50ID0gdGhpc1xuXG4gICAgdGhpc1trT25EcmFpbl0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBhZ2VudC5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgYWdlbnQuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW2FnZW50LCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBhZ2VudC5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbYWdlbnQsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBhZ2VudC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFthZ2VudCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xpZW50ID0gcmVmLmRlcmVmKClcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBnYyBpcyB1bmRldGVybWluaXN0aWMgKi9cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgcmV0ICs9IGNsaWVudFtrUnVubmluZ11cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBsZXQga2V5XG4gICAgaWYgKG9wdHMub3JpZ2luICYmICh0eXBlb2Ygb3B0cy5vcmlnaW4gPT09ICdzdHJpbmcnIHx8IG9wdHMub3JpZ2luIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAga2V5ID0gU3RyaW5nKG9wdHMub3JpZ2luKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMub3JpZ2luIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIFVSTC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG5cbiAgICBsZXQgZGlzcGF0Y2hlciA9IHJlZiA/IHJlZi5kZXJlZigpIDogbnVsbFxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9wdHMub3JpZ2luLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgICAgLm9uKCdkcmFpbicsIHRoaXNba09uRHJhaW5dKVxuICAgICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgICAub24oJ2Nvbm5lY3Rpb25FcnJvcicsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSlcblxuICAgICAgdGhpc1trQ2xpZW50c10uc2V0KGtleSwgbmV3IFdlYWtSZWYoZGlzcGF0Y2hlcikpXG4gICAgICB0aGlzW2tGaW5hbGl6ZXJdLnJlZ2lzdGVyKGRpc3BhdGNoZXIsIGtleSlcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGNvbnN0IGNsb3NlUHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSByZWYuZGVyZWYoKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGdjIGlzIHVuZGV0ZXJtaW5pc3RpYyAqL1xuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICBjbG9zZVByb21pc2VzLnB1c2goY2xpZW50LmNsb3NlKCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcylcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCByZWYgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHJlZi5kZXJlZigpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZ2MgaXMgdW5kZXRlcm1pbmlzdGljICovXG4gICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgIGRlc3Ryb3lQcm9taXNlcy5wdXNoKGNsaWVudC5kZXN0cm95KGVycikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzdHJveVByb21pc2VzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnRcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsInJlcXVpcmUiLCJrQ2xpZW50cyIsImtSdW5uaW5nIiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJrSW50ZXJjZXB0b3JzIiwiRGlzcGF0Y2hlckJhc2UiLCJQb29sIiwiQ2xpZW50IiwidXRpbCIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJXZWFrUmVmIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJrT25Db25uZWN0IiwiU3ltYm9sIiwia09uRGlzY29ubmVjdCIsImtPbkNvbm5lY3Rpb25FcnJvciIsImtNYXhSZWRpcmVjdGlvbnMiLCJrT25EcmFpbiIsImtGYWN0b3J5Iiwia0ZpbmFsaXplciIsImtPcHRpb25zIiwiZGVmYXVsdEZhY3RvcnkiLCJvcmlnaW4iLCJvcHRzIiwiY29ubmVjdGlvbnMiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwiZmFjdG9yeSIsIm1heFJlZGlyZWN0aW9ucyIsImNvbm5lY3QiLCJvcHRpb25zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVlcENsb25lIiwidW5kZWZpbmVkIiwiTWFwIiwia2V5IiwicmVmIiwiZ2V0IiwiZGVyZWYiLCJkZWxldGUiLCJhZ2VudCIsInRhcmdldHMiLCJlbWl0IiwiZXJyIiwicmV0IiwidmFsdWVzIiwiY2xpZW50IiwiaGFuZGxlciIsIlVSTCIsIlN0cmluZyIsImRpc3BhdGNoZXIiLCJvbiIsInNldCIsInJlZ2lzdGVyIiwiZGlzcGF0Y2giLCJjbG9zZVByb21pc2VzIiwicHVzaCIsImNsb3NlIiwiUHJvbWlzZSIsImFsbCIsImRlc3Ryb3lQcm9taXNlcyIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst kListener = Symbol(\"kListener\");\nconst kSignal = Symbol(\"kSignal\");\nfunction abort(self) {\n    if (self.abort) {\n        self.abort();\n    } else {\n        self.onError(new RequestAbortedError());\n    }\n}\nfunction addSignal(self, signal) {\n    self[kSignal] = null;\n    self[kListener] = null;\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        abort(self);\n        return;\n    }\n    self[kSignal] = signal;\n    self[kListener] = ()=>{\n        abort(self);\n    };\n    addAbortListener(self[kSignal], self[kListener]);\n}\nfunction removeSignal(self) {\n    if (!self[kSignal]) {\n        return;\n    }\n    if (\"removeEventListener\" in self[kSignal]) {\n        self[kSignal].removeEventListener(\"abort\", self[kListener]);\n    } else {\n        self[kSignal].removeListener(\"abort\", self[kListener]);\n    }\n    self[kSignal] = null;\n    self[kListener] = null;\n}\nmodule.exports = {\n    addSignal,\n    removeSignal\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsZ0JBQWdCLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDckMsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNRSxZQUFZQyxPQUFPO0FBQ3pCLE1BQU1DLFVBQVVELE9BQU87QUFFdkIsU0FBU0UsTUFBT0MsSUFBSTtJQUNsQixJQUFJQSxLQUFLRCxLQUFLLEVBQUU7UUFDZEMsS0FBS0QsS0FBSztJQUNaLE9BQU87UUFDTEMsS0FBS0MsT0FBTyxDQUFDLElBQUlOO0lBQ25CO0FBQ0Y7QUFFQSxTQUFTTyxVQUFXRixJQUFJLEVBQUVHLE1BQU07SUFDOUJILElBQUksQ0FBQ0YsUUFBUSxHQUFHO0lBQ2hCRSxJQUFJLENBQUNKLFVBQVUsR0FBRztJQUVsQixJQUFJLENBQUNPLFFBQVE7UUFDWDtJQUNGO0lBRUEsSUFBSUEsT0FBT0MsT0FBTyxFQUFFO1FBQ2xCTCxNQUFNQztRQUNOO0lBQ0Y7SUFFQUEsSUFBSSxDQUFDRixRQUFRLEdBQUdLO0lBQ2hCSCxJQUFJLENBQUNKLFVBQVUsR0FBRztRQUNoQkcsTUFBTUM7SUFDUjtJQUVBUCxpQkFBaUJPLElBQUksQ0FBQ0YsUUFBUSxFQUFFRSxJQUFJLENBQUNKLFVBQVU7QUFDakQ7QUFFQSxTQUFTUyxhQUFjTCxJQUFJO0lBQ3pCLElBQUksQ0FBQ0EsSUFBSSxDQUFDRixRQUFRLEVBQUU7UUFDbEI7SUFDRjtJQUVBLElBQUkseUJBQXlCRSxJQUFJLENBQUNGLFFBQVEsRUFBRTtRQUMxQ0UsSUFBSSxDQUFDRixRQUFRLENBQUNRLG1CQUFtQixDQUFDLFNBQVNOLElBQUksQ0FBQ0osVUFBVTtJQUM1RCxPQUFPO1FBQ0xJLElBQUksQ0FBQ0YsUUFBUSxDQUFDUyxjQUFjLENBQUMsU0FBU1AsSUFBSSxDQUFDSixVQUFVO0lBQ3ZEO0lBRUFJLElBQUksQ0FBQ0YsUUFBUSxHQUFHO0lBQ2hCRSxJQUFJLENBQUNKLFVBQVUsR0FBRztBQUNwQjtBQUVBWSxPQUFPQyxPQUFPLEdBQUc7SUFDZlA7SUFDQUc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qcz82M2I0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jb25zdCBrTGlzdGVuZXIgPSBTeW1ib2woJ2tMaXN0ZW5lcicpXG5jb25zdCBrU2lnbmFsID0gU3ltYm9sKCdrU2lnbmFsJylcblxuZnVuY3Rpb24gYWJvcnQgKHNlbGYpIHtcbiAgaWYgKHNlbGYuYWJvcnQpIHtcbiAgICBzZWxmLmFib3J0KClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLm9uRXJyb3IobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbImFkZEFib3J0TGlzdGVuZXIiLCJyZXF1aXJlIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsImtMaXN0ZW5lciIsIlN5bWJvbCIsImtTaWduYWwiLCJhYm9ydCIsInNlbGYiLCJvbkVycm9yIiwiYWRkU2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsInJlbW92ZVNpZ25hbCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\");\nclass ConnectHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        removeSignal(this);\n        this.callback = null;\n        let headers = rawHeaders;\n        // Indicates is an HTTP2Session\n        if (headers != null) {\n            headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        }\n        this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction connect(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            connect.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: \"CONNECT\"\n        }, connectHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGFBQWEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVDLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzNFLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFFNUMsTUFBTU8sdUJBQXVCUjtJQUMzQlMsWUFBYUMsSUFBSSxFQUFFQyxRQUFRLENBQUU7UUFDM0IsSUFBSSxDQUFDRCxRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUNyQyxNQUFNLElBQUlSLHFCQUFxQjtRQUNqQztRQUVBLElBQUksT0FBT1MsYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSVQscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFVSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFLEdBQUdKO1FBRTVDLElBQUlFLFVBQVUsT0FBT0EsT0FBT0csRUFBRSxLQUFLLGNBQWMsT0FBT0gsT0FBT0ksZ0JBQWdCLEtBQUssWUFBWTtZQUM5RixNQUFNLElBQUlkLHFCQUFxQjtRQUNqQztRQUVBLEtBQUssQ0FBQztRQUVOLElBQUksQ0FBQ1csTUFBTSxHQUFHQSxVQUFVO1FBQ3hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHQSxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDSCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ00sS0FBSyxHQUFHO1FBRWJYLFVBQVUsSUFBSSxFQUFFTTtJQUNsQjtJQUVBTSxVQUFXRCxLQUFLLEVBQUVFLE9BQU8sRUFBRTtRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDUixRQUFRLEVBQUU7WUFDbEIsTUFBTSxJQUFJUjtRQUNaO1FBRUEsSUFBSSxDQUFDYyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRSxPQUFPLEdBQUdBO0lBQ2pCO0lBRUFDLFlBQWE7UUFDWCxNQUFNLElBQUloQixZQUFZLGVBQWU7SUFDdkM7SUFFQWlCLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUU7UUFDekMsTUFBTSxFQUFFYixRQUFRLEVBQUVFLE1BQU0sRUFBRU0sT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUUxQ1osYUFBYSxJQUFJO1FBRWpCLElBQUksQ0FBQ0ksUUFBUSxHQUFHO1FBRWhCLElBQUljLFVBQVVGO1FBQ2QsK0JBQStCO1FBQy9CLElBQUlFLFdBQVcsTUFBTTtZQUNuQkEsVUFBVSxJQUFJLENBQUNYLGVBQWUsS0FBSyxRQUFRVCxLQUFLcUIsZUFBZSxDQUFDSCxjQUFjbEIsS0FBS3NCLFlBQVksQ0FBQ0o7UUFDbEc7UUFFQSxJQUFJLENBQUNLLGVBQWUsQ0FBQ2pCLFVBQVUsTUFBTSxNQUFNO1lBQ3pDVztZQUNBRztZQUNBRDtZQUNBWDtZQUNBTTtRQUNGO0lBQ0Y7SUFFQVUsUUFBU0MsR0FBRyxFQUFFO1FBQ1osTUFBTSxFQUFFbkIsUUFBUSxFQUFFRSxNQUFNLEVBQUUsR0FBRyxJQUFJO1FBRWpDTixhQUFhLElBQUk7UUFFakIsSUFBSUksVUFBVTtZQUNaLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1lBQ2hCb0IsZUFBZTtnQkFDYixJQUFJLENBQUNILGVBQWUsQ0FBQ2pCLFVBQVUsTUFBTW1CLEtBQUs7b0JBQUVqQjtnQkFBTztZQUNyRDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNtQixRQUFTdEIsSUFBSSxFQUFFQyxRQUFRO0lBQzlCLElBQUlBLGFBQWFzQixXQUFXO1FBQzFCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQkosUUFBUUssSUFBSSxDQUFDLElBQUksRUFBRTNCLE1BQU0sQ0FBQ29CLEtBQUtRO2dCQUM3QixPQUFPUixNQUFNTSxPQUFPTixPQUFPSyxRQUFRRztZQUNyQztRQUNGO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YsTUFBTUMsaUJBQWlCLElBQUkvQixlQUFlRSxNQUFNQztRQUNoRCxJQUFJLENBQUM2QixRQUFRLENBQUM7WUFBRSxHQUFHOUIsSUFBSTtZQUFFK0IsUUFBUTtRQUFVLEdBQUdGO0lBQ2hELEVBQUUsT0FBT1QsS0FBSztRQUNaLElBQUksT0FBT25CLGFBQWEsWUFBWTtZQUNsQyxNQUFNbUI7UUFDUjtRQUNBLE1BQU1qQixTQUFTSCxRQUFRQSxLQUFLRyxNQUFNO1FBQ2xDa0IsZUFBZSxJQUFNcEIsU0FBU21CLEtBQUs7Z0JBQUVqQjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQTZCLE9BQU9DLE9BQU8sR0FBR1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktY29ubmVjdC5qcz9lZTJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgQ29ubmVjdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9DT05ORUNUJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCBjb25uZWN0JywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG5cbiAgICBsZXQgaGVhZGVycyA9IHJhd0hlYWRlcnNcbiAgICAvLyBJbmRpY2F0ZXMgaXMgYW4gSFRUUDJTZXNzaW9uXG4gICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB9XG5cbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gbmV3IENvbm5lY3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6ICdDT05ORUNUJyB9LCBjb25uZWN0SGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdFxuIl0sIm5hbWVzIjpbIkFzeW5jUmVzb3VyY2UiLCJyZXF1aXJlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiU29ja2V0RXJyb3IiLCJ1dGlsIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiQ29ubmVjdEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJjYWxsYmFjayIsInNpZ25hbCIsIm9wYXF1ZSIsInJlc3BvbnNlSGVhZGVycyIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0Iiwib25Db25uZWN0IiwiY29udGV4dCIsIm9uSGVhZGVycyIsIm9uVXBncmFkZSIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwic29ja2V0IiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInJ1bkluQXN5bmNTY29wZSIsIm9uRXJyb3IiLCJlcnIiLCJxdWV1ZU1pY3JvdGFzayIsImNvbm5lY3QiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwiY29ubmVjdEhhbmRsZXIiLCJkaXNwYXRjaCIsIm1ldGhvZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Readable, Duplex, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kResume = Symbol(\"resume\");\nclass PipelineRequest extends Readable {\n    constructor(){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n            this[kResume] = null;\n            resume();\n        }\n    }\n    _destroy(err, callback) {\n        this._read();\n        callback(err);\n    }\n}\nclass PipelineResponse extends Readable {\n    constructor(resume){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = resume;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        callback(err);\n    }\n}\nclass PipelineHandler extends AsyncResource {\n    constructor(opts, handler){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n            throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util.nop);\n        this.ret = new Duplex({\n            readableObjectMode: opts.objectMode,\n            autoDestroy: true,\n            read: ()=>{\n                const { body } = this;\n                if (body && body.resume) {\n                    body.resume();\n                }\n            },\n            write: (chunk, encoding, callback)=>{\n                const { req } = this;\n                if (req.push(chunk, encoding) || req._readableState.destroyed) {\n                    callback();\n                } else {\n                    req[kResume] = callback;\n                }\n            },\n            destroy: (err, callback)=>{\n                const { body, req, res, ret, abort } = this;\n                if (!err && !ret._readableState.endEmitted) {\n                    err = new RequestAbortedError();\n                }\n                if (abort && err) {\n                    abort();\n                }\n                util.destroy(body, err);\n                util.destroy(req, err);\n                util.destroy(res, err);\n                removeSignal(this);\n                callback(err);\n            }\n        }).on(\"prefinish\", ()=>{\n            const { req } = this;\n            // Node < 15 does not call _final in same tick.\n            req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        const { ret, res } = this;\n        assert(!res, \"pipeline cannot be retried\");\n        if (ret.destroyed) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context } = this;\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n            this.handler = null;\n            const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n            body = this.runInAsyncScope(handler, null, {\n                statusCode,\n                headers,\n                opaque,\n                body: this.res,\n                context\n            });\n        } catch (err) {\n            this.res.on(\"error\", util.nop);\n            throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n            throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk)=>{\n            const { ret, body } = this;\n            if (!ret.push(chunk) && body.pause) {\n                body.pause();\n            }\n        }).on(\"error\", (err)=>{\n            const { ret } = this;\n            util.destroy(ret, err);\n        }).on(\"end\", ()=>{\n            const { ret } = this;\n            ret.push(null);\n        }).on(\"close\", ()=>{\n            const { ret } = this;\n            if (!ret._readableState.ended) {\n                util.destroy(ret, new RequestAbortedError());\n            }\n        });\n        this.body = body;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n    }\n    onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util.destroy(ret, err);\n    }\n}\nfunction pipeline(opts, handler) {\n    try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({\n            ...opts,\n            body: pipelineHandler.req\n        }, pipelineHandler);\n        return pipelineHandler.ret;\n    } catch (err) {\n        return new PassThrough().destroy(err);\n    }\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsV0FBVyxFQUNaLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLHVCQUF1QixFQUN2QkMsbUJBQW1CLEVBQ3BCLEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSyxhQUFhLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTSxTQUFTLEVBQUVDLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUM1QyxNQUFNUSxTQUFTUixtQkFBT0EsQ0FBQztBQUV2QixNQUFNUyxVQUFVQyxPQUFPO0FBRXZCLE1BQU1DLHdCQUF3QmQ7SUFDNUJlLGFBQWU7UUFDYixLQUFLLENBQUM7WUFBRUMsYUFBYTtRQUFLO1FBRTFCLElBQUksQ0FBQ0osUUFBUSxHQUFHO0lBQ2xCO0lBRUFLLFFBQVM7UUFDUCxNQUFNLEVBQUUsQ0FBQ0wsUUFBUSxFQUFFTSxNQUFNLEVBQUUsR0FBRyxJQUFJO1FBRWxDLElBQUlBLFFBQVE7WUFDVixJQUFJLENBQUNOLFFBQVEsR0FBRztZQUNoQk07UUFDRjtJQUNGO0lBRUFDLFNBQVVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0osS0FBSztRQUVWSSxTQUFTRDtJQUNYO0FBQ0Y7QUFFQSxNQUFNRSx5QkFBeUJ0QjtJQUM3QmUsWUFBYUcsTUFBTSxDQUFFO1FBQ25CLEtBQUssQ0FBQztZQUFFRixhQUFhO1FBQUs7UUFDMUIsSUFBSSxDQUFDSixRQUFRLEdBQUdNO0lBQ2xCO0lBRUFELFFBQVM7UUFDUCxJQUFJLENBQUNMLFFBQVE7SUFDZjtJQUVBTyxTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixJQUFJ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Q0FBQ1YsS0FBS25CO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTNkMsU0FBVXZDLElBQUksRUFBRUMsT0FBTztJQUM5QixJQUFJO1FBQ0YsTUFBTXVDLGtCQUFrQixJQUFJekMsZ0JBQWdCQyxNQUFNQztRQUNsRCxJQUFJLENBQUN3QyxRQUFRLENBQUM7WUFBRSxHQUFHekMsSUFBSTtZQUFFaUIsTUFBTXVCLGdCQUFnQjdCLEdBQUc7UUFBQyxHQUFHNkI7UUFDdEQsT0FBT0EsZ0JBQWdCM0IsR0FBRztJQUM1QixFQUFFLE9BQU9uQixLQUFLO1FBQ1osT0FBTyxJQUFJbEIsY0FBYytDLE9BQU8sQ0FBQzdCO0lBQ25DO0FBQ0Y7QUFFQWdELE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcGlwZWxpbmUuanM/MjM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBSZWFkYWJsZSxcbiAgRHVwbGV4LFxuICBQYXNzVGhyb3VnaFxufSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdhc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBrUmVzdW1lID0gU3ltYm9sKCdyZXN1bWUnKVxuXG5jbGFzcyBQaXBlbGluZVJlcXVlc3QgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIGNvbnN0IHsgW2tSZXN1bWVdOiByZXN1bWUgfSA9IHRoaXNcblxuICAgIGlmIChyZXN1bWUpIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gICAgICByZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVhZCgpXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVSZXNwb25zZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHJlc3VtZSkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcbiAgICB0aGlzW2tSZXN1bWVdID0gcmVzdW1lXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgdGhpc1trUmVzdW1lXSgpXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhhbmRsZXInKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9QSVBFTElORScpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG5cbiAgICB0aGlzLnJlcSA9IG5ldyBQaXBlbGluZVJlcXVlc3QoKS5vbignZXJyb3InLCB1dGlsLm5vcClcblxuICAgIHRoaXMucmV0ID0gbmV3IER1cGxleCh7XG4gICAgICByZWFkYWJsZU9iamVjdE1vZGU6IG9wdHMub2JqZWN0TW9kZSxcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoYm9keSAmJiBib2R5LnJlc3VtZSkge1xuICAgICAgICAgIGJvZHkucmVzdW1lKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChyZXEucHVzaChjaHVuaywgZW5jb2RpbmcpIHx8IHJlcS5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxW2tSZXN1bWVdID0gY2FsbGJhY2tcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IChlcnIsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSwgcmVxLCByZXMsIHJldCwgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIWVyciAmJiAhcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWJvcnQgJiYgZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG5cbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgIH0pLm9uKCdwcmVmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAvLyBOb2RlIDwgMTUgZG9lcyBub3QgY2FsbCBfZmluYWwgaW4gc2FtZSB0aWNrLlxuICAgICAgcmVxLnB1c2gobnVsbClcbiAgICB9KVxuXG4gICAgdGhpcy5yZXMgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcmV0LCByZXMgfSA9IHRoaXNcblxuICAgIGFzc2VydCghcmVzLCAncGlwZWxpbmUgY2Fubm90IGJlIHJldHJpZWQnKVxuXG4gICAgaWYgKHJldC5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSkge1xuICAgIGNvbnN0IHsgb3BhcXVlLCBoYW5kbGVyLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5yZXMgPSBuZXcgUGlwZWxpbmVSZXNwb25zZShyZXN1bWUpXG5cbiAgICBsZXQgYm9keVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmhhbmRsZXIgPSBudWxsXG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgYm9keSA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGhhbmRsZXIsIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBib2R5OiB0aGlzLnJlcyxcbiAgICAgICAgY29udGV4dFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMucmVzLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5Lm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFJlYWRhYmxlJylcbiAgICB9XG5cbiAgICBib2R5XG4gICAgICAub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQsIGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5LnBhdXNlKSB7XG4gICAgICAgICAgYm9keS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICByZXQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKG9wdHMsIGhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKVxuICAgIHJldHVybiBwaXBlbGluZUhhbmRsZXIucmV0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lXG4iXSwibmFtZXMiOlsiUmVhZGFibGUiLCJEdXBsZXgiLCJQYXNzVGhyb3VnaCIsInJlcXVpcmUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsInV0aWwiLCJBc3luY1Jlc291cmNlIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiYXNzZXJ0Iiwia1Jlc3VtZSIsIlN5bWJvbCIsIlBpcGVsaW5lUmVxdWVzdCIsImNvbnN0cnVjdG9yIiwiYXV0b0Rlc3Ryb3kiLCJfcmVhZCIsInJlc3VtZSIsIl9kZXN0cm95IiwiZXJyIiwiY2FsbGJhY2siLCJQaXBlbGluZVJlc3BvbnNlIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwiUGlwZWxpbmVIYW5kbGVyIiwib3B0cyIsImhhbmRsZXIiLCJzaWduYWwiLCJtZXRob2QiLCJvcGFxdWUiLCJvbkluZm8iLCJyZXNwb25zZUhlYWRlcnMiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsImNvbnRleHQiLCJyZXEiLCJub3AiLCJyZXQiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJvYmplY3RNb2RlIiwicmVhZCIsImJvZHkiLCJ3cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJwdXNoIiwiZGVzdHJveWVkIiwiZGVzdHJveSIsInJlcyIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInJ1bkluQXN5bmNTY29wZSIsInBhdXNlIiwiZW5kZWQiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwidHJhaWxlcnMiLCJvbkVycm9yIiwicGlwZWxpbmUiLCJwaXBlbGluZUhhbmRsZXIiLCJkaXNwYXRjaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Readable = __webpack_require__(/*! ./readable */ \"(rsc)/./node_modules/undici/lib/api/readable.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\");\nclass RequestHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (highWaterMark && (typeof highWaterMark !== \"number\" || highWaterMark < 0)) {\n                throw new InvalidArgumentError(\"invalid highWaterMark\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_REQUEST\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        this.highWaterMark = highWaterMark;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n        const contentType = parsedHeaders[\"content-type\"];\n        const body = new Readable({\n            resume,\n            abort,\n            contentType,\n            highWaterMark\n        });\n        this.callback = null;\n        this.res = body;\n        if (callback !== null) {\n            if (this.throwOnError && statusCode >= 400) {\n                this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                    callback,\n                    body,\n                    contentType,\n                    statusCode,\n                    statusMessage,\n                    headers\n                });\n            } else {\n                this.runInAsyncScope(callback, null, null, {\n                    statusCode,\n                    headers,\n                    trailers: this.trailers,\n                    opaque,\n                    body,\n                    context\n                });\n            }\n        }\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        util.parseHeaders(trailers, this.trailers);\n        res.push(null);\n    }\n    onError(err) {\n        const { res, callback, body, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            // TODO: Does this need queueMicrotask?\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (res) {\n            this.res = null;\n            // Ensure all queued handlers are invoked before destroying res.\n            queueMicrotask(()=>{\n                util.destroy(res, err);\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction request(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            request.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new RequestHandler(opts, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQ0pDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ3BCLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ1osTUFBTUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSSwyQkFBMkIsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUNoRCxNQUFNLEVBQUVLLGFBQWEsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVNLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBRTVDLE1BQU1RLHVCQUF1Qkg7SUFDM0JJLFlBQWFDLElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxPQUFPQSxTQUFTLFVBQVU7WUFDckMsTUFBTSxJQUFJVCxxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUVXLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFLEdBQUdUO1FBRS9GLElBQUk7WUFDRixJQUFJLE9BQU9DLGFBQWEsWUFBWTtnQkFDbEMsTUFBTSxJQUFJVixxQkFBcUI7WUFDakM7WUFFQSxJQUFJa0IsaUJBQWtCLFFBQU9BLGtCQUFrQixZQUFZQSxnQkFBZ0IsSUFBSTtnQkFDN0UsTUFBTSxJQUFJbEIscUJBQXFCO1lBQ2pDO1lBRUEsSUFBSVcsVUFBVSxPQUFPQSxPQUFPUSxFQUFFLEtBQUssY0FBYyxPQUFPUixPQUFPUyxnQkFBZ0IsS0FBSyxZQUFZO2dCQUM5RixNQUFNLElBQUlwQixxQkFBcUI7WUFDakM7WUFFQSxJQUFJWSxXQUFXLFdBQVc7Z0JBQ3hCLE1BQU0sSUFBSVoscUJBQXFCO1lBQ2pDO1lBRUEs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O1FBQ0EsTUFBTVIsU0FBU0osUUFBUUEsS0FBS0ksTUFBTTtRQUNsQ2lDLGVBQWUsSUFBTXBDLFNBQVNXLEtBQUs7Z0JBQUVSO1lBQU87SUFDOUM7QUFDRjtBQUVBMEMsT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzPzk1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBSZXF1ZXN0SGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yLCBoaWdoV2F0ZXJNYXJrIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayAmJiAodHlwZW9mIGhpZ2hXYXRlck1hcmsgIT09ICdudW1iZXInIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGlnaFdhdGVyTWFyaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9SRVFVRVNUJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIHV0aWwubm9wKSwgZXJyKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnRyYWlsZXJzID0ge31cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdGhyb3dPbkVycm9yXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFya1xuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIGJvZHkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBhYm9ydCwgY29udGV4dCwgcmVzcG9uc2VIZWFkZXJzLCBoaWdoV2F0ZXJNYXJrIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICBjb25zdCBib2R5ID0gbmV3IFJlYWRhYmxlKHsgcmVzdW1lLCBhYm9ydCwgY29udGVudFR5cGUsIGhpZ2hXYXRlck1hcmsgfSlcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgdGhpcy5yZXMgPSBib2R5XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICAgIHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgdHJhaWxlcnM6IHRoaXMudHJhaWxlcnMsXG4gICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJldHVybiByZXMucHVzaChjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdXRpbC5wYXJzZUhlYWRlcnModHJhaWxlcnMsIHRoaXMudHJhaWxlcnMpXG5cbiAgICByZXMucHVzaChudWxsKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBib2R5LCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCBxdWV1ZU1pY3JvdGFzaz9cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgLy8gRW5zdXJlIGFsbCBxdWV1ZWQgaGFuZGxlcnMgYXJlIGludm9rZWQgYmVmb3JlIGRlc3Ryb3lpbmcgcmVzLlxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXF1ZXN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFJlcXVlc3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHMgJiYgb3B0cy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdFxuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwicmVxdWlyZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsInV0aWwiLCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2siLCJBc3luY1Jlc291cmNlIiwiYWRkU2lnbmFsIiwicmVtb3ZlU2lnbmFsIiwiUmVxdWVzdEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJjYWxsYmFjayIsInNpZ25hbCIsIm1ldGhvZCIsIm9wYXF1ZSIsImJvZHkiLCJvbkluZm8iLCJyZXNwb25zZUhlYWRlcnMiLCJ0aHJvd09uRXJyb3IiLCJoaWdoV2F0ZXJNYXJrIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiZXJyIiwiaXNTdHJlYW0iLCJkZXN0cm95Iiwibm9wIiwicmVzIiwiYWJvcnQiLCJ0cmFpbGVycyIsImNvbnRleHQiLCJvbkVycm9yIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJyZXN1bWUiLCJzdGF0dXNNZXNzYWdlIiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInBhcnNlZEhlYWRlcnMiLCJjb250ZW50VHlwZSIsInJ1bkluQXN5bmNTY29wZSIsIm9uRGF0YSIsImNodW5rIiwicHVzaCIsIm9uQ29tcGxldGUiLCJxdWV1ZU1pY3JvdGFzayIsInJlcXVlc3QiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { finished, PassThrough } = __webpack_require__(/*! stream */ \"stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\");\nclass StreamHandler extends AsyncResource {\n    constructor(opts, factory, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (typeof factory !== \"function\") {\n                throw new InvalidArgumentError(\"invalid factory\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_STREAM\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError || false;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { factory, opaque, context, callback, responseHeaders } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.factory = null;\n        let res;\n        if (this.throwOnError && statusCode >= 400) {\n            const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n            const contentType = parsedHeaders[\"content-type\"];\n            res = new PassThrough();\n            this.callback = null;\n            this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback,\n                body: res,\n                contentType,\n                statusCode,\n                statusMessage,\n                headers\n            });\n        } else {\n            if (factory === null) {\n                return;\n            }\n            res = this.runInAsyncScope(factory, null, {\n                statusCode,\n                headers,\n                opaque,\n                context\n            });\n            if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n                throw new InvalidReturnValueError(\"expected Writable\");\n            }\n            // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n            finished(res, {\n                readable: false\n            }, (err)=>{\n                const { callback, res, opaque, trailers, abort } = this;\n                this.res = null;\n                if (err || !res.readable) {\n                    util.destroy(res, err);\n                }\n                this.callback = null;\n                this.runInAsyncScope(callback, null, err || null, {\n                    opaque,\n                    trailers\n                });\n                if (err) {\n                    abort();\n                }\n            });\n        }\n        res.on(\"drain\", resume);\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n        return needDrain !== true;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res ? res.write(chunk) : true;\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        if (!res) {\n            return;\n        }\n        this.trailers = util.parseHeaders(trailers);\n        res.end();\n    }\n    onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n            this.res = null;\n            util.destroy(res, err);\n        } else if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction stream(opts, factory, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            stream.call(this, opts, factory, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsUUFBUSxFQUFFQyxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDMUMsTUFBTSxFQUNKQyxvQkFBb0IsRUFDcEJDLHVCQUF1QixFQUN2QkMsbUJBQW1CLEVBQ3BCLEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSywyQkFBMkIsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNoRCxNQUFNLEVBQUVNLGFBQWEsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVPLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRTVDLE1BQU1TLHNCQUFzQkg7SUFDMUJJLFlBQWFDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDcEMsSUFBSSxDQUFDRixRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUNyQyxNQUFNLElBQUlWLHFCQUFxQjtRQUNqQztRQUVBLE1BQU0sRUFBRWEsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsWUFBWSxFQUFFLEdBQUdUO1FBRWhGLElBQUk7WUFDRixJQUFJLE9BQU9FLGFBQWEsWUFBWTtnQkFDbEMsTUFBTSxJQUFJWixxQkFBcUI7WUFDakM7WUFFQSxJQUFJLE9BQU9XLFlBQVksWUFBWTtnQkFDakMsTUFBTSxJQUFJWCxxQkFBcUI7WUFDakM7WUFFQSxJQUFJYSxVQUFVLE9BQU9BLE9BQU9PLEVBQUUsS0FBSyxjQUFjLE9BQU9QLE9BQU9RLGdCQUFnQixLQUFLLFlBQVk7Z0JBQzlGLE1BQU0sSUFBSXJCLHFCQUFxQjtZQUNqQztZQUVBLElBQUljLFdBQVcsV0FBVztnQkFDeEIsTUFBTSxJQUFJZCxxQkFB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SUFBSSxFQUFFLEdBQUcsSUFBSTtRQUU1Q1QsYUFBYSxJQUFJO1FBRWpCLElBQUksQ0FBQ0ksT0FBTyxHQUFHO1FBRWYsSUFBSWUsS0FBSztZQUNQLElBQUksQ0FBQ0EsR0FBRyxHQUFHO1lBQ1h2QixLQUFLcUIsT0FBTyxDQUFDRSxLQUFLSjtRQUNwQixPQUFPLElBQUlWLFVBQVU7WUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEJ5QyxlQUFlO2dCQUNiLElBQUksQ0FBQ1gsZUFBZSxDQUFDOUIsVUFBVSxNQUFNVSxLQUFLO29CQUFFUDtnQkFBTztZQUNyRDtRQUNGO1FBRUEsSUFBSUMsTUFBTTtZQUNSLElBQUksQ0FBQ0EsSUFBSSxHQUFHO1lBQ1piLEtBQUtxQixPQUFPLENBQUNSLE1BQU1NO1FBQ3JCO0lBQ0Y7QUFDRjtBQUVBLFNBQVNnQyxPQUFRNUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDdEMsSUFBSUEsYUFBYW9DLFdBQVc7UUFDMUIsT0FBTyxJQUFJTyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCSCxPQUFPSSxJQUFJLENBQUMsSUFBSSxFQUFFaEQsTUFBTUMsU0FBUyxDQUFDVyxLQUFLcUM7Z0JBQ3JDLE9BQU9yQyxNQUFNbUMsT0FBT25DLE9BQU9rQyxRQUFRRztZQUNyQztRQUNGO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YsSUFBSSxDQUFDQyxRQUFRLENBQUNsRCxNQUFNLElBQUlGLGNBQWNFLE1BQU1DLFNBQVNDO0lBQ3ZELEVBQUUsT0FBT1UsS0FBSztRQUNaLElBQUksT0FBT1YsYUFBYSxZQUFZO1lBQ2xDLE1BQU1VO1FBQ1I7UUFDQSxNQUFNUCxTQUFTTCxRQUFRQSxLQUFLSyxNQUFNO1FBQ2xDc0MsZUFBZSxJQUFNekMsU0FBU1UsS0FBSztnQkFBRVA7WUFBTztJQUM5QztBQUNGO0FBRUE4QyxPQUFPQyxPQUFPLEdBQUdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcz8zYWM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGZpbmlzaGVkLCBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnYXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBTdHJlYW1IYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCB0aHJvd09uRXJyb3IgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZmFjdG9yeScpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9TVFJFQU0nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgdXRpbC5ub3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuZmFjdG9yeSA9IGZhY3RvcnlcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLnRyYWlsZXJzID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgfHwgZmFsc2VcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgZmFjdG9yeSwgb3BhcXVlLCBjb250ZXh0LCBjYWxsYmFjaywgcmVzcG9uc2VIZWFkZXJzIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBsZXQgcmVzXG5cbiAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycykgOiBoZWFkZXJzXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICByZXMgPSBuZXcgUGFzc1Rocm91Z2goKVxuXG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICB7IGNhbGxiYWNrLCBib2R5OiByZXMsIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhY3RvcnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGZhY3RvcnksIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuXG4gICAgICBpZiAoXG4gICAgICAgICFyZXMgfHxcbiAgICAgICAgdHlwZW9mIHJlcy53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLmVuZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLm9uICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKCdleHBlY3RlZCBXcml0YWJsZScpXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEF2b2lkIGZpbmlzaGVkLiBJdCByZWdpc3RlcnMgYW4gdW5uZWNlc3NhcnkgYW1vdW50IG9mIGxpc3RlbmVycy5cbiAgICAgIGZpbmlzaGVkKHJlcywgeyByZWFkYWJsZTogZmFsc2UgfSwgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCByZXMsIG9wYXF1ZSwgdHJhaWxlcnMsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAgIGlmIChlcnIgfHwgIXJlcy5yZWFkYWJsZSkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWUsIHRyYWlsZXJzIH0pXG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXMub24oJ2RyYWluJywgcmVzdW1lKVxuXG4gICAgdGhpcy5yZXMgPSByZXNcblxuICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHJlcy53cml0YWJsZU5lZWREcmFpblxuICAgICAgOiByZXMuX3dyaXRhYmxlU3RhdGUgJiYgcmVzLl93cml0YWJsZVN0YXRlLm5lZWREcmFpblxuXG4gICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gcmVzID8gcmVzLndyaXRlKGNodW5rKSA6IHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycylcblxuICAgIHJlcy5lbmQoKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmVhbSAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFN0cmVhbUhhbmRsZXIob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cbiJdLCJuYW1lcyI6WyJmaW5pc2hlZCIsIlBhc3NUaHJvdWdoIiwicmVxdWlyZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW52YWxpZFJldHVyblZhbHVlRXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwidXRpbCIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayIsIkFzeW5jUmVzb3VyY2UiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJTdHJlYW1IYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiZmFjdG9yeSIsImNhbGxiYWNrIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwiYm9keSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInRocm93T25FcnJvciIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVyciIsImlzU3RyZWFtIiwiZGVzdHJveSIsIm5vcCIsInJlcyIsImFib3J0IiwiY29udGV4dCIsInRyYWlsZXJzIiwib25FcnJvciIsIm9uQ29ubmVjdCIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZWRIZWFkZXJzIiwiY29udGVudFR5cGUiLCJydW5JbkFzeW5jU2NvcGUiLCJ3cml0ZSIsImVuZCIsInJlYWRhYmxlIiwibmVlZERyYWluIiwid3JpdGFibGVOZWVkRHJhaW4iLCJ1bmRlZmluZWQiLCJfd3JpdGFibGVTdGF0ZSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInF1ZXVlTWljcm90YXNrIiwic3RyZWFtIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImRpc3BhdGNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { AsyncResource } = __webpack_require__(/*! async_hooks */ \"async_hooks\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nclass UpgradeHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (!this.callback) {\n            throw new RequestAbortedError();\n        }\n        this.abort = abort;\n        this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction upgrade(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            upgrade.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: opts.method || \"GET\",\n            upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts && opts.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = upgrade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNFLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUcsU0FBUyxFQUFFQyxZQUFZLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDNUMsTUFBTUssU0FBU0wsbUJBQU9BLENBQUM7QUFFdkIsTUFBTU0sdUJBQXVCTDtJQUMzQk0sWUFBYUMsSUFBSSxFQUFFQyxRQUFRLENBQUU7UUFDM0IsSUFBSSxDQUFDRCxRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUNyQyxNQUFNLElBQUlYLHFCQUFxQjtRQUNqQztRQUVBLElBQUksT0FBT1ksYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSVoscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFYSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFLEdBQUdKO1FBRTVDLElBQUlFLFVBQVUsT0FBT0EsT0FBT0csRUFBRSxLQUFLLGNBQWMsT0FBT0gsT0FBT0ksZ0JBQWdCLEtBQUssWUFBWTtZQUM5RixNQUFNLElBQUlqQixxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNlLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0QsTUFBTSxHQUFHQSxVQUFVO1FBQ3hCLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBRWZiLFVBQVUsSUFBSSxFQUFFTztJQUNsQjtJQUVBTyxVQUFXRixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDUCxRQUFRLEVBQUU7WUFDbEIsTUFBTSxJQUFJWDtRQUNaO1FBRUEsSUFBSSxDQUFDaUIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2pCO0lBRUFFLFlBQWE7UUFDWCxNQUFNLElBQUluQixZQUFZLGVBQWU7SUFDdkM7SUFFQW9CLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUU7UUFDekMsTUFBTSxFQUFFYixRQUFRLEVBQUVFLE1BQU0sRUFBRUssT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUUxQ1gsT0FBT2tCLFdBQVcsQ0FBQ0gsWUFBWTtRQUUvQmhCLGFBQWEsSUFBSTtRQUVqQixJQUFJLENBQUNLLFFBQVEsR0FBRztRQUNoQixNQUFNZSxVQUFVLElBQUksQ0FBQ1osZUFBZSxLQUFLLFFBQVFWLEtBQUt1QixlQUFlLENBQUNKLGNBQWNuQixLQUFLd0IsWUFBWSxDQUFDTDtRQUN0RyxJQUFJLENBQUNNLGVBQWUsQ0FBQ2xCLFVBQVUsTUFBTSxNQUFNO1lBQ3pDZTtZQUNBRjtZQUNBWDtZQUNBSztRQUNGO0lBQ0Y7SUFFQVksUUFBU0MsR0FBRyxFQUFFO1FBQ1osTUFBTSxFQUFFcEIsUUFBUSxFQUFFRSxNQUFNLEVBQUUsR0FBRyxJQUFJO1FBRWpDUCxhQUFhLElBQUk7UUFFakIsSUFBSUssVUFBVTtZQUNaLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1lBQ2hCcUIsZUFBZTtnQkFDYixJQUFJLENBQUNILGVBQWUsQ0FBQ2xCLFVBQVUsTUFBTW9CLEtBQUs7b0JBQUVsQjtnQkFBTztZQUNyRDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNvQixRQUFTdkIsSUFBSSxFQUFFQyxRQUFRO0lBQzlCLElBQUlBLGFBQWF1QixXQUFXO1FBQzFCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQkosUUFBUUssSUFBSSxDQUFDLElBQUksRUFBRTVCLE1BQU0sQ0FBQ3FCLEtBQUtRO2dCQUM3QixPQUFPUixNQUFNTSxPQUFPTixPQUFPSyxRQUFRRztZQUNyQztRQUNGO0lBQ0Y7SUFFQSxJQUFJO1FBQ0YsTUFBTUMsaUJBQWlCLElBQUloQyxlQUFlRSxNQUFNQztRQUNoRCxJQUFJLENBQUM4QixRQUFRLENBQUM7WUFDWixHQUFHL0IsSUFBSTtZQUNQZ0MsUUFBUWhDLEtBQUtnQyxNQUFNLElBQUk7WUFDdkJULFNBQVN2QixLQUFLaUMsUUFBUSxJQUFJO1FBQzVCLEdBQUdIO0lBQ0wsRUFBRSxPQUFPVCxLQUFLO1FBQ1osSUFBSSxPQUFPcEIsYUFBYSxZQUFZO1lBQ2xDLE1BQU1vQjtRQUNSO1FBQ0EsTUFBTWxCLFNBQVNILFFBQVFBLEtBQUtHLE1BQU07UUFDbENtQixlQUFlLElBQU1yQixTQUFTb0IsS0FBSztnQkFBRWxCO1lBQU87SUFDOUM7QUFDRjtBQUVBK0IsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS11cGdyYWRlLmpzPzQ0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ2FzeW5jX2hvb2tzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuY2xhc3MgVXBncmFkZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9VUEdSQURFJylcblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgdXBncmFkZScsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHN0YXR1c0NvZGUsIDEwMSlcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBncmFkZSAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBncmFkZS5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cGdyYWRlSGFuZGxlciA9IG5ldyBVcGdyYWRlSGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgdXBncmFkZTogb3B0cy5wcm90b2NvbCB8fCAnV2Vic29ja2V0J1xuICAgIH0sIHVwZ3JhZGVIYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cyAmJiBvcHRzLm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGdyYWRlXG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiU29ja2V0RXJyb3IiLCJyZXF1aXJlIiwiQXN5bmNSZXNvdXJjZSIsInV0aWwiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJhc3NlcnQiLCJVcGdyYWRlSGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwib3BhcXVlIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJjb250ZXh0Iiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsInJhd0hlYWRlcnMiLCJzb2NrZXQiLCJzdHJpY3RFcXVhbCIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJvbkVycm9yIiwiZXJyIiwicXVldWVNaWNyb3Rhc2siLCJ1cGdyYWRlIiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsInVwZ3JhZGVIYW5kbGVyIiwiZGlzcGF0Y2giLCJtZXRob2QiLCJwcm90b2NvbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(rsc)/./node_modules/undici/lib/api/api-request.js\");\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(rsc)/./node_modules/undici/lib/api/api-stream.js\");\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(rsc)/./node_modules/undici/lib/api/api-pipeline.js\");\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(rsc)/./node_modules/undici/lib/api/api-upgrade.js\");\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(rsc)/./node_modules/undici/lib/api/api-connect.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsdUhBQWlDO0FBQ2pDQSxvSEFBZ0M7QUFDaENBLDBIQUFrQztBQUNsQ0EsdUhBQWlDO0FBQ2pDQSx1SEFBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9pbmRleC5qcz85ZWVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWlyZSgnLi9hcGktcmVxdWVzdCcpXG5tb2R1bGUuZXhwb3J0cy5zdHJlYW0gPSByZXF1aXJlKCcuL2FwaS1zdHJlYW0nKVxubW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2FwaS1waXBlbGluZScpXG5tb2R1bGUuZXhwb3J0cy51cGdyYWRlID0gcmVxdWlyZSgnLi9hcGktdXBncmFkZScpXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gcmVxdWlyZSgnLi9hcGktY29ubmVjdCcpXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVlc3QiLCJyZXF1aXJlIiwic3RyZWFtIiwicGlwZWxpbmUiLCJ1cGdyYWRlIiwiY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nlet Blob;\nconst kConsume = Symbol(\"kConsume\");\nconst kReading = Symbol(\"kReading\");\nconst kBody = Symbol(\"kBody\");\nconst kAbort = Symbol(\"abort\");\nconst kContentType = Symbol(\"kContentType\");\nmodule.exports = class BodyReadable extends Readable {\n    constructor({ resume, abort, contentType = \"\", highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n     }){\n        super({\n            autoDestroy: true,\n            read: resume,\n            highWaterMark\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        // Is stream being consumed through Readable API?\n        // This is an optimization so that we avoid checking\n        // for 'data' and 'readable' listeners in the hot path\n        // inside push().\n        this[kReading] = false;\n    }\n    destroy(err) {\n        if (this.destroyed) {\n            // Node < 16\n            return this;\n        }\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        if (err) {\n            this[kAbort]();\n        }\n        return super.destroy(err);\n    }\n    emit(ev, ...args) {\n        if (ev === \"data\") {\n            // Node < 16.7\n            this._readableState.dataEmitted = true;\n        } else if (ev === \"error\") {\n            // Node < 16\n            this._readableState.errorEmitted = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n    }\n    addListener(ev, ...args) {\n        return this.on(ev, ...args);\n    }\n    off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n    }\n    removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n    }\n    push(chunk) {\n        if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n            consumePush(this[kConsume], chunk);\n            return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-text\n    async text() {\n        return consume(this, \"text\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-json\n    async json() {\n        return consume(this, \"json\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-blob\n    async blob() {\n        return consume(this, \"blob\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n    async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-formdata\n    async formData() {\n        // TODO: Implement.\n        throw new NotSupportedError();\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-bodyused\n    get bodyUsed() {\n        return util.isDisturbed(this);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-body\n    get body() {\n        if (!this[kBody]) {\n            this[kBody] = ReadableStreamFrom(this);\n            if (this[kConsume]) {\n                // TODO: Is this the best way to force a lock?\n                this[kBody].getReader() // Ensure stream is locked.\n                ;\n                assert(this[kBody].locked);\n            }\n        }\n        return this[kBody];\n    }\n    async dump(opts) {\n        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n        const signal = opts && opts.signal;\n        const abortFn = ()=>{\n            this.destroy();\n        };\n        let signalListenerCleanup;\n        if (signal) {\n            if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n                throw new InvalidArgumentError(\"signal must be an AbortSignal\");\n            }\n            util.throwIfAborted(signal);\n            signalListenerCleanup = util.addAbortListener(signal, abortFn);\n        }\n        try {\n            for await (const chunk of this){\n                util.throwIfAborted(signal);\n                limit -= Buffer.byteLength(chunk);\n                if (limit < 0) {\n                    return;\n                }\n            }\n        } catch  {\n            util.throwIfAborted(signal);\n        } finally{\n            if (typeof signalListenerCleanup === \"function\") {\n                signalListenerCleanup();\n            } else if (signalListenerCleanup) {\n                signalListenerCleanup[Symbol.dispose]();\n            }\n        }\n    }\n};\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n    // Consume is an implicit lock.\n    return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n    return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n    if (isUnusable(stream)) {\n        throw new TypeError(\"unusable\");\n    }\n    assert(!stream[kConsume]);\n    return new Promise((resolve, reject)=>{\n        stream[kConsume] = {\n            type,\n            stream,\n            resolve,\n            reject,\n            length: 0,\n            body: []\n        };\n        stream.on(\"error\", function(err) {\n            consumeFinish(this[kConsume], err);\n        }).on(\"close\", function() {\n            if (this[kConsume].body !== null) {\n                consumeFinish(this[kConsume], new RequestAbortedError());\n            }\n        });\n        process.nextTick(consumeStart, stream[kConsume]);\n    });\n}\nfunction consumeStart(consume) {\n    if (consume.body === null) {\n        return;\n    }\n    const { _readableState: state } = consume.stream;\n    for (const chunk of state.buffer){\n        consumePush(consume, chunk);\n    }\n    if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n    } else {\n        consume.stream.on(\"end\", function() {\n            consumeEnd(this[kConsume]);\n        });\n    }\n    consume.stream.resume();\n    while(consume.stream.read() != null){\n    // Loop\n    }\n}\nfunction consumeEnd(consume) {\n    const { type, body, resolve, stream, length } = consume;\n    try {\n        if (type === \"text\") {\n            resolve(toUSVString(Buffer.concat(body)));\n        } else if (type === \"json\") {\n            resolve(JSON.parse(Buffer.concat(body)));\n        } else if (type === \"arrayBuffer\") {\n            const dst = new Uint8Array(length);\n            let pos = 0;\n            for (const buf of body){\n                dst.set(buf, pos);\n                pos += buf.byteLength;\n            }\n            resolve(dst.buffer);\n        } else if (type === \"blob\") {\n            if (!Blob) {\n                Blob = (__webpack_require__(/*! buffer */ \"buffer\").Blob);\n            }\n            resolve(new Blob(body, {\n                type: stream[kContentType]\n            }));\n        }\n        consumeFinish(consume);\n    } catch (err) {\n        stream.destroy(err);\n    }\n}\nfunction consumePush(consume, chunk) {\n    consume.length += chunk.length;\n    consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n    if (consume.body === null) {\n        return;\n    }\n    if (err) {\n        consume.reject(err);\n    } else {\n        consume.resolve();\n    }\n    consume.type = null;\n    consume.stream = null;\n    consume.resolve = null;\n    consume.reject = null;\n    consume.length = 0;\n    consume.body = null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0RBQXdEO0FBRXhEO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFRSxtQkFBbUIsRUFBRUMsaUJBQWlCLEVBQUVDLG9CQUFvQixFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ2pGLE1BQU1LLE9BQU9MLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRU0sa0JBQWtCLEVBQUVDLFdBQVcsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUVwRCxJQUFJUTtBQUVKLE1BQU1DLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsV0FBV0QsT0FBTztBQUN4QixNQUFNRSxRQUFRRixPQUFPO0FBQ3JCLE1BQU1HLFNBQVNILE9BQU87QUFDdEIsTUFBTUksZUFBZUosT0FBTztBQUU1QkssT0FBT0MsT0FBTyxHQUFHLE1BQU1DLHFCQUFxQmhCO0lBQzFDaUIsWUFBYSxFQUNYQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsY0FBYyxFQUFFLEVBQ2hCQyxnQkFBZ0IsS0FBSyxLQUFLLDZCQUE2QjtJQUE5QixFQUMxQixDQUFFO1FBQ0QsS0FBSyxDQUFDO1lBQ0pDLGFBQWE7WUFDYkMsTUFBTUw7WUFDTkc7UUFDRjtRQUVBLElBQUksQ0FBQ0csY0FBYyxDQUFDQyxXQUFXLEdBQUc7UUFFbEMsSUFBSSxDQUFDYixPQUFPLEdBQUdPO1FBQ2YsSUFBSSxDQUFDWCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNFLGFBQWEsR0FBR087UUFFckIsaURBQWlEO1FBQ2pELG9EQUFvRDtRQUNwRCxzREFBc0Q7UUFDdEQsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQ1YsU0FBUyxHQUFHO0lBQ25CO0lBRUFnQixRQUFTQyxHQUFHLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ2xCLFlBQVk7WUFDWixPQUFPLElBQUk7UUFDYjtRQUVBLElBQUksQ0FBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQ0gsY0FBYyxDQUFDSyxVQUFVLEVBQUU7WUFDM0NGLE1BQU0sSUFBSTFCO1FBQ1o7UUFFQSxJQUFJMEIsS0FBSztZQUNQLElBQUksQ0FBQ2YsT0FBTztRQUNkO1FBRUEsT0FBTyxLQUFLLENBQUNjLFFBQVFDO0lBQ3ZCO0lBRUFHLEtBQU1DLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDakIsSUFBSUQsT0FBTyxRQUFRO1lBQ2pCLGNBQWM7WUFDZCxJQUFJLENBQUNQLGNBQWMsQ0FBQ0MsV0FBVyxHQUFHO1FBQ3BDLE9BQU8sSUFBSU0sT0FBTyxTQUFTO1lBQ3pCLFlBQVk7WUFDWixJQUFJLENBQUNQLGNBQWMsQ0FBQ1MsWUFBWSxHQUFHO1FBQ3JDO1FBQ0EsT0FBTyxLQUFLLENBQUNILEtBQUtDLE9BQU9DO0lBQzNCO0lBRUFFLEdBQUlILEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDZixJQUFJRCxPQUFPLFVBQVVBLE9BQU8sWUFBWTtZQUN0QyxJQUFJLENBQUNyQixTQUFTLEdBQUc7UUFDbkI7UUFDQSxPQUFPLEtBQUssQ0FBQ3dCLEdBQUdILE9BQU9DO0lBQ3pCO0lBRUFHLFlBQWFKLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUNFLEVBQUUsQ0FBQ0gsT0FBT0M7SUFDeEI7SUFFQUksSUFBS0wsRUFBRSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNoQixNQUFNSyxNQUFNLEtBQUssQ0FBQ0QsSUFBSUwsT0FBT0M7UUFDN0IsSUFBSUQsT0FBTyxVQUFVQSxPQUFPLFlBQVk7WUFDdEMsSUFBSSxDQUFDckIsU0FBUyxHQUNaLElBQUksQ0FBQzRCLGFBQWEsQ0FBQyxVQUFVLEtBQzdCLElBQUksQ0FBQ0EsYUFBYSxDQUFDLGNBQWM7UUFFckM7UUFDQSxPQUFPRDtJQUNUO0lBRUFFLGVBQWdCUixFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDSSxHQUFHLENBQUNMLE9BQU9DO0lBQ3pCO0lBRUFRLEtBQU1DLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxDQUFDakMsU0FBUyxJQUFJaUMsVUFBVSxRQUFRLElBQUksQ0FBQ0MsY0FBYyxLQUFLLEdBQUc7WUFDakVDLFlBQVksSUFBSSxDQUFDbkMsU0FBUyxFQUFFaUM7WUFDNUIsT0FBTyxJQUFJLENBQUMvQixTQUFTLEdBQUcsS0FBSyxDQUFDOEIsS0FBS0MsU0FBUztRQUM5QztRQUNBLE9BQU8sS0FBSyxDQUFDRCxLQUFLQztJQUNwQjtJQUVBLCtDQUErQztJQUMvQyxNQUFNRyxPQUFRO1FBQ1osT0FBT0MsUUFBUSxJQUFJLEVBQUU7SUFDdkI7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUMsT0FBUTtRQUNaLE9BQU9ELFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1FLE9BQVE7UUFDWixPQUFPRixRQUFRLElBQUksRUFBRTtJQUN2QjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNRyxjQUFlO1FBQ25CLE9BQU9ILFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUEsbURBQW1EO0lBQ25ELE1BQU1JLFdBQVk7UUFDaEIsbUJBQW1CO1FBQ25CLE1BQU0sSUFBSS9DO0lBQ1o7SUFFQSxtREFBbUQ7SUFDbkQsSUFBSWdELFdBQVk7UUFDZCxPQUFPOUMsS0FBSytDLFdBQVcsQ0FBQyxJQUFJO0lBQzlCO0lBRUEsK0NBQStDO0lBQy9DLElBQUlDLE9BQVE7UUFDVixJQUFJLENBQUMsSUFBSSxDQUFDekMsTUFBTSxFQUFFO1lBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHTixtQkFBbUIsSUFBSTtZQUNyQyxJQUFJLElBQUksQ0FBQ0csU0FBUyxFQUFFO2dCQUNsQiw4Q0FBOEM7Z0JBQzlDLElBQUksQ0FBQ0csTUFBTSxDQUFDMEMsU0FBUyxHQUFHLDJCQUEyQjs7Z0JBQ25EdkQsT0FBTyxJQUFJLENBQUNhLE1BQU0sQ0FBQzJDLE1BQU07WUFDM0I7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDM0MsTUFBTTtJQUNwQjtJQUVBLE1BQU00QyxLQUFNQyxJQUFJLEVBQUU7UUFDaEIsSUFBSUMsUUFBUUQsUUFBUUUsT0FBT0MsUUFBUSxDQUFDSCxLQUFLQyxLQUFLLElBQUlELEtBQUtDLEtBQUssR0FBRztRQUMvRCxNQUFNRyxTQUFTSixRQUFRQSxLQUFLSSxNQUFNO1FBQ2xDLE1BQU1DLFVBQVU7WUFDZCxJQUFJLENBQUNuQyxPQUFPO1FBQ2Q7UUFDQSxJQUFJb0M7UUFDSixJQUFJRixRQUFRO1lBQ1YsSUFBSSxPQUFPQSxXQUFXLFlBQVksQ0FBRSxjQUFhQSxNQUFLLEdBQUk7Z0JBQ3hELE1BQU0sSUFBSXpELHFCQUFxQjtZQUNqQztZQUNBQyxLQUFLMkQsY0FBYyxDQUFDSDtZQUNwQkUsd0JBQXdCMUQsS0FBSzRELGdCQUFnQixDQUFDSixRQUFRQztRQUN4RDtRQUNBLElBQUk7WUFDRixXQUFXLE1BQU1wQixTQUFTLElBQUksQ0FBRTtnQkFDOUJyQyxLQUFLMkQsY0FBYyxDQUFDSDtnQkFDcEJILFNBQVNRLE9BQU9DLFVBQVUsQ0FBQ3pCO2dCQUMzQixJQUFJZ0IsUUFBUSxHQUFHO29CQUNiO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU07WUFDTnJELEtBQUsyRCxjQUFjLENBQUNIO1FBQ3RCLFNBQVU7WUFDUixJQUFJLE9BQU9FLDBCQUEwQixZQUFZO2dCQUMvQ0E7WUFDRixPQUFPLElBQUlBLHVCQUF1QjtnQkFDaENBLHFCQUFxQixDQUFDckQsT0FBTzBELE9BQU8sQ0FBQztZQUN2QztRQUNGO0lBQ0Y7QUFDRjtBQUVBLHlEQUF5RDtBQUN6RCxTQUFTQyxTQUFVQyxJQUFJO0lBQ3JCLCtCQUErQjtJQUMvQixPQUFPLElBQUssQ0FBQzFELE1BQU0sSUFBSTBELElBQUksQ0FBQzFELE1BQU0sQ0FBQzJDLE1BQU0sS0FBSyxRQUFTZSxJQUFJLENBQUM3RCxTQUFTO0FBQ3ZFO0FBRUEsK0NBQStDO0FBQy9DLFNBQVM4RCxXQUFZRCxJQUFJO0lBQ3ZCLE9BQU9qRSxLQUFLK0MsV0FBVyxDQUFDa0IsU0FBU0QsU0FBU0M7QUFDNUM7QUFFQSxlQUFleEIsUUFBUzBCLE1BQU0sRUFBRUMsSUFBSTtJQUNsQyxJQUFJRixXQUFXQyxTQUFTO1FBQ3RCLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUVBM0UsT0FBTyxDQUFDeUUsTUFBTSxDQUFDL0QsU0FBUztJQUV4QixPQUFPLElBQUlrRSxRQUFRLENBQUNDLFNBQVNDO1FBQzNCTCxNQUFNLENBQUMvRCxTQUFTLEdBQUc7WUFDakJnRTtZQUNBRDtZQUNBSTtZQUNBQztZQUNBQyxRQUFRO1lBQ1J6QixNQUFNLEVBQUU7UUFDVjtRQUVBbUIsT0FDR3JDLEVBQUUsQ0FBQyxTQUFTLFNBQVVQLEdBQUc7WUFDeEJtRCxjQUFjLElBQUksQ0FBQ3RFLFNBQVMsRUFBRW1CO1FBQ2hDLEdBQ0NPLEVBQUUsQ0FBQyxTQUFTO1lBQ1gsSUFBSSxJQUFJLENBQUMxQixTQUFTLENBQUM0QyxJQUFJLEtBQUssTUFBTTtnQkFDaEMwQixjQUFjLElBQUksQ0FBQ3RFLFNBQVMsRUFBRSxJQUFJUDtZQUNwQztRQUNGO1FBRUY4RSxRQUFRQyxRQUFRLENBQUNDLGNBQWNWLE1BQU0sQ0FBQy9ELFNBQVM7SUFDakQ7QUFDRjtBQUVBLFNBQVN5RSxhQUFjcEMsT0FBTztJQUM1QixJQUFJQSxRQUFRTyxJQUFJLEtBQUssTUFBTTtRQUN6QjtJQUNGO0lBRUEsTUFBTSxFQUFFNUIsZ0JBQWdCMEQsS0FBSyxFQUFFLEdBQUdyQyxRQUFRMEIsTUFBTTtJQUVoRCxLQUFLLE1BQU05QixTQUFTeUMsTUFBTUMsTUFBTSxDQUFFO1FBQ2hDeEMsWUFBWUUsU0FBU0o7SUFDdkI7SUFFQSxJQUFJeUMsTUFBTXJELFVBQVUsRUFBRTtRQUNwQnVELFdBQVcsSUFBSSxDQUFDNUUsU0FBUztJQUMzQixPQUFPO1FBQ0xxQyxRQUFRMEIsTUFBTSxDQUFDckMsRUFBRSxDQUFDLE9BQU87WUFDdkJrRCxXQUFXLElBQUksQ0FBQzVFLFNBQVM7UUFDM0I7SUFDRjtJQUVBcUMsUUFBUTBCLE1BQU0sQ0FBQ3JELE1BQU07SUFFckIsTUFBTzJCLFFBQVEwQixNQUFNLENBQUNoRCxJQUFJLE1BQU0sS0FBTTtJQUNwQyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLFNBQVM2RCxXQUFZdkMsT0FBTztJQUMxQixNQUFNLEVBQUUyQixJQUFJLEVBQUVwQixJQUFJLEVBQUV1QixPQUFPLEVBQUVKLE1BQU0sRUFBRU0sTUFBTSxFQUFFLEdBQUdoQztJQUVoRCxJQUFJO1FBQ0YsSUFBSTJCLFNBQVMsUUFBUTtZQUNuQkcsUUFBUXJFLFlBQVkyRCxPQUFPb0IsTUFBTSxDQUFDakM7UUFDcEMsT0FBTyxJQUFJb0IsU0FBUyxRQUFRO1lBQzFCRyxRQUFRVyxLQUFLQyxLQUFLLENBQUN0QixPQUFPb0IsTUFBTSxDQUFDakM7UUFDbkMsT0FBTyxJQUFJb0IsU0FBUyxlQUFlO1lBQ2pDLE1BQU1nQixNQUFNLElBQUlDLFdBQVdaO1lBRTNCLElBQUlhLE1BQU07WUFDVixLQUFLLE1BQU1DLE9BQU92QyxLQUFNO2dCQUN0Qm9DLElBQUlJLEdBQUcsQ0FBQ0QsS0FBS0Q7Z0JBQ2JBLE9BQU9DLElBQUl6QixVQUFVO1lBQ3ZCO1lBRUFTLFFBQVFhLElBQUlMLE1BQU07UUFDcEIsT0FBTyxJQUFJWCxTQUFTLFFBQVE7WUFDMUIsSUFBSSxDQUFDakUsTUFBTTtnQkFDVEEsT0FBT1Isa0RBQXNCO1lBQy9CO1lBQ0E0RSxRQUFRLElBQUlwRSxLQUFLNkMsTUFBTTtnQkFBRW9CLE1BQU1ELE1BQU0sQ0FBQzFELGFBQWE7WUFBQztRQUN0RDtRQUVBaUUsY0FBY2pDO0lBQ2hCLEVBQUUsT0FBT2xCLEtBQUs7UUFDWjRDLE9BQU83QyxPQUFPLENBQUNDO0lBQ2pCO0FBQ0Y7QUFFQSxTQUFTZ0IsWUFBYUUsT0FBTyxFQUFFSixLQUFLO0lBQ2xDSSxRQUFRZ0MsTUFBTSxJQUFJcEMsTUFBTW9DLE1BQU07SUFDOUJoQyxRQUFRTyxJQUFJLENBQUNaLElBQUksQ0FBQ0M7QUFDcEI7QUFFQSxTQUFTcUMsY0FBZWpDLE9BQU8sRUFBRWxCLEdBQUc7SUFDbEMsSUFBSWtCLFFBQVFPLElBQUksS0FBSyxNQUFNO1FBQ3pCO0lBQ0Y7SUFFQSxJQUFJekIsS0FBSztRQUNQa0IsUUFBUStCLE1BQU0sQ0FBQ2pEO0lBQ2pCLE9BQU87UUFDTGtCLFFBQVE4QixPQUFPO0lBQ2pCO0lBRUE5QixRQUFRMkIsSUFBSSxHQUFHO0lBQ2YzQixRQUFRMEIsTUFBTSxHQUFHO0lBQ2pCMUIsUUFBUThCLE9BQU8sR0FBRztJQUNsQjlCLFFBQVErQixNQUFNLEdBQUc7SUFDakIvQixRQUFRZ0MsTUFBTSxHQUFHO0lBQ2pCaEMsUUFBUU8sSUFBSSxHQUFHO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanM/Njg1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzkwN1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yLCBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtRnJvbSwgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmxldCBCbG9iXG5cbmNvbnN0IGtDb25zdW1lID0gU3ltYm9sKCdrQ29uc3VtZScpXG5jb25zdCBrUmVhZGluZyA9IFN5bWJvbCgna1JlYWRpbmcnKVxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2tCb2R5JylcbmNvbnN0IGtBYm9ydCA9IFN5bWJvbCgnYWJvcnQnKVxuY29uc3Qga0NvbnRlbnRUeXBlID0gU3ltYm9sKCdrQ29udGVudFR5cGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICByZXN1bWUsXG4gICAgYWJvcnQsXG4gICAgY29udGVudFR5cGUgPSAnJyxcbiAgICBoaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0IC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6IHJlc3VtZSxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IGZhbHNlXG5cbiAgICB0aGlzW2tBYm9ydF0gPSBhYm9ydFxuICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbFxuICAgIHRoaXNba0JvZHldID0gbnVsbFxuICAgIHRoaXNba0NvbnRlbnRUeXBlXSA9IGNvbnRlbnRUeXBlXG5cbiAgICAvLyBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgIC8vIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgIC8vIGluc2lkZSBwdXNoKCkuXG4gICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAvLyBOb2RlIDwgMTZcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXNba0Fib3J0XSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgZW1pdCAoZXYsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgLy8gTm9kZSA8IDE2LjdcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gTm9kZSA8IDE2XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBvbiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIGFkZExpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgb2ZmIChldiwgLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgLi4uYXJncylcbiAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhpc1trUmVhZGluZ10gPSAoXG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCB8fFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVyIChldiwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLm9mZihldiwgLi4uYXJncylcbiAgfVxuXG4gIHB1c2ggKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0NvbnN1bWVdICYmIGNodW5rICE9PSBudWxsICYmIHRoaXMucmVhZGFibGVMZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN1bWVQdXNoKHRoaXNba0NvbnN1bWVdLCBjaHVuaylcbiAgICAgIHJldHVybiB0aGlzW2tSZWFkaW5nXSA/IHN1cGVyLnB1c2goY2h1bmspIDogdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS10ZXh0XG4gIGFzeW5jIHRleHQgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICd0ZXh0JylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1qc29uXG4gIGFzeW5jIGpzb24gKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdqc29uJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ibG9iXG4gIGFzeW5jIGJsb2IgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdibG9iJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1hcnJheWJ1ZmZlclxuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1mb3JtZGF0YVxuICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50LlxuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keXVzZWRcbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZCh0aGlzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHlcbiAgZ2V0IGJvZHkgKCkge1xuICAgIGlmICghdGhpc1trQm9keV0pIHtcbiAgICAgIHRoaXNba0JvZHldID0gUmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpXG4gICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0aGUgYmVzdCB3YXkgdG8gZm9yY2UgYSBsb2NrP1xuICAgICAgICB0aGlzW2tCb2R5XS5nZXRSZWFkZXIoKSAvLyBFbnN1cmUgc3RyZWFtIGlzIGxvY2tlZC5cbiAgICAgICAgYXNzZXJ0KHRoaXNba0JvZHldLmxvY2tlZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0JvZHldXG4gIH1cblxuICBhc3luYyBkdW1wIChvcHRzKSB7XG4gICAgbGV0IGxpbWl0ID0gb3B0cyAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5saW1pdCkgPyBvcHRzLmxpbWl0IDogMjYyMTQ0XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0cyAmJiBvcHRzLnNpZ25hbFxuICAgIGNvbnN0IGFib3J0Rm4gPSAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH1cbiAgICBsZXQgc2lnbmFsTGlzdGVuZXJDbGVhbnVwXG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgaWYgKHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBBYm9ydFNpZ25hbCcpXG4gICAgICB9XG4gICAgICB1dGlsLnRocm93SWZBYm9ydGVkKHNpZ25hbClcbiAgICAgIHNpZ25hbExpc3RlbmVyQ2xlYW51cCA9IHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGFib3J0Rm4pXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMpIHtcbiAgICAgICAgdXRpbC50aHJvd0lmQWJvcnRlZChzaWduYWwpXG4gICAgICAgIGxpbWl0IC09IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKVxuICAgICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHV0aWwudGhyb3dJZkFib3J0ZWQoc2lnbmFsKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodHlwZW9mIHNpZ25hbExpc3RlbmVyQ2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaWduYWxMaXN0ZW5lckNsZWFudXAoKVxuICAgICAgfSBlbHNlIGlmIChzaWduYWxMaXN0ZW5lckNsZWFudXApIHtcbiAgICAgICAgc2lnbmFsTGlzdGVuZXJDbGVhbnVwW1N5bWJvbC5kaXNwb3NlXSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWxvY2tlZFxuZnVuY3Rpb24gaXNMb2NrZWQgKHNlbGYpIHtcbiAgLy8gQ29uc3VtZSBpcyBhbiBpbXBsaWNpdCBsb2NrLlxuICByZXR1cm4gKHNlbGZba0JvZHldICYmIHNlbGZba0JvZHldLmxvY2tlZCA9PT0gdHJ1ZSkgfHwgc2VsZltrQ29uc3VtZV1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHktdW51c2FibGVcbmZ1bmN0aW9uIGlzVW51c2FibGUgKHNlbGYpIHtcbiAgcmV0dXJuIHV0aWwuaXNEaXN0dXJiZWQoc2VsZikgfHwgaXNMb2NrZWQoc2VsZilcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29uc3VtZSAoc3RyZWFtLCB0eXBlKSB7XG4gIGlmIChpc1VudXNhYmxlKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpXG4gIH1cblxuICBhc3NlcnQoIXN0cmVhbVtrQ29uc3VtZV0pXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdHJlYW1ba0NvbnN1bWVdID0ge1xuICAgICAgdHlwZSxcbiAgICAgIHN0cmVhbSxcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBib2R5OiBbXVxuICAgIH1cblxuICAgIHN0cmVhbVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgZXJyKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzW2tDb25zdW1lXS5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHByb2Nlc3MubmV4dFRpY2soY29uc3VtZVN0YXJ0LCBzdHJlYW1ba0NvbnN1bWVdKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb25zdW1lU3RhcnQgKGNvbnN1bWUpIHtcbiAgaWYgKGNvbnN1bWUuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBfcmVhZGFibGVTdGF0ZTogc3RhdGUgfSA9IGNvbnN1bWUuc3RyZWFtXG5cbiAgZm9yIChjb25zdCBjaHVuayBvZiBzdGF0ZS5idWZmZXIpIHtcbiAgICBjb25zdW1lUHVzaChjb25zdW1lLCBjaHVuaylcbiAgfVxuXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSlcbiAgICB9KVxuICB9XG5cbiAgY29uc3VtZS5zdHJlYW0ucmVzdW1lKClcblxuICB3aGlsZSAoY29uc3VtZS5zdHJlYW0ucmVhZCgpICE9IG51bGwpIHtcbiAgICAvLyBMb29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZUVuZCAoY29uc3VtZSkge1xuICBjb25zdCB7IHR5cGUsIGJvZHksIHJlc29sdmUsIHN0cmVhbSwgbGVuZ3RoIH0gPSBjb25zdW1lXG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXNvbHZlKHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoYm9keSkpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICByZXNvbHZlKEpTT04ucGFyc2UoQnVmZmVyLmNvbmNhdChib2R5KSkpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJyYXlCdWZmZXInKSB7XG4gICAgICBjb25zdCBkc3QgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG5cbiAgICAgIGxldCBwb3MgPSAwXG4gICAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBib2R5KSB7XG4gICAgICAgIGRzdC5zZXQoYnVmLCBwb3MpXG4gICAgICAgIHBvcyArPSBidWYuYnl0ZUxlbmd0aFxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGRzdC5idWZmZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgIGlmICghQmxvYikge1xuICAgICAgICBCbG9iID0gcmVxdWlyZSgnYnVmZmVyJykuQmxvYlxuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXcgQmxvYihib2R5LCB7IHR5cGU6IHN0cmVhbVtrQ29udGVudFR5cGVdIH0pKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICBjb25zdW1lLnR5cGUgPSBudWxsXG4gIGNvbnN1bWUuc3RyZWFtID0gbnVsbFxuICBjb25zdW1lLnJlc29sdmUgPSBudWxsXG4gIGNvbnN1bWUucmVqZWN0ID0gbnVsbFxuICBjb25zdW1lLmxlbmd0aCA9IDBcbiAgY29uc3VtZS5ib2R5ID0gbnVsbFxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZWFkYWJsZSIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJOb3RTdXBwb3J0ZWRFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwidXRpbCIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsInRvVVNWU3RyaW5nIiwiQmxvYiIsImtDb25zdW1lIiwiU3ltYm9sIiwia1JlYWRpbmciLCJrQm9keSIsImtBYm9ydCIsImtDb250ZW50VHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJCb2R5UmVhZGFibGUiLCJjb25zdHJ1Y3RvciIsInJlc3VtZSIsImFib3J0IiwiY29udGVudFR5cGUiLCJoaWdoV2F0ZXJNYXJrIiwiYXV0b0Rlc3Ryb3kiLCJyZWFkIiwiX3JlYWRhYmxlU3RhdGUiLCJkYXRhRW1pdHRlZCIsImRlc3Ryb3kiLCJlcnIiLCJkZXN0cm95ZWQiLCJlbmRFbWl0dGVkIiwiZW1pdCIsImV2IiwiYXJncyIsImVycm9yRW1pdHRlZCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvZmYiLCJyZXQiLCJsaXN0ZW5lckNvdW50IiwicmVtb3ZlTGlzdGVuZXIiLCJwdXNoIiwiY2h1bmsiLCJyZWFkYWJsZUxlbmd0aCIsImNvbnN1bWVQdXNoIiwidGV4dCIsImNvbnN1bWUiLCJqc29uIiwiYmxvYiIsImFycmF5QnVmZmVyIiwiZm9ybURhdGEiLCJib2R5VXNlZCIsImlzRGlzdHVyYmVkIiwiYm9keSIsImdldFJlYWRlciIsImxvY2tlZCIsImR1bXAiLCJvcHRzIiwibGltaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNpZ25hbCIsImFib3J0Rm4iLCJzaWduYWxMaXN0ZW5lckNsZWFudXAiLCJ0aHJvd0lmQWJvcnRlZCIsImFkZEFib3J0TGlzdGVuZXIiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiZGlzcG9zZSIsImlzTG9ja2VkIiwic2VsZiIsImlzVW51c2FibGUiLCJzdHJlYW0iLCJ0eXBlIiwiVHlwZUVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsZW5ndGgiLCJjb25zdW1lRmluaXNoIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY29uc3VtZVN0YXJ0Iiwic3RhdGUiLCJidWZmZXIiLCJjb25zdW1lRW5kIiwiY29uY2F0IiwiSlNPTiIsInBhcnNlIiwiZHN0IiwiVWludDhBcnJheSIsInBvcyIsImJ1ZiIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst { ResponseStatusCodeError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { toUSVString } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nasync function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n    assert(body);\n    let chunks = [];\n    let limit = 0;\n    for await (const chunk of body){\n        chunks.push(chunk);\n        limit += chunk.length;\n        if (limit > 128 * 1024) {\n            chunks = null;\n            break;\n        }\n    }\n    if (statusCode === 204 || !contentType || !chunks) {\n        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n        return;\n    }\n    try {\n        if (contentType.startsWith(\"application/json\")) {\n            const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n        if (contentType.startsWith(\"text/\")) {\n            const payload = toUSVString(Buffer.concat(chunks));\n            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers, payload));\n            return;\n        }\n    } catch (err) {\n    // Process in a fallback if error\n    }\n    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`, statusCode, headers));\n}\nmodule.exports = {\n    getResolveErrorBodyCallback\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pDLHVCQUF1QixFQUN4QixHQUFHRCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUUsV0FBVyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBRWhDLGVBQWVHLDRCQUE2QixFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLGFBQWEsRUFBRUMsT0FBTyxFQUFFO0lBQzdHVixPQUFPTTtJQUVQLElBQUlLLFNBQVMsRUFBRTtJQUNmLElBQUlDLFFBQVE7SUFFWixXQUFXLE1BQU1DLFNBQVNQLEtBQU07UUFDOUJLLE9BQU9HLElBQUksQ0FBQ0Q7UUFDWkQsU0FBU0MsTUFBTUUsTUFBTTtRQUNyQixJQUFJSCxRQUFRLE1BQU0sTUFBTTtZQUN0QkQsU0FBUztZQUNUO1FBQ0Y7SUFDRjtJQUVBLElBQUlILGVBQWUsT0FBTyxDQUFDRCxlQUFlLENBQUNJLFFBQVE7UUFDakRLLFFBQVFDLFFBQVEsQ0FBQ1osVUFBVSxJQUFJSCx3QkFBd0IsQ0FBQyxxQkFBcUIsRUFBRU0sV0FBVyxFQUFFQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFRCxZQUFZRTtRQUNySjtJQUNGO0lBRUEsSUFBSTtRQUNGLElBQUlILFlBQVlXLFVBQVUsQ0FBQyxxQkFBcUI7WUFDOUMsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDbEIsWUFBWW1CLE9BQU9DLE1BQU0sQ0FBQ1o7WUFDckRLLFFBQVFDLFFBQVEsQ0FBQ1osVUFBVSxJQUFJSCx3QkFBd0IsQ0FBQyxxQkFBcUIsRUFBRU0sV0FBVyxFQUFFQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFRCxZQUFZRSxTQUFTUztZQUM5SjtRQUNGO1FBRUEsSUFBSVosWUFBWVcsVUFBVSxDQUFDLFVBQVU7WUFDbkMsTUFBTUMsVUFBVWhCLFlBQVltQixPQUFPQyxNQUFNLENBQUNaO1lBQzFDSyxRQUFRQyxRQUFRLENBQUNaLFVBQVUsSUFBSUgsd0JBQXdCLENBQUMscUJBQXFCLEVBQUVNLFdBQVcsRUFBRUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxjQUFjLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRUQsWUFBWUUsU0FBU1M7WUFDOUo7UUFDRjtJQUNGLEVBQUUsT0FBT0ssS0FBSztJQUNaLGlDQUFpQztJQUNuQztJQUVBUixRQUFRQyxRQUFRLENBQUNaLFVBQVUsSUFBSUgsd0JBQXdCLENBQUMscUJBQXFCLEVBQUVNLFdBQVcsRUFBRUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxjQUFjLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRUQsWUFBWUU7QUFDdko7QUFFQWUsT0FBT0MsT0FBTyxHQUFHO0lBQUV0QjtBQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3V0aWwuanM/NDI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qge1xuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayAoeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfSkge1xuICBhc3NlcnQoYm9keSlcblxuICBsZXQgY2h1bmtzID0gW11cbiAgbGV0IGxpbWl0ID0gMFxuXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIGxpbWl0ICs9IGNodW5rLmxlbmd0aFxuICAgIGlmIChsaW1pdCA+IDEyOCAqIDEwMjQpIHtcbiAgICAgIGNodW5rcyA9IG51bGxcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNCB8fCAhY29udGVudFR5cGUgfHwgIWNodW5rcykge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycykpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGlmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRvVVNWU3RyaW5nKEJ1ZmZlci5jb25jYXQoY2h1bmtzKSkpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvJykpIHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB0b1VTVlN0cmluZyhCdWZmZXIuY29uY2F0KGNodW5rcykpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IoYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWAsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBQcm9jZXNzIGluIGEgZmFsbGJhY2sgaWYgZXJyb3JcbiAgfVxuXG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YCwgc3RhdHVzQ29kZSwgaGVhZGVycykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJSZXNwb25zZVN0YXR1c0NvZGVFcnJvciIsInRvVVNWU3RyaW5nIiwiZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrIiwiY2FsbGJhY2siLCJib2R5IiwiY29udGVudFR5cGUiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJjaHVua3MiLCJsaW1pdCIsImNodW5rIiwicHVzaCIsImxlbmd0aCIsInByb2Nlc3MiLCJuZXh0VGljayIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwiSlNPTiIsInBhcnNlIiwiQnVmZmVyIiwiY29uY2F0IiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/balanced-pool.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/balanced-pool.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/pool-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/pool.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { parseOrigin } = __webpack_require__(/*! ./core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst kFactory = Symbol(\"factory\");\nconst kOptions = Symbol(\"options\");\nconst kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\nconst kCurrentWeight = Symbol(\"kCurrentWeight\");\nconst kIndex = Symbol(\"kIndex\");\nconst kWeight = Symbol(\"kWeight\");\nconst kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\nconst kErrorPenalty = Symbol(\"kErrorPenalty\");\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0) return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n            upstreams = [\n                upstreams\n            ];\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n        this[kFactory] = factory;\n        for (const upstream of upstreams){\n            this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n    }\n    addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n            return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", ()=>{\n            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", ()=>{\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args)=>{\n            const err = args[2];\n            if (err && err.code === \"UND_ERR_SOCKET\") {\n                // decrease the weight of the pool.\n                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n                this._updateBalancedPoolStats();\n            }\n        });\n        for (const client of this[kClients]){\n            client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n    }\n    _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n    }\n    removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n        if (pool) {\n            this[kRemoveClient](pool);\n        }\n        return this;\n    }\n    get upstreams() {\n        return this[kClients].filter((dispatcher)=>dispatcher.closed !== true && dispatcher.destroyed !== true).map((p)=>p[kUrl].origin);\n    }\n    [kGetDispatcher]() {\n        // We validate that pools is greater than 0,\n        // otherwise we would have to wait until an upstream\n        // is added, which might never happen.\n        if (this[kClients].length === 0) {\n            throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n        if (!dispatcher) {\n            return;\n        }\n        const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);\n        if (allClientsBusy) {\n            return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);\n        while(counter++ < this[kClients].length){\n            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n            const pool = this[kClients][this[kIndex]];\n            // find pool index with the largest weight\n            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n                maxWeightIndex = this[kIndex];\n            }\n            // decrease the current weight every `this[kClients].length`.\n            if (this[kIndex] === 0) {\n                // Set the current weight to the next lower weight.\n                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n                if (this[kCurrentWeight] <= 0) {\n                    this[kCurrentWeight] = this[kMaxWeightPerServer];\n                }\n            }\n            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n                return pool;\n            }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n    }\n}\nmodule.exports = BalancedPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9iYWxhbmNlZC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxnQ0FBZ0MsRUFDaENDLG9CQUFvQixFQUNyQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxhQUFhLEVBQ2JDLGNBQWMsRUFDZixHQUFHTixtQkFBT0EsQ0FBQztBQUNaLE1BQU1PLE9BQU9QLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRVEsSUFBSSxFQUFFQyxhQUFhLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUFFVSxXQUFXLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTVcsV0FBV0MsT0FBTztBQUV4QixNQUFNQyxXQUFXRCxPQUFPO0FBQ3hCLE1BQU1FLHlCQUF5QkYsT0FBTztBQUN0QyxNQUFNRyxpQkFBaUJILE9BQU87QUFDOUIsTUFBTUksU0FBU0osT0FBTztBQUN0QixNQUFNSyxVQUFVTCxPQUFPO0FBQ3ZCLE1BQU1NLHNCQUFzQk4sT0FBTztBQUNuQyxNQUFNTyxnQkFBZ0JQLE9BQU87QUFFN0IsU0FBU1EseUJBQTBCQyxDQUFDLEVBQUVDLENBQUM7SUFDckMsSUFBSUEsTUFBTSxHQUFHLE9BQU9EO0lBQ3BCLE9BQU9ELHlCQUF5QkUsR0FBR0QsSUFBSUM7QUFDekM7QUFFQSxTQUFTQyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU8sSUFBSWxCLEtBQUtpQixRQUFRQztBQUMxQjtBQUVBLE1BQU1DLHFCQUFxQnpCO0lBQ3pCMEIsWUFBYUMsWUFBWSxFQUFFLEVBQUUsRUFBRUMsVUFBVU4sY0FBYyxFQUFFLEdBQUdFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN2RSxLQUFLO1FBRUwsSUFBSSxDQUFDWixTQUFTLEdBQUdZO1FBQ2pCLElBQUksQ0FBQ1Qs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ZTtJQUN2QztBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBR3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9iYWxhbmNlZC1wb29sLmpzPzUwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBwYXJzZU9yaWdpbiB9ID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKCdrR3JlYXRlc3RDb21tb25EaXZpc29yJylcbmNvbnN0IGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKCdrQ3VycmVudFdlaWdodCcpXG5jb25zdCBrSW5kZXggPSBTeW1ib2woJ2tJbmRleCcpXG5jb25zdCBrV2VpZ2h0ID0gU3ltYm9sKCdrV2VpZ2h0JylcbmNvbnN0IGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woJ2tNYXhXZWlnaHRQZXJTZXJ2ZXInKVxuY29uc3Qga0Vycm9yUGVuYWx0eSA9IFN5bWJvbCgna0Vycm9yUGVuYWx0eScpXG5cbmZ1bmN0aW9uIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciAoYSwgYikge1xuICBpZiAoYiA9PT0gMCkgcmV0dXJuIGFcbiAgcmV0dXJuIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYilcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSBvcHRzXG4gICAgdGhpc1trSW5kZXhdID0gLTFcbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IDBcblxuICAgIHRoaXNba01heFdlaWdodFBlclNlcnZlcl0gPSB0aGlzW2tPcHRpb25zXS5tYXhXZWlnaHRQZXJTZXJ2ZXIgfHwgMTAwXG4gICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgIHVwc3RyZWFtcyA9IFt1cHN0cmVhbXNdXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzICYmIG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbCAmJiBBcnJheS5pc0FycmF5KG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuQmFsYW5jZWRQb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG5cbiAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSlcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICB9XG5cbiAgYWRkVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBpZiAodGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpXG5cbiAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpXG4gICAgcG9vbC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICB9KVxuXG4gICAgcG9vbC5vbignY29ubmVjdGlvbkVycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdkaXNjb25uZWN0JywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl1cbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdVTkRfRVJSX1NPQ0tFVCcpIHtcbiAgICAgICAgLy8gZGVjcmVhc2UgdGhlIHdlaWdodCBvZiB0aGUgcG9vbC5cbiAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBjbGllbnRba1dlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyAoKSB7XG4gICAgdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXSA9IHRoaXNba0NsaWVudHNdLm1hcChwID0+IHBba1dlaWdodF0pLnJlZHVjZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIDApXG4gIH1cblxuICByZW1vdmVVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAocG9vbCkge1xuICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgdXBzdHJlYW1zICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11cbiAgICAgIC5maWx0ZXIoZGlzcGF0Y2hlciA9PiBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZSlcbiAgICAgIC5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBwb29scyBpcyBncmVhdGVyIHRoYW4gMCxcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIGFuIHVwc3RyZWFtXG4gICAgLy8gaXMgYWRkZWQsIHdoaWNoIG1pZ2h0IG5ldmVyIGhhcHBlbi5cbiAgICBpZiAodGhpc1trQ2xpZW50c10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKHBvb2wgPT4gcG9vbFtrTmVlZERyYWluXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG5cbiAgICBpZiAoYWxsQ2xpZW50c0J1c3kpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjb3VudGVyID0gMFxuXG4gICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KHBvb2wgPT4gIXBvb2xba05lZWREcmFpbl0pXG5cbiAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGhcbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIGZpbmQgcG9vbCBpbmRleCB3aXRoIHRoZSBsYXJnZXN0IHdlaWdodFxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tJbmRleF1cbiAgICAgIH1cblxuICAgICAgLy8gZGVjcmVhc2UgdGhlIGN1cnJlbnQgd2VpZ2h0IGV2ZXJ5IGB0aGlzW2tDbGllbnRzXS5sZW5ndGhgLlxuICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgd2VpZ2h0IHRvIHRoZSBuZXh0IGxvd2VyIHdlaWdodC5cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl1cblxuICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+PSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAmJiAoIXBvb2xba05lZWREcmFpbl0pKSB7XG4gICAgICAgIHJldHVybiBwb29sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF1cbiAgICB0aGlzW2tJbmRleF0gPSBtYXhXZWlnaHRJbmRleFxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VkUG9vbFxuIl0sIm5hbWVzIjpbIkJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJyZXF1aXJlIiwiUG9vbEJhc2UiLCJrQ2xpZW50cyIsImtOZWVkRHJhaW4iLCJrQWRkQ2xpZW50Iiwia1JlbW92ZUNsaWVudCIsImtHZXREaXNwYXRjaGVyIiwiUG9vbCIsImtVcmwiLCJrSW50ZXJjZXB0b3JzIiwicGFyc2VPcmlnaW4iLCJrRmFjdG9yeSIsIlN5bWJvbCIsImtPcHRpb25zIiwia0dyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImtDdXJyZW50V2VpZ2h0Iiwia0luZGV4Iiwia1dlaWdodCIsImtNYXhXZWlnaHRQZXJTZXJ2ZXIiLCJrRXJyb3JQZW5hbHR5IiwiZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yIiwiYSIsImIiLCJkZWZhdWx0RmFjdG9yeSIsIm9yaWdpbiIsIm9wdHMiLCJCYWxhbmNlZFBvb2wiLCJjb25zdHJ1Y3RvciIsInVwc3RyZWFtcyIsImZhY3RvcnkiLCJtYXhXZWlnaHRQZXJTZXJ2ZXIiLCJlcnJvclBlbmFsdHkiLCJBcnJheSIsImlzQXJyYXkiLCJpbnRlcmNlcHRvcnMiLCJ1cHN0cmVhbSIsImFkZFVwc3RyZWFtIiwiX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzIiwidXBzdHJlYW1PcmlnaW4iLCJmaW5kIiwicG9vbCIsImNsb3NlZCIsImRlc3Ryb3llZCIsIk9iamVjdCIsImFzc2lnbiIsIm9uIiwiTWF0aCIsIm1pbiIsIm1heCIsImFyZ3MiLCJlcnIiLCJjb2RlIiwiY2xpZW50IiwibWFwIiwicCIsInJlZHVjZSIsInJlbW92ZVVwc3RyZWFtIiwiZmlsdGVyIiwiZGlzcGF0Y2hlciIsImxlbmd0aCIsImFsbENsaWVudHNCdXN5IiwiY291bnRlciIsIm1heFdlaWdodEluZGV4IiwiZmluZEluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/balanced-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/cache.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/cache/cache.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/cache/symbols.js\");\nconst { urlEquals, fieldValues: getFieldValues } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/cache/util.js\");\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { Response, cloneResponse } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/fetch/response.js\");\nconst { Request } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/fetch/request.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ../fetch/symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/fetch/index.js\");\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/./node_modules/undici/lib/global.js\");\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        const p = await this.matchAll(request, options);\n        if (p.length === 0) {\n            return;\n        }\n        return p[0];\n    }\n    async matchAll(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                // 2.2.1\n                r = new Request(request)[kState];\n            }\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                responses.push(requestResponse[1]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                responses.push(requestResponse[1]);\n            }\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = new Response(response.body?.source ?? null);\n            const body = responseObject[kState].body;\n            responseObject[kState] = response;\n            responseObject[kState].body = body;\n            responseObject[kHeaders][kHeadersList] = response.headersList;\n            responseObject[kHeaders][kGuard] = \"immutable\";\n            responseList.push(responseObject);\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n    async add(request) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.add\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.addAll\"\n        });\n        requests = webidl.converters[\"sequence<RequestInfo>\"](requests);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (const request of requests){\n            if (typeof request === \"string\") {\n                continue;\n            }\n            // 3.1\n            const r = request[kState];\n            // 3.2\n            if (!urlIsHttpHttpsScheme(r.url) || r.method !== \"GET\") {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme when method is not GET.\"\n                });\n            }\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new Request(request)[kState];\n            // 5.2\n            if (!urlIsHttpHttpsScheme(r.url)) {\n                throw webidl.errors.exception({\n                    header: \"Cache.addAll\",\n                    message: \"Expected http/s scheme.\"\n                });\n            }\n            // 5.4\n            r.initiator = \"fetch\";\n            r.destination = \"subresource\";\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = createDeferredPromise();\n            // 5.7\n            fetchControllers.push(fetching({\n                request: r,\n                dispatcher: getGlobalDispatcher(),\n                processResponse (response) {\n                    // 1.\n                    if (response.type === \"error\" || response.status === 206 || response.status < 200 || response.status > 299) {\n                        responsePromise.reject(webidl.errors.exception({\n                            header: \"Cache.addAll\",\n                            message: \"Received an invalid status code or the request failed.\"\n                        }));\n                    } else if (response.headersList.contains(\"vary\")) {\n                        // 2.1\n                        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n                        // 2.2\n                        for (const fieldValue of fieldValues){\n                            // 2.2.1\n                            if (fieldValue === \"*\") {\n                                responsePromise.reject(webidl.errors.exception({\n                                    header: \"Cache.addAll\",\n                                    message: \"invalid vary field value\"\n                                }));\n                                for (const controller of fetchControllers){\n                                    controller.abort();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException(\"aborted\", \"AbortError\"));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: \"put\",\n                request: requestList[index],\n                response\n            };\n            operations.push(operation) // 7.3.5\n            ;\n            index++ // 7.3.6\n            ;\n        }\n        // 7.5\n        const cacheJobPromise = createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve(undefined);\n            } else {\n                // 7.6.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Cache.put\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        response = webidl.converters.Response(response);\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof Request) {\n            innerRequest = request[kState];\n        } else {\n            innerRequest = new Request(request)[kState];\n        }\n        // 4.\n        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== \"GET\") {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Expected an http/s scheme when method is not GET\"\n            });\n        }\n        // 5.\n        const innerResponse = response[kState];\n        // 6.\n        if (innerResponse.status === 206) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Got 206 status\"\n            });\n        }\n        // 7.\n        if (innerResponse.headersList.contains(\"vary\")) {\n            // 7.1.\n            const fieldValues = getFieldValues(innerResponse.headersList.get(\"vary\"));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === \"*\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.put\",\n                        message: \"Got * vary field value\"\n                    });\n                }\n            }\n        }\n        // 8.\n        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n            throw webidl.errors.exception({\n                header: \"Cache.put\",\n                message: \"Response body is locked or disturbed\"\n            });\n        }\n        // 9.\n        const clonedResponse = cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else {\n            bodyReadPromise.resolve(undefined);\n        }\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"put\",\n            request: innerRequest,\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) {\n            clonedResponse.body.source = bytes;\n        }\n        // 19.1\n        const cacheJobPromise = createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve();\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Cache.delete\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof Request) {\n            r = request[kState];\n            if (r.method !== \"GET\" && !options.ignoreMethod) {\n                return false;\n            }\n        } else {\n            assert(typeof request === \"string\");\n            r = new Request(request)[kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"delete\",\n            request: r,\n            options\n        };\n        operations.push(operation);\n        const cacheJobPromise = createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) {\n                cacheJobPromise.resolve(!!requestResponses?.length);\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {readonly Request[]}\n   */ async keys(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        if (request !== undefined) request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.CacheQueryOptions(options);\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                r = new Request(request)[kState];\n            }\n        }\n        // 4.\n        const promise = createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                // 5.2.1.1\n                requests.push(requestResponse[0]);\n            }\n        } else {\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                // 5.3.2.1\n                requests.push(requestResponse[0]);\n            }\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = new Request(\"https://a\");\n                requestObject[kState] = request;\n                requestObject[kHeaders][kHeadersList] = request.headersList;\n                requestObject[kHeaders][kGuard] = \"immutable\";\n                requestObject[kRealm] = request.client;\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== \"delete\" && operation.type !== \"put\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: 'operation type does not match \"delete\" or \"put\"'\n                    });\n                }\n                // 4.2.2\n                if (operation.type === \"delete\" && operation.response != null) {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"delete operation should not have an associated response\"\n                    });\n                }\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n                    throw new DOMException(\"???\", \"InvalidStateError\");\n                }\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === \"delete\") {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) {\n                        return [];\n                    }\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === \"put\") {\n                    // 4.2.6.1\n                    if (operation.response == null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"put operation should have an associated response\"\n                        });\n                    }\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!urlIsHttpHttpsScheme(r.url)) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"expected http or https scheme\"\n                        });\n                    }\n                    // 4.2.6.4\n                    if (r.method !== \"GET\") {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"not get method\"\n                        });\n                    }\n                    // 4.2.6.5\n                    if (operation.options != null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"options must not be defined\"\n                        });\n                    }\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n                resultList.push(requestResponse);\n            }\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = \"\";\n            queryURL.search = \"\";\n        }\n        if (!urlEquals(queryURL, cachedURL, true)) {\n            return false;\n        }\n        if (response == null || options?.ignoreVary || !response.headersList.contains(\"vary\")) {\n            return true;\n        }\n        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === \"*\") {\n                return false;\n            }\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nObject.defineProperties(Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"Cache\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    matchAll: kEnumerableProperty,\n    add: kEnumerableProperty,\n    addAll: kEnumerableProperty,\n    put: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [\n    {\n        key: \"ignoreSearch\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreMethod\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"ignoreVary\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n    ...cacheQueryOptionConverters,\n    {\n        key: \"cacheName\",\n        converter: webidl.converters.DOMString\n    }\n]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters[\"sequence<RequestInfo>\"] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n    Cache\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsVUFBVSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxhQUFhQyxjQUFjLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDM0QsTUFBTSxFQUFFSSxtQkFBbUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU0sRUFBRU0sWUFBWSxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRU8sTUFBTSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRVEsUUFBUSxFQUFFQyxhQUFhLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDNUMsTUFBTSxFQUFFVSxPQUFPLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFFVyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR2QsbUJBQU9BLENBQUM7QUFDckQsTUFBTSxFQUFFZSxRQUFRLEVBQUUsR0FBR2YsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFZ0Isb0JBQW9CLEVBQUVDLHFCQUFxQixFQUFFQyxZQUFZLEVBQUUsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQzlFLE1BQU1tQixTQUFTbkIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFb0IsbUJBQW1CLEVBQUUsR0FBR3BCLG1CQUFPQSxDQUFDO0FBRXhDOzs7Ozs7O0NBT0MsR0FFRDs7O0NBR0MsR0FFRCxNQUFNcUI7SUFDSjs7O0dBR0MsR0FDRCxDQUFDQywyQkFBMkI7SUFFNUJDLGFBQWU7UUFDYixJQUFJQyxTQUFTLENBQUMsRUFBRSxLQUFLekIsWUFBWTtZQUMvQlEsT0FBT2tCLGtCQUFrQjtRQUMzQjtRQUVBLElBQUksQ0FBQyxDQUFDSCwyQkFBMkIsR0FBR0Us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QU87UUFDcENDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVduSSxPQUFPeUIsVUFBVSxDQUFDMkcsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtDQUNEO0FBRURySSxPQUFPeUIsVUFBVSxDQUFDRSxpQkFBaUIsR0FBRzNCLE9BQU9zSSxtQkFBbUIsQ0FBQ0w7QUFFakVqSSxPQUFPeUIsVUFBVSxDQUFDOEcsc0JBQXNCLEdBQUd2SSxPQUFPc0ksbUJBQW1CLENBQUM7T0FDakVMO0lBQ0g7UUFDRUMsS0FBSztRQUNMQyxXQUFXbkksT0FBT3lCLFVBQVUsQ0FBQytHLFNBQVM7SUFDeEM7Q0FDRDtBQUVEeEksT0FBT3lCLFVBQVUsQ0FBQ3hCLFFBQVEsR0FBR0QsT0FBT3lJLGtCQUFrQixDQUFDeEk7QUFFdkRELE9BQU95QixVQUFVLENBQUMsd0JBQXdCLEdBQUd6QixPQUFPMEksaUJBQWlCLENBQ25FMUksT0FBT3lCLFVBQVUsQ0FBQ0MsV0FBVztBQUcvQmlILE9BQU9DLE9BQU8sR0FBRztJQUNmOUg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvY2FjaGUuanM/ZTFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB1cmxFcXVhbHMsIGZpZWxkVmFsdWVzOiBnZXRGaWVsZFZhbHVlcyB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNEaXN0dXJiZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBSZXNwb25zZSwgY2xvbmVSZXNwb25zZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsga1N0YXRlLCBrSGVhZGVycywga0d1YXJkLCBrUmVhbG0gfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3N5bWJvbHMnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyB1cmxJc0h0dHBIdHRwc1NjaGVtZSwgY3JlYXRlRGVmZXJyZWRQcm9taXNlLCByZWFkQWxsQnl0ZXMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tY2FjaGUtYmF0Y2gtb3BlcmF0aW9uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYWNoZUJhdGNoT3BlcmF0aW9uXG4gKiBAcHJvcGVydHkgeydkZWxldGUnIHwgJ3B1dCd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXF1ZXN0XG4gKiBAcHJvcGVydHkge2FueX0gcmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gKiBAdHlwZWRlZiB7W2FueSwgYW55XVtdfSByZXF1ZXN0UmVzcG9uc2VMaXN0XG4gKi9cblxuY2xhc3MgQ2FjaGUge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LXJlcXVlc3QtcmVzcG9uc2UtbGlzdFxuICAgKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAhPT0ga0NvbnN0cnVjdCkge1xuICAgICAgd2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvcigpXG4gICAgfVxuXG4gICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYXJndW1lbnRzWzFdXG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlLm1hdGNoJyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBjb25zdCBwID0gYXdhaXQgdGhpcy5tYXRjaEFsbChyZXF1ZXN0LCBvcHRpb25zKVxuXG4gICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gcFswXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2hBbGwgKHJlcXVlc3QgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyAxLlxuICAgIGxldCByID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIDIuMi4xXG4gICAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXNwb25zZXMgPSBbXVxuXG4gICAgLy8gNS4yXG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gNS4yLjFcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCkge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIC8vIFdlIGRvbid0IGltcGxlbWVudCBDT1JzIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9vcCBvdmVyIHRoZSByZXNwb25zZXMsIHlheSFcblxuICAgIC8vIDUuNS4xXG4gICAgY29uc3QgcmVzcG9uc2VMaXN0ID0gW11cblxuICAgIC8vIDUuNS4yXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIC8vIDUuNS4yLjFcbiAgICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHk/LnNvdXJjZSA/PyBudWxsKVxuICAgICAgY29uc3QgYm9keSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uYm9keVxuICAgICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IHJlc3BvbnNlXG4gICAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLmJvZHkgPSBib2R5XG4gICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdpbW11dGFibGUnXG5cbiAgICAgIHJlc3BvbnNlTGlzdC5wdXNoKHJlc3BvbnNlT2JqZWN0KVxuICAgIH1cblxuICAgIC8vIDYuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzcG9uc2VMaXN0KVxuICB9XG5cbiAgYXN5bmMgYWRkIChyZXF1ZXN0KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlLmFkZCcgfSlcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuXG4gICAgLy8gMS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IFtyZXF1ZXN0XVxuXG4gICAgLy8gMi5cbiAgICBjb25zdCByZXNwb25zZUFycmF5UHJvbWlzZSA9IHRoaXMuYWRkQWxsKHJlcXVlc3RzKVxuXG4gICAgLy8gMy5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2VBcnJheVByb21pc2VcbiAgfVxuXG4gIGFzeW5jIGFkZEFsbCAocmVxdWVzdHMpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyB9KVxuXG4gICAgcmVxdWVzdHMgPSB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8UmVxdWVzdEluZm8+J10ocmVxdWVzdHMpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZXMgPSBbXVxuXG4gICAgLy8gMi5cbiAgICBjb25zdCByZXF1ZXN0TGlzdCA9IFtdXG5cbiAgICAvLyAzLlxuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAzLjFcbiAgICAgIGNvbnN0IHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgLy8gMy4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSB8fCByLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVC4nXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICAvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIGZldGNoaW5nPltdfSAqL1xuICAgIGNvbnN0IGZldGNoQ29udHJvbGxlcnMgPSBbXVxuXG4gICAgLy8gNS5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIC8vIDUuMVxuICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cblxuICAgICAgLy8gNS4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZS4nXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDUuNFxuICAgICAgci5pbml0aWF0b3IgPSAnZmV0Y2gnXG4gICAgICByLmRlc3RpbmF0aW9uID0gJ3N1YnJlc291cmNlJ1xuXG4gICAgICAvLyA1LjVcbiAgICAgIHJlcXVlc3RMaXN0LnB1c2gocilcblxuICAgICAgLy8gNS42XG4gICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgICAvLyA1LjdcbiAgICAgIGZldGNoQ29udHJvbGxlcnMucHVzaChmZXRjaGluZyh7XG4gICAgICAgIHJlcXVlc3Q6IHIsXG4gICAgICAgIGRpc3BhdGNoZXI6IGdldEdsb2JhbERpc3BhdGNoZXIoKSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgfHwgcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+IDI5OSkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhbiBpbnZhbGlkIHN0YXR1cyBjb2RlIG9yIHRoZSByZXF1ZXN0IGZhaWxlZC4nXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JykpIHsgLy8gMi5cbiAgICAgICAgICAgIC8vIDIuMVxuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgICAgICAgICAgLy8gMi4yXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgLy8gMi4yLjFcbiAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3Qod2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIHZhcnkgZmllbGQgdmFsdWUnXG4gICAgICAgICAgICAgICAgfSkpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgZmV0Y2hDb250cm9sbGVycykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIGlmIChyZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ2Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMi5cbiAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZSlcbiAgICAgICAgfVxuICAgICAgfSkpXG5cbiAgICAgIC8vIDUuOFxuICAgICAgcmVzcG9uc2VQcm9taXNlcy5wdXNoKHJlc3BvbnNlUHJvbWlzZS5wcm9taXNlKVxuICAgIH1cblxuICAgIC8vIDYuXG4gICAgY29uc3QgcCA9IFByb21pc2UuYWxsKHJlc3BvbnNlUHJvbWlzZXMpXG5cbiAgICAvLyA3LlxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHBcblxuICAgIC8vIDcuMVxuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gNy4yXG4gICAgbGV0IGluZGV4ID0gMFxuXG4gICAgLy8gNy4zXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIC8vIDcuMy4xXG4gICAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdwdXQnLCAvLyA3LjMuMlxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0TGlzdFtpbmRleF0sIC8vIDcuMy4zXG4gICAgICAgIHJlc3BvbnNlIC8vIDcuMy40XG4gICAgICB9XG5cbiAgICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pIC8vIDcuMy41XG5cbiAgICAgIGluZGV4KysgLy8gNy4zLjZcbiAgICB9XG5cbiAgICAvLyA3LjVcbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNy42LjFcbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuXG4gICAgLy8gNy42LjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gNy42LjNcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA3LjYuMy4xXG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDcuNi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDcuN1xuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgcHV0IChyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdDYWNoZS5wdXQnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICByZXNwb25zZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlKHJlc3BvbnNlKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgaW5uZXJSZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlubmVyUmVxdWVzdCA9IHJlcXVlc3Rba1N0YXRlXVxuICAgIH0gZWxzZSB7IC8vIDMuXG4gICAgICBpbm5lclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGlubmVyUmVxdWVzdC51cmwpIHx8IGlubmVyUmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0NhY2hlLnB1dCcsXG4gICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBhbiBodHRwL3Mgc2NoZW1lIHdoZW4gbWV0aG9kIGlzIG5vdCBHRVQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgY29uc3QgaW5uZXJSZXNwb25zZSA9IHJlc3BvbnNlW2tTdGF0ZV1cblxuICAgIC8vIDYuXG4gICAgaWYgKGlubmVyUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnQ2FjaGUucHV0JyxcbiAgICAgICAgbWVzc2FnZTogJ0dvdCAyMDYgc3RhdHVzJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA3LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JykpIHtcbiAgICAgIC8vIDcuMS5cbiAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgICAgLy8gNy4yLlxuICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgIC8vIDcuMi4xXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5wdXQnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0dvdCAqIHZhcnkgZmllbGQgdmFsdWUnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAmJiAoaXNEaXN0dXJiZWQoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkgfHwgaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbS5sb2NrZWQpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0NhY2hlLnB1dCcsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXNwb25zZSBib2R5IGlzIGxvY2tlZCBvciBkaXN0dXJiZWQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDkuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKGlubmVyUmVzcG9uc2UpXG5cbiAgICAvLyAxMC5cbiAgICBjb25zdCBib2R5UmVhZFByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTEuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxMS4xXG4gICAgICBjb25zdCBzdHJlYW0gPSBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtXG5cbiAgICAgIC8vIDExLjJcbiAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gICAgICAvLyAxMS4zXG4gICAgICByZWFkQWxsQnl0ZXMocmVhZGVyKS50aGVuKGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlLCBib2R5UmVhZFByb21pc2UucmVqZWN0KVxuICAgIH0gZWxzZSB7XG4gICAgICBib2R5UmVhZFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgLy8gMTIuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyAxMy5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ3B1dCcsIC8vIDE0LlxuICAgICAgcmVxdWVzdDogaW5uZXJSZXF1ZXN0LCAvLyAxNS5cbiAgICAgIHJlc3BvbnNlOiBjbG9uZWRSZXNwb25zZSAvLyAxNi5cbiAgICB9XG5cbiAgICAvLyAxNy5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgLy8gMTkuXG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBib2R5UmVhZFByb21pc2UucHJvbWlzZVxuXG4gICAgaWYgKGNsb25lZFJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY2xvbmVkUmVzcG9uc2UuYm9keS5zb3VyY2UgPSBieXRlc1xuICAgIH1cblxuICAgIC8vIDE5LjFcbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTkuMi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDE5LjIuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyAxOS4yLjNcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyAxOS4yLjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9IGVsc2UgeyAvLyAxOS4yLjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBkZWxldGUgKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZS5kZWxldGUnIH0pXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZXF1ZXN0fVxuICAgICAqL1xuICAgIGxldCByID0gbnVsbFxuXG4gICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKVxuXG4gICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgcmVxdWVzdDogcixcbiAgICAgIG9wdGlvbnNcbiAgICB9XG5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG4gICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSghIXJlcXVlc3RSZXNwb25zZXM/Lmxlbmd0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGUta2V5c1xuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7cmVhZG9ubHkgUmVxdWVzdFtdfVxuICAgKi9cbiAgYXN5bmMga2V5cyAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDIuMVxuICAgICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykgeyAvLyAyLjJcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIC8vIDUuMi4xLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgLy8gNS4zLjIuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA1LjQuMVxuICAgICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgICAvLyA1LjQuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdCgnaHR0cHM6Ly9hJylcbiAgICAgICAgcmVxdWVzdE9iamVjdFtrU3RhdGVdID0gcmVxdWVzdFxuICAgICAgICByZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVxdWVzdC5oZWFkZXJzTGlzdFxuICAgICAgICByZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcbiAgICAgICAgcmVxdWVzdE9iamVjdFtrUmVhbG1dID0gcmVxdWVzdC5jbGllbnRcblxuICAgICAgICAvLyA1LjQuMi4xXG4gICAgICAgIHJlcXVlc3RMaXN0LnB1c2gocmVxdWVzdE9iamVjdClcbiAgICAgIH1cblxuICAgICAgLy8gNS40LjNcbiAgICAgIHByb21pc2UucmVzb2x2ZShPYmplY3QuZnJlZXplKHJlcXVlc3RMaXN0KSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2JhdGNoLWNhY2hlLW9wZXJhdGlvbnMtYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2JhdGNoQ2FjaGVPcGVyYXRpb25zIChvcGVyYXRpb25zKSB7XG4gICAgLy8gMS5cbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgLy8gMi5cbiAgICBjb25zdCBiYWNrdXBDYWNoZSA9IFsuLi5jYWNoZV1cblxuICAgIC8vIDMuXG4gICAgY29uc3QgYWRkZWRJdGVtcyA9IFtdXG5cbiAgICAvLyA0LjFcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIHRyeSB7XG4gICAgICAvLyA0LjJcbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgLy8gNC4yLjFcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlICE9PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24udHlwZSAhPT0gJ3B1dCcpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ29wZXJhdGlvbiB0eXBlIGRvZXMgbm90IG1hdGNoIFwiZGVsZXRlXCIgb3IgXCJwdXRcIidcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24ucmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnZGVsZXRlIG9wZXJhdGlvbiBzaG91bGQgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjNcbiAgICAgICAgaWYgKHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zLCBhZGRlZEl0ZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCc/Pz8nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjRcbiAgICAgICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgICAgICAvLyA0LjIuNVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgLy8gNC4yLjUuMVxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucylcblxuICAgICAgICAgIC8vIFRPRE86IHRoZSBzcGVjIGlzIHdyb25nLCB0aGlzIGlzIG5lZWRlZCB0byBwYXNzIFdQVHNcbiAgICAgICAgICBpZiAocmVxdWVzdFJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi41LjJcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNS4yLjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSAncHV0JykgeyAvLyA0LjIuNlxuICAgICAgICAgIC8vIDQuMi42LjFcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLnJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3B1dCBvcGVyYXRpb24gc2hvdWxkIGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuMlxuICAgICAgICAgIGNvbnN0IHIgPSBvcGVyYXRpb24ucmVxdWVzdFxuXG4gICAgICAgICAgLy8gNC4yLjYuM1xuICAgICAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdleHBlY3RlZCBodHRwIG9yIGh0dHBzIHNjaGVtZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNFxuICAgICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ25vdCBnZXQgbWV0aG9kJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi41XG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ29wdGlvbnMgbXVzdCBub3QgYmUgZGVmaW5lZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNlxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0KVxuXG4gICAgICAgICAgLy8gNC4yLjYuN1xuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi42LjcuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi44XG4gICAgICAgICAgY2FjaGUucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG5cbiAgICAgICAgICAvLyA0LjIuNi4xMFxuICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuN1xuICAgICAgICByZXN1bHRMaXN0LnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgfVxuXG4gICAgICAvLyA0LjNcbiAgICAgIHJldHVybiByZXN1bHRMaXN0XG4gICAgfSBjYXRjaCAoZSkgeyAvLyA1LlxuICAgICAgLy8gNS4xXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QubGVuZ3RoID0gMFxuXG4gICAgICAvLyA1LjJcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGJhY2t1cENhY2hlXG5cbiAgICAgIC8vIDUuM1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNxdWVyeS1jYWNoZVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gdGFyZ2V0U3RvcmFnZVxuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNxdWVyeUNhY2hlIChyZXF1ZXN0UXVlcnksIG9wdGlvbnMsIHRhcmdldFN0b3JhZ2UpIHtcbiAgICAvKiogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9ICovXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0U3RvcmFnZSA/PyB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IFtjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZV0gPSByZXF1ZXN0UmVzcG9uc2VcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0ocmVxdWVzdFF1ZXJ5LCBjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3JlcXVlc3QtbWF0Y2hlcy1jYWNoZWQtaXRlbS1hbGdvcml0aG1cbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueSB8IG51bGx9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zIHwgdW5kZWZpbmVkfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSAocmVxdWVzdFF1ZXJ5LCByZXF1ZXN0LCByZXNwb25zZSA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiAob3B0aW9ucz8uaWdub3JlTWV0aG9kID09PSBmYWxzZSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyAgIHJldHVybiBmYWxzZVxuICAgIC8vIH1cblxuICAgIGNvbnN0IHF1ZXJ5VVJMID0gbmV3IFVSTChyZXF1ZXN0UXVlcnkudXJsKVxuXG4gICAgY29uc3QgY2FjaGVkVVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybClcblxuICAgIGlmIChvcHRpb25zPy5pZ25vcmVTZWFyY2gpIHtcbiAgICAgIGNhY2hlZFVSTC5zZWFyY2ggPSAnJ1xuXG4gICAgICBxdWVyeVVSTC5zZWFyY2ggPSAnJ1xuICAgIH1cblxuICAgIGlmICghdXJsRXF1YWxzKHF1ZXJ5VVJMLCBjYWNoZWRVUkwsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICByZXNwb25zZSA9PSBudWxsIHx8XG4gICAgICBvcHRpb25zPy5pZ25vcmVWYXJ5IHx8XG4gICAgICAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0VmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuICAgICAgY29uc3QgcXVlcnlWYWx1ZSA9IHJlcXVlc3RRdWVyeS5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcblxuICAgICAgLy8gSWYgb25lIGhhcyB0aGUgaGVhZGVyIGFuZCB0aGUgb3RoZXIgZG9lc24ndCwgb3Igb25lIGhhc1xuICAgICAgLy8gYSBkaWZmZXJlbnQgdmFsdWUgdGhhbiB0aGUgb3RoZXIsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHJlcXVlc3RWYWx1ZSAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhY2hlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbWF0Y2hBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwdXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuY29uc3QgY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMgPSBbXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVTZWFyY2gnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVNZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVWYXJ5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9XG5dXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzLFxuICB7XG4gICAga2V5OiAnY2FjaGVOYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5SZXNwb25zZSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoUmVzcG9uc2UpXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxSZXF1ZXN0SW5mbz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm9cbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlXG59XG4iXSwibmFtZXMiOlsia0NvbnN0cnVjdCIsInJlcXVpcmUiLCJ1cmxFcXVhbHMiLCJmaWVsZFZhbHVlcyIsImdldEZpZWxkVmFsdWVzIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImlzRGlzdHVyYmVkIiwia0hlYWRlcnNMaXN0Iiwid2ViaWRsIiwiUmVzcG9uc2UiLCJjbG9uZVJlc3BvbnNlIiwiUmVxdWVzdCIsImtTdGF0ZSIsImtIZWFkZXJzIiwia0d1YXJkIiwia1JlYWxtIiwiZmV0Y2hpbmciLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsImNyZWF0ZURlZmVycmVkUHJvbWlzZSIsInJlYWRBbGxCeXRlcyIsImFzc2VydCIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJDYWNoZSIsInJlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiaWxsZWdhbENvbnN0cnVjdG9yIiwibWF0Y2giLCJyZXF1ZXN0Iiwib3B0aW9ucyIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiaGVhZGVyIiwiY29udmVydGVycyIsIlJlcXVlc3RJbmZvIiwiQ2FjaGVRdWVyeU9wdGlvbnMiLCJwIiwibWF0Y2hBbGwiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyIiwibWV0aG9kIiwiaWdub3JlTWV0aG9kIiwicmVzcG9uc2VzIiwicmVxdWVzdFJlc3BvbnNlIiwicHVzaCIsInJlcXVlc3RSZXNwb25zZXMiLCJxdWVyeUNhY2hlIiwicmVzcG9uc2VMaXN0IiwicmVzcG9uc2UiLCJyZXNwb25zZU9iamVjdCIsImJvZHkiLCJzb3VyY2UiLCJoZWFkZXJzTGlzdCIsIk9iamVjdCIsImZyZWV6ZSIsImFkZCIsInJlcXVlc3RzIiwicmVzcG9uc2VBcnJheVByb21pc2UiLCJhZGRBbGwiLCJyZXNwb25zZVByb21pc2VzIiwicmVxdWVzdExpc3QiLCJ1cmwiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiZmV0Y2hDb250cm9sbGVycyIsImluaXRpYXRvciIsImRlc3RpbmF0aW9uIiwicmVzcG9uc2VQcm9taXNlIiwiZGlzcGF0Y2hlciIsInByb2Nlc3NSZXNwb25zZSIsInR5cGUiLCJzdGF0dXMiLCJyZWplY3QiLCJjb250YWlucyIsImdldCIsImZpZWxkVmFsdWUiLCJjb250cm9sbGVyIiwiYWJvcnQiLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkiLCJhYm9ydGVkIiwiRE9NRXhjZXB0aW9uIiwicmVzb2x2ZSIsInByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwib3BlcmF0aW9ucyIsImluZGV4Iiwib3BlcmF0aW9uIiwiY2FjaGVKb2JQcm9taXNlIiwiZXJyb3JEYXRhIiwiYmF0Y2hDYWNoZU9wZXJhdGlvbnMiLCJlIiwicXVldWVNaWNyb3Rhc2siLCJwdXQiLCJpbm5lclJlcXVlc3QiLCJpbm5lclJlc3BvbnNlIiwic3RyZWFtIiwibG9ja2VkIiwiY2xvbmVkUmVzcG9uc2UiLCJib2R5UmVhZFByb21pc2UiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJ0aGVuIiwiYnl0ZXMiLCJkZWxldGUiLCJrZXlzIiwicmVxdWVzdE9iamVjdCIsImNsaWVudCIsImNhY2hlIiwiYmFja3VwQ2FjaGUiLCJhZGRlZEl0ZW1zIiwicmVzdWx0TGlzdCIsImlkeCIsImluZGV4T2YiLCJzcGxpY2UiLCJyZXF1ZXN0UXVlcnkiLCJ0YXJnZXRTdG9yYWdlIiwic3RvcmFnZSIsImNhY2hlZFJlcXVlc3QiLCJjYWNoZWRSZXNwb25zZSIsInJlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSIsInF1ZXJ5VVJMIiwiVVJMIiwiY2FjaGVkVVJMIiwiaWdub3JlU2VhcmNoIiwic2VhcmNoIiwiaWdub3JlVmFyeSIsInJlcXVlc3RWYWx1ZSIsInF1ZXJ5VmFsdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJNdWx0aUNhY2hlUXVlcnlPcHRpb25zIiwiRE9NU3RyaW5nIiwiaW50ZXJmYWNlQ29udmVydGVyIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/cachestorage.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/cache/cachestorage.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/cache/symbols.js\");\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/undici/lib/cache/cache.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nclass CacheStorage {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */ #caches;\n    constructor(){\n        this.#caches = new Map();\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.match\"\n        });\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.MultiCacheQueryOptions(options);\n        // 1.\n        if (options.cacheName != null) {\n            // 1.1.1.1\n            if (this.#caches.has(options.cacheName)) {\n                // 1.1.1.1.1\n                const cacheList = this.#caches.get(options.cacheName);\n                const cache = new Cache(kConstruct, cacheList);\n                return await cache.match(request, options);\n            }\n        } else {\n            // 2.2\n            for (const cacheList of this.#caches.values()){\n                const cache = new Cache(kConstruct, cacheList);\n                // 2.2.1.2\n                const response = await cache.match(request, options);\n                if (response !== undefined) {\n                    return response;\n                }\n            }\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async has(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.has\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1.1\n        // 2.2\n        return this.#caches.has(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */ async open(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.open\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        // 2.1\n        if (this.#caches.has(cacheName)) {\n            // await caches.open('v1') !== await caches.open('v1')\n            // 2.1.1\n            const cache = this.#caches.get(cacheName);\n            // 2.1.1.1\n            return new Cache(kConstruct, cache);\n        }\n        // 2.2\n        const cache = [];\n        // 2.3\n        this.#caches.set(cacheName, cache);\n        // 2.4\n        return new Cache(kConstruct, cache);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async delete(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CacheStorage.delete\"\n        });\n        cacheName = webidl.converters.DOMString(cacheName);\n        return this.#caches.delete(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {string[]}\n   */ async keys() {\n        webidl.brandCheck(this, CacheStorage);\n        // 2.1\n        const keys = this.#caches.keys();\n        // 2.2\n        return [\n            ...keys\n        ];\n    }\n}\nObject.defineProperties(CacheStorage.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CacheStorage\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    has: kEnumerableProperty,\n    open: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nmodule.exports = {\n    CacheStorage\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVFLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVHLG1CQUFtQixFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRXhDLE1BQU1JO0lBQ0o7OztHQUdDLEdBQ0QsQ0FBQ0MsTUFBTSxDQUFZO0lBRW5CQyxhQUFlO2FBRmYsQ0FBQ0QsTUFBTSxHQUFHLElBQUlFO1FBR1osSUFBSUMsU0FBUyxDQUFDLEVBQUUsS0FBS1QsWUFBWTtZQUMvQkcsT0FBT08sa0JBQWtCO1FBQzNCO0lBQ0Y7SUFFQSxNQUFNQyxNQUFPQyxPQUFPLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDbENWLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBcUI7UUFFeEVKLFVBQVVULE9BQU9jLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTjtRQUN4Q0MsVUFBVVYsT0FBT2MsVUFBVSxDQUFDRSxzQkFBc0IsQ0FBQ047UUFFbkQsS0FBSztRQUNMLElBQUlBLFFBQVFPLFNBQVMsSUFBSSxNQUFNO1lBQzdCLFVBQVU7WUFDVixJQUFJLElBQUksQ0FBQyxDQUFDZCxNQUFNLENBQUNlLEdBQUcsQ0FBQ1IsUUFBUU8sU0FBUyxHQUFHO2dCQUN2QyxZQUFZO2dCQUNaLE1BQU1FLFlBQVksSUFBSSxDQUFDLENBQUNoQixNQUFNLENBQUNpQixHQUFHLENBQUNWLFFBQVFPLFNBQVM7Z0JBQ3BELE1BQU1JLFFBQVEsSUFBSXRCLE1BQU1GLFlBQVlzQjtnQkFFcEMsT0FBTyxNQUFNRSxNQUFNYixLQUFLLENBQUNDLFNBQVNDO1lBQ3BDO1FBQ0YsT0FBTztZQUNMLE1BQU07WUFDTixLQUFLLE1BQU1TLGFBQWEsSUFBSSxDQUFDLENBQUNoQixNQUFNLENBQUNtQixNQUFNLEdBQUk7Z0JBQzdDLE1BQU1ELFFBQVEsSUFBSXRCLE1BQU1GLFlBQVlzQjtnQkFFcEMsVUFBVTtnQkFDVixNQUFNSSxXQUFXLE1BQU1GLE1BQU1iLEtBQUssQ0FBQ0MsU0FBU0M7Z0JBRTVDLElBQUlhLGFBQWFDLFdBQVc7b0JBQzFCLE9BQU9EO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1MLElBQUtELFNBQVMsRUFBRTtRQUNwQmpCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBQ3hCRixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHO1lBQUVPLFFBQVE7UUFBbUI7UUFFdEVJLFlBQVlqQixPQUFPYyxVQUFVLENBQUNXLFNBQVMsQ0FBQ1I7UUFFeEMsUUFBUTtRQUNSLE1BQU07UUFDTixPQUFPLElBQUksQ0FBQyxDQUFDZCxNQUFNLENBQUNlLEdBQUcsQ0FBQ0Q7SUFDMUI7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTVMsS0FBTVQsU0FBUyxFQUFFO1FBQ3JCakIsT0FBT1csVUFBVSxDQUFDLElBQUksRUFBRVQ7UUFDeEJGLE9BQU9ZLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7WUFBRU8sUUFBUTtRQUFvQjtRQUV2RUksWUFBWWpCLE9BQU9jLFVBQVUsQ0FBQ1csU0FBUyxDQUFDUjtRQUV4QyxNQUFNO1FBQ04sSUFBSSxJQUFJLENBQUMsQ0FBQ2QsTUFBTSxDQUFDZSxHQUFHLENBQUNELFlBQVk7WUFDL0Isc0RBQXNEO1lBRXRELFFBQVE7WUFDUixNQUFNSSxRQUFRLElBQUksQ0FBQyxDQUFDbEIsTUFBTSxDQUFDaUIsR0FBRyxDQUFDSDtZQUUvQixVQUFVO1lBQ1YsT0FBTyxJQUFJbEIsTUFBTUYsWUFBWXdCO1FBQy9CO1FBRUEsTUFBTTtRQUNOLE1BQU1BLFFBQVEsRUFBRTtRQUVoQixNQUFNO1FBQ04sSUFBSSxDQUFDLENBQUNsQixNQUFNLENBQUN3QixHQUFHLENBQUNWLFdBQVdJO1FBRTVCLE1BQU07UUFDTixPQUFPLElBQUl0QixNQUFNRixZQUFZd0I7SUFDL0I7SUFFQTs7OztHQUlDLEdBQ0QsTUFBTU8sT0FBUVgsU0FBUyxFQUFFO1FBQ3ZCakIsT0FBT1csVUFBVSxDQUFDLElBQUksRUFBRVQ7UUFDeEJGLE9BQU9ZLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7WUFBRU8sUUFBUTtRQUFzQjtRQUV6RUksWUFBWWpCLE9BQU9jLFVBQVUsQ0FBQ1csU0FBUyxDQUFDUjtRQUV4QyxPQUFPLElBQUksQ0FBQyxDQUFDZCxNQUFNLENBQUN5QixNQUFNLENBQUNYO0lBQzdCO0lBRUE7OztHQUdDLEdBQ0QsTUFBTVksT0FBUTtRQUNaN0IsT0FBT1csVUFBVSxDQUFDLElBQUksRUFBRVQ7UUFFeEIsTUFBTTtRQUNOLE1BQU0yQixPQUFPLElBQUksQ0FBQyxDQUFDMUIsTUFBTSxDQUFDMEIsSUFBSTtRQUU5QixNQUFNO1FBQ04sT0FBTztlQUFJQTtTQUFLO0lBQ2xCO0FBQ0Y7QUFFQUMsT0FBT0MsZ0JBQWdCLENBQUM3QixhQUFhOEIsU0FBUyxFQUFFO0lBQzlDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQTVCLE9BQU9QO0lBQ1BpQixLQUFLakI7SUFDTHlCLE1BQU16QjtJQUNOMkIsUUFBUTNCO0lBQ1I0QixNQUFNNUI7QUFDUjtBQUVBb0MsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZwQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9jYWNoZXN0b3JhZ2UuanM/ZTM5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBDYWNoZSB9ID0gcmVxdWlyZSgnLi9jYWNoZScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY2xhc3MgQ2FjaGVTdG9yYWdlIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZWxldmFudC1uYW1lLXRvLWNhY2hlLW1hcFxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgaW1wb3J0KCcuL2NhY2hlJykucmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNjYWNoZXMgPSBuZXcgTWFwKClcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAhPT0ga0NvbnN0cnVjdCkge1xuICAgICAgd2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvcigpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnQ2FjaGVTdG9yYWdlLm1hdGNoJyB9KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIDEuXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVOYW1lICE9IG51bGwpIHtcbiAgICAgIC8vIDEuMS4xLjFcbiAgICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKG9wdGlvbnMuY2FjaGVOYW1lKSkge1xuICAgICAgICAvLyAxLjEuMS4xLjFcbiAgICAgICAgY29uc3QgY2FjaGVMaXN0ID0gdGhpcy4jY2FjaGVzLmdldChvcHRpb25zLmNhY2hlTmFtZSlcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGVMaXN0KVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDIuXG4gICAgICAvLyAyLjJcbiAgICAgIGZvciAoY29uc3QgY2FjaGVMaXN0IG9mIHRoaXMuI2NhY2hlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgLy8gMi4yLjEuMlxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKHJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWhhc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgaGFzIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlU3RvcmFnZS5oYXMnIH0pXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lKVxuXG4gICAgLy8gMi4xLjFcbiAgICAvLyAyLjJcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZG9tLWNhY2hlc3RvcmFnZS1vcGVuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGU+fVxuICAgKi9cbiAgYXN5bmMgb3BlbiAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDYWNoZVN0b3JhZ2Uub3BlbicgfSlcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUpXG5cbiAgICAvLyAyLjFcbiAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpKSB7XG4gICAgICAvLyBhd2FpdCBjYWNoZXMub3BlbigndjEnKSAhPT0gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJylcblxuICAgICAgLy8gMi4xLjFcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jY2FjaGVzLmdldChjYWNoZU5hbWUpXG5cbiAgICAgIC8vIDIuMS4xLjFcbiAgICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gICAgfVxuXG4gICAgLy8gMi4yXG4gICAgY29uc3QgY2FjaGUgPSBbXVxuXG4gICAgLy8gMi4zXG4gICAgdGhpcy4jY2FjaGVzLnNldChjYWNoZU5hbWUsIGNhY2hlKVxuXG4gICAgLy8gMi40XG4gICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0NhY2hlU3RvcmFnZS5kZWxldGUnIH0pXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lKVxuXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5kZWxldGUoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2Uta2V5c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBhc3luYyBrZXlzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICAvLyAyLjFcbiAgICBjb25zdCBrZXlzID0gdGhpcy4jY2FjaGVzLmtleXMoKVxuXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIFsuLi5rZXlzXVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhY2hlU3RvcmFnZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0NhY2hlU3RvcmFnZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlU3RvcmFnZVxufVxuIl0sIm5hbWVzIjpbImtDb25zdHJ1Y3QiLCJyZXF1aXJlIiwiQ2FjaGUiLCJ3ZWJpZGwiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiQ2FjaGVTdG9yYWdlIiwiY2FjaGVzIiwiY29uc3RydWN0b3IiLCJNYXAiLCJhcmd1bWVudHMiLCJpbGxlZ2FsQ29uc3RydWN0b3IiLCJtYXRjaCIsInJlcXVlc3QiLCJvcHRpb25zIiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiUmVxdWVzdEluZm8iLCJNdWx0aUNhY2hlUXVlcnlPcHRpb25zIiwiY2FjaGVOYW1lIiwiaGFzIiwiY2FjaGVMaXN0IiwiZ2V0IiwiY2FjaGUiLCJ2YWx1ZXMiLCJyZXNwb25zZSIsInVuZGVmaW5lZCIsIkRPTVN0cmluZyIsIm9wZW4iLCJzZXQiLCJkZWxldGUiLCJrZXlzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/cachestorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cache/symbols.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kConstruct: Symbol(\"constructable\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxZQUFZQyxPQUFPO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9zeW1ib2xzLmpzP2QzNTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ29uc3RydWN0OiBTeW1ib2woJ2NvbnN0cnVjdGFibGUnKVxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJrQ29uc3RydWN0IiwiU3ltYm9sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/util.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/cache/util.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */ function urlEquals(A, B, excludeFragment = false) {\n    const serializedA = URLSerializer(A, excludeFragment);\n    const serializedB = URLSerializer(B, excludeFragment);\n    return serializedA === serializedB;\n}\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */ function fieldValues(header) {\n    assert(header !== null);\n    const values = [];\n    for (let value of header.split(\",\")){\n        value = value.trim();\n        if (!value.length) {\n            continue;\n        } else if (!isValidHeaderName(value)) {\n            continue;\n        }\n        values.push(value);\n    }\n    return values;\n}\nmodule.exports = {\n    urlEquals,\n    fieldValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRSxpQkFBaUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUV0Qzs7Ozs7O0NBTUMsR0FDRCxTQUFTRyxVQUFXQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsa0JBQWtCLEtBQUs7SUFDL0MsTUFBTUMsY0FBY04sY0FBY0csR0FBR0U7SUFFckMsTUFBTUUsY0FBY1AsY0FBY0ksR0FBR0M7SUFFckMsT0FBT0MsZ0JBQWdCQztBQUN6QjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNDLFlBQWFDLE1BQU07SUFDMUJYLE9BQU9XLFdBQVc7SUFFbEIsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLEtBQUssSUFBSUMsU0FBU0YsT0FBT0csS0FBSyxDQUFDLEtBQU07UUFDbkNELFFBQVFBLE1BQU1FLElBQUk7UUFFbEIsSUFBSSxDQUFDRixNQUFNRyxNQUFNLEVBQUU7WUFDakI7UUFDRixPQUFPLElBQUksQ0FBQ2Isa0JBQWtCVSxRQUFRO1lBQ3BDO1FBQ0Y7UUFFQUQsT0FBT0ssSUFBSSxDQUFDSjtJQUNkO0lBRUEsT0FBT0Q7QUFDVDtBQUVBTSxPQUFPQyxPQUFPLEdBQUc7SUFDZmY7SUFDQU07QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2FjaGUvdXRpbC5qcz9hMGFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhVVJMJylcbmNvbnN0IHsgaXNWYWxpZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1lcXVhbHNcbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSBleGNsdWRlRnJhZ21lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxFcXVhbHMgKEEsIEIsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRBID0gVVJMU2VyaWFsaXplcihBLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgY29uc3Qgc2VyaWFsaXplZEIgPSBVUkxTZXJpYWxpemVyKEIsIGV4Y2x1ZGVGcmFnbWVudClcblxuICByZXR1cm4gc2VyaWFsaXplZEEgPT09IHNlcmlhbGl6ZWRCXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi82OTRkMjBkMTM0Y2I1NTNkOGQ4OWU1NTAwYjkxNDgwMTJiMWJhMjk5L2NvbnRlbnQvYnJvd3Nlci9jYWNoZV9zdG9yYWdlL2NhY2hlX3N0b3JhZ2VfY2FjaGUuY2MjTDI2MC1MMjYyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGZpZWxkVmFsdWVzIChoZWFkZXIpIHtcbiAgYXNzZXJ0KGhlYWRlciAhPT0gbnVsbClcblxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIGZvciAobGV0IHZhbHVlIG9mIGhlYWRlci5zcGxpdCgnLCcpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKHZhbHVlKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVybEVxdWFscyxcbiAgZmllbGRWYWx1ZXNcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiVVJMU2VyaWFsaXplciIsImlzVmFsaWRIZWFkZXJOYW1lIiwidXJsRXF1YWxzIiwiQSIsIkIiLCJleGNsdWRlRnJhZ21lbnQiLCJzZXJpYWxpemVkQSIsInNlcmlhbGl6ZWRCIiwiZmllbGRWYWx1ZXMiLCJoZWFkZXIiLCJ2YWx1ZXMiLCJ2YWx1ZSIsInNwbGl0IiwidHJpbSIsImxlbmd0aCIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/client.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/client.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// @ts-check\n\n/* global WebAssembly */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst timers = __webpack_require__(/*! ./timers */ \"(rsc)/./node_modules/undici/lib/timers.js\");\nconst Request = __webpack_require__(/*! ./core/request */ \"(rsc)/./node_modules/undici/lib/core/request.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher-base.js\");\nconst { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\");\nconst { kUrl, kReset, kServerName, kClient, kBusy, kParser, kConnect, kBlocking, kResuming, kRunning, kPending, kSize, kWriting, kQueue, kConnected, kConnecting, kNeedDrain, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, // HTTP2\nkHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\n/** @type {import('http2')} */ let http2;\ntry {\n    http2 = __webpack_require__(/*! http2 */ \"http2\");\n} catch  {\n    // @ts-ignore\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\n// Experimental\nlet h2ExperimentalWarned = false;\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol(\"kClosedResolve\");\nconst channels = {};\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.sendHeaders = diagnosticsChannel.channel(\"undici:client:sendHeaders\");\n    channels.beforeConnect = diagnosticsChannel.channel(\"undici:client:beforeConnect\");\n    channels.connectError = diagnosticsChannel.channel(\"undici:client:connectError\");\n    channels.connected = diagnosticsChannel.channel(\"undici:client:connected\");\n} catch  {\n    channels.sendHeaders = {\n        hasSubscribers: false\n    };\n    channels.beforeConnect = {\n        hasSubscribers: false\n    };\n    channels.connectError = {\n        hasSubscribers: false\n    };\n    channels.connected = {\n        hasSubscribers: false\n    };\n}\n/**\n * @type {import('../types/client').default}\n */ class Client extends DispatcherBase {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */ constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, // h2\n    allowH2, maxConcurrentStreams } = {}){\n        super();\n        if (keepAlive !== undefined) {\n            throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n            throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n            throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n            throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (localAddress != null && (typeof localAddress !== \"string\" || net.isIP(localAddress) === 0)) {\n            throw new InvalidArgumentError(\"localAddress must be valid string IP address\");\n        }\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n            throw new InvalidArgumentError(\"maxResponseSize must be a positive number\");\n        }\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n            throw new InvalidArgumentError(\"autoSelectFamilyAttemptTimeout must be a positive number\");\n        }\n        // h2\n        if (allowH2 != null && typeof allowH2 !== \"boolean\") {\n            throw new InvalidArgumentError(\"allowH2 must be a valid boolean value\");\n        }\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== \"number\" || maxConcurrentStreams < 1)) {\n            throw new InvalidArgumentError(\"maxConcurrentStreams must be a possitive integer, greater than 0\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kUrl] = util.parseOrigin(url);\n        this[kConnector] = connect;\n        this[kSocket] = null;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kLocalAddress] = localAddress != null ? localAddress : null;\n        this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n        ;\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[kHTTPConnVersion] = \"h1\";\n        // HTTP/2\n        this[kHTTP2Session] = null;\n        this[kHTTP2SessionState] = !allowH2 ? null : {\n            // streams: null, // Fixed queue of streams - For future support of `push`\n            openStreams: 0,\n            maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n        };\n        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}`;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(value) {\n        this[kPipelining] = value;\n        resume(this, true);\n    }\n    get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n    }\n    get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n    }\n    get [kConnected]() {\n        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n    }\n    get [kBusy]() {\n        const socket = this[kSocket];\n        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n    }\n    /* istanbul ignore: only used for test */ [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n    }\n    [kDispatch](opts, handler) {\n        const origin = opts.origin || this[kUrl].origin;\n        const request = this[kHTTPConnVersion] === \"h2\" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);\n        this[kQueue].push(request);\n        if (this[kResuming]) {\n        // Do nothing.\n        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[kResuming] = 1;\n            process.nextTick(resume, this);\n        } else {\n            resume(this, true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n            this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n    }\n    async [kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (!this[kSize]) {\n                resolve(null);\n            } else {\n                this[kClosedResolve] = resolve;\n            }\n        });\n    }\n    async [kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[kQueue].splice(this[kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[kClosedResolve]();\n                    this[kClosedResolve] = null;\n                }\n                resolve();\n            };\n            if (this[kHTTP2Session] != null) {\n                util.destroy(this[kHTTP2Session], err);\n                this[kHTTP2Session] = null;\n                this[kHTTP2SessionState] = null;\n            }\n            if (!this[kSocket]) {\n                queueMicrotask(callback);\n            } else {\n                util.destroy(this[kSocket].on(\"close\", callback), err);\n            }\n            resume(this);\n        });\n    }\n}\nfunction onHttp2SessionError(err) {\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    this[kSocket][kError] = err;\n    onError(this[kClient], err);\n}\nfunction onHttp2FrameError(type, code, id) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n    if (id === 0) {\n        this[kSocket][kError] = err;\n        onError(this[kClient], err);\n    }\n}\nfunction onHttp2SessionEnd() {\n    util.destroy(this, new SocketError(\"other side closed\"));\n    util.destroy(this[kSocket], new SocketError(\"other side closed\"));\n}\nfunction onHTTP2GoAway(code) {\n    const client = this[kClient];\n    const err = new InformationalError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    client[kSocket] = null;\n    client[kHTTP2Session] = null;\n    if (client.destroyed) {\n        assert(this[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(this, request, err);\n        }\n    } else if (client[kRunning] > 0) {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nconst constants = __webpack_require__(/*! ./llhttp/constants */ \"(rsc)/./node_modules/undici/lib/llhttp/constants.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./interceptor/redirectInterceptor */ \"(rsc)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\");\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(Buffer.from(__webpack_require__(/*! ./llhttp/llhttp_simd-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"), \"base64\"));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__(/*! ./llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"), \"base64\"));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n    constructor(client, socket, { exports }){\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n        this.connection = \"\";\n        this.maxResponseSize = client[kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            timers.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = timers.setTimeout(onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) {\n                    this.timeout.unref();\n                }\n            } else {\n                this.timeout = null;\n            }\n            this.timeoutValue = value;\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) {\n            return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n        ;\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) {\n                break;\n            }\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n            if (currentBufferPtr) {\n                llhttp.free(currentBufferPtr);\n            }\n            currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                currentBufferRef = data;\n                currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                currentParser = null;\n                currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (ret === constants.ERROR.PAUSED_UPGRADE) {\n                this.onUpgrade(data.slice(offset));\n            } else if (ret === constants.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== constants.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = \"\";\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = \"Response does not match the HTTP/1.1 protocol (\" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + \")\";\n                }\n                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n    }\n    destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        timers.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket, client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        if (!request) {\n            return -1;\n        }\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n            this.headers.push(buf);\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10 && key.toString().toLowerCase() === \"keep-alive\") {\n            this.keepAlive += buf.toString();\n        } else if (key.length === 10 && key.toString().toLowerCase() === \"connection\") {\n            this.connection += buf.toString();\n        } else if (key.length === 14 && key.toString().toLowerCase() === \"content-length\") {\n            this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n            util.destroy(this.socket, new HeadersOverflowError());\n        }\n    }\n    onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request.upgrade || request.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        socket.removeListener(\"error\", onSocketError).removeListener(\"readable\", onSocketReadable).removeListener(\"end\", onSocketEnd).removeListener(\"close\", onSocketClose);\n        client[kSocket] = null;\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], new InformationalError(\"upgrade\"));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n        resume(client);\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) {\n            return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            util.destroy(socket, new SocketError(\"bad response\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            util.destroy(socket, new SocketError(\"bad upgrade\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === \"HEAD\" && !socket[kReset] && this.connection.toLowerCase() === \"keep-alive\";\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n            this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        if (request.method === \"CONNECT\") {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n                if (timeout <= 0) {\n                    socket[kReset] = true;\n                } else {\n                    client[kKeepAliveTimeoutValue] = timeout;\n                }\n            } else {\n                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n            }\n        } else {\n            // Stop more requests from being dispatched.\n            socket[kReset] = true;\n        }\n        let pause;\n        try {\n            pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        } catch (err) {\n            util.destroy(socket, err);\n            return -1;\n        }\n        if (request.method === \"HEAD\") {\n            return 1;\n        }\n        if (statusCode < 200) {\n            return 1;\n        }\n        if (socket[kBlocking]) {\n            socket[kBlocking] = false;\n            resume(client);\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client, socket, statusCode, maxResponseSize } = this;\n        if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            util.destroy(socket, new ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        try {\n            if (request.onData(buf) === false) {\n                return constants.ERROR.PAUSED;\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n            return -1;\n        }\n    }\n    onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n            return -1;\n        }\n        if (upgrade) {\n            return;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        this.connection = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n            return;\n        }\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            util.destroy(socket, new ResponseContentLengthMismatchError());\n            return -1;\n        }\n        try {\n            request.onComplete(headers);\n        } catch (err) {\n            errorRequest(client, request, err);\n        }\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n            assert.strictEqual(client[kRunning], 0);\n            // Response completed before request.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] === 1) {\n            // We must wait a full event loop cycle to reuse this socket to make sure\n            // that non-spec compliant servers are not closing the connection even if they\n            // said they won't.\n            setImmediate(resume, client);\n        } else {\n            resume(client);\n        }\n    }\n}\nfunction onParserTimeout(parser) {\n    const { socket, timeoutType, client } = parser;\n    /* istanbul ignore else */ if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n            assert(!parser.paused, \"cannot be paused while waiting for headers\");\n            util.destroy(socket, new HeadersTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n            util.destroy(socket, new BodyTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util.destroy(socket, new InformationalError(\"socket idle timeout\"));\n    }\n}\nfunction onSocketReadable() {\n    const { [kParser]: parser } = this;\n    if (parser) {\n        parser.readMore();\n    }\n}\nfunction onSocketError(err) {\n    const { [kClient]: client, [kParser]: parser } = this;\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n        // to the user.\n        if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    this[kError] = err;\n    onError(this[kClient], err);\n}\nfunction onError(client, err) {\n    if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n        assert(client[kSize] === 0);\n    }\n}\nfunction onSocketEnd() {\n    const { [kParser]: parser, [kClient]: client } = this;\n    if (client[kHTTPConnVersion] !== \"h2\") {\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n    }\n    util.destroy(this, new SocketError(\"other side closed\", util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n    const { [kClient]: client, [kParser]: parser } = this;\n    if (client[kHTTPConnVersion] === \"h1\" && parser) {\n        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n        }\n        this[kParser].destroy();\n        this[kParser] = null;\n    }\n    const err = this[kError] || new SocketError(\"closed\", util.getSocketInfo(this));\n    client[kSocket] = null;\n    if (client.destroyed) {\n        assert(client[kPending] === 0);\n        // Fail entire queue.\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            errorRequest(client, request, err);\n        }\n    } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n        // Fail head of pipeline.\n        const request = client[kQueue][client[kRunningIdx]];\n        client[kQueue][client[kRunningIdx]++] = null;\n        errorRequest(client, request, err);\n    }\n    client[kPendingIdx] = client[kRunningIdx];\n    assert(client[kRunning] === 0);\n    client.emit(\"disconnect\", client[kUrl], [\n        client\n    ], err);\n    resume(client);\n}\nasync function connect(client) {\n    assert(!client[kConnecting]);\n    assert(!client[kSocket]);\n    let { host, hostname, protocol, port } = client[kUrl];\n    // Resolve ipv6\n    if (hostname[0] === \"[\") {\n        const idx = hostname.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname.substr(1, idx - 1);\n        assert(net.isIP(ip));\n        hostname = ip;\n    }\n    client[kConnecting] = true;\n    if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n            connectParams: {\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            },\n            connector: client[kConnector]\n        });\n    }\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[kConnector]({\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            }, (err, socket)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(socket);\n                }\n            });\n        });\n        if (client.destroyed) {\n            util.destroy(socket.on(\"error\", ()=>{}), new ClientDestroyedError());\n            return;\n        }\n        client[kConnecting] = false;\n        assert(socket);\n        const isH2 = socket.alpnProtocol === \"h2\";\n        if (isH2) {\n            if (!h2ExperimentalWarned) {\n                h2ExperimentalWarned = true;\n                process.emitWarning(\"H2 support is experimental, expect them to change at any time.\", {\n                    code: \"UNDICI-H2\"\n                });\n            }\n            const session = http2.connect(client[kUrl], {\n                createConnection: ()=>socket,\n                peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams\n            });\n            client[kHTTPConnVersion] = \"h2\";\n            session[kClient] = client;\n            session[kSocket] = socket;\n            session.on(\"error\", onHttp2SessionError);\n            session.on(\"frameError\", onHttp2FrameError);\n            session.on(\"end\", onHttp2SessionEnd);\n            session.on(\"goaway\", onHTTP2GoAway);\n            session.on(\"close\", onSocketClose);\n            session.unref();\n            client[kHTTP2Session] = session;\n            socket[kHTTP2Session] = session;\n        } else {\n            if (!llhttpInstance) {\n                llhttpInstance = await llhttpPromise;\n                llhttpPromise = null;\n            }\n            socket[kNoRef] = false;\n            socket[kWriting] = false;\n            socket[kReset] = false;\n            socket[kBlocking] = false;\n            socket[kParser] = new Parser(client, socket, llhttpInstance);\n        }\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket[kClient] = client;\n        socket[kError] = null;\n        socket.on(\"error\", onSocketError).on(\"readable\", onSocketReadable).on(\"end\", onSocketEnd).on(\"close\", onSocketClose);\n        client[kSocket] = socket;\n        if (channels.connected.hasSubscribers) {\n            channels.connected.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                socket\n            });\n        }\n        client.emit(\"connect\", client[kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) {\n            return;\n        }\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n            channels.connectError.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                error: err\n            });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n            assert(client[kRunning] === 0);\n            while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){\n                const request = client[kQueue][client[kPendingIdx]++];\n                errorRequest(client, request, err);\n            }\n        } else {\n            onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [\n            client\n        ], err);\n    }\n    resume(client);\n}\nfunction emitDrain(client) {\n    client[kNeedDrain] = 0;\n    client.emit(\"drain\", client[kUrl], [\n        client\n    ]);\n}\nfunction resume(client, sync) {\n    if (client[kResuming] === 2) {\n        return;\n    }\n    client[kResuming] = 2;\n    _resume(client, sync);\n    client[kResuming] = 0;\n    if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n    }\n}\nfunction _resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            return;\n        }\n        if (client[kClosedResolve] && !client[kSize]) {\n            client[kClosedResolve]();\n            client[kClosedResolve] = null;\n            return;\n        }\n        const socket = client[kSocket];\n        if (socket && !socket.destroyed && socket.alpnProtocol !== \"h2\") {\n            if (client[kSize] === 0) {\n                if (!socket[kNoRef] && socket.unref) {\n                    socket.unref();\n                    socket[kNoRef] = true;\n                }\n            } else if (socket[kNoRef] && socket.ref) {\n                socket.ref();\n                socket[kNoRef] = false;\n            }\n            if (client[kSize] === 0) {\n                if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n                    socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n                }\n            } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n                if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n                    const request = client[kQueue][client[kRunningIdx]];\n                    const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n                    socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n                }\n            }\n        }\n        if (client[kBusy]) {\n            client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n            if (sync) {\n                client[kNeedDrain] = 1;\n                process.nextTick(emitDrain, client);\n            } else {\n                emitDrain(client);\n            }\n            continue;\n        }\n        if (client[kPending] === 0) {\n            return;\n        }\n        if (client[kRunning] >= (client[kPipelining] || 1)) {\n            return;\n        }\n        const request = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request.servername) {\n            if (client[kRunning] > 0) {\n                return;\n            }\n            client[kServerName] = request.servername;\n            if (socket && socket.servername !== request.servername) {\n                util.destroy(socket, new InformationalError(\"servername changed\"));\n                return;\n            }\n        }\n        if (client[kConnecting]) {\n            return;\n        }\n        if (!socket && !client[kHTTP2Session]) {\n            connect(client);\n            return;\n        }\n        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n            return;\n        }\n        if (client[kRunning] > 0 && !request.idempotent) {\n            // Non-idempotent request cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (client[kRunning] > 0 && (request.upgrade || request.method === \"CONNECT\")) {\n            // Don't dispatch an upgrade until all preceding requests have completed.\n            // A misbehaving server might upgrade the connection before all pipelined\n            // request has completed.\n            return;\n        }\n        if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n            request.body.on(\"data\", /* istanbul ignore next */ function() {\n                /* istanbul ignore next */ assert(false);\n            }).on(\"error\", function(err) {\n                errorRequest(client, request, err);\n            }).on(\"end\", function() {\n                util.destroy(this);\n            });\n            request.body = null;\n        }\n        if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n            // Request with stream or iterator body can error while other requests\n            // are inflight and indirectly error those as well.\n            // Ensure this doesn't happen by waiting for inflight\n            // to complete before dispatching.\n            // Request with stream or iterator body cannot be retried.\n            // Ensure that no other requests are inflight and\n            // could cause failure.\n            return;\n        }\n        if (!request.aborted && write(client, request)) {\n            client[kPendingIdx]++;\n        } else {\n            client[kQueue].splice(client[kPendingIdx], 1);\n        }\n    }\n}\nfunction write(client, request) {\n    if (client[kHTTPConnVersion] === \"h2\") {\n        writeH2(client, client[kHTTP2Session], request);\n        return;\n    }\n    const { body, method, path, host, upgrade, headers, blocking, reset } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength === null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 && !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    if (request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    const socket = client[kSocket];\n    try {\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n            util.destroy(socket, new InformationalError(\"aborted\"));\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    if (method === \"HEAD\") {\n        // https://github.com/mcollina/undici/issues/258\n        // Close after a HEAD request to interop with misbehaving servers\n        // that may send a body in the response.\n        socket[kReset] = true;\n    }\n    if (upgrade || method === \"CONNECT\") {\n        // On CONNECT or upgrade, block pipeline from dispatching further\n        // requests on this connection.\n        socket[kReset] = true;\n    }\n    if (reset != null) {\n        socket[kReset] = reset;\n    }\n    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n    }\n    if (blocking) {\n        socket[kBlocking] = true;\n    }\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === \"string\") {\n        header += `host: ${host}\\r\\n`;\n    } else {\n        header += client[kHostHeader];\n    }\n    if (upgrade) {\n        header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    } else if (client[kPipelining] && !socket[kReset]) {\n        header += \"connection: keep-alive\\r\\n\";\n    } else {\n        header += \"connection: close\\r\\n\";\n    }\n    if (headers) {\n        header += headers;\n    }\n    if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({\n            request,\n            headers: header,\n            socket\n        });\n    }\n    /* istanbul ignore else: assertion */ if (!body) {\n        if (contentLength === 0) {\n            socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n        } else {\n            assert(contentLength === null, \"no body must not have content length\");\n            socket.write(`${header}\\r\\n`, \"latin1\");\n        }\n        request.onRequestSent();\n    } else if (util.isBuffer(body)) {\n        assert(contentLength === body.byteLength, \"buffer body must have content length\");\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n        socket.write(body);\n        socket.uncork();\n        request.onBodySent(body);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n    } else if (util.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n            writeIterable({\n                body: body.stream(),\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        } else {\n            writeBlob({\n                body,\n                client,\n                request,\n                socket,\n                contentLength,\n                header,\n                expectsPayload\n            });\n        }\n    } else if (util.isStream(body)) {\n        writeStream({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else if (util.isIterable(body)) {\n        writeIterable({\n            body,\n            client,\n            request,\n            socket,\n            contentLength,\n            header,\n            expectsPayload\n        });\n    } else {\n        assert(false);\n    }\n    return true;\n}\nfunction writeH2(client, session, request) {\n    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;\n    let headers;\n    if (typeof reqHeaders === \"string\") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());\n    else headers = reqHeaders;\n    if (upgrade) {\n        errorRequest(client, request, new Error(\"Upgrade not supported for H2\"));\n        return false;\n    }\n    try {\n        // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?\n        request.onConnect((err)=>{\n            if (request.aborted || request.completed) {\n                return;\n            }\n            errorRequest(client, request, err || new RequestAbortedError());\n        });\n    } catch (err) {\n        errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    let stream;\n    const h2State = client[kHTTP2SessionState];\n    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];\n    headers[HTTP2_HEADER_METHOD] = method;\n    if (method === \"CONNECT\") {\n        session.ref();\n        // we are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++h2State.openStreams;\n        } else {\n            stream.once(\"ready\", ()=>{\n                request.onUpgrade(null, null, stream);\n                ++h2State.openStreams;\n            });\n        }\n        stream.once(\"close\", ()=>{\n            h2State.openStreams -= 1;\n            // TODO(HTTP/2): unref only if current streams count is 0\n            if (h2State.openStreams === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omited when sending CONNECT\n    headers[HTTP2_HEADER_PATH] = path;\n    headers[HTTP2_HEADER_SCHEME] = \"https\";\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength == null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 || !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    if (request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        assert(body, \"no body must not have content length\");\n        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === \"GET\" || method === \"HEAD\";\n    if (expectContinue) {\n        headers[HTTP2_HEADER_EXPECT] = \"100-continue\";\n        /**\n     * @type {import('node:http2').ClientHttp2Stream}\n     */ stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        stream.once(\"continue\", writeBodyH2);\n    } else {\n        /** @type {import('node:http2').ClientHttp2Stream} */ stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new several streams open\n    ++h2State.openStreams;\n    stream.once(\"response\", (headers)=>{\n        if (request.onHeaders(Number(headers[HTTP2_HEADER_STATUS]), headers, stream.resume.bind(stream), \"\") === false) {\n            stream.pause();\n        }\n    });\n    stream.once(\"end\", ()=>{\n        request.onComplete([]);\n    });\n    stream.on(\"data\", (chunk)=>{\n        if (request.onData(chunk) === false) stream.pause();\n    });\n    stream.once(\"close\", ()=>{\n        h2State.openStreams -= 1;\n        // TODO(HTTP/2): unref only if current streams count is 0\n        if (h2State.openStreams === 0) session.unref();\n    });\n    stream.once(\"error\", function(err) {\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    stream.once(\"frameError\", (type, code)=>{\n        const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        errorRequest(client, request, err);\n        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {\n            h2State.streams -= 1;\n            util.destroy(stream, err);\n        }\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Suppor push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body) {\n            request.onRequestSent();\n        } else if (util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, \"buffer body must have content length\");\n            stream.cork();\n            stream.write(body);\n            stream.uncork();\n            stream.end();\n            request.onBodySent(body);\n            request.onRequestSent();\n        } else if (util.isBlobLike(body)) {\n            if (typeof body.stream === \"function\") {\n                writeIterable({\n                    client,\n                    request,\n                    contentLength,\n                    h2stream: stream,\n                    expectsPayload,\n                    body: body.stream(),\n                    socket: client[kSocket],\n                    header: \"\"\n                });\n            } else {\n                writeBlob({\n                    body,\n                    client,\n                    request,\n                    contentLength,\n                    expectsPayload,\n                    h2stream: stream,\n                    header: \"\",\n                    socket: client[kSocket]\n                });\n            }\n        } else if (util.isStream(body)) {\n            writeStream({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                socket: client[kSocket],\n                h2stream: stream,\n                header: \"\"\n            });\n        } else if (util.isIterable(body)) {\n            writeIterable({\n                body,\n                client,\n                request,\n                contentLength,\n                expectsPayload,\n                header: \"\",\n                h2stream: stream,\n                socket: client[kSocket]\n            });\n        } else {\n            assert(false);\n        }\n    }\n}\nfunction writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n    if (client[kHTTPConnVersion] === \"h2\") {\n        // For HTTP/2, is enough to pipe the stream\n        const pipe = pipeline(body, h2stream, (err)=>{\n            if (err) {\n                util.destroy(body, err);\n                util.destroy(h2stream, err);\n            } else {\n                request.onRequestSent();\n            }\n        });\n        pipe.on(\"data\", onPipeData);\n        pipe.once(\"end\", ()=>{\n            pipe.removeListener(\"data\", onPipeData);\n            util.destroy(pipe);\n        });\n        function onPipeData(chunk) {\n            request.onBodySent(chunk);\n        }\n        return;\n    }\n    let finished = false;\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    const onData = function(chunk) {\n        if (finished) {\n            return;\n        }\n        try {\n            if (!writer.write(chunk) && this.pause) {\n                this.pause();\n            }\n        } catch (err) {\n            util.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) {\n            return;\n        }\n        if (body.resume) {\n            body.resume();\n        }\n    };\n    const onAbort = function() {\n        onFinished(new RequestAbortedError());\n    };\n    const onFinished = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"error\", onFinished).removeListener(\"close\", onAbort);\n        if (!err) {\n            try {\n                writer.end();\n            } catch (er) {\n                err = er;\n            }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n            util.destroy(body, err);\n        } else {\n            util.destroy(body);\n        }\n    };\n    body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onAbort);\n    if (body.resume) {\n        body.resume();\n    }\n    socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n}\nasync function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength === body.size, \"blob body must have content length\");\n    const isH2 = client[kHTTPConnVersion] === \"h2\";\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        if (isH2) {\n            h2stream.cork();\n            h2stream.write(buffer);\n            h2stream.uncork();\n        } else {\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            socket.write(buffer);\n            socket.uncork();\n        }\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        resume(client);\n    } catch (err) {\n        util.destroy(isH2 ? h2stream : socket, err);\n    }\n}\nasync function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    if (client[kHTTPConnVersion] === \"h2\") {\n        h2stream.on(\"close\", onDrain).on(\"drain\", onDrain);\n        try {\n            // It's up to the user to somehow abort the async iterable.\n            for await (const chunk of body){\n                if (socket[kError]) {\n                    throw socket[kError];\n                }\n                const res = h2stream.write(chunk);\n                request.onBodySent(chunk);\n                if (!res) {\n                    await waitForDrain();\n                }\n            }\n        } catch (err) {\n            h2stream.destroy(err);\n        } finally{\n            request.onRequestSent();\n            h2stream.end();\n            h2stream.off(\"close\", onDrain).off(\"drain\", onDrain);\n        }\n        return;\n    }\n    socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n    const writer = new AsyncWriter({\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            if (!writer.write(chunk)) {\n                await waitForDrain();\n            }\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n    }\n}\nclass AsyncWriter {\n    constructor({ socket, request, contentLength, client, expectsPayload, header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        socket[kWriting] = true;\n    }\n    write(chunk) {\n        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n            return true;\n        }\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            }\n            process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            if (contentLength === null) {\n                socket.write(`${header}transfer-encoding: chunked\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            }\n        }\n        if (contentLength === null) {\n            socket.write(`\\r\\n${len.toString(16)}\\r\\n`, \"latin1\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n                // istanbul ignore else: only for jest\n                if (socket[kParser].timeout.refresh) {\n                    socket[kParser].timeout.refresh();\n                }\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;\n        request.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return;\n        }\n        if (bytesWritten === 0) {\n            if (expectsPayload) {\n                // https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}\\r\\n`, \"latin1\");\n            }\n        } else if (contentLength === null) {\n            socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"latin1\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            } else {\n                process.emitWarning(new RequestContentLengthMismatchError());\n            }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            // istanbul ignore else: only for jest\n            if (socket[kParser].timeout.refresh) {\n                socket[kParser].timeout.refresh();\n            }\n        }\n        resume(client);\n    }\n    destroy(err) {\n        const { socket, client } = this;\n        socket[kWriting] = false;\n        if (err) {\n            assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n            util.destroy(socket, err);\n        }\n    }\n}\nfunction errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        assert(request.aborted);\n    } catch (err) {\n        client.emit(\"error\", err);\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTtBQUVaO0FBRUEsc0JBQXNCLEdBRXRCLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUcsUUFBUSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1LLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUNKUSxpQ0FBaUMsRUFDakNDLGtDQUFrQyxFQUNsQ0Msb0JBQW9CLEVBQ3BCQyxtQkFBbUIsRUFDbkJDLG1CQUFtQixFQUNuQkMsb0JBQW9CLEVBQ3BCQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsZ0JBQWdCLEVBQ2hCQyxlQUFlLEVBQ2ZDLDRCQUE0QixFQUM1QkMsb0JBQW9CLEVBQ3JCLEdBQUduQixtQkFBT0EsQ0FBQztBQUNaLE1BQU1vQixpQkFBaUJwQixtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQ0pxQixJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLEtBQUssRUFDTEMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyx3QkFBd0IsRUFDeEJDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLHNCQUFzQixFQUN0QkMs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QjdKLE9BQU9vSixRQUFRK0ssT0FBTztJQUN4QixFQUFFLE9BQU90SyxLQUFLO1FBQ1ppQixPQUFPQyxJQUFJLENBQUMsU0FBU2xCO0lBQ3ZCO0FBQ0Y7QUFFQXdOLE9BQU9uSixPQUFPLEdBQUdwSSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY2xpZW50LmpzPzk4MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLWNoZWNrXG5cbid1c2Ugc3RyaWN0J1xuXG4vKiBnbG9iYWwgV2ViQXNzZW1ibHkgKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJylcbmNvbnN0IHRpbWVycyA9IHJlcXVpcmUoJy4vdGltZXJzJylcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuL2NvcmUvcmVxdWVzdCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIEhUVFBQYXJzZXJFcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9jb3JlL2Nvbm5lY3QnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtTZXJ2ZXJOYW1lLFxuICBrQ2xpZW50LFxuICBrQnVzeSxcbiAga1BhcnNlcixcbiAga0Nvbm5lY3QsXG4gIGtCbG9ja2luZyxcbiAga1Jlc3VtaW5nLFxuICBrUnVubmluZyxcbiAga1BlbmRpbmcsXG4gIGtTaXplLFxuICBrV3JpdGluZyxcbiAga1F1ZXVlLFxuICBrQ29ubmVjdGVkLFxuICBrQ29ubmVjdGluZyxcbiAga05lZWREcmFpbixcbiAga05vUmVmLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQsXG4gIGtIb3N0SGVhZGVyLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1BpcGVsaW5pbmcsXG4gIGtTb2NrZXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWUsXG4gIGtNYXhIZWFkZXJzU2l6ZSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICBrSGVhZGVyc1RpbWVvdXQsXG4gIGtCb2R5VGltZW91dCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtDb25uZWN0b3IsXG4gIGtNYXhSZWRpcmVjdGlvbnMsXG4gIGtNYXhSZXF1ZXN0cyxcbiAga0NvdW50ZXIsXG4gIGtDbG9zZSxcbiAga0Rlc3Ryb3ksXG4gIGtEaXNwYXRjaCxcbiAga0ludGVyY2VwdG9ycyxcbiAga0xvY2FsQWRkcmVzcyxcbiAga01heFJlc3BvbnNlU2l6ZSxcbiAga0hUVFBDb25uVmVyc2lvbixcbiAgLy8gSFRUUDJcbiAga0hvc3QsXG4gIGtIVFRQMlNlc3Npb24sXG4gIGtIVFRQMlNlc3Npb25TdGF0ZSxcbiAga0hUVFAyQnVpbGRSZXF1ZXN0LFxuICBrSFRUUDJDb3B5SGVhZGVycyxcbiAga0hUVFAxQnVpbGRSZXF1ZXN0XG59ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnaHR0cDInKX0gKi9cbmxldCBodHRwMlxudHJ5IHtcbiAgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpXG59IGNhdGNoIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBodHRwMiA9IHsgY29uc3RhbnRzOiB7fSB9XG59XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICAgIEhUVFAyX0hFQURFUl9QQVRILFxuICAgIEhUVFAyX0hFQURFUl9TQ0hFTUUsXG4gICAgSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RILFxuICAgIEhUVFAyX0hFQURFUl9FWFBFQ1QsXG4gICAgSFRUUDJfSEVBREVSX1NUQVRVU1xuICB9XG59ID0gaHR0cDJcblxuLy8gRXhwZXJpbWVudGFsXG5sZXQgaDJFeHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXVxuXG5jb25zdCBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbCgna0Nsb3NlZFJlc29sdmUnKVxuXG5jb25zdCBjaGFubmVscyA9IHt9XG5cbnRyeSB7XG4gIGNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuICBjaGFubmVscy5zZW5kSGVhZGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJylcbiAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdCA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKVxuICBjaGFubmVscy5jb25uZWN0RXJyb3IgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKVxuICBjaGFubmVscy5jb25uZWN0ZWQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKVxufSBjYXRjaCB7XG4gIGNoYW5uZWxzLnNlbmRIZWFkZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5iZWZvcmVDb25uZWN0ID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5jb25uZWN0RXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLmNvbm5lY3RlZCA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi90eXBlcy9jbGllbnQnKS5kZWZhdWx0fVxuICovXG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvY2xpZW50JykuQ2xpZW50Lk9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHtcbiAgICBpbnRlcmNlcHRvcnMsXG4gICAgbWF4SGVhZGVyU2l6ZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBzb2NrZXRUaW1lb3V0LFxuICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIGlkbGVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZSxcbiAgICBrZWVwQWxpdmVUaW1lb3V0LFxuICAgIG1heEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAga2VlcEFsaXZlTWF4VGltZW91dCxcbiAgICBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICAgIHNvY2tldFBhdGgsXG4gICAgcGlwZWxpbmluZyxcbiAgICB0bHMsXG4gICAgc3RyaWN0Q29udGVudExlbmd0aCxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBtYXhSZWRpcmVjdGlvbnMsXG4gICAgY29ubmVjdCxcbiAgICBtYXhSZXF1ZXN0c1BlckNsaWVudCxcbiAgICBsb2NhbEFkZHJlc3MsXG4gICAgbWF4UmVzcG9uc2VTaXplLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIC8vIGgyXG4gICAgYWxsb3dIMixcbiAgICBtYXhDb25jdXJyZW50U3RyZWFtc1xuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoa2VlcEFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQga2VlcEFsaXZlLCB1c2UgcGlwZWxpbmluZz0wIGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgc29ja2V0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgcmVxdWVzdFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChpZGxlVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGlkbGVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlVGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4S2VlcEFsaXZlVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIG1heEtlZXBBbGl2ZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVNYXhUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChtYXhIZWFkZXJTaXplICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShtYXhIZWFkZXJTaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1heEhlYWRlclNpemUnKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRQYXRoICE9IG51bGwgJiYgdHlwZW9mIHNvY2tldFBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgc29ja2V0UGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3RUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdFRpbWVvdXQpIHx8IGNvbm5lY3RUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0KSB8fCBrZWVwQWxpdmVUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZU1heFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVNYXhUaW1lb3V0KSB8fCBrZWVwQWxpdmVNYXhUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlTWF4VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCcpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnNUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKG1heFJlcXVlc3RzUGVyQ2xpZW50ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlcXVlc3RzUGVyQ2xpZW50KSB8fCBtYXhSZXF1ZXN0c1BlckNsaWVudCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlcXVlc3RzUGVyQ2xpZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChsb2NhbEFkZHJlc3MgIT0gbnVsbCAmJiAodHlwZW9mIGxvY2FsQWRkcmVzcyAhPT0gJ3N0cmluZycgfHwgbmV0LmlzSVAobG9jYWxBZGRyZXNzKSA9PT0gMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbG9jYWxBZGRyZXNzIG11c3QgYmUgdmFsaWQgc3RyaW5nIElQIGFkZHJlc3MnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXNwb25zZVNpemUgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVzcG9uc2VTaXplKSB8fCBtYXhSZXNwb25zZVNpemUgPCAtMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVzcG9uc2VTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCAhPSBudWxsICYmXG4gICAgICAoIU51bWJlci5pc0ludGVnZXIoYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0KSB8fCBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgPCAtMSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIC8vIGgyXG4gICAgaWYgKGFsbG93SDIgIT0gbnVsbCAmJiB0eXBlb2YgYWxsb3dIMiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2FsbG93SDIgbXVzdCBiZSBhIHZhbGlkIGJvb2xlYW4gdmFsdWUnKVxuICAgIH1cblxuICAgIGlmIChtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsICYmICh0eXBlb2YgbWF4Q29uY3VycmVudFN0cmVhbXMgIT09ICdudW1iZXInIHx8IG1heENvbmN1cnJlbnRTdHJlYW1zIDwgMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4Q29uY3VycmVudFN0cmVhbXMgbXVzdCBiZSBhIHBvc3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHV0aWwubm9kZUhhc0F1dG9TZWxlY3RGYW1pbHkgJiYgYXV0b1NlbGVjdEZhbWlseSA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBpbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3JzLkNsaWVudCAmJiBBcnJheS5pc0FycmF5KGludGVyY2VwdG9ycy5DbGllbnQpXG4gICAgICA/IGludGVyY2VwdG9ycy5DbGllbnRcbiAgICAgIDogW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG4gICAgdGhpc1trVXJsXSA9IHV0aWwucGFyc2VPcmlnaW4odXJsKVxuICAgIHRoaXNba0Nvbm5lY3Rvcl0gPSBjb25uZWN0XG4gICAgdGhpc1trU29ja2V0XSA9IG51bGxcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHBpcGVsaW5pbmcgIT0gbnVsbCA/IHBpcGVsaW5pbmcgOiAxXG4gICAgdGhpc1trTWF4SGVhZGVyc1NpemVdID0gbWF4SGVhZGVyU2l6ZSB8fCBodHRwLm1heEhlYWRlclNpemVcbiAgICB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF0gPSBrZWVwQWxpdmVUaW1lb3V0ID09IG51bGwgPyA0ZTMgOiBrZWVwQWxpdmVUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlTWF4VGltZW91dF0gPSBrZWVwQWxpdmVNYXhUaW1lb3V0ID09IG51bGwgPyA2MDBlMyA6IGtlZXBBbGl2ZU1heFRpbWVvdXRcbiAgICB0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSA9IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgPT0gbnVsbCA/IDFlMyA6IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRcbiAgICB0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgdGhpc1trU2VydmVyTmFtZV0gPSBudWxsXG4gICAgdGhpc1trTG9jYWxBZGRyZXNzXSA9IGxvY2FsQWRkcmVzcyAhPSBudWxsID8gbG9jYWxBZGRyZXNzIDogbnVsbFxuICAgIHRoaXNba1Jlc3VtaW5nXSA9IDAgLy8gMCwgaWRsZSwgMSwgc2NoZWR1bGVkLCAyIHJlc3VtaW5nXG4gICAgdGhpc1trTmVlZERyYWluXSA9IDAgLy8gMCwgaWRsZSwgMSwgc2NoZWR1bGVkLCAyIHJlc3VtaW5nXG4gICAgdGhpc1trSG9zdEhlYWRlcl0gPSBgaG9zdDogJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogJyd9XFxyXFxuYFxuICAgIHRoaXNba0JvZHlUaW1lb3V0XSA9IGJvZHlUaW1lb3V0ICE9IG51bGwgPyBib2R5VGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trSGVhZGVyc1RpbWVvdXRdID0gaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCA/IGhlYWRlcnNUaW1lb3V0IDogMzAwZTNcbiAgICB0aGlzW2tTdHJpY3RDb250ZW50TGVuZ3RoXSA9IHN0cmljdENvbnRlbnRMZW5ndGggPT0gbnVsbCA/IHRydWUgOiBzdHJpY3RDb250ZW50TGVuZ3RoXG4gICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXNba01heFJlcXVlc3RzXSA9IG1heFJlcXVlc3RzUGVyQ2xpZW50XG4gICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgdGhpc1trTWF4UmVzcG9uc2VTaXplXSA9IG1heFJlc3BvbnNlU2l6ZSA+IC0xID8gbWF4UmVzcG9uc2VTaXplIDogLTFcbiAgICB0aGlzW2tIVFRQQ29ublZlcnNpb25dID0gJ2gxJ1xuXG4gICAgLy8gSFRUUC8yXG4gICAgdGhpc1trSFRUUDJTZXNzaW9uXSA9IG51bGxcbiAgICB0aGlzW2tIVFRQMlNlc3Npb25TdGF0ZV0gPSAhYWxsb3dIMlxuICAgICAgPyBudWxsXG4gICAgICA6IHtcbiAgICAgICAgLy8gc3RyZWFtczogbnVsbCwgLy8gRml4ZWQgcXVldWUgb2Ygc3RyZWFtcyAtIEZvciBmdXR1cmUgc3VwcG9ydCBvZiBgcHVzaGBcbiAgICAgICAgICBvcGVuU3RyZWFtczogMCwgLy8gS2VlcCB0cmFjayBvZiB0aGVtIHRvIGRlY2lkZSB3ZXRoZXIgb3Igbm90IHVucmVmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IG1heENvbmN1cnJlbnRTdHJlYW1zICE9IG51bGwgPyBtYXhDb25jdXJyZW50U3RyZWFtcyA6IDEwMCAvLyBNYXggcGVlckNvbmN1cnJlbnRTdHJlYW1zIGZvciBhIE5vZGUgaDIgc2VydmVyXG4gICAgICAgIH1cbiAgICB0aGlzW2tIb3N0XSA9IGAke3RoaXNba1VybF0uaG9zdG5hbWV9JHt0aGlzW2tVcmxdLnBvcnQgPyBgOiR7dGhpc1trVXJsXS5wb3J0fWAgOiAnJ31gXG5cbiAgICAvLyBrUXVldWUgaXMgYnVpbHQgdXAgb2YgMyBzZWN0aW9ucyBzZXBhcmF0ZWQgYnlcbiAgICAvLyB0aGUga1J1bm5pbmdJZHggYW5kIGtQZW5kaW5nSWR4IGluZGljZXMuXG4gICAgLy8gfCAgIGNvbXBsZXRlICAgfCAgIHJ1bm5pbmcgICB8ICAgcGVuZGluZyAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICBeIGtSdW5uaW5nSWR4IF4ga1BlbmRpbmdJZHggXiBrUXVldWUubGVuZ3RoXG4gICAgLy8ga1J1bm5pbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBydW5uaW5nIGVsZW1lbnQuXG4gICAgLy8ga1BlbmRpbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBwZW5kaW5nIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIGEgZmFzdCBxdWV1ZSB3aXRoIGFuIGFtb3J0aXplZFxuICAgIC8vIHRpbWUgb2YgTygxKS5cblxuICAgIHRoaXNba1F1ZXVlXSA9IFtdXG4gICAgdGhpc1trUnVubmluZ0lkeF0gPSAwXG4gICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwXG4gIH1cblxuICBnZXQgcGlwZWxpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddXG4gIH1cblxuICBzZXQgcGlwZWxpbmluZyAodmFsdWUpIHtcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHZhbHVlXG4gICAgcmVzdW1lKHRoaXMsIHRydWUpXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tQZW5kaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tQZW5kaW5nSWR4XSAtIHRoaXNba1J1bm5pbmdJZHhdXG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuICEhdGhpc1trU29ja2V0XSAmJiAhdGhpc1trQ29ubmVjdGluZ10gJiYgIXRoaXNba1NvY2tldF0uZGVzdHJveWVkXG4gIH1cblxuICBnZXQgW2tCdXN5XSAoKSB7XG4gICAgY29uc3Qgc29ja2V0ID0gdGhpc1trU29ja2V0XVxuICAgIHJldHVybiAoXG4gICAgICAoc29ja2V0ICYmIChzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldFtrQmxvY2tpbmddKSkgfHxcbiAgICAgICh0aGlzW2tTaXplXSA+PSAodGhpc1trUGlwZWxpbmluZ10gfHwgMSkpIHx8XG4gICAgICB0aGlzW2tQZW5kaW5nXSA+IDBcbiAgICApXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmU6IG9ubHkgdXNlZCBmb3IgdGVzdCAqL1xuICBba0Nvbm5lY3RdIChjYikge1xuICAgIGNvbm5lY3QodGhpcylcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBjYilcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgdGhpc1trVXJsXS5vcmlnaW5cblxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzW2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInXG4gICAgICA/IFJlcXVlc3Rba0hUVFAyQnVpbGRSZXF1ZXN0XShvcmlnaW4sIG9wdHMsIGhhbmRsZXIpXG4gICAgICA6IFJlcXVlc3Rba0hUVFAxQnVpbGRSZXF1ZXN0XShvcmlnaW4sIG9wdHMsIGhhbmRsZXIpXG5cbiAgICB0aGlzW2tRdWV1ZV0ucHVzaChyZXF1ZXN0KVxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10pIHtcbiAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmICh1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSA9PSBudWxsICYmIHV0aWwuaXNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpKSB7XG4gICAgICAvLyBXYWl0IGEgdGljayBpbiBjYXNlIHN0cmVhbS9pdGVyYXRvciBpcyBlbmRlZCBpbiB0aGUgc2FtZSB0aWNrLlxuICAgICAgdGhpc1trUmVzdW1pbmddID0gMVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VtZSh0aGlzLCB0cnVlKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10gJiYgdGhpc1trTmVlZERyYWluXSAhPT0gMiAmJiB0aGlzW2tCdXN5XSkge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IDJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXSA8IDJcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICAvLyBUT0RPOiBmb3IgSDIgd2UgbmVlZCB0byBncmFjZWZ1bGx5IGZsdXNoIHRoZSByZW1haW5pbmcgZW5xdWV1ZWRcbiAgICAvLyByZXF1ZXN0IGFuZCBjbG9zZSBlYWNoIHN0cmVhbS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICghdGhpc1trU2l6ZV0pIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzW2tRdWV1ZV0uc3BsaWNlKHRoaXNba1BlbmRpbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgZXJyb3JSZXF1ZXN0KHRoaXMsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzW2tDbG9zZWRSZXNvbHZlXSkge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IFNob3VsZCB3ZSBlcnJvciBoZXJlIHdpdGggQ2xpZW50RGVzdHJveWVkRXJyb3I/XG4gICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trSFRUUDJTZXNzaW9uXSAhPSBudWxsKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveSh0aGlzW2tIVFRQMlNlc3Npb25dLCBlcnIpXG4gICAgICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0gPSBudWxsXG4gICAgICAgIHRoaXNba0hUVFAyU2Vzc2lvblN0YXRlXSA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzW2tTb2NrZXRdKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHRoaXNba1NvY2tldF0ub24oJ2Nsb3NlJywgY2FsbGJhY2spLCBlcnIpXG4gICAgICB9XG5cbiAgICAgIHJlc3VtZSh0aGlzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FcnJvciAoZXJyKSB7XG4gIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuXG4gIG9uRXJyb3IodGhpc1trQ2xpZW50XSwgZXJyKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyRnJhbWVFcnJvciAodHlwZSwgY29kZSwgaWQpIHtcbiAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YClcblxuICBpZiAoaWQgPT09IDApIHtcbiAgICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgICBvbkVycm9yKHRoaXNba0NsaWVudF0sIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVuZCAoKSB7XG4gIHV0aWwuZGVzdHJveSh0aGlzLCBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJykpXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJykpXG59XG5cbmZ1bmN0aW9uIG9uSFRUUDJHb0F3YXkgKGNvZGUpIHtcbiAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50XVxuICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiR09BV0FZXCIgZnJhbWUgcmVjZWl2ZWQgd2l0aCBjb2RlICR7Y29kZX1gKVxuICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gIGNsaWVudFtrSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIGFzc2VydCh0aGlzW2tQZW5kaW5nXSA9PT0gMClcblxuICAgIC8vIEZhaWwgZW50aXJlIHF1ZXVlLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICBlcnJvclJlcXVlc3QodGhpcywgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsXG4gICAgY2xpZW50W2tVcmxdLFxuICAgIFtjbGllbnRdLFxuICAgIGVyclxuICApXG5cbiAgcmVzdW1lKGNsaWVudClcbn1cblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9sbGh0dHAvY29uc3RhbnRzJylcbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuL2ludGVyY2VwdG9yL3JlZGlyZWN0SW50ZXJjZXB0b3InKVxuY29uc3QgRU1QVFlfQlVGID0gQnVmZmVyLmFsbG9jKDApXG5cbmFzeW5jIGZ1bmN0aW9uIGxhenlsbGh0dHAgKCkge1xuICBjb25zdCBsbGh0dHBXYXNtRGF0YSA9IHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEID8gcmVxdWlyZSgnLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSA6IHVuZGVmaW5lZFxuXG4gIGxldCBtb2RcbiAgdHJ5IHtcbiAgICBtb2QgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKEJ1ZmZlci5mcm9tKHJlcXVpcmUoJy4vbGxodHRwL2xsaHR0cF9zaW1kLXdhc20uanMnKSwgJ2Jhc2U2NCcpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIC8vIFdlIGNvdWxkIGNoZWNrIGlmIHRoZSBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoZSBzaW1kIG9wdGlvbiBub3RcbiAgICAvLyBiZWluZyBlbmFibGVkLCBidXQgdGhlIG9jY3VycmluZyBvZiB0aGlzIG90aGVyIGVycm9yXG4gICAgLy8gKiBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vaXNzdWVzLzExNDk1XG4gICAgLy8gZ290IG1lIHRvIHJlbW92ZSB0aGF0IGNoZWNrIHRvIGF2b2lkIGJyZWFraW5nIE5vZGUgMTIuXG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShCdWZmZXIuZnJvbShsbGh0dHBXYXNtRGF0YSB8fCByZXF1aXJlKCcuL2xsaHR0cC9sbGh0dHAtd2FzbS5qcycpLCAnYmFzZTY0JykpXG4gIH1cblxuICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kLCB7XG4gICAgZW52OiB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgd2FzbV9vbl91cmw6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9zdGF0dXM6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25TdGF0dXMobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9tZXNzYWdlX2JlZ2luOiAocCkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUJlZ2luKCkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX2ZpZWxkOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyRmllbGQobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJfdmFsdWU6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJWYWx1ZShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcnNfY29tcGxldGU6IChwLCBzdGF0dXNDb2RlLCB1cGdyYWRlLCBzaG91bGRLZWVwQWxpdmUpID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlcnNDb21wbGV0ZShzdGF0dXNDb2RlLCBCb29sZWFuKHVwZ3JhZGUpLCBCb29sZWFuKHNob3VsZEtlZXBBbGl2ZSkpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2JvZHk6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25Cb2R5KG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZTogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpIHx8IDBcbiAgICAgIH1cblxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9XG4gIH0pXG59XG5cbmxldCBsbGh0dHBJbnN0YW5jZSA9IG51bGxcbmxldCBsbGh0dHBQcm9taXNlID0gbGF6eWxsaHR0cCgpXG5sbGh0dHBQcm9taXNlLmNhdGNoKClcblxubGV0IGN1cnJlbnRQYXJzZXIgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbmxldCBjdXJyZW50QnVmZmVyU2l6ZSA9IDBcbmxldCBjdXJyZW50QnVmZmVyUHRyID0gbnVsbFxuXG5jb25zdCBUSU1FT1VUX0hFQURFUlMgPSAxXG5jb25zdCBUSU1FT1VUX0JPRFkgPSAyXG5jb25zdCBUSU1FT1VUX0lETEUgPSAzXG5cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yIChjbGllbnQsIHNvY2tldCwgeyBleHBvcnRzIH0pIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGNsaWVudFtrTWF4SGVhZGVyc1NpemVdKSAmJiBjbGllbnRba01heEhlYWRlcnNTaXplXSA+IDApXG5cbiAgICB0aGlzLmxsaHR0cCA9IGV4cG9ydHNcbiAgICB0aGlzLnB0ciA9IHRoaXMubGxodHRwLmxsaHR0cF9hbGxvYyhjb25zdGFudHMuVFlQRS5SRVNQT05TRSlcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbFxuICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnXG4gICAgdGhpcy51cGdyYWRlID0gZmFsc2VcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG4gICAgdGhpcy5oZWFkZXJzTWF4U2l6ZSA9IGNsaWVudFtrTWF4SGVhZGVyc1NpemVdXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLnJlc3VtZSA9IHRoaXMucmVzdW1lLmJpbmQodGhpcylcblxuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5jb25uZWN0aW9uID0gJydcbiAgICB0aGlzLm1heFJlc3BvbnNlU2l6ZSA9IGNsaWVudFtrTWF4UmVzcG9uc2VTaXplXVxuICB9XG5cbiAgc2V0VGltZW91dCAodmFsdWUsIHR5cGUpIHtcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gdHlwZVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy50aW1lb3V0VmFsdWUpIHtcbiAgICAgIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVycy5zZXRUaW1lb3V0KG9uUGFyc2VyVGltZW91dCwgdmFsdWUsIHRoaXMpXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgICB9XG4gICAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LmRlc3Ryb3llZCB8fCAhdGhpcy5wYXVzZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG5cbiAgICB0aGlzLmxsaHR0cC5sbGh0dHBfcmVzdW1lKHRoaXMucHRyKVxuXG4gICAgYXNzZXJ0KHRoaXMudGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSlcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5leGVjdXRlKHRoaXMuc29ja2V0LnJlYWQoKSB8fCBFTVBUWV9CVUYpIC8vIEZsdXNoIHBhcnNlci5cbiAgICB0aGlzLnJlYWRNb3JlKClcbiAgfVxuXG4gIHJlYWRNb3JlICgpIHtcbiAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIHRoaXMucHRyKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuc29ja2V0LnJlYWQoKVxuICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGUoY2h1bmspXG4gICAgfVxuICB9XG5cbiAgZXhlY3V0ZSAoZGF0YSkge1xuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG4gICAgYXNzZXJ0KCF0aGlzLnBhdXNlZClcblxuICAgIGNvbnN0IHsgc29ja2V0LCBsbGh0dHAgfSA9IHRoaXNcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IGN1cnJlbnRCdWZmZXJTaXplKSB7XG4gICAgICBpZiAoY3VycmVudEJ1ZmZlclB0cikge1xuICAgICAgICBsbGh0dHAuZnJlZShjdXJyZW50QnVmZmVyUHRyKVxuICAgICAgfVxuICAgICAgY3VycmVudEJ1ZmZlclNpemUgPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0MDk2KSAqIDQwOTZcbiAgICAgIGN1cnJlbnRCdWZmZXJQdHIgPSBsbGh0dHAubWFsbG9jKGN1cnJlbnRCdWZmZXJTaXplKVxuICAgIH1cblxuICAgIG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBjdXJyZW50QnVmZmVyUHRyLCBjdXJyZW50QnVmZmVyU2l6ZSkuc2V0KGRhdGEpXG5cbiAgICAvLyBDYWxsIGBleGVjdXRlYCBvbiB0aGUgd2FzbSBwYXJzZXIuXG4gICAgLy8gV2UgcGFzcyB0aGUgYGxsaHR0cF9wYXJzZXJgIHBvaW50ZXIgYWRkcmVzcywgdGhlIHBvaW50ZXIgYWRkcmVzcyBvZiBidWZmZXIgdmlldyBkYXRhLFxuICAgIC8vIGFuZCBmaW5hbGx5IHRoZSBsZW5ndGggb2YgYnl0ZXMgdG8gcGFyc2UuXG4gICAgLy8gVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBlcnJvciBjb2RlIG9yIGBjb25zdGFudHMuRVJST1IuT0tgLlxuICAgIHRyeSB7XG4gICAgICBsZXQgcmV0XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGN1cnJlbnRCdWZmZXJSZWYgPSBkYXRhXG4gICAgICAgIGN1cnJlbnRQYXJzZXIgPSB0aGlzXG4gICAgICAgIHJldCA9IGxsaHR0cC5sbGh0dHBfZXhlY3V0ZSh0aGlzLnB0ciwgY3VycmVudEJ1ZmZlclB0ciwgZGF0YS5sZW5ndGgpXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhdGNoICovXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQYXJzZXIgPSBudWxsXG4gICAgICAgIGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9mZnNldCA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0cikgLSBjdXJyZW50QnVmZmVyUHRyXG5cbiAgICAgIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRURfVVBHUkFERSkge1xuICAgICAgICB0aGlzLm9uVXBncmFkZShkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9IGVsc2UgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWVcbiAgICAgICAgc29ja2V0LnVuc2hpZnQoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfSBlbHNlIGlmIChyZXQgIT09IGNvbnN0YW50cy5FUlJPUi5PSykge1xuICAgICAgICBjb25zdCBwdHIgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9yZWFzb24odGhpcy5wdHIpXG4gICAgICAgIGxldCBtZXNzYWdlID0gJydcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgICAgICBpZiAocHRyKSB7XG4gICAgICAgICAgY29uc3QgbGVuID0gbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIHB0cikuaW5kZXhPZigwKVxuICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgJ1Jlc3BvbnNlIGRvZXMgbm90IG1hdGNoIHRoZSBIVFRQLzEuMSBwcm90b2NvbCAoJyArXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyLCBsZW4pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgJyknXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEhUVFBQYXJzZXJFcnJvcihtZXNzYWdlLCBjb25zdGFudHMuRVJST1JbcmV0XSwgZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG5cbiAgICB0aGlzLmxsaHR0cC5sbGh0dHBfZnJlZSh0aGlzLnB0cilcbiAgICB0aGlzLnB0ciA9IG51bGxcblxuICAgIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB9XG5cbiAgb25TdGF0dXMgKGJ1Zikge1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGJ1Zi50b1N0cmluZygpXG4gIH1cblxuICBvbk1lc3NhZ2VCZWdpbiAoKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxuXG4gIG9uSGVhZGVyRmllbGQgKGJ1Zikge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGhcblxuICAgIGlmICgobGVuICYgMSkgPT09IDApIHtcbiAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1ZilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcbiAgfVxuXG4gIG9uSGVhZGVyVmFsdWUgKGJ1Zikge1xuICAgIGxldCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAxKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgICBsZW4gKz0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5oZWFkZXJzW2xlbiAtIDJdXG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEwICYmIGtleS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgdGhpcy5rZWVwQWxpdmUgKz0gYnVmLnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPT09IDEwICYmIGtleS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdjb25uZWN0aW9uJykge1xuICAgICAgdGhpcy5jb25uZWN0aW9uICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiBrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgICB0aGlzLmNvbnRlbnRMZW5ndGggKz0gYnVmLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG4gIH1cblxuICB0cmFja0hlYWRlciAobGVuKSB7XG4gICAgdGhpcy5oZWFkZXJzU2l6ZSArPSBsZW5cbiAgICBpZiAodGhpcy5oZWFkZXJzU2l6ZSA+PSB0aGlzLmhlYWRlcnNNYXhTaXplKSB7XG4gICAgICB1dGlsLmRlc3Ryb3kodGhpcy5zb2NrZXQsIG5ldyBIZWFkZXJzT3ZlcmZsb3dFcnJvcigpKVxuICAgIH1cbiAgfVxuXG4gIG9uVXBncmFkZSAoaGVhZCkge1xuICAgIGNvbnN0IHsgdXBncmFkZSwgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c0NvZGUgfSA9IHRoaXNcblxuICAgIGFzc2VydCh1cGdyYWRlKVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQoIXNvY2tldC5kZXN0cm95ZWQpXG4gICAgYXNzZXJ0KHNvY2tldCA9PT0gY2xpZW50W2tTb2NrZXRdKVxuICAgIGFzc2VydCghdGhpcy5wYXVzZWQpXG4gICAgYXNzZXJ0KHJlcXVlc3QudXBncmFkZSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBudWxsXG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgc29ja2V0LnVuc2hpZnQoaGVhZClcblxuICAgIHNvY2tldFtrUGFyc2VyXS5kZXN0cm95KClcbiAgICBzb2NrZXRba1BhcnNlcl0gPSBudWxsXG5cbiAgICBzb2NrZXRba0NsaWVudF0gPSBudWxsXG4gICAgc29ja2V0W2tFcnJvcl0gPSBudWxsXG4gICAgc29ja2V0XG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvblNvY2tldFJlYWRhYmxlKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvblNvY2tldEVuZClcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCd1cGdyYWRlJykpXG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdC5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cblxuICAgIHJlc3VtZShjbGllbnQpXG4gIH1cblxuICBvbkhlYWRlcnNDb21wbGV0ZSAoc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzVGV4dCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGFzc2VydCghdGhpcy51cGdyYWRlKVxuICAgIGFzc2VydCh0aGlzLnN0YXR1c0NvZGUgPCAyMDApXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCByZXNwb25zZScsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIC8qIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNlcnZlciBpcyBtaXNiZWhhdmluZyAqL1xuICAgIGlmICh1cGdyYWRlICYmICFyZXF1ZXN0LnVwZ3JhZGUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9IRUFERVJTKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gKFxuICAgICAgc2hvdWxkS2VlcEFsaXZlIHx8XG4gICAgICAvLyBPdmVycmlkZSBsbGh0dHAgdmFsdWUgd2hpY2ggZG9lcyBub3QgYWxsb3cga2VlcEFsaXZlIGZvciBIRUFELlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgJiYgIXNvY2tldFtrUmVzZXRdICYmIHRoaXMuY29ubmVjdGlvbi50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuc3RhdHVzQ29kZSA+PSAyMDApIHtcbiAgICAgIGNvbnN0IGJvZHlUaW1lb3V0ID0gcmVxdWVzdC5ib2R5VGltZW91dCAhPSBudWxsXG4gICAgICAgID8gcmVxdWVzdC5ib2R5VGltZW91dFxuICAgICAgICA6IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gICAgICB0aGlzLnNldFRpbWVvdXQoYm9keVRpbWVvdXQsIFRJTUVPVVRfQk9EWSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpXG4gICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlXG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmhlYWRlcnMubGVuZ3RoICUgMiA9PT0gMClcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAodGhpcy5zaG91bGRLZWVwQWxpdmUgJiYgY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlVGltZW91dCA9IHRoaXMua2VlcEFsaXZlID8gdXRpbC5wYXJzZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmUpIDogbnVsbFxuXG4gICAgICBpZiAoa2VlcEFsaXZlVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihcbiAgICAgICAgICBrZWVwQWxpdmVUaW1lb3V0IC0gY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSxcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZU1heFRpbWVvdXRdXG4gICAgICAgIClcbiAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRpbWVvdXRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gY2xpZW50W2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcCBtb3JlIHJlcXVlc3RzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZC5cbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBwYXVzZVxuICAgIHRyeSB7XG4gICAgICBwYXVzZSA9IHJlcXVlc3Qub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2VcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgcmVzdW1lKGNsaWVudClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2UgPyBjb25zdGFudHMuRVJST1IuUEFVU0VEIDogMFxuICB9XG5cbiAgb25Cb2R5IChidWYpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCBtYXhSZXNwb25zZVNpemUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLCBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIHRyeSB7XG4gICAgICBpZiAocmVxdWVzdC5vbkRhdGEoYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxuXG4gIG9uTWVzc2FnZUNvbXBsZXRlICgpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCB1cGdyYWRlLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCBieXRlc1JlYWQsIHNob3VsZEtlZXBBbGl2ZSB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQgJiYgKCFzdGF0dXNDb2RlIHx8IHNob3VsZEtlZXBBbGl2ZSkpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydChzdGF0dXNDb2RlID49IDEwMClcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgYmUgaGFuZGxlZCBieSBsbGh0dHA/ICovXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aCAmJiBieXRlc1JlYWQgIT09IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0Lm9uQ29tcGxldGUoaGVhZGVycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgaWYgKHNvY2tldFtrV3JpdGluZ10pIHtcbiAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjbGllbnRba1J1bm5pbmddLCAwKVxuICAgICAgLy8gUmVzcG9uc2UgY29tcGxldGVkIGJlZm9yZSByZXF1ZXN0LlxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmICghc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKHNvY2tldFtrUmVzZXRdICYmIGNsaWVudFtrUnVubmluZ10gPT09IDApIHtcbiAgICAgIC8vIERlc3Ryb3kgc29ja2V0IG9uY2UgYWxsIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuICAgICAgLy8gVGhlIHJlcXVlc3QgYXQgdGhlIHRhaWwgb2YgdGhlIHBpcGVsaW5lIGlzIHRoZSBvbmVcbiAgICAgIC8vIHRoYXQgcmVxdWVzdGVkIHJlc2V0IGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZFxuICAgICAgLy8gaGF2ZSBiZWVuIHF1ZXVlZCBzaW5jZSB0aGVuLlxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddID09PSAxKSB7XG4gICAgICAvLyBXZSBtdXN0IHdhaXQgYSBmdWxsIGV2ZW50IGxvb3AgY3ljbGUgdG8gcmV1c2UgdGhpcyBzb2NrZXQgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IG5vbi1zcGVjIGNvbXBsaWFudCBzZXJ2ZXJzIGFyZSBub3QgY2xvc2luZyB0aGUgY29ubmVjdGlvbiBldmVuIGlmIHRoZXlcbiAgICAgIC8vIHNhaWQgdGhleSB3b24ndC5cbiAgICAgIHNldEltbWVkaWF0ZShyZXN1bWUsIGNsaWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdW1lKGNsaWVudClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25QYXJzZXJUaW1lb3V0IChwYXJzZXIpIHtcbiAgY29uc3QgeyBzb2NrZXQsIHRpbWVvdXRUeXBlLCBjbGllbnQgfSA9IHBhcnNlclxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgaWYgKCFzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldC53cml0YWJsZU5lZWREcmFpbiB8fCBjbGllbnRba1J1bm5pbmddID4gMSkge1xuICAgICAgYXNzZXJ0KCFwYXJzZXIucGF1c2VkLCAnY2Fubm90IGJlIHBhdXNlZCB3aGlsZSB3YWl0aW5nIGZvciBoZWFkZXJzJylcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBIZWFkZXJzVGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpIHtcbiAgICBpZiAoIXBhcnNlci5wYXVzZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBCb2R5VGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0lETEUpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0pXG4gICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc29ja2V0IGlkbGUgdGltZW91dCcpKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0UmVhZGFibGUgKCkge1xuICBjb25zdCB7IFtrUGFyc2VyXTogcGFyc2VyIH0gPSB0aGlzXG4gIGlmIChwYXJzZXIpIHtcbiAgICBwYXJzZXIucmVhZE1vcmUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0RXJyb3IgKGVycikge1xuICBjb25zdCB7IFtrQ2xpZW50XTogY2xpZW50LCBba1BhcnNlcl06IHBhcnNlciB9ID0gdGhpc1xuXG4gIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gIT09ICdoMicpIHtcbiAgICAvLyBPbiBNYWMgT1MsIHdlIGdldCBhbiBFQ09OTlJFU0VUIGV2ZW4gaWYgdGhlcmUgaXMgYSBmdWxsIGJvZHkgdG8gYmUgZm9yd2FyZGVkXG4gICAgLy8gdG8gdGhlIHVzZXIuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcgJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZvciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IGVyclxuXG4gIG9uRXJyb3IodGhpc1trQ2xpZW50XSwgZXJyKVxufVxuXG5mdW5jdGlvbiBvbkVycm9yIChjbGllbnQsIGVycikge1xuICBpZiAoXG4gICAgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJlxuICAgIGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyAmJlxuICAgIGVyci5jb2RlICE9PSAnVU5EX0VSUl9TT0NLRVQnXG4gICkge1xuICAgIC8vIEVycm9yIGlzIG5vdCBjYXVzZWQgYnkgcnVubmluZyByZXF1ZXN0IGFuZCBub3QgYSByZWNvdmVyYWJsZVxuICAgIC8vIHNvY2tldCBlcnJvci5cblxuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmdJZHhdID09PSBjbGllbnRba1J1bm5pbmdJZHhdKVxuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gICAgYXNzZXJ0KGNsaWVudFtrU2l6ZV0gPT09IDApXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFbmQgKCkge1xuICBjb25zdCB7IFtrUGFyc2VyXTogcGFyc2VyLCBba0NsaWVudF06IGNsaWVudCB9ID0gdGhpc1xuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gIT09ICdoMicpIHtcbiAgICBpZiAocGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHV0aWwuZGVzdHJveSh0aGlzLCBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKSlcbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRDbG9zZSAoKSB7XG4gIGNvbnN0IHsgW2tDbGllbnRdOiBjbGllbnQsIFtrUGFyc2VyXTogcGFyc2VyIH0gPSB0aGlzXG5cbiAgaWYgKGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gxJyAmJiBwYXJzZXIpIHtcbiAgICBpZiAoIXRoaXNba0Vycm9yXSAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZmFyIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgIH1cblxuICAgIHRoaXNba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgdGhpc1trUGFyc2VyXSA9IG51bGxcbiAgfVxuXG4gIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoJ2Nsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSlcblxuICBjbGllbnRba1NvY2tldF0gPSBudWxsXG5cbiAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcblxuICAgIC8vIEZhaWwgZW50aXJlIHF1ZXVlLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJykge1xuICAgIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICByZXN1bWUoY2xpZW50KVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0IChjbGllbnQpIHtcbiAgYXNzZXJ0KCFjbGllbnRba0Nvbm5lY3RpbmddKVxuICBhc3NlcnQoIWNsaWVudFtrU29ja2V0XSlcblxuICBsZXQgeyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQgfSA9IGNsaWVudFtrVXJsXVxuXG4gIC8vIFJlc29sdmUgaXB2NlxuICBpZiAoaG9zdG5hbWVbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3RuYW1lLmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgY29uc3QgaXAgPSBob3N0bmFtZS5zdWJzdHIoMSwgaWR4IC0gMSlcblxuICAgIGFzc2VydChuZXQuaXNJUChpcCkpXG4gICAgaG9zdG5hbWUgPSBpcFxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0aW5nXSA9IHRydWVcblxuICBpZiAoY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QucHVibGlzaCh7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudFtrQ29ubmVjdG9yXSh7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sIChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge30pLCBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZVxuXG4gICAgYXNzZXJ0KHNvY2tldClcblxuICAgIGNvbnN0IGlzSDIgPSBzb2NrZXQuYWxwblByb3RvY29sID09PSAnaDInXG4gICAgaWYgKGlzSDIpIHtcbiAgICAgIGlmICghaDJFeHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICAgICAgaDJFeHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0gyIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICAgIGNvZGU6ICdVTkRJQ0ktSDInXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGNsaWVudFtrVXJsXSwge1xuICAgICAgICBjcmVhdGVDb25uZWN0aW9uOiAoKSA9PiBzb2NrZXQsXG4gICAgICAgIHBlZXJNYXhDb25jdXJyZW50U3RyZWFtczogY2xpZW50W2tIVFRQMlNlc3Npb25TdGF0ZV0ubWF4Q29uY3VycmVudFN0cmVhbXNcbiAgICAgIH0pXG5cbiAgICAgIGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9ICdoMidcbiAgICAgIHNlc3Npb25ba0NsaWVudF0gPSBjbGllbnRcbiAgICAgIHNlc3Npb25ba1NvY2tldF0gPSBzb2NrZXRcbiAgICAgIHNlc3Npb24ub24oJ2Vycm9yJywgb25IdHRwMlNlc3Npb25FcnJvcilcbiAgICAgIHNlc3Npb24ub24oJ2ZyYW1lRXJyb3InLCBvbkh0dHAyRnJhbWVFcnJvcilcbiAgICAgIHNlc3Npb24ub24oJ2VuZCcsIG9uSHR0cDJTZXNzaW9uRW5kKVxuICAgICAgc2Vzc2lvbi5vbignZ29hd2F5Jywgb25IVFRQMkdvQXdheSlcbiAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcbiAgICAgIHNlc3Npb24udW5yZWYoKVxuXG4gICAgICBjbGllbnRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG4gICAgICBzb2NrZXRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbGxodHRwSW5zdGFuY2UpIHtcbiAgICAgICAgbGxodHRwSW5zdGFuY2UgPSBhd2FpdCBsbGh0dHBQcm9taXNlXG4gICAgICAgIGxsaHR0cFByb21pc2UgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHNvY2tldFtrTm9SZWZdID0gZmFsc2VcbiAgICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuICAgICAgc29ja2V0W2tSZXNldF0gPSBmYWxzZVxuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgc29ja2V0W2tQYXJzZXJdID0gbmV3IFBhcnNlcihjbGllbnQsIHNvY2tldCwgbGxodHRwSW5zdGFuY2UpXG4gICAgfVxuXG4gICAgc29ja2V0W2tDb3VudGVyXSA9IDBcbiAgICBzb2NrZXRba01heFJlcXVlc3RzXSA9IGNsaWVudFtrTWF4UmVxdWVzdHNdXG4gICAgc29ja2V0W2tDbGllbnRdID0gY2xpZW50XG4gICAgc29ja2V0W2tFcnJvcl0gPSBudWxsXG5cbiAgICBzb2NrZXRcbiAgICAgIC5vbignZXJyb3InLCBvblNvY2tldEVycm9yKVxuICAgICAgLm9uKCdyZWFkYWJsZScsIG9uU29ja2V0UmVhZGFibGUpXG4gICAgICAub24oJ2VuZCcsIG9uU29ja2V0RW5kKVxuICAgICAgLm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0ZWQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZC5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBzb2NrZXRcbiAgICAgIH0pXG4gICAgfVxuICAgIGNsaWVudC5lbWl0KCdjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuICAgICAgd2hpbGUgKGNsaWVudFtrUGVuZGluZ10gPiAwICYmIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dLnNlcnZlcm5hbWUgPT09IGNsaWVudFtrU2VydmVyTmFtZV0pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF0rK11cbiAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKGNsaWVudCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG4gIH1cblxuICByZXN1bWUoY2xpZW50KVxufVxuXG5mdW5jdGlvbiBlbWl0RHJhaW4gKGNsaWVudCkge1xuICBjbGllbnRba05lZWREcmFpbl0gPSAwXG4gIGNsaWVudC5lbWl0KCdkcmFpbicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG59XG5cbmZ1bmN0aW9uIHJlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIGlmIChjbGllbnRba1Jlc3VtaW5nXSA9PT0gMikge1xuICAgIHJldHVyblxuICB9XG5cbiAgY2xpZW50W2tSZXN1bWluZ10gPSAyXG5cbiAgX3Jlc3VtZShjbGllbnQsIHN5bmMpXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMFxuXG4gIGlmIChjbGllbnRba1J1bm5pbmdJZHhdID4gMjU2KSB7XG4gICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKDAsIGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgY2xpZW50W2tQZW5kaW5nSWR4XSAtPSBjbGllbnRba1J1bm5pbmdJZHhdXG4gICAgY2xpZW50W2tSdW5uaW5nSWR4XSA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzdW1lIChjbGllbnQsIHN5bmMpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tDbG9zZWRSZXNvbHZlXSAmJiAhY2xpZW50W2tTaXplXSkge1xuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSgpXG4gICAgICBjbGllbnRba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgICBpZiAoc29ja2V0ICYmICFzb2NrZXQuZGVzdHJveWVkICYmIHNvY2tldC5hbHBuUHJvdG9jb2wgIT09ICdoMicpIHtcbiAgICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICAgIGlmICghc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnVucmVmKSB7XG4gICAgICAgICAgc29ja2V0LnVucmVmKClcbiAgICAgICAgICBzb2NrZXRba05vUmVmXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb2NrZXRba05vUmVmXSAmJiBzb2NrZXQucmVmKSB7XG4gICAgICAgIHNvY2tldC5yZWYoKVxuICAgICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfSURMRSkge1xuICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS5zZXRUaW1lb3V0KGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSwgVElNRU9VVF9JRExFKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHNvY2tldFtrUGFyc2VyXS5zdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgICAgICAgIGNvbnN0IGhlYWRlcnNUaW1lb3V0ID0gcmVxdWVzdC5oZWFkZXJzVGltZW91dCAhPSBudWxsXG4gICAgICAgICAgICA/IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXRcbiAgICAgICAgICAgIDogY2xpZW50W2tIZWFkZXJzVGltZW91dF1cbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChoZWFkZXJzVGltZW91dCwgVElNRU9VVF9IRUFERVJTKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQnVzeV0pIHtcbiAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDJcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrTmVlZERyYWluXSA9PT0gMikge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXREcmFpbiwgY2xpZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdERyYWluKGNsaWVudClcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUGVuZGluZ10gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID49IChjbGllbnRba1BpcGVsaW5pbmddIHx8IDEpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV1cblxuICAgIGlmIChjbGllbnRba1VybF0ucHJvdG9jb2wgPT09ICdodHRwczonICYmIGNsaWVudFtrU2VydmVyTmFtZV0gIT09IHJlcXVlc3Quc2VydmVybmFtZSkge1xuICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjbGllbnRba1NlcnZlck5hbWVdID0gcmVxdWVzdC5zZXJ2ZXJuYW1lXG5cbiAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnNlcnZlcm5hbWUgIT09IHJlcXVlc3Quc2VydmVybmFtZSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzZXJ2ZXJuYW1lIGNoYW5nZWQnKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ29ubmVjdGluZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc29ja2V0ICYmICFjbGllbnRba0hUVFAyU2Vzc2lvbl0pIHtcbiAgICAgIGNvbm5lY3QoY2xpZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQgfHwgc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmICFyZXF1ZXN0LmlkZW1wb3RlbnQpIHtcbiAgICAgIC8vIE5vbi1pZGVtcG90ZW50IHJlcXVlc3QgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBubyBvdGhlciByZXF1ZXN0cyBhcmUgaW5mbGlnaHQgYW5kXG4gICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykpIHtcbiAgICAgIC8vIERvbid0IGRpc3BhdGNoIGFuIHVwZ3JhZGUgdW50aWwgYWxsIHByZWNlZGluZyByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIEEgbWlzYmVoYXZpbmcgc2VydmVyIG1pZ2h0IHVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGFsbCBwaXBlbGluZWRcbiAgICAgIC8vIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgJiYgdXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT09IDApIHtcbiAgICAgIHJlcXVlc3QuYm9keVxuICAgICAgICAub24oJ2RhdGEnLCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kodGhpcylcbiAgICAgICAgfSlcblxuICAgICAgcmVxdWVzdC5ib2R5ID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJlxuICAgICAgKHV0aWwuaXNTdHJlYW0ocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzQXN5bmNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpKSkge1xuICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbiBlcnJvciB3aGlsZSBvdGhlciByZXF1ZXN0c1xuICAgICAgLy8gYXJlIGluZmxpZ2h0IGFuZCBpbmRpcmVjdGx5IGVycm9yIHRob3NlIGFzIHdlbGwuXG4gICAgICAvLyBFbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBieSB3YWl0aW5nIGZvciBpbmZsaWdodFxuICAgICAgLy8gdG8gY29tcGxldGUgYmVmb3JlIGRpc3BhdGNoaW5nLlxuXG4gICAgICAvLyBSZXF1ZXN0IHdpdGggc3RyZWFtIG9yIGl0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAvLyBFbnN1cmUgdGhhdCBubyBvdGhlciByZXF1ZXN0cyBhcmUgaW5mbGlnaHQgYW5kXG4gICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0LmFib3J0ZWQgJiYgd3JpdGUoY2xpZW50LCByZXF1ZXN0KSkge1xuICAgICAgY2xpZW50W2tQZW5kaW5nSWR4XSsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1BlbmRpbmdJZHhdLCAxKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoY2xpZW50LCByZXF1ZXN0KSB7XG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMicpIHtcbiAgICB3cml0ZUgyKGNsaWVudCwgY2xpZW50W2tIVFRQMlNlc3Npb25dLCByZXF1ZXN0KVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBib2R5LCBtZXRob2QsIHBhdGgsIGhvc3QsIHVwZ3JhZGUsIGhlYWRlcnMsIGJsb2NraW5nLCByZXNldCB9ID0gcmVxdWVzdFxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjFcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy41XG5cbiAgLy8gU2VuZGluZyBhIHBheWxvYWQgYm9keSBvbiBhIHJlcXVlc3QgdGhhdCBkb2VzIG5vdFxuICAvLyBleHBlY3QgaXQgY2FuIGNhdXNlIHVuZGVmaW5lZCBiZWhhdmlvciBvbiBzb21lXG4gIC8vIHNlcnZlcnMgYW5kIGNvcnJ1cHQgY29ubmVjdGlvbiBzdGF0ZS4gRG8gbm90XG4gIC8vIHJlLXVzZSB0aGUgY29ubmVjdGlvbiBmb3IgZnVydGhlciByZXF1ZXN0cy5cblxuICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IChcbiAgICBtZXRob2QgPT09ICdQVVQnIHx8XG4gICAgbWV0aG9kID09PSAnUE9TVCcgfHxcbiAgICBtZXRob2QgPT09ICdQQVRDSCdcbiAgKVxuXG4gIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUcnkgdG8gcmVhZCBFT0YgaW4gb3JkZXIgdG8gZ2V0IGxlbmd0aC5cbiAgICBib2R5LnJlYWQoMClcbiAgfVxuXG4gIGxldCBjb250ZW50TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uQ29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcblxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignYWJvcnRlZCcpKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChtZXRob2QgPT09ICdIRUFEJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvaXNzdWVzLzI1OFxuICAgIC8vIENsb3NlIGFmdGVyIGEgSEVBRCByZXF1ZXN0IHRvIGludGVyb3Agd2l0aCBtaXNiZWhhdmluZyBzZXJ2ZXJzXG4gICAgLy8gdGhhdCBtYXkgc2VuZCBhIGJvZHkgaW4gdGhlIHJlc3BvbnNlLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIC8vIE9uIENPTk5FQ1Qgb3IgdXBncmFkZSwgYmxvY2sgcGlwZWxpbmUgZnJvbSBkaXNwYXRjaGluZyBmdXJ0aGVyXG4gICAgLy8gcmVxdWVzdHMgb24gdGhpcyBjb25uZWN0aW9uLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAocmVzZXQgIT0gbnVsbCkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gcmVzZXRcbiAgfVxuXG4gIGlmIChjbGllbnRba01heFJlcXVlc3RzXSAmJiBzb2NrZXRba0NvdW50ZXJdKysgPj0gY2xpZW50W2tNYXhSZXF1ZXN0c10pIHtcbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChibG9ja2luZykge1xuICAgIHNvY2tldFtrQmxvY2tpbmddID0gdHJ1ZVxuICB9XG5cbiAgbGV0IGhlYWRlciA9IGAke21ldGhvZH0gJHtwYXRofSBIVFRQLzEuMVxcclxcbmBcblxuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgaGVhZGVyICs9IGBob3N0OiAke2hvc3R9XFxyXFxuYFxuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSBjbGllbnRba0hvc3RIZWFkZXJdXG4gIH1cblxuICBpZiAodXBncmFkZSkge1xuICAgIGhlYWRlciArPSBgY29ubmVjdGlvbjogdXBncmFkZVxcclxcbnVwZ3JhZGU6ICR7dXBncmFkZX1cXHJcXG5gXG4gIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSAmJiAhc29ja2V0W2tSZXNldF0pIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGtlZXAtYWxpdmVcXHJcXG4nXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9ICdjb25uZWN0aW9uOiBjbG9zZVxcclxcbidcbiAgfVxuXG4gIGlmIChoZWFkZXJzKSB7XG4gICAgaGVhZGVyICs9IGhlYWRlcnNcbiAgfVxuXG4gIGlmIChjaGFubmVscy5zZW5kSGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLnNlbmRIZWFkZXJzLnB1Ymxpc2goeyByZXF1ZXN0LCBoZWFkZXJzOiBoZWFkZXIsIHNvY2tldCB9KVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGFzc2VydGlvbiAqL1xuICBpZiAoIWJvZHkpIHtcbiAgICBpZiAoY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gbnVsbCwgJ25vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJvZHkpXG4gICAgc29ja2V0LnVuY29yaygpXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd3JpdGVJdGVyYWJsZSh7IGJvZHk6IGJvZHkuc3RyZWFtKCksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlQmxvYih7IGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICB3cml0ZVN0cmVhbSh7IGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pXG4gIH0gZWxzZSBpZiAodXRpbC5pc0l0ZXJhYmxlKGJvZHkpKSB7XG4gICAgd3JpdGVJdGVyYWJsZSh7IGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pXG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gd3JpdGVIMiAoY2xpZW50LCBzZXNzaW9uLCByZXF1ZXN0KSB7XG4gIGNvbnN0IHsgYm9keSwgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBleHBlY3RDb250aW51ZSwgc2lnbmFsLCBoZWFkZXJzOiByZXFIZWFkZXJzIH0gPSByZXF1ZXN0XG5cbiAgbGV0IGhlYWRlcnNcbiAgaWYgKHR5cGVvZiByZXFIZWFkZXJzID09PSAnc3RyaW5nJykgaGVhZGVycyA9IFJlcXVlc3Rba0hUVFAyQ29weUhlYWRlcnNdKHJlcUhlYWRlcnMudHJpbSgpKVxuICBlbHNlIGhlYWRlcnMgPSByZXFIZWFkZXJzXG5cbiAgaWYgKHVwZ3JhZGUpIHtcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgRXJyb3IoJ1VwZ3JhZGUgbm90IHN1cHBvcnRlZCBmb3IgSDInKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVE9ETyhIVFRQLzIpOiBTaG91bGQgd2UgY2FsbCBvbkNvbm5lY3QgaW1tZWRpYXRlbHkgb3Igb24gc3RyZWFtIHJlYWR5IGV2ZW50P1xuICAgIHJlcXVlc3Qub25Db25uZWN0KChlcnIpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBzdHJlYW1cbiAgY29uc3QgaDJTdGF0ZSA9IGNsaWVudFtrSFRUUDJTZXNzaW9uU3RhdGVdXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGhvc3QgfHwgY2xpZW50W2tIb3N0XVxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gbWV0aG9kXG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgc2Vzc2lvbi5yZWYoKVxuICAgIC8vIHdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZywgZmlyc3QgcmVxdWVzdFxuICAgIC8vIHdpbGwgY3JlYXRlIGEgbmV3IHN0cmVhbS4gV2UgdHJpZ2dlciBhIHJlcXVlc3QgdG8gY3JlYXRlIHRoZSBzdHJlYW0gYW5kIHdhaXQgdW50aWxcbiAgICAvLyBgcmVhZHlgIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgIC8vIFdlIGRpc2FibGVkIGVuZFN0cmVhbSB0byBhbGxvdyB0aGUgdXNlciB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBmYWxzZSwgc2lnbmFsIH0pXG5cbiAgICBpZiAoc3RyZWFtLmlkICYmICFzdHJlYW0ucGVuZGluZykge1xuICAgICAgcmVxdWVzdC5vblVwZ3JhZGUobnVsbCwgbnVsbCwgc3RyZWFtKVxuICAgICAgKytoMlN0YXRlLm9wZW5TdHJlYW1zXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5vbmNlKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgcmVxdWVzdC5vblVwZ3JhZGUobnVsbCwgbnVsbCwgc3RyZWFtKVxuICAgICAgICArK2gyU3RhdGUub3BlblN0cmVhbXNcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaDJTdGF0ZS5vcGVuU3RyZWFtcyAtPSAxXG4gICAgICAvLyBUT0RPKEhUVFAvMik6IHVucmVmIG9ubHkgaWYgY3VycmVudCBzdHJlYW1zIGNvdW50IGlzIDBcbiAgICAgIGlmIChoMlN0YXRlLm9wZW5TdHJlYW1zID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTQwI3NlY3Rpb24tOC4zXG4gIC8vIDpwYXRoIGFuZCA6c2NoZW1lIGhlYWRlcnMgbXVzdCBiZSBvbWl0ZWQgd2hlbiBzZW5kaW5nIENPTk5FQ1RcblxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IHBhdGhcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfU0NIRU1FXSA9ICdodHRwcydcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBsZXQgY29udGVudExlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCB8fCAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHksICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IGAke2NvbnRlbnRMZW5ndGh9YFxuICB9XG5cbiAgc2Vzc2lvbi5yZWYoKVxuXG4gIGNvbnN0IHNob3VsZEVuZFN0cmVhbSA9IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCdcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfVxuICAgICAqL1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLCBzaWduYWwgfSlcblxuICAgIHN0cmVhbS5vbmNlKCdjb250aW51ZScsIHdyaXRlQm9keUgyKVxuICB9IGVsc2Uge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOmh0dHAyJykuQ2xpZW50SHR0cDJTdHJlYW19ICovXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzZXZlcmFsIHN0cmVhbXMgb3BlblxuICArK2gyU3RhdGUub3BlblN0cmVhbXNcblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBpZiAocmVxdWVzdC5vbkhlYWRlcnMoTnVtYmVyKGhlYWRlcnNbSFRUUDJfSEVBREVSX1NUQVRVU10pLCBoZWFkZXJzLCBzdHJlYW0ucmVzdW1lLmJpbmQoc3RyZWFtKSwgJycpID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoW10pXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGNodW5rKSA9PT0gZmFsc2UpIHN0cmVhbS5wYXVzZSgpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGgyU3RhdGUub3BlblN0cmVhbXMgLT0gMVxuICAgIC8vIFRPRE8oSFRUUC8yKTogdW5yZWYgb25seSBpZiBjdXJyZW50IHN0cmVhbXMgY291bnQgaXMgMFxuICAgIGlmIChoMlN0YXRlLm9wZW5TdHJlYW1zID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsaWVudFtrSFRUUDJTZXNzaW9uXSAmJiAhY2xpZW50W2tIVFRQMlNlc3Npb25dLmRlc3Ryb3llZCAmJiAhdGhpcy5jbG9zZWQgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICBoMlN0YXRlLnN0cmVhbXMgLT0gMVxuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZnJhbWVFcnJvcicsICh0eXBlLCBjb2RlKSA9PiB7XG4gICAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YClcbiAgICBlcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG5cbiAgICBpZiAoY2xpZW50W2tIVFRQMlNlc3Npb25dICYmICFjbGllbnRba0hUVFAyU2Vzc2lvbl0uZGVzdHJveWVkICYmICF0aGlzLmNsb3NlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGgyU3RhdGUuc3RyZWFtcyAtPSAxXG4gICAgICB1dGlsLmRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gICAgfVxuICB9KVxuXG4gIC8vIHN0cmVhbS5vbignYWJvcnRlZCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgYWJvcnRlZFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndGltZW91dCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdGltZW91dFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigncHVzaCcsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9yIHB1c2hcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3RyYWlsZXJzJywgaGVhZGVycyA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHRyYWlsZXJzXG4gIC8vIH0pXG5cbiAgcmV0dXJuIHRydWVcblxuICBmdW5jdGlvbiB3cml0ZUJvZHlIMiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGFzc2VydGlvbiAqL1xuICAgIGlmICghYm9keSkge1xuICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgc3RyZWFtLmNvcmsoKVxuICAgICAgc3RyZWFtLndyaXRlKGJvZHkpXG4gICAgICBzdHJlYW0udW5jb3JrKClcbiAgICAgIHN0cmVhbS5lbmQoKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyaXRlSXRlcmFibGUoe1xuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgICBib2R5OiBib2R5LnN0cmVhbSgpLFxuICAgICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGhlYWRlcjogJydcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQmxvYih7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgaGVhZGVyOiAnJyxcbiAgICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgd3JpdGVTdHJlYW0oe1xuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkLFxuICAgICAgICBzb2NrZXQ6IGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgaDJzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgaGVhZGVyOiAnJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgd3JpdGVJdGVyYWJsZSh7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgIGhlYWRlcjogJycsXG4gICAgICAgIGgyc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgIHNvY2tldDogY2xpZW50W2tTb2NrZXRdXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtICh7IGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCB9KSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBpZiAoY2xpZW50W2tIVFRQQ29ublZlcnNpb25dID09PSAnaDInKSB7XG4gICAgLy8gRm9yIEhUVFAvMiwgaXMgZW5vdWdoIHRvIHBpcGUgdGhlIHN0cmVhbVxuICAgIGNvbnN0IHBpcGUgPSBwaXBlbGluZShcbiAgICAgIGJvZHksXG4gICAgICBoMnN0cmVhbSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgICAgdXRpbC5kZXN0cm95KGgyc3RyZWFtLCBlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcblxuICAgIHBpcGUub24oJ2RhdGEnLCBvblBpcGVEYXRhKVxuICAgIHBpcGUub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgcGlwZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uUGlwZURhdGEpXG4gICAgICB1dGlsLmRlc3Ryb3kocGlwZSlcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gb25QaXBlRGF0YSAoY2h1bmspIHtcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcblxuICBjb25zdCBvbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykgJiYgdGhpcy5wYXVzZSkge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLCBlcnIpXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICAgIGJvZHkucmVzdW1lKClcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25BYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkZpbmlzaGVkKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25BYm9ydClcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cml0ZXIuZW5kKClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGVyciA9IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuXG4gICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nIHx8IGVyci5tZXNzYWdlICE9PSAncmVzZXQnKSkge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgfVxuICB9XG5cbiAgYm9keVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdjbG9zZScsIG9uQWJvcnQpXG5cbiAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgYm9keS5yZXN1bWUoKVxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoeyBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQgfSkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5zaXplLCAnYmxvYiBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgY29uc3QgaXNIMiA9IGNsaWVudFtrSFRUUENvbm5WZXJzaW9uXSA9PT0gJ2gyJ1xuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBpZiAoaXNIMikge1xuICAgICAgaDJzdHJlYW0uY29yaygpXG4gICAgICBoMnN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyKVxuICAgICAgc29ja2V0LnVuY29yaygpXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJ1ZmZlcilcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgcmVzdW1lKGNsaWVudClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5kZXN0cm95KGlzSDIgPyBoMnN0cmVhbSA6IHNvY2tldCwgZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKHsgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkIH0pIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGlmIChjbGllbnRba0hUVFBDb25uVmVyc2lvbl0gPT09ICdoMicpIHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub24oJ2RyYWluJywgb25EcmFpbilcblxuICAgIHRyeSB7XG4gICAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXMgPSBoMnN0cmVhbS53cml0ZShjaHVuaylcbiAgICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGgyc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgIH0gZmluYWxseSB7XG4gICAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgICAgaDJzdHJlYW0uZW5kKClcbiAgICAgIGgyc3RyZWFtXG4gICAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgIH1cblxuICAgIHJldHVyblxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5lbmQoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB3cml0ZXIuZGVzdHJveShlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gIH1cbn1cblxuY2xhc3MgQXN5bmNXcml0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VtZShjbGllbnQpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddIDw9IDEsICdwaXBlbGluZSBzaG91bGQgb25seSBjb250YWluIHRoaXMgcmVxdWVzdCcpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yUmVxdWVzdCAoY2xpZW50LCByZXF1ZXN0LCBlcnIpIHtcbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uRXJyb3IoZXJyKVxuICAgIGFzc2VydChyZXF1ZXN0LmFib3J0ZWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJuZXQiLCJodHRwIiwicGlwZWxpbmUiLCJ1dGlsIiwidGltZXJzIiwiUmVxdWVzdCIsIkRpc3BhdGNoZXJCYXNlIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsImJ1aWxkQ29ubmVjdG9yIiwia1VybCIsImtSZXNldCIsImtTZXJ2ZXJOYW1lIiwia0NsaWVudCIsImtCdXN5Iiwia1BhcnNlciIsImtDb25uZWN0Iiwia0Jsb2NraW5nIiwia1Jlc3VtaW5nIiwia1J1bm5pbmciLCJrUGVuZGluZyIsImtTaXplIiwia1dyaXRpbmciLCJrUXVldWUiLCJrQ29ubmVjdGVkIiwia0Nvbm5lY3RpbmciLCJrTmVlZERyYWluIiwia05vUmVmIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0Iiwia0hvc3RIZWFkZXIiLCJrUGVuZGluZ0lkeCIsImtSdW5uaW5nSWR4Iiwia0Vycm9yIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSIsImtNYXhIZWFkZXJzU2l6ZSIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrSGVhZGVyc1RpbWVvdXQiLCJrQm9keVRpbWVvdXQiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtDb25uZWN0b3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia0NvdW50ZXIiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJrTG9jYWxBZGRyZXNzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQQ29ublZlcnNpb24iLCJrSG9zdCIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrSFRUUDJCdWlsZFJlcXVlc3QiLCJrSFRUUDJDb3B5SGVhZGVycyIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImh0dHAyIiwiY29uc3RhbnRzIiwiSFRUUDJfSEVBREVSX0FVVEhPUklUWSIsIkhUVFAyX0hFQURFUl9NRVRIT0QiLCJIVFRQMl9IRUFERVJfUEFUSCIsIkhUVFAyX0hFQURFUl9TQ0hFTUUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgiLCJIVFRQMl9IRUFERVJfRVhQRUNUIiwiSFRUUDJfSEVBREVSX1NUQVRVUyIsImgyRXhwZXJpbWVudGFsV2FybmVkIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJrQ2xvc2VkUmVzb2x2ZSIsImNoYW5uZWxzIiwiZGlhZ25vc3RpY3NDaGFubmVsIiwic2VuZEhlYWRlcnMiLCJjaGFubmVsIiwiYmVmb3JlQ29ubmVjdCIsImNvbm5lY3RFcnJvciIsImNvbm5lY3RlZCIsImhhc1N1YnNjcmliZXJzIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJpbnRlcmNlcHRvcnMiLCJtYXhIZWFkZXJTaXplIiwiaGVhZGVyc1RpbWVvdXQiLCJzb2NrZXRUaW1lb3V0IiwicmVxdWVzdFRpbWVvdXQiLCJjb25uZWN0VGltZW91dCIsImJvZHlUaW1lb3V0IiwiaWRsZVRpbWVvdXQiLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVUaW1lb3V0IiwibWF4S2VlcEFsaXZlVGltZW91dCIsImtlZXBBbGl2ZU1heFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwic29ja2V0UGF0aCIsInBpcGVsaW5pbmciLCJ0bHMiLCJzdHJpY3RDb250ZW50TGVuZ3RoIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJtYXhSZWRpcmVjdGlvbnMiLCJjb25uZWN0IiwibWF4UmVxdWVzdHNQZXJDbGllbnQiLCJsb2NhbEFkZHJlc3MiLCJtYXhSZXNwb25zZVNpemUiLCJhdXRvU2VsZWN0RmFtaWx5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IiwiYWxsb3dIMiIsIm1heENvbmN1cnJlbnRTdHJlYW1zIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0lQIiwidGltZW91dCIsIm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5IiwiQXJyYXkiLCJpc0FycmF5IiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsInBhcnNlT3JpZ2luIiwiaG9zdG5hbWUiLCJwb3J0Iiwib3BlblN0cmVhbXMiLCJ2YWx1ZSIsInJlc3VtZSIsImxlbmd0aCIsImRlc3Ryb3llZCIsInNvY2tldCIsImNiIiwib25jZSIsIm9wdHMiLCJoYW5kbGVyIiwib3JpZ2luIiwicmVxdWVzdCIsInB1c2giLCJib2R5TGVuZ3RoIiwiYm9keSIsImlzSXRlcmFibGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsImVyciIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImVycm9yUmVxdWVzdCIsImNhbGxiYWNrIiwiZGVzdHJveSIsInF1ZXVlTWljcm90YXNrIiwib24iLCJvbkh0dHAyU2Vzc2lvbkVycm9yIiwiY29kZSIsIm9uRXJyb3IiLCJvbkh0dHAyRnJhbWVFcnJvciIsInR5cGUiLCJpZCIsIm9uSHR0cDJTZXNzaW9uRW5kIiwib25IVFRQMkdvQXdheSIsImNsaWVudCIsImVtaXQiLCJFTVBUWV9CVUYiLCJhbGxvYyIsImxhenlsbGh0dHAiLCJsbGh0dHBXYXNtRGF0YSIsImVudiIsIkpFU1RfV09SS0VSX0lEIiwibW9kIiwiV2ViQXNzZW1ibHkiLCJjb21waWxlIiwiZnJvbSIsImUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwicCIsImF0IiwibGVuIiwid2FzbV9vbl9zdGF0dXMiLCJzdHJpY3RFcXVhbCIsImN1cnJlbnRQYXJzZXIiLCJwdHIiLCJzdGFydCIsImN1cnJlbnRCdWZmZXJQdHIiLCJjdXJyZW50QnVmZmVyUmVmIiwiYnl0ZU9mZnNldCIsIm9uU3RhdHVzIiwiYnVmZmVyIiwid2FzbV9vbl9tZXNzYWdlX2JlZ2luIiwib25NZXNzYWdlQmVnaW4iLCJ3YXNtX29uX2hlYWRlcl9maWVsZCIsIm9uSGVhZGVyRmllbGQiLCJ3YXNtX29uX2hlYWRlcl92YWx1ZSIsIm9uSGVhZGVyVmFsdWUiLCJ3YXNtX29uX2hlYWRlcnNfY29tcGxldGUiLCJzdGF0dXNDb2RlIiwidXBncmFkZSIsInNob3VsZEtlZXBBbGl2ZSIsIm9uSGVhZGVyc0NvbXBsZXRlIiwiQm9vbGVhbiIsIndhc21fb25fYm9keSIsIm9uQm9keSIsIndhc21fb25fbWVzc2FnZV9jb21wbGV0ZSIsIm9uTWVzc2FnZUNvbXBsZXRlIiwibGxodHRwSW5zdGFuY2UiLCJsbGh0dHBQcm9taXNlIiwiY2F0Y2giLCJjdXJyZW50QnVmZmVyU2l6ZSIsIlRJTUVPVVRfSEVBREVSUyIsIlRJTUVPVVRfQk9EWSIsIlRJTUVPVVRfSURMRSIsIlBhcnNlciIsImV4cG9ydHMiLCJsbGh0dHAiLCJsbGh0dHBfYWxsb2MiLCJUWVBFIiwiUkVTUE9OU0UiLCJ0aW1lb3V0VmFsdWUiLCJ0aW1lb3V0VHlwZSIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwiaGVhZGVyc1NpemUiLCJoZWFkZXJzTWF4U2l6ZSIsInBhdXNlZCIsImJpbmQiLCJieXRlc1JlYWQiLCJjb250ZW50TGVuZ3RoIiwiY29ubmVjdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJvblBhcnNlclRpbWVvdXQiLCJ1bnJlZiIsInJlZnJlc2giLCJsbGh0dHBfcmVzdW1lIiwiZXhlY3V0ZSIsInJlYWQiLCJyZWFkTW9yZSIsImNodW5rIiwiZGF0YSIsImZyZWUiLCJNYXRoIiwiY2VpbCIsIm1hbGxvYyIsIlVpbnQ4QXJyYXkiLCJtZW1vcnkiLCJzZXQiLCJyZXQiLCJsbGh0dHBfZXhlY3V0ZSIsIm9mZnNldCIsImxsaHR0cF9nZXRfZXJyb3JfcG9zIiwiRVJST1IiLCJQQVVTRURfVVBHUkFERSIsIm9uVXBncmFkZSIsInNsaWNlIiwiUEFVU0VEIiwidW5zaGlmdCIsIk9LIiwibGxodHRwX2dldF9lcnJvcl9yZWFzb24iLCJtZXNzYWdlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwibGxodHRwX2ZyZWUiLCJidWYiLCJjb25jYXQiLCJ0cmFja0hlYWRlciIsImtleSIsInRvTG93ZXJDYXNlIiwiaGVhZCIsIm1ldGhvZCIsInJlbW92ZUxpc3RlbmVyIiwib25Tb2NrZXRFcnJvciIsIm9uU29ja2V0UmVhZGFibGUiLCJvblNvY2tldEVuZCIsIm9uU29ja2V0Q2xvc2UiLCJnZXRTb2NrZXRJbmZvIiwicGFyc2VLZWVwQWxpdmVUaW1lb3V0IiwibWluIiwicGF1c2UiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJwYXJzZUludCIsIm9uQ29tcGxldGUiLCJzZXRJbW1lZGlhdGUiLCJwYXJzZXIiLCJ3cml0YWJsZU5lZWREcmFpbiIsImhvc3QiLCJwcm90b2NvbCIsImlkeCIsImlwIiwic3Vic3RyIiwicHVibGlzaCIsImNvbm5lY3RQYXJhbXMiLCJzZXJ2ZXJuYW1lIiwiY29ubmVjdG9yIiwicmVqZWN0IiwiaXNIMiIsImFscG5Qcm90b2NvbCIsImVtaXRXYXJuaW5nIiwic2Vzc2lvbiIsImNyZWF0ZUNvbm5lY3Rpb24iLCJwZWVyTWF4Q29uY3VycmVudFN0cmVhbXMiLCJlcnJvciIsImVtaXREcmFpbiIsInN5bmMiLCJfcmVzdW1lIiwicmVmIiwiaWRlbXBvdGVudCIsImlzU3RyZWFtIiwiaXNBc3luY0l0ZXJhYmxlIiwiYWJvcnRlZCIsIndyaXRlIiwid3JpdGVIMiIsInBhdGgiLCJibG9ja2luZyIsInJlc2V0IiwiZXhwZWN0c1BheWxvYWQiLCJvbkNvbm5lY3QiLCJjb21wbGV0ZWQiLCJoZWFkZXIiLCJvblJlcXVlc3RTZW50IiwiaXNCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY29yayIsInVuY29yayIsIm9uQm9keVNlbnQiLCJpc0Jsb2JMaWtlIiwic3RyZWFtIiwid3JpdGVJdGVyYWJsZSIsIndyaXRlQmxvYiIsIndyaXRlU3RyZWFtIiwiZXhwZWN0Q29udGludWUiLCJzaWduYWwiLCJyZXFIZWFkZXJzIiwidHJpbSIsIkVycm9yIiwiaDJTdGF0ZSIsImVuZFN0cmVhbSIsInBlbmRpbmciLCJzaG91bGRFbmRTdHJlYW0iLCJ3cml0ZUJvZHlIMiIsImNsb3NlZCIsInN0cmVhbXMiLCJlbmQiLCJoMnN0cmVhbSIsInBpcGUiLCJvblBpcGVEYXRhIiwiZmluaXNoZWQiLCJ3cml0ZXIiLCJBc3luY1dyaXRlciIsIm9uRHJhaW4iLCJvbkFib3J0Iiwib25GaW5pc2hlZCIsIm9mZiIsImVyIiwic2l6ZSIsImFycmF5QnVmZmVyIiwid2FpdEZvckRyYWluIiwicmVzIiwiYnl0ZXNXcml0dGVuIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* istanbul ignore file: only for Node 12 */ const { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nclass CompatWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;\n    }\n}\nclass CompatFinalizer {\n    constructor(finalizer){\n        this.finalizer = finalizer;\n    }\n    register(dispatcher, key) {\n        if (dispatcher.on) {\n            dispatcher.on(\"disconnect\", ()=>{\n                if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n                    this.finalizer(key);\n                }\n            });\n        }\n    }\n}\nmodule.exports = function() {\n    // FIXME: remove workaround when the Node bug is fixed\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n    if (process.env.NODE_V8_COVERAGE) {\n        return {\n            WeakRef: CompatWeakRef,\n            FinalizationRegistry: CompatFinalizer\n        };\n    }\n    return {\n        WeakRef: global.WeakRef || CompatWeakRef,\n        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb21wYXQvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsMENBQTBDLEdBRTFDLE1BQU0sRUFBRUEsVUFBVSxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFdEMsTUFBTUM7SUFDSkMsWUFBYUMsS0FBSyxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNmO0lBRUFDLFFBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDTCxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUNLLEtBQUssQ0FBQ0osTUFBTSxLQUFLLElBQ3pETSxZQUNBLElBQUksQ0FBQ0YsS0FBSztJQUNoQjtBQUNGO0FBRUEsTUFBTUc7SUFDSkosWUFBYUssU0FBUyxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNuQjtJQUVBQyxTQUFVQyxVQUFVLEVBQUVDLEdBQUcsRUFBRTtRQUN6QixJQUFJRCxXQUFXRSxFQUFFLEVBQUU7WUFDakJGLFdBQVdFLEVBQUUsQ0FBQyxjQUFjO2dCQUMxQixJQUFJRixVQUFVLENBQUNYLFdBQVcsS0FBSyxLQUFLVyxVQUFVLENBQUNWLE1BQU0sS0FBSyxHQUFHO29CQUMzRCxJQUFJLENBQUNRLFNBQVMsQ0FBQ0c7Z0JBQ2pCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2Ysc0RBQXNEO0lBQ3RELHNFQUFzRTtJQUN0RSxJQUFJQyxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQixFQUFFO1FBQ2hDLE9BQU87WUFDTEMsU0FBU2hCO1lBQ1RpQixzQkFBc0JaO1FBQ3hCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xXLFNBQVNFLE9BQU9GLE9BQU8sSUFBSWhCO1FBQzNCaUIsc0JBQXNCQyxPQUFPRCxvQkFBb0IsSUFBSVo7SUFDdkQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZi5qcz9iNTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZTogb25seSBmb3IgTm9kZSAxMiAqL1xuXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5jbGFzcyBDb21wYXRXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBkZXJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVba0Nvbm5lY3RlZF0gPT09IDAgJiYgdGhpcy52YWx1ZVtrU2l6ZV0gPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMudmFsdWVcbiAgfVxufVxuXG5jbGFzcyBDb21wYXRGaW5hbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoZmluYWxpemVyKSB7XG4gICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXJcbiAgfVxuXG4gIHJlZ2lzdGVyIChkaXNwYXRjaGVyLCBrZXkpIHtcbiAgICBpZiAoZGlzcGF0Y2hlci5vbikge1xuICAgICAgZGlzcGF0Y2hlci5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXJba0Nvbm5lY3RlZF0gPT09IDAgJiYgZGlzcGF0Y2hlcltrU2l6ZV0gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZpbmFsaXplcihrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAvLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTM0NCNpc3N1ZWNvbW1lbnQtMTc0MTc3NjMwOFxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRSkge1xuICAgIHJldHVybiB7XG4gICAgICBXZWFrUmVmOiBDb21wYXRXZWFrUmVmLFxuICAgICAgRmluYWxpemF0aW9uUmVnaXN0cnk6IENvbXBhdEZpbmFsaXplclxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIFdlYWtSZWY6IGdsb2JhbC5XZWFrUmVmIHx8IENvbXBhdFdlYWtSZWYsXG4gICAgRmluYWxpemF0aW9uUmVnaXN0cnk6IGdsb2JhbC5GaW5hbGl6YXRpb25SZWdpc3RyeSB8fCBDb21wYXRGaW5hbGl6ZXJcbiAgfVxufVxuIl0sIm5hbWVzIjpbImtDb25uZWN0ZWQiLCJrU2l6ZSIsInJlcXVpcmUiLCJDb21wYXRXZWFrUmVmIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsImRlcmVmIiwidW5kZWZpbmVkIiwiQ29tcGF0RmluYWxpemVyIiwiZmluYWxpemVyIiwicmVnaXN0ZXIiLCJkaXNwYXRjaGVyIiwia2V5Iiwib24iLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImVudiIsIk5PREVfVjhfQ09WRVJBR0UiLCJXZWFrUmVmIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/compat/dispatcher-weakref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cookies/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/cookies/constants.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024;\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096;\nmodule.exports = {\n    maxAttributeValueSize,\n    maxNameValuePairSize\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDJFQUEyRTtBQUMzRSxNQUFNQSx3QkFBd0I7QUFFOUIsMkVBQTJFO0FBQzNFLE1BQU1DLHVCQUF1QjtBQUU3QkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZIO0lBQ0FDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Nvb2tpZXMvY29uc3RhbnRzLmpzPzk5NTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1hdHRyaWJ1dGUtdmFsdWUtc2l6ZVxuY29uc3QgbWF4QXR0cmlidXRlVmFsdWVTaXplID0gMTAyNFxuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tbmFtZS12YWx1ZS1wYWlyLXNpemVcbmNvbnN0IG1heE5hbWVWYWx1ZVBhaXJTaXplID0gNDA5NlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4QXR0cmlidXRlVmFsdWVTaXplLFxuICBtYXhOYW1lVmFsdWVQYWlyU2l6ZVxufVxuIl0sIm5hbWVzIjpbIm1heEF0dHJpYnV0ZVZhbHVlU2l6ZSIsIm1heE5hbWVWYWx1ZVBhaXJTaXplIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cookies/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cookies/index.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cookies/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/undici/lib/cookies/parse.js\");\nconst { stringify, getHeadersList } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/cookies/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\");\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */ /**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */ function getCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookie = headers.get(\"cookie\");\n    const out = {};\n    if (!cookie) {\n        return out;\n    }\n    for (const piece of cookie.split(\";\")){\n        const [name, ...value] = piece.split(\"=\");\n        out[name.trim()] = value.join(\"=\");\n    }\n    return out;\n}\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */ function deleteCookie(headers, name, attributes) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"deleteCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    name = webidl.converters.DOMString(name);\n    attributes = webidl.converters.DeleteCookieAttributes(attributes);\n    // Matches behavior of\n    // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n    setCookie(headers, {\n        name,\n        value: \"\",\n        expires: new Date(0),\n        ...attributes\n    });\n}\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */ function getSetCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"getSetCookies\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookies = getHeadersList(headers).cookies;\n    if (!cookies) {\n        return [];\n    }\n    // In older versions of undici, cookies is a list of name:value.\n    return cookies.map((pair)=>parseSetCookie(Array.isArray(pair) ? pair[1] : pair));\n}\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */ function setCookie(headers, cookie) {\n    webidl.argumentLengthCheck(arguments, 2, {\n        header: \"setCookie\"\n    });\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    cookie = webidl.converters.Cookie(cookie);\n    const str = stringify(cookie);\n    if (str) {\n        headers.append(\"Set-Cookie\", stringify(cookie));\n    }\n}\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    }\n]);\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n    {\n        converter: webidl.converters.DOMString,\n        key: \"name\"\n    },\n    {\n        converter: webidl.converters.DOMString,\n        key: \"value\"\n    },\n    {\n        converter: webidl.nullableConverter((value)=>{\n            if (typeof value === \"number\") {\n                return webidl.converters[\"unsigned long long\"](value);\n            }\n            return new Date(value);\n        }),\n        key: \"expires\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters[\"long long\"]),\n        key: \"maxAge\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"secure\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"httpOnly\",\n        defaultValue: null\n    },\n    {\n        converter: webidl.converters.USVString,\n        key: \"sameSite\",\n        allowedValues: [\n            \"Strict\",\n            \"Lax\",\n            \"None\"\n        ]\n    },\n    {\n        converter: webidl.sequenceConverter(webidl.converters.DOMString),\n        key: \"unparsed\",\n        defaultValue: []\n    }\n]);\nmodule.exports = {\n    getCookies,\n    deleteCookie,\n    getSetCookies,\n    setCookie\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxjQUFjLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUM5QyxNQUFNLEVBQUVHLE1BQU0sRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVJLE9BQU8sRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUU1Qjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRDs7O0NBR0MsR0FDRCxTQUFTSyxXQUFZQyxPQUFPO0lBQzFCSCxPQUFPSSxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1FBQUVDLFFBQVE7SUFBYTtJQUVoRU4sT0FBT08sVUFBVSxDQUFDSixTQUFTRixTQUFTO1FBQUVPLFFBQVE7SUFBTTtJQUVwRCxNQUFNQyxTQUFTTixRQUFRTyxHQUFHLENBQUM7SUFDM0IsTUFBTUMsTUFBTSxDQUFDO0lBRWIsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT0U7SUFDVDtJQUVBLEtBQUssTUFBTUMsU0FBU0gsT0FBT0ksS0FBSyxDQUFDLEtBQU07UUFDckMsTUFBTSxDQUFDQyxNQUFNLEdBQUdDLE1BQU0sR0FBR0gsTUFBTUMsS0FBSyxDQUFDO1FBRXJDRixHQUFHLENBQUNHLEtBQUtFLElBQUksR0FBRyxHQUFHRCxNQUFNRSxJQUFJLENBQUM7SUFDaEM7SUFFQSxPQUFPTjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTTyxhQUFjZixPQUFPLEVBQUVXLElBQUksRUFBRUssVUFBVTtJQUM5Q25CLE9BQU9JLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7UUFBRUMsUUFBUTtJQUFlO0lBRWxFTixPQUFPTyxVQUFVLENBQUNKLFNBQVNGLFNBQVM7UUFBRU8sUUFBUTtJQUFNO0lBRXBETSxPQUFPZCxPQUFPb0IsVUFBVSxDQUFDQyxT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QUNvQixPQUFPO1FBQzdERixLQUFLO1FBQ0xDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxXQUFXcEMsT0FBT29CLFVBQVUsQ0FBQ3FCLFNBQVM7UUFDdENILEtBQUs7UUFDTEksZUFBZTtZQUFDO1lBQVU7WUFBTztTQUFPO0lBQzFDO0lBQ0E7UUFDRU4sV0FBV3BDLE9BQU8yQyxpQkFBaUIsQ0FBQzNDLE9BQU9vQixVQUFVLENBQUNDLFNBQVM7UUFDL0RpQixLQUFLO1FBQ0xDLGNBQWMsRUFBRTtJQUNsQjtDQUNEO0FBRURLLE9BQU9DLE9BQU8sR0FBRztJQUNmM0M7SUFDQWdCO0lBQ0FRO0lBQ0FIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Nvb2tpZXMvaW5kZXguanM/YjlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwYXJzZVNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHN0cmluZ2lmeSwgZ2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29va2llXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0RhdGV8bnVtYmVyfHVuZGVmaW5lZH0gZXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ8dW5kZWZpbmVkfSBtYXhBZ2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gZG9tYWluXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHBhdGhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IHNlY3VyZVxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gaHR0cE9ubHlcbiAqIEBwcm9wZXJ0eSB7J1N0cmljdCd8J0xheCd8J05vbmUnfSBzYW1lU2l0ZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdW5wYXJzZWRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ2dldENvb2tpZXMnIH0pXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgY29va2llID0gaGVhZGVycy5nZXQoJ2Nvb2tpZScpXG4gIGNvbnN0IG91dCA9IHt9XG5cbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmb3IgKGNvbnN0IHBpZWNlIG9mIGNvb2tpZS5zcGxpdCgnOycpKSB7XG4gICAgY29uc3QgW25hbWUsIC4uLnZhbHVlXSA9IHBpZWNlLnNwbGl0KCc9JylcblxuICAgIG91dFtuYW1lLnRyaW0oKV0gPSB2YWx1ZS5qb2luKCc9JylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgcGF0aD86IHN0cmluZywgZG9tYWluPzogc3RyaW5nIH18dW5kZWZpbmVkfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVsZXRlQ29va2llIChoZWFkZXJzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdkZWxldGVDb29raWUnIH0pXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhuYW1lKVxuICBhdHRyaWJ1dGVzID0gd2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyhhdHRyaWJ1dGVzKVxuXG4gIC8vIE1hdGNoZXMgYmVoYXZpb3Igb2ZcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm9fc3RkL2Jsb2IvNjM4MjdiMTYzMzBiODI0ODlhMDQ2MTQwMjdjMzNiNzkwNGUwOGJlNS9odHRwL2Nvb2tpZS50cyNMMjc4XG4gIHNldENvb2tpZShoZWFkZXJzLCB7XG4gICAgbmFtZSxcbiAgICB2YWx1ZTogJycsXG4gICAgZXhwaXJlczogbmV3IERhdGUoMCksXG4gICAgLi4uYXR0cmlidXRlc1xuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHJldHVybnMge0Nvb2tpZVtdfVxuICovXG5mdW5jdGlvbiBnZXRTZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdnZXRTZXRDb29raWVzJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNvb2tpZXMgPSBnZXRIZWFkZXJzTGlzdChoZWFkZXJzKS5jb29raWVzXG5cbiAgaWYgKCFjb29raWVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvLyBJbiBvbGRlciB2ZXJzaW9ucyBvZiB1bmRpY2ksIGNvb2tpZXMgaXMgYSBsaXN0IG9mIG5hbWU6dmFsdWUuXG4gIHJldHVybiBjb29raWVzLm1hcCgocGFpcikgPT4gcGFyc2VTZXRDb29raWUoQXJyYXkuaXNBcnJheShwYWlyKSA/IHBhaXJbMV0gOiBwYWlyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7Q29va2llfSBjb29raWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRDb29raWUgKGhlYWRlcnMsIGNvb2tpZSkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnc2V0Q29va2llJyB9KVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvb2tpZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZShjb29raWUpXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGNvb2tpZSlcblxuICBpZiAoc3RyKSB7XG4gICAgaGVhZGVycy5hcHBlbmQoJ1NldC1Db29raWUnLCBzdHJpbmdpZnkoY29va2llKSlcbiAgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5EZWxldGVDb29raWVBdHRyaWJ1dGVzID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAnZG9tYWluJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ29va2llID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAga2V5OiAnbmFtZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ3ZhbHVlJ1xuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddKHZhbHVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpXG4gICAgfSksXG4gICAga2V5OiAnZXhwaXJlcycsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10pLFxuICAgIGtleTogJ21heEFnZScsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3BhdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiksXG4gICAga2V5OiAnc2VjdXJlJyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ2h0dHBPbmx5JyxcbiAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGtleTogJ3NhbWVTaXRlJyxcbiAgICBhbGxvd2VkVmFsdWVzOiBbJ1N0cmljdCcsICdMYXgnLCAnTm9uZSddXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3VucGFyc2VkJyxcbiAgICBkZWZhdWx0VmFsdWU6IFtdXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb29raWVzLFxuICBkZWxldGVDb29raWUsXG4gIGdldFNldENvb2tpZXMsXG4gIHNldENvb2tpZVxufVxuIl0sIm5hbWVzIjpbInBhcnNlU2V0Q29va2llIiwicmVxdWlyZSIsInN0cmluZ2lmeSIsImdldEhlYWRlcnNMaXN0Iiwid2ViaWRsIiwiSGVhZGVycyIsImdldENvb2tpZXMiLCJoZWFkZXJzIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImJyYW5kQ2hlY2siLCJzdHJpY3QiLCJjb29raWUiLCJnZXQiLCJvdXQiLCJwaWVjZSIsInNwbGl0IiwibmFtZSIsInZhbHVlIiwidHJpbSIsImpvaW4iLCJkZWxldGVDb29raWUiLCJhdHRyaWJ1dGVzIiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMiLCJzZXRDb29raWUiLCJleHBpcmVzIiwiRGF0ZSIsImdldFNldENvb2tpZXMiLCJjb29raWVzIiwibWFwIiwicGFpciIsIkFycmF5IiwiaXNBcnJheSIsIkNvb2tpZSIsInN0ciIsImFwcGVuZCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJudWxsYWJsZUNvbnZlcnRlciIsImtleSIsImRlZmF1bHRWYWx1ZSIsImJvb2xlYW4iLCJVU1ZTdHJpbmciLCJhbGxvd2VkVmFsdWVzIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cookies/parse.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/cookies/parse.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/cookies/constants.js\");\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/cookies/util.js\");\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if (isCTLExcludingHtab(header)) {\n        return null;\n    }\n    let nameValuePair = \"\";\n    let unparsedAttributes = \"\";\n    let name = \"\";\n    let value = \"\";\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(\";\")) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = collectASequenceOfCodePointsFast(\";\", header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else {\n        // Otherwise:\n        // 1. The name-value-pair string consists of all the characters\n        //    contained in the set-cookie-string, and the unparsed-\n        //    attributes is the empty string.\n        nameValuePair = header;\n    }\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes(\"=\")) {\n        value = nameValuePair;\n    } else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = collectASequenceOfCodePointsFast(\"=\", nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > maxNameValuePairSize) {\n        return null;\n    }\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name,\n        value,\n        ...parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) {\n        return cookieAttributeList;\n    }\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    assert(unparsedAttributes[0] === \";\");\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = \"\";\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(\";\")) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = collectASequenceOfCodePointsFast(\";\", unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = \"\";\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = \"\";\n    let attributeValue = \"\";\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes(\"=\")) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = collectASequenceOfCodePointsFast(\"=\", cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else {\n        // Otherwise:\n        // 1. The attribute-name string consists of the entire cookie-av\n        //    string, and the attribute-value string is empty.\n        attributeName = cookieAv;\n    }\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > maxAttributeValueSize) {\n        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === \"expires\") {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === \"max-age\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== \"-\") {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === \"domain\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === \".\") {\n            cookieDomain = cookieDomain.slice(1);\n        }\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === \"path\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = \"\";\n        if (attributeValue.length === 0 || attributeValue[0] !== \"/\") {\n            // 1. Let cookie-path be the default-path.\n            cookiePath = \"/\";\n        } else {\n            // Otherwise:\n            // 1. Let cookie-path be the attribute-value.\n            cookiePath = attributeValue;\n        }\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === \"secure\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n        // If the attribute-name case-insensitively matches the string \"Secure\",\n        // the user agent MUST append an attribute to the cookie-attribute-list\n        // with an attribute-name of Secure and an empty attribute-value.\n        cookieAttributeList.secure = true;\n    } else if (attributeNameLowercase === \"httponly\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n        // If the attribute-name case-insensitively matches the string\n        // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n        // attribute-list with an attribute-name of HttpOnly and an empty\n        // attribute-value.\n        cookieAttributeList.httpOnly = true;\n    } else if (attributeNameLowercase === \"samesite\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = \"Default\";\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes(\"none\")) {\n            enforcement = \"None\";\n        }\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes(\"strict\")) {\n            enforcement = \"Strict\";\n        }\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes(\"lax\")) {\n            enforcement = \"Lax\";\n        }\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n    parseSetCookie,\n    parseUnparsedAttributes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRUMscUJBQXFCLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDaEUsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVFLGdDQUFnQyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBRXZCOzs7OztDQUtDLEdBQ0QsU0FBU0ksZUFBZ0JDLE1BQU07SUFDN0Isa0VBQWtFO0lBQ2xFLHNFQUFzRTtJQUN0RSw0Q0FBNEM7SUFDNUMsSUFBSUosbUJBQW1CSSxTQUFTO1FBQzlCLE9BQU87SUFDVDtJQUVBLElBQUlDLGdCQUFnQjtJQUNwQixJQUFJQyxxQkFBcUI7SUFDekIsSUFBSUMsT0FBTztJQUNYLElBQUlDLFFBQVE7SUFFWiwrREFBK0Q7SUFDL0QsSUFBSUosT0FBT0ssUUFBUSxDQUFDLE1BQU07UUFDeEIsa0VBQWtFO1FBQ2xFLGdFQUFnRTtRQUNoRSxrRUFBa0U7UUFDbEUsNkNBQTZDO1FBQzdDLE1BQU1DLFdBQVc7WUFBRUEsVUFBVTtRQUFFO1FBRS9CTCxnQkFBZ0JKLGlDQUFpQyxLQUFLRyxRQUFRTTtRQUM5REoscUJBQXFCRixPQUFPTyxLQUFLLENBQUNELFNBQVNBLFFBQVE7SUFDckQsT0FBTztRQUNMLGFBQWE7UUFFYiwrREFBK0Q7UUFDL0QsMkRBQTJEO1FBQzNELHFDQUFxQztRQUNyQ0wsZ0JBQWdCRDtJQUNsQjtJQUVBLHNFQUFzRTtJQUN0RSxvRUFBb0U7SUFDcEUsc0JBQXNCO0lBQ3RCLElBQUksQ0FBQ0MsY0FBY0ksUUFBUSxDQUFDLE1BQU07UUFDaENELFFBQVFIO0lBQ1YsT0FBTztRQUNMLHNFQUFzRTtRQUN0RSxzRUFBc0U7UUFDdEUsb0VBQW9FO1FBQ3BFLDJCQUEyQjtRQUMz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LE9BQU9DLE9BQU8sR0FBRztJQUNmdkM7SUFDQVc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29va2llcy9wYXJzZS5qcz9mYTg1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG1heE5hbWVWYWx1ZVBhaXJTaXplLCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgaXNDVExFeGNsdWRpbmdIdGFiIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YVVSTCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBQYXJzZXMgdGhlIGZpZWxkLXZhbHVlIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlciBzdHJpbmcuXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAqIEByZXR1cm5zIGlmIHRoZSBoZWFkZXIgaXMgaW52YWxpZCwgbnVsbCB3aWxsIGJlIHJldHVybmVkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V0Q29va2llIChoZWFkZXIpIHtcbiAgLy8gMS4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgwMC0wOCAvICV4MEEtMUYgLyAleDdGXG4gIC8vICAgIGNoYXJhY3RlciAoQ1RMIGNoYXJhY3RlcnMgZXhjbHVkaW5nIEhUQUIpOiBBYm9ydCB0aGVzZSBzdGVwcyBhbmRcbiAgLy8gICAgaWdub3JlIHRoZSBzZXQtY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKGlzQ1RMRXhjbHVkaW5nSHRhYihoZWFkZXIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBuYW1lVmFsdWVQYWlyID0gJydcbiAgbGV0IHVucGFyc2VkQXR0cmlidXRlcyA9ICcnXG4gIGxldCBuYW1lID0gJydcbiAgbGV0IHZhbHVlID0gJydcblxuICAvLyAyLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyOlxuICBpZiAoaGVhZGVyLmluY2x1ZGVzKCc7JykpIHtcbiAgICAvLyAxLiBUaGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0byxcbiAgICAvLyAgICBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSwgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGNvbnNpc3Qgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmdcbiAgICAvLyAgICAoaW5jbHVkaW5nIHRoZSAleDNCIChcIjtcIikgaW4gcXVlc3Rpb24pLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBuYW1lVmFsdWVQYWlyID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoJzsnLCBoZWFkZXIsIHBvc2l0aW9uKVxuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9IGhlYWRlci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbilcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBUaGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBjb25zaXN0cyBvZiBhbGwgdGhlIGNoYXJhY3RlcnNcbiAgICAvLyAgICBjb250YWluZWQgaW4gdGhlIHNldC1jb29raWUtc3RyaW5nLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgaXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICBuYW1lVmFsdWVQYWlyID0gaGVhZGVyXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgbmFtZS12YWx1ZS1wYWlyIHN0cmluZyBsYWNrcyBhICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIHRoZW5cbiAgLy8gICAgdGhlIG5hbWUgc3RyaW5nIGlzIGVtcHR5LCBhbmQgdGhlIHZhbHVlIHN0cmluZyBpcyB0aGUgdmFsdWUgb2ZcbiAgLy8gICAgbmFtZS12YWx1ZS1wYWlyLlxuICBpZiAoIW5hbWVWYWx1ZVBhaXIuaW5jbHVkZXMoJz0nKSkge1xuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpclxuICB9IGVsc2Uge1xuICAgIC8vICAgIE90aGVyd2lzZSwgdGhlIG5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLCBidXRcbiAgICAvLyAgICBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHlcbiAgICAvLyAgICBlbXB0eSkgdmFsdWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdFxuICAgIC8vICAgICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cbiAgICBuYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBuYW1lVmFsdWVQYWlyLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uICsgMSlcbiAgfVxuXG4gIC8vIDQuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBuYW1lXG4gIC8vICAgIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZy5cbiAgbmFtZSA9IG5hbWUudHJpbSgpXG4gIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgLy8gNS4gSWYgdGhlIHN1bSBvZiB0aGUgbGVuZ3RocyBvZiB0aGUgbmFtZSBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmdcbiAgLy8gICAgaXMgbW9yZSB0aGFuIDQwOTYgb2N0ZXRzLCBhYm9ydCB0aGVzZSBzdGVwcyBhbmQgaWdub3JlIHRoZSBzZXQtXG4gIC8vICAgIGNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChuYW1lLmxlbmd0aCArIHZhbHVlLmxlbmd0aCA+IG1heE5hbWVWYWx1ZVBhaXJTaXplKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDYuIFRoZSBjb29raWUtbmFtZSBpcyB0aGUgbmFtZSBzdHJpbmcsIGFuZCB0aGUgY29va2llLXZhbHVlIGlzIHRoZVxuICAvLyAgICB2YWx1ZSBzdHJpbmcuXG4gIHJldHVybiB7XG4gICAgbmFtZSwgdmFsdWUsIC4uLnBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcylcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcmVtYWluaW5nIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlclxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1tPYmplY3QuPHN0cmluZywgdW5rbm93bj5dPXt9fSBjb29raWVBdHRyaWJ1dGVMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzICh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QgPSB7fSkge1xuICAvLyAxLiBJZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyBzdHJpbmcgaXMgZW1wdHksIHNraXAgdGhlIHJlc3Qgb2ZcbiAgLy8gICAgdGhlc2Ugc3RlcHMuXG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAgfVxuXG4gIC8vIDIuIERpc2NhcmQgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyAod2hpY2hcbiAgLy8gICAgd2lsbCBiZSBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIpLlxuICBhc3NlcnQodW5wYXJzZWRBdHRyaWJ1dGVzWzBdID09PSAnOycpXG4gIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZSgxKVxuXG4gIGxldCBjb29raWVBdiA9ICcnXG5cbiAgLy8gMy4gSWYgdGhlIHJlbWFpbmluZyB1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpXG4gIC8vICAgIGNoYXJhY3RlcjpcbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIuXG4gICAgY29va2llQXYgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc7JyxcbiAgICAgIHVucGFyc2VkQXR0cmlidXRlcyxcbiAgICAgIHsgcG9zaXRpb246IDAgfVxuICAgIClcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoY29va2llQXYubGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIENvbnN1bWUgdGhlIHJlbWFpbmRlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcy5cbiAgICBjb29raWVBdiA9IHVucGFyc2VkQXR0cmlidXRlc1xuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9ICcnXG4gIH1cblxuICAvLyBMZXQgdGhlIGNvb2tpZS1hdiBzdHJpbmcgYmUgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgaW4gdGhpcyBzdGVwLlxuXG4gIGxldCBhdHRyaWJ1dGVOYW1lID0gJydcbiAgbGV0IGF0dHJpYnV0ZVZhbHVlID0gJydcblxuICAvLyA0LiBJZiB0aGUgY29va2llLWF2IHN0cmluZyBjb250YWlucyBhICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXI6XG4gIGlmIChjb29raWVBdi5pbmNsdWRlcygnPScpKSB7XG4gICAgLy8gMS4gVGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZVxuICAgIC8vICAgIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLXZhbHVlIHN0cmluZ1xuICAgIC8vICAgIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIGNvb2tpZUF2LFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gICAgYXR0cmlidXRlVmFsdWUgPSBjb29raWVBdi5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgZW50aXJlIGNvb2tpZS1hdlxuICAgIC8vICAgIHN0cmluZywgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nIGlzIGVtcHR5LlxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb29raWVBdlxuICB9XG5cbiAgLy8gNS4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIGF0dHJpYnV0ZS1cbiAgLy8gICAgbmFtZSBzdHJpbmcgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nLlxuICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS50cmltKClcbiAgYXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGVWYWx1ZS50cmltKClcblxuICAvLyA2LiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGxvbmdlciB0aGFuIDEwMjQgb2N0ZXRzLCBpZ25vcmUgdGhlXG4gIC8vICAgIGNvb2tpZS1hdiBzdHJpbmcgYW5kIHJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPiBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUpIHtcbiAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICB9XG5cbiAgLy8gNy4gUHJvY2VzcyB0aGUgYXR0cmlidXRlLW5hbWUgYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlXG4gIC8vICAgIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLiAgKE5vdGljZSB0aGF0XG4gIC8vICAgIGF0dHJpYnV0ZXMgd2l0aCB1bnJlY29nbml6ZWQgYXR0cmlidXRlLW5hbWVzIGFyZSBpZ25vcmVkLilcbiAgY29uc3QgYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMVxuICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAvLyBcIkV4cGlyZXNcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cbiAgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdleHBpcmVzJykge1xuICAgIC8vIDEuIExldCB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBhdHRyaWJ1dGUtdmFsdWVcbiAgICAvLyAgICBhcyBjb29raWUtZGF0ZSAoc2VlIFNlY3Rpb24gNS4xLjEpLlxuICAgIGNvbnN0IGV4cGlyeVRpbWUgPSBuZXcgRGF0ZShhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDIuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgZmFpbGVkIHRvIHBhcnNlIGFzIGEgY29va2llIGRhdGUsIGlnbm9yZVxuICAgIC8vICAgIHRoZSBjb29raWUtYXYuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmV4cGlyZXMgPSBleHBpcnlUaW1lXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ21heC1hZ2UnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4yXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJNYXgtXG4gICAgLy8gQWdlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90IGEgRElHSVQgb3IgYVxuICAgIC8vICAgIFwiLVwiIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgY29uc3QgY2hhckNvZGUgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoKGNoYXJDb2RlIDwgNDggfHwgY2hhckNvZGUgPiA1NykgJiYgYXR0cmlidXRlVmFsdWVbMF0gIT09ICctJykge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGUgcmVtYWluZGVyIG9mIGF0dHJpYnV0ZS12YWx1ZSBjb250YWlucyBhIG5vbi1ESUdJVFxuICAgIC8vICAgIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgZGVsdGEtc2Vjb25kcyBiZSB0aGUgYXR0cmlidXRlLXZhbHVlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLlxuICAgIGNvbnN0IGRlbHRhU2Vjb25kcyA9IE51bWJlcihhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDQuIExldCBjb29raWUtYWdlLWxpbWl0IGJlIHRoZSBtYXhpbXVtIGFnZSBvZiB0aGUgY29va2llICh3aGljaFxuICAgIC8vICAgIFNIT1VMRCBiZSA0MDAgZGF5cyBvciBsZXNzLCBzZWUgU2VjdGlvbiA0LjEuMi4yKS5cblxuICAgIC8vIDUuIFNldCBkZWx0YS1zZWNvbmRzIHRvIHRoZSBzbWFsbGVyIG9mIGl0cyBwcmVzZW50IHZhbHVlIGFuZCBjb29raWUtXG4gICAgLy8gICAgYWdlLWxpbWl0LlxuICAgIC8vIGRlbHRhU2Vjb25kcyA9IE1hdGgubWluKGRlbHRhU2Vjb25kcyAqIDEwMDAsIG1heEV4cGlyZXNNcylcblxuICAgIC8vIDYuIElmIGRlbHRhLXNlY29uZHMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gKDApLCBsZXQgZXhwaXJ5LVxuICAgIC8vICAgIHRpbWUgYmUgdGhlIGVhcmxpZXN0IHJlcHJlc2VudGFibGUgZGF0ZSBhbmQgdGltZS4gIE90aGVyd2lzZSwgbGV0XG4gICAgLy8gICAgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcGx1cyBkZWx0YS1zZWNvbmRzXG4gICAgLy8gICAgc2Vjb25kcy5cbiAgICAvLyBjb25zdCBleHBpcnlUaW1lID0gZGVsdGFTZWNvbmRzIDw9IDAgPyBEYXRlLm5vdygpIDogRGF0ZS5ub3coKSArIGRlbHRhU2Vjb25kc1xuXG4gICAgLy8gNy4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBNYXgtQWdlIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgZXhwaXJ5LXRpbWUuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5tYXhBZ2UgPSBkZWx0YVNlY29uZHNcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZG9tYWluJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuM1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiRG9tYWluXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIExldCBjb29raWUtZG9tYWluIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgbGV0IGNvb2tpZURvbWFpbiA9IGF0dHJpYnV0ZVZhbHVlXG5cbiAgICAvLyAyLiBJZiBjb29raWUtZG9tYWluIHN0YXJ0cyB3aXRoICV4MkUgKFwiLlwiKSwgbGV0IGNvb2tpZS1kb21haW4gYmVcbiAgICAvLyAgICBjb29raWUtZG9tYWluIHdpdGhvdXQgaXRzIGxlYWRpbmcgJXgyRSAoXCIuXCIpLlxuICAgIGlmIChjb29raWVEb21haW5bMF0gPT09ICcuJykge1xuICAgICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnNsaWNlKDEpXG4gICAgfVxuXG4gICAgLy8gMy4gQ29udmVydCB0aGUgY29va2llLWRvbWFpbiB0byBsb3dlciBjYXNlLlxuICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA0LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIERvbWFpbiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1kb21haW4uXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5kb21haW4gPSBjb29raWVEb21haW5cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAncGF0aCcpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjRcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlBhdGhcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAgIC8vICAgIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAgIGxldCBjb29raWVQYXRoID0gJydcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLycpIHtcbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICAgICAgY29va2llUGF0aCA9ICcvJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgICAgY29va2llUGF0aCA9IGF0dHJpYnV0ZVZhbHVlXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBQYXRoIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLXBhdGguXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5wYXRoID0gY29va2llUGF0aFxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzZWN1cmUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC41XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJTZWN1cmVcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdFxuICAgIC8vIHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgU2VjdXJlIGFuZCBhbiBlbXB0eSBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNlY3VyZSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnaHR0cG9ubHknKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC42XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIkh0dHBPbmx5XCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLVxuICAgIC8vIGF0dHJpYnV0ZS1saXN0IHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgSHR0cE9ubHkgYW5kIGFuIGVtcHR5XG4gICAgLy8gYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5odHRwT25seSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2FtZXNpdGUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC43XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIlNhbWVTaXRlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3M6XG5cbiAgICAvLyAxLiBMZXQgZW5mb3JjZW1lbnQgYmUgXCJEZWZhdWx0XCIuXG4gICAgbGV0IGVuZm9yY2VtZW50ID0gJ0RlZmF1bHQnXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZVZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAvLyAyLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTm9uZVwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJOb25lXCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdub25lJykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ05vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIlN0cmljdFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJTdHJpY3RcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ3N0cmljdCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdTdHJpY3QnXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIkxheFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJMYXhcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ2xheCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdMYXgnXG4gICAgfVxuXG4gICAgLy8gNS4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBcIlNhbWVTaXRlXCIgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZlxuICAgIC8vICAgIGVuZm9yY2VtZW50LlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2FtZVNpdGUgPSBlbmZvcmNlbWVudFxuICB9IGVsc2Uge1xuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQgPz89IFtdXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkLnB1c2goYCR7YXR0cmlidXRlTmFtZX09JHthdHRyaWJ1dGVWYWx1ZX1gKVxuICB9XG5cbiAgLy8gOC4gUmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlU2V0Q29va2llLFxuICBwYXJzZVVucGFyc2VkQXR0cmlidXRlc1xufVxuIl0sIm5hbWVzIjpbIm1heE5hbWVWYWx1ZVBhaXJTaXplIiwibWF4QXR0cmlidXRlVmFsdWVTaXplIiwicmVxdWlyZSIsImlzQ1RMRXhjbHVkaW5nSHRhYiIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IiwiYXNzZXJ0IiwicGFyc2VTZXRDb29raWUiLCJoZWFkZXIiLCJuYW1lVmFsdWVQYWlyIiwidW5wYXJzZWRBdHRyaWJ1dGVzIiwibmFtZSIsInZhbHVlIiwiaW5jbHVkZXMiLCJwb3NpdGlvbiIsInNsaWNlIiwidHJpbSIsImxlbmd0aCIsInBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzIiwiY29va2llQXR0cmlidXRlTGlzdCIsImNvb2tpZUF2IiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlTmFtZUxvd2VyY2FzZSIsInRvTG93ZXJDYXNlIiwiZXhwaXJ5VGltZSIsIkRhdGUiLCJleHBpcmVzIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwidGVzdCIsImRlbHRhU2Vjb25kcyIsIk51bWJlciIsIm1heEFnZSIsImNvb2tpZURvbWFpbiIsImRvbWFpbiIsImNvb2tpZVBhdGgiLCJwYXRoIiwic2VjdXJlIiwiaHR0cE9ubHkiLCJlbmZvcmNlbWVudCIsImF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlIiwic2FtZVNpdGUiLCJ1bnBhcnNlZCIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cookies/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cookies/util.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/cookies/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nfunction isCTLExcludingHtab(value) {\n    if (value.length === 0) {\n        return false;\n    }\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code >= 0x00 || code <= 0x08 || code >= 0x0A || code <= 0x1F || code === 0x7F) {\n            return false;\n        }\n    }\n}\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */ function validateCookieName(name) {\n    for (const char of name){\n        const code = char.charCodeAt(0);\n        if (code <= 0x20 || code > 0x7F || char === \"(\" || char === \")\" || char === \">\" || char === \"<\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\") {\n            throw new Error(\"Invalid cookie name\");\n        }\n    }\n}\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */ function validateCookieValue(value) {\n    for (const char of value){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || // exclude CTLs (0-31)\n        code === 0x22 || code === 0x2C || code === 0x3B || code === 0x5C || code > 0x7E // non-ascii\n        ) {\n            throw new Error(\"Invalid header value\");\n        }\n    }\n}\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */ function validateCookiePath(path) {\n    for (const char of path){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || char === \";\") {\n            throw new Error(\"Invalid cookie path\");\n        }\n    }\n}\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */ function validateCookieDomain(domain) {\n    if (domain.startsWith(\"-\") || domain.endsWith(\".\") || domain.endsWith(\"-\")) {\n        throw new Error(\"Invalid cookie domain\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */ function toIMFDate(date) {\n    if (typeof date === \"number\") {\n        date = new Date(date);\n    }\n    const days = [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ];\n    const months = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const dayName = days[date.getUTCDay()];\n    const day = date.getUTCDate().toString().padStart(2, \"0\");\n    const month = months[date.getUTCMonth()];\n    const year = date.getUTCFullYear();\n    const hour = date.getUTCHours().toString().padStart(2, \"0\");\n    const minute = date.getUTCMinutes().toString().padStart(2, \"0\");\n    const second = date.getUTCSeconds().toString().padStart(2, \"0\");\n    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;\n}\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */ function validateCookieMaxAge(maxAge) {\n    if (maxAge < 0) {\n        throw new Error(\"Invalid cookie max-age\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */ function stringify(cookie) {\n    if (cookie.name.length === 0) {\n        return null;\n    }\n    validateCookieName(cookie.name);\n    validateCookieValue(cookie.value);\n    const out = [\n        `${cookie.name}=${cookie.value}`\n    ];\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n    if (cookie.name.startsWith(\"__Secure-\")) {\n        cookie.secure = true;\n    }\n    if (cookie.name.startsWith(\"__Host-\")) {\n        cookie.secure = true;\n        cookie.domain = null;\n        cookie.path = \"/\";\n    }\n    if (cookie.secure) {\n        out.push(\"Secure\");\n    }\n    if (cookie.httpOnly) {\n        out.push(\"HttpOnly\");\n    }\n    if (typeof cookie.maxAge === \"number\") {\n        validateCookieMaxAge(cookie.maxAge);\n        out.push(`Max-Age=${cookie.maxAge}`);\n    }\n    if (cookie.domain) {\n        validateCookieDomain(cookie.domain);\n        out.push(`Domain=${cookie.domain}`);\n    }\n    if (cookie.path) {\n        validateCookiePath(cookie.path);\n        out.push(`Path=${cookie.path}`);\n    }\n    if (cookie.expires && cookie.expires.toString() !== \"Invalid Date\") {\n        out.push(`Expires=${toIMFDate(cookie.expires)}`);\n    }\n    if (cookie.sameSite) {\n        out.push(`SameSite=${cookie.sameSite}`);\n    }\n    for (const part of cookie.unparsed){\n        if (!part.includes(\"=\")) {\n            throw new Error(\"Invalid unparsed\");\n        }\n        const [key, ...value] = part.split(\"=\");\n        out.push(`${key.trim()}=${value.join(\"=\")}`);\n    }\n    return out.join(\"; \");\n}\nlet kHeadersListNode;\nfunction getHeadersList(headers) {\n    if (headers[kHeadersList]) {\n        return headers[kHeadersList];\n    }\n    if (!kHeadersListNode) {\n        kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol)=>symbol.description === \"headers list\");\n        assert(kHeadersListNode, \"Headers cannot be parsed\");\n    }\n    const headersList = headers[kHeadersListNode];\n    assert(headersList);\n    return headersList;\n}\nmodule.exports = {\n    isCTLExcludingHtab,\n    stringify,\n    getHeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb29raWVzL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUVqQyxTQUFTRSxtQkFBb0JDLEtBQUs7SUFDaEMsSUFBSUEsTUFBTUMsTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBTztJQUNUO0lBRUEsS0FBSyxNQUFNQyxRQUFRRixNQUFPO1FBQ3hCLE1BQU1HLE9BQU9ELEtBQUtFLFVBQVUsQ0FBQztRQUU3QixJQUNFLFFBQVMsUUFBUUQsUUFBUSxRQUN4QkEsUUFBUSxRQUFRQSxRQUFRLFFBQ3pCQSxTQUFTLE1BQ1Q7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRSxtQkFBb0JDLElBQUk7SUFDL0IsS0FBSyxNQUFNSixRQUFRSSxLQUFNO1FBQ3ZCLE1BQU1ILE9BQU9ELEtBQUtFLFVBQVUsQ0FBQztRQUU3QixJQUNFLFFBQVMsUUFBUUQsT0FBTyxRQUN4QkQsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsUUFDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLE9BQ1RBLFNBQVMsT0FDVEEsU0FBUyxPQUNUQSxTQUFTLEtBQ1Q7WUFDQSxNQUFNLElBQUlLLE1BQU07UUFDbEI7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLG9CQUFxQlIsS0FBSztJQUNqQyxLQUFLLE1BQU1FLFFBQVFGLE1BQU87UUFDeEIsTUFBTUcsT0FBT0QsS0FBS0UsVUFBVSxDQUFDO1FBRTdCLElBQ0VELE9BQU8sUUFBUSxzQkFBc0I7UUFDckNBLFNBQVMsUUFDVEEsU0FB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LEtBQUssQ0FBQztJQUM3QztJQUVBLE9BQU9aLElBQUlZLElBQUksQ0FBQztBQUNsQjtBQUVBLElBQUlDO0FBRUosU0FBU0MsZUFBZ0JDLE9BQU87SUFDOUIsSUFBSUEsT0FBTyxDQUFDekQsYUFBYSxFQUFFO1FBQ3pCLE9BQU95RCxPQUFPLENBQUN6RCxhQUFhO0lBQzlCO0lBRUEsSUFBSSxDQUFDdUQsa0JBQWtCO1FBQ3JCQSxtQkFBbUJHLE9BQU9DLHFCQUFxQixDQUFDRixTQUFTRyxJQUFJLENBQzNELENBQUNDLFNBQVdBLE9BQU9DLFdBQVcsS0FBSztRQUdyQ2hFLE9BQU95RCxrQkFBa0I7SUFDM0I7SUFFQSxNQUFNUSxjQUFjTixPQUFPLENBQUNGLGlCQUFpQjtJQUM3Q3pELE9BQU9pRTtJQUVQLE9BQU9BO0FBQ1Q7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoRTtJQUNBdUM7SUFDQWdCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Nvb2tpZXMvdXRpbC5qcz9jZDY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmZ1bmN0aW9uIGlzQ1RMRXhjbHVkaW5nSHRhYiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjaGFyIG9mIHZhbHVlKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgKGNvZGUgPj0gMHgwMCB8fCBjb2RlIDw9IDB4MDgpIHx8XG4gICAgICAoY29kZSA+PSAweDBBIHx8IGNvZGUgPD0gMHgxRikgfHxcbiAgICAgIGNvZGUgPT09IDB4N0ZcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiBDSEFSICAgICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gdG9rZW4gICAgICAgICAgPSAxKjxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBzZXBhcmF0b3JzPlxuIHNlcGFyYXRvcnMgICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICAgICAgICAgICAgICAgIHwgXCIsXCIgfCBcIjtcIiB8IFwiOlwiIHwgXCJcXFwiIHwgPFwiPlxuICAgICAgICAgICAgICAgIHwgXCIvXCIgfCBcIltcIiB8IFwiXVwiIHwgXCI/XCIgfCBcIj1cIlxuICAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llTmFtZSAobmFtZSkge1xuICBmb3IgKGNvbnN0IGNoYXIgb2YgbmFtZSkge1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChcbiAgICAgIChjb2RlIDw9IDB4MjAgfHwgY29kZSA+IDB4N0YpIHx8XG4gICAgICBjaGFyID09PSAnKCcgfHxcbiAgICAgIGNoYXIgPT09ICcpJyB8fFxuICAgICAgY2hhciA9PT0gJz4nIHx8XG4gICAgICBjaGFyID09PSAnPCcgfHxcbiAgICAgIGNoYXIgPT09ICdAJyB8fFxuICAgICAgY2hhciA9PT0gJywnIHx8XG4gICAgICBjaGFyID09PSAnOycgfHxcbiAgICAgIGNoYXIgPT09ICc6JyB8fFxuICAgICAgY2hhciA9PT0gJ1xcXFwnIHx8XG4gICAgICBjaGFyID09PSAnXCInIHx8XG4gICAgICBjaGFyID09PSAnLycgfHxcbiAgICAgIGNoYXIgPT09ICdbJyB8fFxuICAgICAgY2hhciA9PT0gJ10nIHx8XG4gICAgICBjaGFyID09PSAnPycgfHxcbiAgICAgIGNoYXIgPT09ICc9JyB8fFxuICAgICAgY2hhciA9PT0gJ3snIHx8XG4gICAgICBjaGFyID09PSAnfSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbmFtZScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuIGNvb2tpZS12YWx1ZSAgICAgID0gKmNvb2tpZS1vY3RldCAvICggRFFVT1RFICpjb29raWUtb2N0ZXQgRFFVT1RFIClcbiBjb29raWUtb2N0ZXQgICAgICA9ICV4MjEgLyAleDIzLTJCIC8gJXgyRC0zQSAvICV4M0MtNUIgLyAleDVELTdFXG4gICAgICAgICAgICAgICAgICAgICAgIDsgVVMtQVNDSUkgY2hhcmFjdGVycyBleGNsdWRpbmcgQ1RMcyxcbiAgICAgICAgICAgICAgICAgICAgICAgOyB3aGl0ZXNwYWNlIERRVU9URSwgY29tbWEsIHNlbWljb2xvbixcbiAgICAgICAgICAgICAgICAgICAgICAgOyBhbmQgYmFja3NsYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVWYWx1ZSAodmFsdWUpIHtcbiAgZm9yIChjb25zdCBjaGFyIG9mIHZhbHVlKSB7XG4gICAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKVxuICAgICAgY29kZSA9PT0gMHgyMiB8fFxuICAgICAgY29kZSA9PT0gMHgyQyB8fFxuICAgICAgY29kZSA9PT0gMHgzQiB8fFxuICAgICAgY29kZSA9PT0gMHg1QyB8fFxuICAgICAgY29kZSA+IDB4N0UgLy8gbm9uLWFzY2lpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGVhZGVyIHZhbHVlJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llUGF0aCAocGF0aCkge1xuICBmb3IgKGNvbnN0IGNoYXIgb2YgcGF0aCkge1xuICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgIGlmIChjb2RlIDwgMHgyMSB8fCBjaGFyID09PSAnOycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgcGF0aCcpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSSBoYXZlIG5vIGlkZWEgd2h5IHRoZXNlIHZhbHVlcyBhcmVuJ3QgYWxsb3dlZCB0byBiZSBob25lc3QsXG4gKiBidXQgRGVubyB0ZXN0cyB0aGVzZS4gLSBLaGFmcmFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVEb21haW4gKGRvbWFpbikge1xuICBpZiAoXG4gICAgZG9tYWluLnN0YXJ0c1dpdGgoJy0nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLicpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCctJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBkb21haW4nKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTcuMS4xLjFcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRhdGVcbiAgSU1GLWZpeGRhdGUgID0gZGF5LW5hbWUgXCIsXCIgU1AgZGF0ZTEgU1AgdGltZS1vZi1kYXkgU1AgR01UXG4gIDsgZml4ZWQgbGVuZ3RoL3pvbmUvY2FwaXRhbGl6YXRpb24gc3Vic2V0IG9mIHRoZSBmb3JtYXRcbiAgOyBzZWUgU2VjdGlvbiAzLjMgb2YgW1JGQzUzMjJdXG5cbiAgZGF5LW5hbWUgICAgID0gJXg0RC42Ri42RSA7IFwiTW9uXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC43NS42NSA7IFwiVHVlXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1Ny42NS42NCA7IFwiV2VkXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC42OC43NSA7IFwiVGh1XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni43Mi42OSA7IFwiRnJpXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42MS43NCA7IFwiU2F0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My43NS42RSA7IFwiU3VuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIGRhdGUxICAgICAgICA9IGRheSBTUCBtb250aCBTUCB5ZWFyXG4gICAgICAgICAgICAgICAgICA7IGUuZy4sIDAyIEp1biAxOTgyXG5cbiAgZGF5ICAgICAgICAgID0gMkRJR0lUXG4gIG1vbnRoICAgICAgICA9ICV4NEEuNjEuNkUgOyBcIkphblwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDYuNjUuNjIgOyBcIkZlYlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzIgOyBcIk1hclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzAuNzIgOyBcIkFwclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzkgOyBcIk1heVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkUgOyBcIkp1blwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkMgOyBcIkp1bFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzUuNjcgOyBcIkF1Z1wiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNjUuNzAgOyBcIlNlcFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEYuNjMuNzQgOyBcIk9jdFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEUuNkYuNzYgOyBcIk5vdlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDQuNjUuNjMgOyBcIkRlY1wiLCBjYXNlLXNlbnNpdGl2ZVxuICB5ZWFyICAgICAgICAgPSA0RElHSVRcblxuICBHTVQgICAgICAgICAgPSAleDQ3LjRELjU0IDsgXCJHTVRcIiwgY2FzZS1zZW5zaXRpdmVcblxuICB0aW1lLW9mLWRheSAgPSBob3VyIFwiOlwiIG1pbnV0ZSBcIjpcIiBzZWNvbmRcbiAgICAgICAgICAgICAgOyAwMDowMDowMCAtIDIzOjU5OjYwIChsZWFwIHNlY29uZClcblxuICBob3VyICAgICAgICAgPSAyRElHSVRcbiAgbWludXRlICAgICAgID0gMkRJR0lUXG4gIHNlY29uZCAgICAgICA9IDJESUdJVFxuICovXG5mdW5jdGlvbiB0b0lNRkRhdGUgKGRhdGUpIHtcbiAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKVxuICB9XG5cbiAgY29uc3QgZGF5cyA9IFtcbiAgICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJyxcbiAgICAnVGh1JywgJ0ZyaScsICdTYXQnXG4gIF1cblxuICBjb25zdCBtb250aHMgPSBbXG4gICAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgICAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXG4gIF1cblxuICBjb25zdCBkYXlOYW1lID0gZGF5c1tkYXRlLmdldFVUQ0RheSgpXVxuICBjb25zdCBkYXkgPSBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcbiAgY29uc3QgbW9udGggPSBtb250aHNbZGF0ZS5nZXRVVENNb250aCgpXVxuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpXG4gIGNvbnN0IGhvdXIgPSBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IG1pbnV0ZSA9IGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICBjb25zdCBzZWNvbmQgPSBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcblxuICByZXR1cm4gYCR7ZGF5TmFtZX0sICR7ZGF5fSAke21vbnRofSAke3llYXJ9ICR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSBHTVRgXG59XG5cbi8qKlxuIG1heC1hZ2UtYXYgICAgICAgID0gXCJNYXgtQWdlPVwiIG5vbi16ZXJvLWRpZ2l0ICpESUdJVFxuICAgICAgICAgICAgICAgICAgICAgICA7IEluIHByYWN0aWNlLCBib3RoIGV4cGlyZXMtYXYgYW5kIG1heC1hZ2UtYXZcbiAgICAgICAgICAgICAgICAgICAgICAgOyBhcmUgbGltaXRlZCB0byBkYXRlcyByZXByZXNlbnRhYmxlIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICA7IHVzZXIgYWdlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QWdlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llTWF4QWdlIChtYXhBZ2UpIHtcbiAgaWYgKG1heEFnZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG1heC1hZ2UnKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjI2NSNzZWN0aW9uLTQuMS4xXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkNvb2tpZX0gY29va2llXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeSAoY29va2llKSB7XG4gIGlmIChjb29raWUubmFtZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFsaWRhdGVDb29raWVOYW1lKGNvb2tpZS5uYW1lKVxuICB2YWxpZGF0ZUNvb2tpZVZhbHVlKGNvb2tpZS52YWx1ZSlcblxuICBjb25zdCBvdXQgPSBbYCR7Y29va2llLm5hbWV9PSR7Y29va2llLnZhbHVlfWBdXG5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4xXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMlxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19TZWN1cmUtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fSG9zdC0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gICAgY29va2llLmRvbWFpbiA9IG51bGxcbiAgICBjb29raWUucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKGNvb2tpZS5zZWN1cmUpIHtcbiAgICBvdXQucHVzaCgnU2VjdXJlJylcbiAgfVxuXG4gIGlmIChjb29raWUuaHR0cE9ubHkpIHtcbiAgICBvdXQucHVzaCgnSHR0cE9ubHknKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb29raWUubWF4QWdlID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlQ29va2llTWF4QWdlKGNvb2tpZS5tYXhBZ2UpXG4gICAgb3V0LnB1c2goYE1heC1BZ2U9JHtjb29raWUubWF4QWdlfWApXG4gIH1cblxuICBpZiAoY29va2llLmRvbWFpbikge1xuICAgIHZhbGlkYXRlQ29va2llRG9tYWluKGNvb2tpZS5kb21haW4pXG4gICAgb3V0LnB1c2goYERvbWFpbj0ke2Nvb2tpZS5kb21haW59YClcbiAgfVxuXG4gIGlmIChjb29raWUucGF0aCkge1xuICAgIHZhbGlkYXRlQ29va2llUGF0aChjb29raWUucGF0aClcbiAgICBvdXQucHVzaChgUGF0aD0ke2Nvb2tpZS5wYXRofWApXG4gIH1cblxuICBpZiAoY29va2llLmV4cGlyZXMgJiYgY29va2llLmV4cGlyZXMudG9TdHJpbmcoKSAhPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICBvdXQucHVzaChgRXhwaXJlcz0ke3RvSU1GRGF0ZShjb29raWUuZXhwaXJlcyl9YClcbiAgfVxuXG4gIGlmIChjb29raWUuc2FtZVNpdGUpIHtcbiAgICBvdXQucHVzaChgU2FtZVNpdGU9JHtjb29raWUuc2FtZVNpdGV9YClcbiAgfVxuXG4gIGZvciAoY29uc3QgcGFydCBvZiBjb29raWUudW5wYXJzZWQpIHtcbiAgICBpZiAoIXBhcnQuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVucGFyc2VkJylcbiAgICB9XG5cbiAgICBjb25zdCBba2V5LCAuLi52YWx1ZV0gPSBwYXJ0LnNwbGl0KCc9JylcblxuICAgIG91dC5wdXNoKGAke2tleS50cmltKCl9PSR7dmFsdWUuam9pbignPScpfWApXG4gIH1cblxuICByZXR1cm4gb3V0LmpvaW4oJzsgJylcbn1cblxubGV0IGtIZWFkZXJzTGlzdE5vZGVcblxuZnVuY3Rpb24gZ2V0SGVhZGVyc0xpc3QgKGhlYWRlcnMpIHtcbiAgaWYgKGhlYWRlcnNba0hlYWRlcnNMaXN0XSkge1xuICAgIHJldHVybiBoZWFkZXJzW2tIZWFkZXJzTGlzdF1cbiAgfVxuXG4gIGlmICgha0hlYWRlcnNMaXN0Tm9kZSkge1xuICAgIGtIZWFkZXJzTGlzdE5vZGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlYWRlcnMpLmZpbmQoXG4gICAgICAoc3ltYm9sKSA9PiBzeW1ib2wuZGVzY3JpcHRpb24gPT09ICdoZWFkZXJzIGxpc3QnXG4gICAgKVxuXG4gICAgYXNzZXJ0KGtIZWFkZXJzTGlzdE5vZGUsICdIZWFkZXJzIGNhbm5vdCBiZSBwYXJzZWQnKVxuICB9XG5cbiAgY29uc3QgaGVhZGVyc0xpc3QgPSBoZWFkZXJzW2tIZWFkZXJzTGlzdE5vZGVdXG4gIGFzc2VydChoZWFkZXJzTGlzdClcblxuICByZXR1cm4gaGVhZGVyc0xpc3Rcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQ1RMRXhjbHVkaW5nSHRhYixcbiAgc3RyaW5naWZ5LFxuICBnZXRIZWFkZXJzTGlzdFxufVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJrSGVhZGVyc0xpc3QiLCJpc0NUTEV4Y2x1ZGluZ0h0YWIiLCJ2YWx1ZSIsImxlbmd0aCIsImNoYXIiLCJjb2RlIiwiY2hhckNvZGVBdCIsInZhbGlkYXRlQ29va2llTmFtZSIsIm5hbWUiLCJFcnJvciIsInZhbGlkYXRlQ29va2llVmFsdWUiLCJ2YWxpZGF0ZUNvb2tpZVBhdGgiLCJwYXRoIiwidmFsaWRhdGVDb29raWVEb21haW4iLCJkb21haW4iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ0b0lNRkRhdGUiLCJkYXRlIiwiRGF0ZSIsImRheXMiLCJtb250aHMiLCJkYXlOYW1lIiwiZ2V0VVRDRGF5IiwiZGF5IiwiZ2V0VVRDRGF0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJtb250aCIsImdldFVUQ01vbnRoIiwieWVhciIsImdldFVUQ0Z1bGxZZWFyIiwiaG91ciIsImdldFVUQ0hvdXJzIiwibWludXRlIiwiZ2V0VVRDTWludXRlcyIsInNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJ2YWxpZGF0ZUNvb2tpZU1heEFnZSIsIm1heEFnZSIsInN0cmluZ2lmeSIsImNvb2tpZSIsIm91dCIsInNlY3VyZSIsInB1c2giLCJodHRwT25seSIsImV4cGlyZXMiLCJzYW1lU2l0ZSIsInBhcnQiLCJ1bnBhcnNlZCIsImluY2x1ZGVzIiwia2V5Iiwic3BsaXQiLCJ0cmltIiwiam9pbiIsImtIZWFkZXJzTGlzdE5vZGUiLCJnZXRIZWFkZXJzTGlzdCIsImhlYWRlcnMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaW5kIiwic3ltYm9sIiwiZGVzY3JpcHRpb24iLCJoZWFkZXJzTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cookies/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst net = __webpack_require__(/*! net */ \"net\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nlet tls // include tls conditionally since it is not always available\n;\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {\n    SessionCache = class WeakSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n            this._sessionRegistry = new global.FinalizationRegistry((key)=>{\n                if (this._sessionCache.size < this._maxCachedSessions) {\n                    return;\n                }\n                const ref = this._sessionCache.get(key);\n                if (ref !== undefined && ref.deref() === undefined) {\n                    this._sessionCache.delete(key);\n                }\n            });\n        }\n        get(sessionKey) {\n            const ref = this._sessionCache.get(sessionKey);\n            return ref ? ref.deref() : null;\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            this._sessionCache.set(sessionKey, new WeakRef(session));\n            this._sessionRegistry.register(session, sessionKey);\n        }\n    };\n} else {\n    SessionCache = class SimpleSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n        }\n        get(sessionKey) {\n            return this._sessionCache.get(sessionKey);\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                // remove the oldest session\n                const { value: oldestKey } = this._sessionCache.keys().next();\n                this._sessionCache.delete(oldestKey);\n            }\n            this._sessionCache.set(sessionKey, session);\n        }\n    };\n}\nfunction buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n    }\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n            if (!tls) {\n                tls = __webpack_require__(/*! tls */ \"tls\");\n            }\n            servername = servername || options.servername || util.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = sessionCache.get(sessionKey) || null;\n            assert(sessionKey);\n            socket = tls.connect({\n                highWaterMark: 16384,\n                ...options,\n                servername,\n                session,\n                localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    \"http/1.1\",\n                    \"h2\"\n                ] : [\n                    \"http/1.1\"\n                ],\n                socket: httpSocket,\n                port: port || 443,\n                host: hostname\n            });\n            socket.on(\"session\", function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n            socket = net.connect({\n                highWaterMark: 64 * 1024,\n                ...options,\n                localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on(\"error\", function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) {\n        return ()=>{};\n    }\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we priotorise socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === \"win32\") {\n                // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n                s2 = setImmediate(()=>onConnectTimeout());\n            } else {\n                onConnectTimeout();\n            }\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction onConnectTimeout(socket) {\n    util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUNwQixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLG9CQUFvQixFQUFFQyxtQkFBbUIsRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUU5RCxJQUFJSyxJQUFJLDZEQUE2RDs7QUFFckUsbURBQW1EO0FBQ25ELHdEQUF3RDtBQUN4RCx1REFBdUQ7QUFDdkQscUJBQXFCO0FBRXJCLElBQUlDO0FBQ0osc0RBQXNEO0FBQ3RELHNFQUFzRTtBQUN0RSxJQUFJQyxPQUFPQyxvQkFBb0IsSUFBSSxDQUFDQyxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQixFQUFFO0lBQ2hFTCxlQUFlLE1BQU1NO1FBQ25CQyxZQUFhQyxpQkFBaUIsQ0FBRTtZQUM5QixJQUFJLENBQUNDLGtCQUFrQixHQUFHRDtZQUMxQixJQUFJLENBQUNFLGFBQWEsR0FBRyxJQUFJQztZQUN6QixJQUFJLENBQUNDLGdCQUFnQixHQUFHLElBQUlYLE9BQU9DLG9CQUFvQixDQUFDLENBQUNXO2dCQUN2RCxJQUFJLElBQUksQ0FBQ0gsYUFBYSxDQUFDSSxJQUFJLEdBQUcsSUFBSSxDQUFDTCxrQkFBa0IsRUFBRTtvQkFDckQ7Z0JBQ0Y7Z0JBRUEsTUFBTU0sTUFBTSxJQUFJLENBQUNMLGFBQWEsQ0FBQ00sR0FBRyxDQUFDSDtnQkFDbkMsSUFBSUUsUUFBUUUsYUFBYUYsSUFBSUcsS0FBSyxPQUFPRCxXQUFXO29CQUNsRCxJQUFJLENBQUNQLGFBQWEsQ0FBQ1MsTUFBTSxDQUFDTjtnQkFDNUI7WUFDRjtRQUNGO1FBRUFHLElBQUtJLFVBQVUsRUFBRTtZQUNmLE1BQU1MLE1BQU0sSUFBSSxDQUFDTCxhQUFhLENBQUNNLEdBQUcsQ0FBQ0k7WUFDbkMsT0FBT0wsTUFB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O1FBQ2ZPLGVBQWVOO0lBQ2pCO0FBQ0Y7QUFFQSxTQUFTTixpQkFBa0JWLE1BQU07SUFDL0JyRCxLQUFLNEUsT0FBTyxDQUFDdkIsUUFBUSxJQUFJbkQ7QUFDM0I7QUFFQTJFLE9BQU9DLE9BQU8sR0FBRzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanM/OWJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0JylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIENvbm5lY3RUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxubGV0IHRscyAvLyBpbmNsdWRlIHRscyBjb25kaXRpb25hbGx5IHNpbmNlIGl0IGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlXG5cbi8vIFRPRE86IHNlc3Npb24gcmUtdXNlIGRvZXMgbm90IHdhaXQgZm9yIHRoZSBmaXJzdFxuLy8gY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBzZXNzaW9uIGFuZCBtaWdodCB0aGVyZWZvcmVcbi8vIHJlc29sdmUgdGhlIHNhbWUgc2VydmVybmFtZSBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW5cbi8vIHJlLXVzZSBpcyBlbmFibGVkLlxuXG5sZXQgU2Vzc2lvbkNhY2hlXG4vLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbmlmIChnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgIXByb2Nlc3MuZW52Lk5PREVfVjhfQ09WRVJBR0UpIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeSA9IG5ldyBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPCB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChrZXkpXG4gICAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkucmVnaXN0ZXIoc2Vzc2lvbiwgc2Vzc2lvbktleSlcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFNpbXBsZVNlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG9sZGVzdEtleSB9ID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmtleXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCd0bHMnKVxuICAgICAgfVxuICAgICAgc2VydmVybmFtZSA9IHNlcnZlcm5hbWUgfHwgb3B0aW9ucy5zZXJ2ZXJuYW1lIHx8IHV0aWwuZ2V0U2VydmVyTmFtZShob3N0KSB8fCBudWxsXG5cbiAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBzZXJ2ZXJuYW1lIHx8IGhvc3RuYW1lXG4gICAgICBjb25zdCBzZXNzaW9uID0gc2Vzc2lvbkNhY2hlLmdldChzZXNzaW9uS2V5KSB8fCBudWxsXG5cbiAgICAgIGFzc2VydChzZXNzaW9uS2V5KVxuXG4gICAgICBzb2NrZXQgPSB0bHMuY29ubmVjdCh7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IDE2Mzg0LCAvLyBUTFMgaW4gbm9kZSBjYW4ndCBoYXZlIGJpZ2dlciBIV00gYW55d2F5Li4uXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNlcnZlcm5hbWUsXG4gICAgICAgIHNlc3Npb24sXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgLy8gVE9ETyhIVFRQLzIpOiBBZGQgc3VwcG9ydCBmb3IgaDJjXG4gICAgICAgIEFMUE5Qcm90b2NvbHM6IGFsbG93SDIgPyBbJ2h0dHAvMS4xJywgJ2gyJ10gOiBbJ2h0dHAvMS4xJ10sXG4gICAgICAgIHNvY2tldDogaHR0cFNvY2tldCwgLy8gdXBncmFkZSBzb2NrZXQgY29ubmVjdGlvblxuICAgICAgICBwb3J0OiBwb3J0IHx8IDQ0MyxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldFxuICAgICAgICAub24oJ3Nlc3Npb24nLCBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IENhbiBhIHNlc3Npb24gYmVjb21lIGludmFsaWQgb25jZSBlc3RhYmxpc2hlZD8gRG9uJ3QgdGhpbmsgc28/XG4gICAgICAgICAgc2Vzc2lvbkNhY2hlLnNldChzZXNzaW9uS2V5LCBzZXNzaW9uKVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoIWh0dHBTb2NrZXQsICdodHRwU29ja2V0IGNhbiBvbmx5IGJlIHNlbnQgb24gVExTIHVwZGF0ZScpXG4gICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdCh7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNCwgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbG9jYWxBZGRyZXNzLFxuICAgICAgICBwb3J0OiBwb3J0IHx8IDgwLFxuICAgICAgICBob3N0OiBob3N0bmFtZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTZXQgVENQIGtlZXAgYWxpdmUgb3B0aW9ucyBvbiB0aGUgc29ja2V0IGhlcmUgaW5zdGVhZCBvZiBpbiBjb25uZWN0KCkgZm9yIHRoZSBjYXNlIG9mIGFzc2lnbmluZyB0aGUgc29ja2V0XG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlID09IG51bGwgfHwgb3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZUluaXRpYWxEZWxheSA9IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5ID09PSB1bmRlZmluZWQgPyA2MGUzIDogb3B0aW9ucy5rZWVwQWxpdmVJbml0aWFsRGVsYXlcbiAgICAgIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwga2VlcEFsaXZlSW5pdGlhbERlbGF5KVxuICAgIH1cblxuICAgIGNvbnN0IGNhbmNlbFRpbWVvdXQgPSBzZXR1cFRpbWVvdXQoKCkgPT4gb25Db25uZWN0VGltZW91dChzb2NrZXQpLCB0aW1lb3V0KVxuXG4gICAgc29ja2V0XG4gICAgICAuc2V0Tm9EZWxheSh0cnVlKVxuICAgICAgLm9uY2UocHJvdG9jb2wgPT09ICdodHRwczonID8gJ3NlY3VyZUNvbm5lY3QnIDogJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihudWxsLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FuY2VsVGltZW91dCgpXG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHJldHVybiBzb2NrZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cFRpbWVvdXQgKG9uQ29ubmVjdFRpbWVvdXQsIHRpbWVvdXQpIHtcbiAgaWYgKCF0aW1lb3V0KSB7XG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cblxuICBsZXQgczEgPSBudWxsXG4gIGxldCBzMiA9IG51bGxcbiAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gc2V0SW1tZWRpYXRlIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHByaW90b3Jpc2Ugc29ja2V0IGVycm9yIGV2ZW50cyBvdmVyIHRpbWVvdXRzXG4gICAgczEgPSBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgLy8gV2luZG93cyBuZWVkcyBhbiBleHRyYSBzZXRJbW1lZGlhdGUgcHJvYmFibHkgZHVlIHRvIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzIGluIHRoZSBzb2NrZXQgbG9naWNcbiAgICAgICAgczIgPSBzZXRJbW1lZGlhdGUoKCkgPT4gb25Db25uZWN0VGltZW91dCgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Db25uZWN0VGltZW91dCgpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgdGltZW91dClcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIGNsZWFySW1tZWRpYXRlKHMxKVxuICAgIGNsZWFySW1tZWRpYXRlKHMyKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29ubmVjdFRpbWVvdXQgKHNvY2tldCkge1xuICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgQ29ubmVjdFRpbWVvdXRFcnJvcigpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yXG4iXSwibmFtZXMiOlsibmV0IiwicmVxdWlyZSIsImFzc2VydCIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkNvbm5lY3RUaW1lb3V0RXJyb3IiLCJ0bHMiLCJTZXNzaW9uQ2FjaGUiLCJnbG9iYWwiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwiV2Vha1Nlc3Npb25DYWNoZSIsImNvbnN0cnVjdG9yIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJfbWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwiTWFwIiwiX3Nlc3Npb25SZWdpc3RyeSIsImtleSIsInNpemUiLCJyZWYiLCJnZXQiLCJ1bmRlZmluZWQiLCJkZXJlZiIsImRlbGV0ZSIsInNlc3Npb25LZXkiLCJzZXQiLCJzZXNzaW9uIiwiV2Vha1JlZiIsInJlZ2lzdGVyIiwiU2ltcGxlU2Vzc2lvbkNhY2hlIiwidmFsdWUiLCJvbGRlc3RLZXkiLCJrZXlzIiwibmV4dCIsImJ1aWxkQ29ubmVjdG9yIiwiYWxsb3dIMiIsInNvY2tldFBhdGgiLCJ0aW1lb3V0Iiwib3B0cyIsIk51bWJlciIsImlzSW50ZWdlciIsIm9wdGlvbnMiLCJwYXRoIiwic2Vzc2lvbkNhY2hlIiwiY29ubmVjdCIsImhvc3RuYW1lIiwiaG9zdCIsInByb3RvY29sIiwicG9ydCIsInNlcnZlcm5hbWUiLCJsb2NhbEFkZHJlc3MiLCJodHRwU29ja2V0IiwiY2FsbGJhY2siLCJzb2NrZXQiLCJnZXRTZXJ2ZXJOYW1lIiwiaGlnaFdhdGVyTWFyayIsIkFMUE5Qcm90b2NvbHMiLCJvbiIsImtlZXBBbGl2ZSIsImtlZXBBbGl2ZUluaXRpYWxEZWxheSIsInNldEtlZXBBbGl2ZSIsImNhbmNlbFRpbWVvdXQiLCJzZXR1cFRpbWVvdXQiLCJvbkNvbm5lY3RUaW1lb3V0Iiwic2V0Tm9EZWxheSIsIm9uY2UiLCJjYiIsImVyciIsInMxIiwiczIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0Iiwic2V0SW1tZWRpYXRlIiwicGxhdGZvcm0iLCJjbGVhclRpbWVvdXQiLCJjbGVhckltbWVkaWF0ZSIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass UndiciError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n    }\n}\nclass ConnectTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n    }\n}\nclass HeadersTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n    }\n}\nclass HeadersOverflowError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n    }\n}\nclass BodyTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n    }\n}\nclass ResponseStatusCodeError extends UndiciError {\n    constructor(message, statusCode, headers, body){\n        super(message);\n        Error.captureStackTrace(this, ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n    }\n}\nclass InvalidArgumentError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n    }\n}\nclass InvalidReturnValueError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n    }\n}\nclass RequestAbortedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n    }\n}\nclass InformationalError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n    }\n}\nclass RequestContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ResponseContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ClientDestroyedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n    }\n}\nclass ClientClosedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n    }\n}\nclass SocketError extends UndiciError {\n    constructor(message, socket){\n        super(message);\n        Error.captureStackTrace(this, SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n    }\n}\nclass NotSupportedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n    }\n}\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n    }\n}\nclass HTTPParserError extends Error {\n    constructor(message, code, data){\n        super(message);\n        Error.captureStackTrace(this, HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : undefined;\n        this.data = data ? data.toString() : undefined;\n    }\n}\nclass ResponseExceededMaxSizeError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, ResponseExceededMaxSizeError);\n        this.name = \"ResponseExceededMaxSizeError\";\n        this.message = message || \"Response content exceeded max size\";\n        this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n    }\n}\nmodule.exports = {\n    HTTPParserError,\n    UndiciError,\n    HeadersTimeoutError,\n    HeadersOverflowError,\n    BodyTimeoutError,\n    RequestContentLengthMismatchError,\n    ConnectTimeoutError,\n    ResponseStatusCodeError,\n    InvalidArgumentError,\n    InvalidReturnValueError,\n    RequestAbortedError,\n    ClientDestroyedError,\n    ClientClosedError,\n    InformationalError,\n    SocketError,\n    NotSupportedError,\n    ResponseContentLengthMismatchError,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLG9CQUFvQkM7SUFDeEJDLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNQyw0QkFBNEJOO0lBQ2hDRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVEO1FBQzlCLElBQUksQ0FBQ0YsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUcsNEJBQTRCUjtJQUNoQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFQztRQUM5QixJQUFJLENBQUNKLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1JLDZCQUE2QlQ7SUFDakNFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05GLE1BQU1NLGlCQUFpQixDQUFDLElBQUksRUFBRUU7UUFDOUIsSUFBSSxDQUFDTCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNSyx5QkFBeUJWO0lBQzdCRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNORixNQUFNTSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUVHO1FBQzlCLElBQUksQ0FBQ04sSUFBSSxHQUFHO1FB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QUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHQSxPQUFPLENBQUMsSUFBSSxFQUFFQSxLQUFLLENBQUMsR0FBR3lCO1FBQ25DLElBQUksQ0FBQ0QsSUFBSSxHQUFHQSxPQUFPQSxLQUFLRSxRQUFRLEtBQUtEO0lBQ3ZDO0FBQ0Y7QUFFQSxNQUFNRSxxQ0FBcUNoQztJQUN6Q0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkYsTUFBTU0saUJBQWlCLENBQUMsSUFBSSxFQUFFeUI7UUFDOUIsSUFBSSxDQUFDNUIsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUE0QixPQUFPQyxPQUFPLEdBQUc7SUFDZk47SUFDQTVCO0lBQ0FRO0lBQ0FDO0lBQ0FDO0lBQ0FVO0lBQ0FkO0lBQ0FLO0lBQ0FLO0lBQ0FDO0lBQ0FDO0lBQ0FJO0lBQ0FDO0lBQ0FKO0lBQ0FLO0lBQ0FFO0lBQ0FMO0lBQ0FNO0lBQ0FLO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvZXJyb3JzLmpzPzAzOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFVuZGljaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1VuZGljaUVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSJ1xuICB9XG59XG5cbmNsYXNzIENvbm5lY3RUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDb25uZWN0VGltZW91dEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhlYWRlcnNUaW1lb3V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0hlYWRlcnNUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBIZWFkZXJzT3ZlcmZsb3dFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhlYWRlcnNPdmVyZmxvd0Vycm9yKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzT3ZlcmZsb3dFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdIZWFkZXJzIE92ZXJmbG93IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1cnXG4gIH1cbn1cblxuY2xhc3MgQm9keVRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEJvZHlUaW1lb3V0RXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0JvZHlUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnQm9keSBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JPRFlfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZVN0YXR1c0NvZGVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBTdGF0dXMgQ29kZSBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNQT05TRV9TVEFUVVNfQ09ERSdcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRBcmd1bWVudEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQXJndW1lbnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdJbnZhbGlkIEFyZ3VtZW50IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lOVkFMSURfQVJHJ1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFJldHVyblZhbHVlRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRSZXR1cm5WYWx1ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgUmV0dXJuIFZhbHVlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJ1xuICB9XG59XG5cbmNsYXNzIFJlcXVlc3RBYm9ydGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0QWJvcnRlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgYWJvcnRlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9BQk9SVEVEJ1xuICB9XG59XG5cbmNsYXNzIEluZm9ybWF0aW9uYWxFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEluZm9ybWF0aW9uYWxFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSW5mb3JtYXRpb25hbEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgaW5mb3JtYXRpb24nXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5GTydcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxufVxuXG5jbGFzcyBDbGllbnREZXN0cm95ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENsaWVudERlc3Ryb3llZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdDbGllbnREZXN0cm95ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgY2xpZW50IGlzIGRlc3Ryb3llZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9ERVNUUk9ZRUQnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50Q2xvc2VkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDbGllbnRDbG9zZWRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50Q2xvc2VkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBjbG9zZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQ0xPU0VEJ1xuICB9XG59XG5cbmNsYXNzIFNvY2tldEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc29ja2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTb2NrZXRFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnU29ja2V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnU29ja2V0IGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1NPQ0tFVCdcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICB9XG59XG5cbmNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vdCBzdXBwb3J0ZWQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfTk9UX1NVUFBPUlRFRCdcbiAgfVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFN1cHBvcnRlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nVXBzdHJlYW1FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdObyB1cHN0cmVhbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQmFsYW5jZWRQb29sJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JQTF9NSVNTSU5HX1VQU1RSRUFNJ1xuICB9XG59XG5cbmNsYXNzIEhUVFBQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEhUVFBQYXJzZXJFcnJvcilcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGNvbnRlbnQgZXhjZWVkZWQgbWF4IHNpemUnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTX0VYQ0VFREVEX01BWF9TSVpFJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFVuZGljaUVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBDb25uZWN0VGltZW91dEVycm9yLFxuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvclxufVxuIl0sIm5hbWVzIjpbIlVuZGljaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkNvbm5lY3RUaW1lb3V0RXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIkJvZHlUaW1lb3V0RXJyb3IiLCJSZXNwb25zZVN0YXR1c0NvZGVFcnJvciIsInN0YXR1c0NvZGUiLCJoZWFkZXJzIiwiYm9keSIsInN0YXR1cyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW52YWxpZFJldHVyblZhbHVlRXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciIsIkNsaWVudERlc3Ryb3llZEVycm9yIiwiQ2xpZW50Q2xvc2VkRXJyb3IiLCJTb2NrZXRFcnJvciIsInNvY2tldCIsIk5vdFN1cHBvcnRlZEVycm9yIiwiQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IiLCJIVFRQUGFyc2VyRXJyb3IiLCJkYXRhIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { InvalidArgumentError, NotSupportedError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\n// tokenRegExp and headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */ const tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */ const headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol(\"handler\");\nconst channels = {};\nlet extractBody;\ntry {\n    const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\n    channels.create = diagnosticsChannel.channel(\"undici:request:create\");\n    channels.bodySent = diagnosticsChannel.channel(\"undici:request:bodySent\");\n    channels.headers = diagnosticsChannel.channel(\"undici:request:headers\");\n    channels.trailers = diagnosticsChannel.channel(\"undici:request:trailers\");\n    channels.error = diagnosticsChannel.channel(\"undici:request:error\");\n} catch  {\n    channels.create = {\n        hasSubscribers: false\n    };\n    channels.bodySent = {\n        hasSubscribers: false\n    };\n    channels.headers = {\n        hasSubscribers: false\n    };\n    channels.trailers = {\n        hasSubscribers: false\n    };\n    channels.error = {\n        hasSubscribers: false\n    };\n}\nclass Request {\n    constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler){\n        if (typeof path !== \"string\") {\n            throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path[0] !== \"/\" && !(path.startsWith(\"http://\") || path.startsWith(\"https://\")) && method !== \"CONNECT\") {\n            throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.exec(path) !== null) {\n            throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n            throw new InvalidArgumentError(\"method must be a string\");\n        } else if (tokenRegExp.exec(method) === null) {\n            throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n            throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        if (reset != null && typeof reset !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid reset\");\n        }\n        if (expectContinue != null && typeof expectContinue !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid expectContinue\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        if (body == null) {\n            this.body = null;\n        } else if (util.isStream(body)) {\n            this.body = body;\n        } else if (util.isBuffer(body)) {\n            this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n            this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n            this.body = body.length ? Buffer.from(body) : null;\n        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {\n            this.body = body;\n        } else {\n            throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query ? util.buildURL(path, query) : path;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.reset = reset == null ? null : reset;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = \"\";\n        // Only for H2\n        this.expectContinue = expectContinue != null ? expectContinue : false;\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(this, headers[i], headers[i + 1]);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(this, key, headers[key]);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        if (util.isFormDataLike(this.body)) {\n            if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {\n                throw new InvalidArgumentError(\"Form-Data bodies are only supported in node v16.8 and newer.\");\n            }\n            if (!extractBody) {\n                extractBody = (__webpack_require__(/*! ../fetch/body.js */ \"(rsc)/./node_modules/undici/lib/fetch/body.js\").extractBody);\n            }\n            const [bodyStream, contentType] = extractBody(body);\n            if (this.contentType == null) {\n                this.contentType = contentType;\n                this.headers += `content-type: ${contentType}\\r\\n`;\n            }\n            this.body = bodyStream.stream;\n            this.contentLength = bodyStream.length;\n        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {\n            this.contentType = body.type;\n            this.headers += `content-type: ${body.type}\\r\\n`;\n        }\n        util.validateHandler(handler, method, upgrade);\n        this.servername = util.getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n            channels.create.publish({\n                request: this\n            });\n        }\n    }\n    onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n            try {\n                this[kHandler].onBodySent(chunk);\n            } catch (err) {\n                this.onError(err);\n            }\n        }\n    }\n    onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n            channels.bodySent.publish({\n                request: this\n            });\n        }\n    }\n    onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onConnect(abort);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n            channels.headers.publish({\n                request: this,\n                response: {\n                    statusCode,\n                    headers,\n                    statusText\n                }\n            });\n        }\n        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n    }\n    onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onData(chunk);\n    }\n    onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n    }\n    onComplete(trailers) {\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n            channels.trailers.publish({\n                request: this,\n                trailers\n            });\n        }\n        return this[kHandler].onComplete(trailers);\n    }\n    onError(error) {\n        if (channels.error.hasSubscribers) {\n            channels.error.publish({\n                request: this,\n                error\n            });\n        }\n        if (this.aborted) {\n            return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error);\n    }\n    // TODO: adjust to support H2\n    addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n    }\n    static [kHTTP1BuildRequest](origin, opts, handler) {\n        // TODO: Migrate header parsing here, to make Requests\n        // HTTP agnostic\n        return new Request(origin, opts, handler);\n    }\n    static [kHTTP2BuildRequest](origin, opts, handler) {\n        const headers = opts.headers;\n        opts = {\n            ...opts,\n            headers: null\n        };\n        const request = new Request(origin, opts, handler);\n        request.headers = {};\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(request, headers[i], headers[i + 1], true);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            const keys = Object.keys(headers);\n            for(let i = 0; i < keys.length; i++){\n                const key = keys[i];\n                processHeader(request, key, headers[key], true);\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        return request;\n    }\n    static [kHTTP2CopyHeaders](raw) {\n        const rawHeaders = raw.split(\"\\r\\n\");\n        const headers = {};\n        for (const header of rawHeaders){\n            const [key, value] = header.split(\": \");\n            if (value == null || value.length === 0) continue;\n            if (headers[key]) headers[key] += `,${value}`;\n            else headers[key] = value;\n        }\n        return headers;\n    }\n}\nfunction processHeaderValue(key, val, skipAppend) {\n    if (val && typeof val === \"object\") {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    val = val != null ? `${val}` : \"\";\n    if (headerCharRegex.exec(val) !== null) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    }\n    return skipAppend ? val : `${key}: ${val}\\r\\n`;\n}\nfunction processHeader(request, key, val, skipAppend = false) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    } else if (val === undefined) {\n        return;\n    }\n    if (request.host === null && key.length === 4 && key.toLowerCase() === \"host\") {\n        if (headerCharRegex.exec(val) !== null) {\n            throw new InvalidArgumentError(`invalid ${key} header`);\n        }\n        // Consumed by Client\n        request.host = val;\n    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === \"content-length\") {\n        request.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request.contentLength)) {\n            throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === \"content-type\") {\n        request.contentType = val;\n        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n        else request.headers += processHeaderValue(key, val);\n    } else if (key.length === 17 && key.toLowerCase() === \"transfer-encoding\") {\n        throw new InvalidArgumentError(\"invalid transfer-encoding header\");\n    } else if (key.length === 10 && key.toLowerCase() === \"connection\") {\n        const value = typeof val === \"string\" ? val.toLowerCase() : null;\n        if (value !== \"close\" && value !== \"keep-alive\") {\n            throw new InvalidArgumentError(\"invalid connection header\");\n        } else if (value === \"close\") {\n            request.reset = true;\n        }\n    } else if (key.length === 10 && key.toLowerCase() === \"keep-alive\") {\n        throw new InvalidArgumentError(\"invalid keep-alive header\");\n    } else if (key.length === 7 && key.toLowerCase() === \"upgrade\") {\n        throw new InvalidArgumentError(\"invalid upgrade header\");\n    } else if (key.length === 6 && key.toLowerCase() === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n    } else if (tokenRegExp.exec(key) === null) {\n        throw new InvalidArgumentError(\"invalid header key\");\n    } else {\n        if (Array.isArray(val)) {\n            for(let i = 0; i < val.length; i++){\n                if (skipAppend) {\n                    if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;\n                    else request.headers[key] = processHeaderValue(key, val[i], skipAppend);\n                } else {\n                    request.headers += processHeaderValue(key, val[i]);\n                }\n            }\n        } else {\n            if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);\n            else request.headers += processHeaderValue(key, val);\n        }\n    }\n}\nmodule.exports = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLG9CQUFvQixFQUNwQkMsaUJBQWlCLEVBQ2xCLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFRSxrQkFBa0IsRUFBRUMsaUJBQWlCLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzlFLE1BQU1LLE9BQU9MLG1CQUFPQSxDQUFDO0FBRXJCLHdEQUF3RDtBQUN4RCwrREFBK0Q7QUFFL0Q7Ozs7Q0FJQyxHQUNELE1BQU1NLGNBQWM7QUFFcEI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEIsa0ZBQWtGO0FBQ2xGLE1BQU1DLG1CQUFtQjtBQUV6QixNQUFNQyxXQUFXQyxPQUFPO0FBRXhCLE1BQU1DLFdBQVcsQ0FBQztBQUVsQixJQUFJQztBQUVKLElBQUk7SUFDRixNQUFNQyxxQkFBcUJiLG1CQUFPQSxDQUFDO0lBQ25DVyxTQUFTRyxNQUFNLEdBQUdELG1CQUFtQkUsT0FBTyxDQUFDO0lBQzdDSixTQUFTSyxRQUFRLEdBQUdILG1CQUFtQkUsT0FBTyxDQUFDO0lBQy9DSixTQUFTTSxPQUFPLEdBQUdKLG1CQUFtQkUsT0FBTyxDQUFDO0lBQzlDSixTQUFTTyxRQUFRLEdBQUdMLG1CQUFtQkUsT0FBTyxDQUFDO0lBQy9DSixTQUFTUSxLQUFLLEdBQUdOLG1CQUFtQkUsT0FBTyxDQUFDO0FBQzlDLEVBQUUsT0FBTTtJQUNOSixTQUFTRyxNQUFNLEdBQUc7UUFBRU0sZ0JBQWdCO0lBQU07SUFDMUNULFNBQVNLLFFBQVEsR0FBRztRQUFFSSxnQkFBZ0I7SUFBTTtJQUM1Q1QsU0FBU00sT0FBTyxHQUFHO1FBQUVHLGdCQUFnQjtJQUFNO0lBQzNDVCxTQUFTTyxRQUFRLEdBQUc7UUFBRUUsZ0JBQWdCO0lBQU07SUFDNUNULFNBQVNR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QUM5RjFCLFFBQVEzRCxPQUFPLENBQUNpRCxJQUFJLEdBQUdrQyxtQkFBbUJsQyxLQUFLbUMsR0FBRyxDQUFDdkMsRUFBRSxFQUFFd0M7Z0JBQzlELE9BQU87b0JBQ0wxQixRQUFRM0QsT0FBTyxJQUFJbUYsbUJBQW1CbEMsS0FBS21DLEdBQUcsQ0FBQ3ZDLEVBQUU7Z0JBQ25EO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSXdDLFlBQVkxQixRQUFRM0QsT0FBTyxDQUFDaUQsSUFBSSxHQUFHa0MsbUJBQW1CbEMsS0FBS21DLEtBQUtDO2lCQUMvRDFCLFFBQVEzRCxPQUFPLElBQUltRixtQkFBbUJsQyxLQUFLbUM7UUFDbEQ7SUFDRjtBQUNGO0FBRUFLLE9BQU9DLE9BQU8sR0FBR3RGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanM/MzhhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBrSFRUUDJCdWlsZFJlcXVlc3QsIGtIVFRQMkNvcHlIZWFkZXJzLCBrSFRUUDFCdWlsZFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcblxuLy8gdG9rZW5SZWdFeHAgYW5kIGhlYWRlckNoYXJSZWdleCBoYXZlIGJlZW4gbGlmdGVkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL19odHRwX2NvbW1vbi5qc1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGdpdmVuIHZhbCBpcyBhIHZhbGlkIEhUVFAgdG9rZW5cbiAqIHBlciB0aGUgcnVsZXMgZGVmaW5lZCBpbiBSRkMgNzIzMFxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqL1xuY29uc3QgdG9rZW5SZWdFeHAgPSAvXltcXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XSskL1xuXG4vKipcbiAqIE1hdGNoZXMgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKi9cbmNvbnN0IGhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdL1xuXG4vLyBWZXJpZmllcyB0aGF0IGEgZ2l2ZW4gcGF0aCBpcyB2YWxpZCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgY2hhcnMgXFx4MDAgdG8gXFx4MjBcbmNvbnN0IGludmFsaWRQYXRoUmVnZXggPSAvW15cXHUwMDIxLVxcdTAwZmZdL1xuXG5jb25zdCBrSGFuZGxlciA9IFN5bWJvbCgnaGFuZGxlcicpXG5cbmNvbnN0IGNoYW5uZWxzID0ge31cblxubGV0IGV4dHJhY3RCb2R5XG5cbnRyeSB7XG4gIGNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuICBjaGFubmVscy5jcmVhdGUgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJylcbiAgY2hhbm5lbHMuYm9keVNlbnQgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKVxuICBjaGFubmVscy5oZWFkZXJzID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKVxuICBjaGFubmVscy50cmFpbGVycyA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpXG4gIGNoYW5uZWxzLmVycm9yID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJylcbn0gY2F0Y2gge1xuICBjaGFubmVscy5jcmVhdGUgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG4gIGNoYW5uZWxzLmJvZHlTZW50ID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy5oZWFkZXJzID0geyBoYXNTdWJzY3JpYmVyczogZmFsc2UgfVxuICBjaGFubmVscy50cmFpbGVycyA9IHsgaGFzU3Vic2NyaWJlcnM6IGZhbHNlIH1cbiAgY2hhbm5lbHMuZXJyb3IgPSB7IGhhc1N1YnNjcmliZXJzOiBmYWxzZSB9XG59XG5cbmNsYXNzIFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgcGF0aCxcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBoZWFkZXJzLFxuICAgIHF1ZXJ5LFxuICAgIGlkZW1wb3RlbnQsXG4gICAgYmxvY2tpbmcsXG4gICAgdXBncmFkZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICByZXNldCxcbiAgICB0aHJvd09uRXJyb3IsXG4gICAgZXhwZWN0Q29udGludWVcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXguZXhlYyhwYXRoKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKHRva2VuUmVnRXhwLmV4ZWMobWV0aG9kKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXRcblxuICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dFxuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWVcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IHV0aWwuaXNJdGVyYWJsZShib2R5KSB8fCB1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBxdWVyeSA/IHV0aWwuYnVpbGRVUkwocGF0aCwgcXVlcnkpIDogcGF0aFxuXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSAnJ1xuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKHRoaXMuYm9keSkpIHtcbiAgICAgIGlmICh1dGlsLm5vZGVNYWpvciA8IDE2IHx8ICh1dGlsLm5vZGVNYWpvciA9PT0gMTYgJiYgdXRpbC5ub2RlTWlub3IgPCA4KSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0Zvcm0tRGF0YSBib2RpZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIG5vZGUgdjE2LjggYW5kIG5ld2VyLicpXG4gICAgICB9XG5cbiAgICAgIGlmICghZXh0cmFjdEJvZHkpIHtcbiAgICAgICAgZXh0cmFjdEJvZHkgPSByZXF1aXJlKCcuLi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBpZiAodGhpcy5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuICAgICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtjb250ZW50VHlwZX1cXHJcXG5gXG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbVxuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSAmJiB0aGlzLmNvbnRlbnRUeXBlID09IG51bGwgJiYgYm9keS50eXBlKSB7XG4gICAgICB0aGlzLmNvbnRlbnRUeXBlID0gYm9keS50eXBlXG4gICAgICB0aGlzLmhlYWRlcnMgKz0gYGNvbnRlbnQtdHlwZTogJHtib2R5LnR5cGV9XFxyXFxuYFxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSlcblxuICAgIHRoaXMuc2VydmVybmFtZSA9IHV0aWwuZ2V0U2VydmVyTmFtZSh0aGlzLmhvc3QpXG5cbiAgICB0aGlzW2tIYW5kbGVyXSA9IGhhbmRsZXJcblxuICAgIGlmIChjaGFubmVscy5jcmVhdGUuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNyZWF0ZS5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAoY2hhbm5lbHMuYm9keVNlbnQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db25uZWN0KGFib3J0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKGNoYW5uZWxzLmhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH1cblxuICBvbkVycm9yIChlcnJvcikge1xuICAgIGlmIChjaGFubmVscy5lcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuZXJyb3IucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIGVycm9yIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIC8vIFRPRE86IGFkanVzdCB0byBzdXBwb3J0IEgyXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIFtrSFRUUDFCdWlsZFJlcXVlc3RdIChvcmlnaW4sIG9wdHMsIGhhbmRsZXIpIHtcbiAgICAvLyBUT0RPOiBNaWdyYXRlIGhlYWRlciBwYXJzaW5nIGhlcmUsIHRvIG1ha2UgUmVxdWVzdHNcbiAgICAvLyBIVFRQIGFnbm9zdGljXG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIHN0YXRpYyBba0hUVFAyQnVpbGRSZXF1ZXN0XSAob3JpZ2luLCBvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdHMuaGVhZGVyc1xuICAgIG9wdHMgPSB7IC4uLm9wdHMsIGhlYWRlcnM6IG51bGwgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcblxuICAgIHJlcXVlc3QuaGVhZGVycyA9IHt9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuJylcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHJlcXVlc3QsIGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdLCB0cnVlKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgcHJvY2Vzc0hlYWRlcihyZXF1ZXN0LCBrZXksIGhlYWRlcnNba2V5XSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICB9XG5cbiAgc3RhdGljIFtrSFRUUDJDb3B5SGVhZGVyc10gKHJhdykge1xuICAgIGNvbnN0IHJhd0hlYWRlcnMgPSByYXcuc3BsaXQoJ1xcclxcbicpXG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiByYXdIZWFkZXJzKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBoZWFkZXIuc3BsaXQoJzogJylcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSBjb250aW51ZVxuXG4gICAgICBpZiAoaGVhZGVyc1trZXldKSBoZWFkZXJzW2tleV0gKz0gYCwke3ZhbHVlfWBcbiAgICAgIGVsc2UgaGVhZGVyc1trZXldID0gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXJWYWx1ZSAoa2V5LCB2YWwsIHNraXBBcHBlbmQpIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfVxuXG4gIHZhbCA9IHZhbCAhPSBudWxsID8gYCR7dmFsfWAgOiAnJ1xuXG4gIGlmIChoZWFkZXJDaGFyUmVnZXguZXhlYyh2YWwpICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9XG5cbiAgcmV0dXJuIHNraXBBcHBlbmQgPyB2YWwgOiBgJHtrZXl9OiAke3ZhbH1cXHJcXG5gXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsLCBza2lwQXBwZW5kID0gZmFsc2UpIHtcbiAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gIH0gZWxzZSBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChcbiAgICByZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSA0ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdob3N0J1xuICApIHtcbiAgICBpZiAoaGVhZGVyQ2hhclJlZ2V4LmV4ZWModmFsKSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChcbiAgICByZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxNCAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnXG4gICkge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiZcbiAgICBrZXkubGVuZ3RoID09PSAxMiAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJ1xuICApIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgIGVsc2UgcmVxdWVzdC5oZWFkZXJzICs9IHByb2Nlc3NIZWFkZXJWYWx1ZShrZXksIHZhbClcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSAxNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndHJhbnNmZXItZW5jb2RpbmcnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXInKVxuICB9IGVsc2UgaWYgKFxuICAgIGtleS5sZW5ndGggPT09IDEwICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb25uZWN0aW9uJ1xuICApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgcmVxdWVzdC5yZXNldCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gMTAgJiZcbiAgICBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBrZWVwLWFsaXZlIGhlYWRlcicpXG4gIH0gZWxzZSBpZiAoXG4gICAga2V5Lmxlbmd0aCA9PT0gNyAmJlxuICAgIGtleS50b0xvd2VyQ2FzZSgpID09PSAndXBncmFkZSdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVwZ3JhZGUgaGVhZGVyJylcbiAgfSBlbHNlIGlmIChcbiAgICBrZXkubGVuZ3RoID09PSA2ICYmXG4gICAga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdleHBlY3QnXG4gICkge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIGlmICh0b2tlblJlZ0V4cC5leGVjKGtleSkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNraXBBcHBlbmQpIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzW2tleV0pIHJlcXVlc3QuaGVhZGVyc1trZXldICs9IGAsJHtwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0sIHNraXBBcHBlbmQpfWBcbiAgICAgICAgICBlbHNlIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsW2ldLCBza2lwQXBwZW5kKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBwcm9jZXNzSGVhZGVyVmFsdWUoa2V5LCB2YWxbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNraXBBcHBlbmQpIHJlcXVlc3QuaGVhZGVyc1trZXldID0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsLCBza2lwQXBwZW5kKVxuICAgICAgZWxzZSByZXF1ZXN0LmhlYWRlcnMgKz0gcHJvY2Vzc0hlYWRlclZhbHVlKGtleSwgdmFsKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk5vdFN1cHBvcnRlZEVycm9yIiwicmVxdWlyZSIsImFzc2VydCIsImtIVFRQMkJ1aWxkUmVxdWVzdCIsImtIVFRQMkNvcHlIZWFkZXJzIiwia0hUVFAxQnVpbGRSZXF1ZXN0IiwidXRpbCIsInRva2VuUmVnRXhwIiwiaGVhZGVyQ2hhclJlZ2V4IiwiaW52YWxpZFBhdGhSZWdleCIsImtIYW5kbGVyIiwiU3ltYm9sIiwiY2hhbm5lbHMiLCJleHRyYWN0Qm9keSIsImRpYWdub3N0aWNzQ2hhbm5lbCIsImNyZWF0ZSIsImNoYW5uZWwiLCJib2R5U2VudCIsImhlYWRlcnMiLCJ0cmFpbGVycyIsImVycm9yIiwiaGFzU3Vic2NyaWJlcnMiLCJSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJwYXRoIiwibWV0aG9kIiwiYm9keSIsInF1ZXJ5IiwiaWRlbXBvdGVudCIsImJsb2NraW5nIiwidXBncmFkZSIsImhlYWRlcnNUaW1lb3V0IiwiYm9keVRpbWVvdXQiLCJyZXNldCIsInRocm93T25FcnJvciIsImV4cGVjdENvbnRpbnVlIiwiaGFuZGxlciIsInN0YXJ0c1dpdGgiLCJleGVjIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc1N0cmVhbSIsImlzQnVmZmVyIiwiYnl0ZUxlbmd0aCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJpc0Zvcm1EYXRhTGlrZSIsImlzSXRlcmFibGUiLCJpc0Jsb2JMaWtlIiwiY29tcGxldGVkIiwiYWJvcnRlZCIsImJ1aWxkVVJMIiwiaG9zdCIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJwcm9jZXNzSGVhZGVyIiwia2V5cyIsIk9iamVjdCIsImtleSIsIm5vZGVNYWpvciIsIm5vZGVNaW5vciIsImJvZHlTdHJlYW0iLCJzdHJlYW0iLCJ0eXBlIiwidmFsaWRhdGVIYW5kbGVyIiwic2VydmVybmFtZSIsImdldFNlcnZlck5hbWUiLCJwdWJsaXNoIiwicmVxdWVzdCIsIm9uQm9keVNlbnQiLCJjaHVuayIsImVyciIsIm9uRXJyb3IiLCJvblJlcXVlc3RTZW50Iiwib25Db25uZWN0IiwiYWJvcnQiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmVzdW1lIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlIiwib25EYXRhIiwib25VcGdyYWRlIiwic29ja2V0Iiwib25Db21wbGV0ZSIsImFkZEhlYWRlciIsInZhbHVlIiwib3B0cyIsInJhdyIsInJhd0hlYWRlcnMiLCJzcGxpdCIsImhlYWRlciIsInByb2Nlc3NIZWFkZXJWYWx1ZSIsInZhbCIsInNraXBBcHBlbmQiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlSW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("module.exports = {\n    kClose: Symbol(\"close\"),\n    kDestroy: Symbol(\"destroy\"),\n    kDispatch: Symbol(\"dispatch\"),\n    kUrl: Symbol(\"url\"),\n    kWriting: Symbol(\"writing\"),\n    kResuming: Symbol(\"resuming\"),\n    kQueue: Symbol(\"queue\"),\n    kConnect: Symbol(\"connect\"),\n    kConnecting: Symbol(\"connecting\"),\n    kHeadersList: Symbol(\"headers list\"),\n    kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n    kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n    kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n    kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n    kKeepAlive: Symbol(\"keep alive\"),\n    kHeadersTimeout: Symbol(\"headers timeout\"),\n    kBodyTimeout: Symbol(\"body timeout\"),\n    kServerName: Symbol(\"server name\"),\n    kLocalAddress: Symbol(\"local address\"),\n    kHost: Symbol(\"host\"),\n    kNoRef: Symbol(\"no ref\"),\n    kBodyUsed: Symbol(\"used\"),\n    kRunning: Symbol(\"running\"),\n    kBlocking: Symbol(\"blocking\"),\n    kPending: Symbol(\"pending\"),\n    kSize: Symbol(\"size\"),\n    kBusy: Symbol(\"busy\"),\n    kQueued: Symbol(\"queued\"),\n    kFree: Symbol(\"free\"),\n    kConnected: Symbol(\"connected\"),\n    kClosed: Symbol(\"closed\"),\n    kNeedDrain: Symbol(\"need drain\"),\n    kReset: Symbol(\"reset\"),\n    kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n    kMaxHeadersSize: Symbol(\"max headers size\"),\n    kRunningIdx: Symbol(\"running index\"),\n    kPendingIdx: Symbol(\"pending index\"),\n    kError: Symbol(\"error\"),\n    kClients: Symbol(\"clients\"),\n    kClient: Symbol(\"client\"),\n    kParser: Symbol(\"parser\"),\n    kOnDestroyed: Symbol(\"destroy callbacks\"),\n    kPipelining: Symbol(\"pipelining\"),\n    kSocket: Symbol(\"socket\"),\n    kHostHeader: Symbol(\"host header\"),\n    kConnector: Symbol(\"connector\"),\n    kStrictContentLength: Symbol(\"strict content length\"),\n    kMaxRedirections: Symbol(\"maxRedirections\"),\n    kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n    kProxy: Symbol(\"proxy agent options\"),\n    kCounter: Symbol(\"socket request counter\"),\n    kInterceptors: Symbol(\"dispatch interceptors\"),\n    kMaxResponseSize: Symbol(\"max response size\"),\n    kHTTP2Session: Symbol(\"http2Session\"),\n    kHTTP2SessionState: Symbol(\"http2Session state\"),\n    kHTTP2BuildRequest: Symbol(\"http2 build request\"),\n    kHTTP1BuildRequest: Symbol(\"http1 build request\"),\n    kHTTP2CopyHeaders: Symbol(\"http2 copy headers\"),\n    kHTTPConnVersion: Symbol(\"http connection version\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qcz9lNTdlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga0Rlc3Ryb3k6IFN5bWJvbCgnZGVzdHJveScpLFxuICBrRGlzcGF0Y2g6IFN5bWJvbCgnZGlzcGF0Y2gnKSxcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga1dyaXRpbmc6IFN5bWJvbCgnd3JpdGluZycpLFxuICBrUmVzdW1pbmc6IFN5bWJvbCgncmVzdW1pbmcnKSxcbiAga1F1ZXVlOiBTeW1ib2woJ3F1ZXVlJyksXG4gIGtDb25uZWN0OiBTeW1ib2woJ2Nvbm5lY3QnKSxcbiAga0Nvbm5lY3Rpbmc6IFN5bWJvbCgnY29ubmVjdGluZycpLFxuICBrSGVhZGVyc0xpc3Q6IFN5bWJvbCgnaGVhZGVycyBsaXN0JyksXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKCdkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKCdtYXgga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZTogU3ltYm9sKCdrZWVwIGFsaXZlJyksXG4gIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKCdoZWFkZXJzIHRpbWVvdXQnKSxcbiAga0JvZHlUaW1lb3V0OiBTeW1ib2woJ2JvZHkgdGltZW91dCcpLFxuICBrU2VydmVyTmFtZTogU3ltYm9sKCdzZXJ2ZXIgbmFtZScpLFxuICBrTG9jYWxBZGRyZXNzOiBTeW1ib2woJ2xvY2FsIGFkZHJlc3MnKSxcbiAga0hvc3Q6IFN5bWJvbCgnaG9zdCcpLFxuICBrTm9SZWY6IFN5bWJvbCgnbm8gcmVmJyksXG4gIGtCb2R5VXNlZDogU3ltYm9sKCd1c2VkJyksXG4gIGtSdW5uaW5nOiBTeW1ib2woJ3J1bm5pbmcnKSxcbiAga0Jsb2NraW5nOiBTeW1ib2woJ2Jsb2NraW5nJyksXG4gIGtQZW5kaW5nOiBTeW1ib2woJ3BlbmRpbmcnKSxcbiAga1NpemU6IFN5bWJvbCgnc2l6ZScpLFxuICBrQnVzeTogU3ltYm9sKCdidXN5JyksXG4gIGtRdWV1ZWQ6IFN5bWJvbCgncXVldWVkJyksXG4gIGtGcmVlOiBTeW1ib2woJ2ZyZWUnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKSxcbiAga0Nsb3NlZDogU3ltYm9sKCdjbG9zZWQnKSxcbiAga05lZWREcmFpbjogU3ltYm9sKCduZWVkIGRyYWluJyksXG4gIGtSZXNldDogU3ltYm9sKCdyZXNldCcpLFxuICBrRGVzdHJveWVkOiBTeW1ib2wuZm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpLFxuICBrTWF4SGVhZGVyc1NpemU6IFN5bWJvbCgnbWF4IGhlYWRlcnMgc2l6ZScpLFxuICBrUnVubmluZ0lkeDogU3ltYm9sKCdydW5uaW5nIGluZGV4JyksXG4gIGtQZW5kaW5nSWR4OiBTeW1ib2woJ3BlbmRpbmcgaW5kZXgnKSxcbiAga0Vycm9yOiBTeW1ib2woJ2Vycm9yJyksXG4gIGtDbGllbnRzOiBTeW1ib2woJ2NsaWVudHMnKSxcbiAga0NsaWVudDogU3ltYm9sKCdjbGllbnQnKSxcbiAga1BhcnNlcjogU3ltYm9sKCdwYXJzZXInKSxcbiAga09uRGVzdHJveWVkOiBTeW1ib2woJ2Rlc3Ryb3kgY2FsbGJhY2tzJyksXG4gIGtQaXBlbGluaW5nOiBTeW1ib2woJ3BpcGVsaW5pbmcnKSxcbiAga1NvY2tldDogU3ltYm9sKCdzb2NrZXQnKSxcbiAga0hvc3RIZWFkZXI6IFN5bWJvbCgnaG9zdCBoZWFkZXInKSxcbiAga0Nvbm5lY3RvcjogU3ltYm9sKCdjb25uZWN0b3InKSxcbiAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbCgnc3RyaWN0IGNvbnRlbnQgbGVuZ3RoJyksXG4gIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJyksXG4gIGtNYXhSZXF1ZXN0czogU3ltYm9sKCdtYXhSZXF1ZXN0c1BlckNsaWVudCcpLFxuICBrUHJveHk6IFN5bWJvbCgncHJveHkgYWdlbnQgb3B0aW9ucycpLFxuICBrQ291bnRlcjogU3ltYm9sKCdzb2NrZXQgcmVxdWVzdCBjb3VudGVyJyksXG4gIGtJbnRlcmNlcHRvcnM6IFN5bWJvbCgnZGlzcGF0Y2ggaW50ZXJjZXB0b3JzJyksXG4gIGtNYXhSZXNwb25zZVNpemU6IFN5bWJvbCgnbWF4IHJlc3BvbnNlIHNpemUnKSxcbiAga0hUVFAyU2Vzc2lvbjogU3ltYm9sKCdodHRwMlNlc3Npb24nKSxcbiAga0hUVFAyU2Vzc2lvblN0YXRlOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbiBzdGF0ZScpLFxuICBrSFRUUDJCdWlsZFJlcXVlc3Q6IFN5bWJvbCgnaHR0cDIgYnVpbGQgcmVxdWVzdCcpLFxuICBrSFRUUDFCdWlsZFJlcXVlc3Q6IFN5bWJvbCgnaHR0cDEgYnVpbGQgcmVxdWVzdCcpLFxuICBrSFRUUDJDb3B5SGVhZGVyczogU3ltYm9sKCdodHRwMiBjb3B5IGhlYWRlcnMnKSxcbiAga0hUVFBDb25uVmVyc2lvbjogU3ltYm9sKCdodHRwIGNvbm5lY3Rpb24gdmVyc2lvbicpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtDbG9zZSIsIlN5bWJvbCIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwia1VybCIsImtXcml0aW5nIiwia1Jlc3VtaW5nIiwia1F1ZXVlIiwia0Nvbm5lY3QiLCJrQ29ubmVjdGluZyIsImtIZWFkZXJzTGlzdCIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrS2VlcEFsaXZlVGltZW91dFZhbHVlIiwia0tlZXBBbGl2ZSIsImtIZWFkZXJzVGltZW91dCIsImtCb2R5VGltZW91dCIsImtTZXJ2ZXJOYW1lIiwia0xvY2FsQWRkcmVzcyIsImtIb3N0Iiwia05vUmVmIiwia0JvZHlVc2VkIiwia1J1bm5pbmciLCJrQmxvY2tpbmciLCJrUGVuZGluZyIsImtTaXplIiwia0J1c3kiLCJrUXVldWVkIiwia0ZyZWUiLCJrQ29ubmVjdGVkIiwia0Nsb3NlZCIsImtOZWVkRHJhaW4iLCJrUmVzZXQiLCJrRGVzdHJveWVkIiwiZm9yIiwia01heEhlYWRlcnNTaXplIiwia1J1bm5pbmdJZHgiLCJrUGVuZGluZ0lkeCIsImtFcnJvciIsImtDbGllbnRzIiwia0NsaWVudCIsImtQYXJzZXIiLCJrT25EZXN0cm95ZWQiLCJrUGlwZWxpbmluZyIsImtTb2NrZXQiLCJrSG9zdEhlYWRlciIsImtDb25uZWN0b3IiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtNYXhSZWRpcmVjdGlvbnMiLCJrTWF4UmVxdWVzdHMiLCJrUHJveHkiLCJrQ291bnRlciIsImtJbnRlcmNlcHRvcnMiLCJrTWF4UmVzcG9uc2VTaXplIiwia0hUVFAyU2Vzc2lvbiIsImtIVFRQMlNlc3Npb25TdGF0ZSIsImtIVFRQMkJ1aWxkUmVxdWVzdCIsImtIVFRQMUJ1aWxkUmVxdWVzdCIsImtIVFRQMkNvcHlIZWFkZXJzIiwia0hUVFBDb25uVmVyc2lvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFVBQVVELE9BQU87SUFDakJFLFdBQVdGLE9BQU87SUFDbEJHLE1BQU1ILE9BQU87SUFDYkksVUFBVUosT0FBTztJQUNqQkssV0FBV0wsT0FBTztJQUNsQk0sUUFBUU4sT0FBTztJQUNmTyxVQUFVUCxPQUFPO0lBQ2pCUSxhQUFhUixPQUFPO0lBQ3BCUyxjQUFjVCxPQUFPO0lBQ3JCVSwwQkFBMEJWLE9BQU87SUFDakNXLHNCQUFzQlgsT0FBTztJQUM3QlksNEJBQTRCWixPQUFPO0lBQ25DYSx3QkFBd0JiLE9BQU87SUFDL0JjLFlBQVlkLE9BQU87SUFDbkJlLGlCQUFpQmYsT0FBTztJQUN4QmdCLGNBQWNoQixPQUFPO0lBQ3JCaUIsYUFBYWpCLE9BQU87SUFDcEJrQixlQUFlbEIsT0FBTztJQUN0Qm1CLE9BQU9uQixPQUFPO0lBQ2RvQixRQUFRcEIsT0FBTztJQUNmcUIsV0FBV3JCLE9BQU87SUFDbEJzQixVQUFVdEIsT0FBTztJQUNqQnVCLFdBQVd2QixPQUFPO0lBQ2xCd0IsVUFBVXhCLE9BQU87SUFDakJ5QixPQUFPekIsT0FBTztJQUNkMEIsT0FBTzFCLE9BQU87SUFDZDJCLFNBQVMzQixPQUFPO0lBQ2hCNEIsT0FBTzVCLE9BQU87SUFDZDZCLFlBQVk3QixPQUFPO0lBQ25COEIsU0FBUzlCLE9BQU87SUFDaEIrQixZQUFZL0IsT0FBTztJQUNuQmdDLFFBQVFoQyxPQUFPO0lBQ2ZpQyxZQUFZakMsT0FBT2tDLEdBQUcsQ0FBQztJQUN2QkMsaUJBQWlCbkMsT0FBTztJQUN4Qm9DLGFBQWFwQyxPQUFPO0lBQ3BCcUMsYUFBYXJDLE9BQU87SUFDcEJzQyxRQUFRdEMsT0FBTztJQUNmdUMsVUFBVXZDLE9BQU87SUFDakJ3QyxTQUFTeEMsT0FBTztJQUNoQnlDLFNBQVN6QyxPQUFPO0lBQ2hCMEMsY0FBYzFDLE9BQU87SUFDckIyQyxhQUFhM0MsT0FBTztJQUNwQjRDLFNBQVM1QyxPQUFPO0lBQ2hCNkMsYUFBYTdDLE9BQU87SUFDcEI4QyxZQUFZOUMsT0FBTztJQUNuQitDLHNCQUFzQi9DLE9BQU87SUFDN0JnRCxrQkFBa0JoRCxPQUFPO0lBQ3pCaUQsY0FBY2pELE9BQU87SUFDckJrRCxRQUFRbEQsT0FBTztJQUNmbUQsVUFBVW5ELE9BQU87SUFDakJvRCxlQUFlcEQsT0FBTztJQUN0QnFELGtCQUFrQnJELE9BQU87SUFDekJzRCxlQUFldEQsT0FBTztJQUN0QnVELG9CQUFvQnZELE9BQU87SUFDM0J3RCxvQkFBb0J4RCxPQUFPO0lBQzNCeUQsb0JBQW9CekQsT0FBTztJQUMzQjBELG1CQUFtQjFELE9BQU87SUFDMUIyRCxrQkFBa0IzRCxPQUFPO0FBQzNCIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9zeW1ib2xzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { IncomingMessage } = __webpack_require__(/*! http */ \"http\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { Blob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst nodeUtil = __webpack_require__(/*! util */ \"util\");\nconst { stringify } = __webpack_require__(/*! querystring */ \"querystring\");\nconst [nodeMajor, nodeMinor] = process.versions.node.split(\".\").map((v)=>Number(v));\nfunction nop() {}\nfunction isStream(obj) {\n    return obj && typeof obj === \"object\" && typeof obj.pipe === \"function\" && typeof obj.on === \"function\";\n}\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike(object) {\n    return Blob && object instanceof Blob || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n}\nfunction buildURL(url, queryParams) {\n    if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    }\n    const stringified = stringify(queryParams);\n    if (stringified) {\n        url += \"?\" + stringified;\n    }\n    return url;\n}\nfunction parseURL(url) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n        if (!/^https?:/.test(url.origin || url.protocol)) {\n            throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        return url;\n    }\n    if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"Invalid URL: The URL argument must be a non-null object.\");\n    }\n    if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n    }\n    if (!(url instanceof URL)) {\n        if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n            throw new InvalidArgumentError(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n        }\n        if (url.path != null && typeof url.path !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL path: the path must be a string or null/undefined.\");\n        }\n        if (url.pathname != null && typeof url.pathname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n        }\n        if (url.hostname != null && typeof url.hostname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n        }\n        if (url.origin != null && typeof url.origin !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n        }\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;\n        let path = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin.endsWith(\"/\")) {\n            origin = origin.substring(0, origin.length - 1);\n        }\n        if (path && !path.startsWith(\"/\")) {\n            path = `/${path}`;\n        }\n        // new URL(path, origin) is unsafe when `path` contains an absolute URL\n        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n        // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n        // If first parameter is an absolute URL, a given second param will be ignored.\n        url = new URL(origin + path);\n    }\n    return url;\n}\nfunction parseOrigin(url) {\n    url = parseURL(url);\n    if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n    }\n    return url;\n}\nfunction getHostname(host) {\n    if (host[0] === \"[\") {\n        const idx = host.indexOf(\"]\");\n        assert(idx !== -1);\n        return host.substr(1, idx - 1);\n    }\n    const idx = host.indexOf(\":\");\n    if (idx === -1) return host;\n    return host.substr(0, idx);\n}\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName(host) {\n    if (!host) {\n        return null;\n    }\n    assert.strictEqual(typeof host, \"string\");\n    const servername = getHostname(host);\n    if (net.isIP(servername)) {\n        return \"\";\n    }\n    return servername;\n}\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction isAsyncIterable(obj) {\n    return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n}\nfunction isIterable(obj) {\n    return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n}\nfunction bodyLength(body) {\n    if (body == null) {\n        return 0;\n    } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n    } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n    } else if (isBuffer(body)) {\n        return body.byteLength;\n    }\n    return null;\n}\nfunction isDestroyed(stream) {\n    return !stream || !!(stream.destroyed || stream[kDestroyed]);\n}\nfunction isReadableAborted(stream) {\n    const state = stream && stream._readableState;\n    return isDestroyed(stream) && state && !state.endEmitted;\n}\nfunction destroy(stream, err) {\n    if (!isStream(stream) || isDestroyed(stream)) {\n        return;\n    }\n    if (typeof stream.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n            // See: https://github.com/nodejs/node/pull/38505/files\n            stream.socket = null;\n        }\n        stream.destroy(err);\n    } else if (err) {\n        process.nextTick((stream, err)=>{\n            stream.emit(\"error\", err);\n        }, stream, err);\n    }\n    if (stream.destroyed !== true) {\n        stream[kDestroyed] = true;\n    }\n}\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(val) {\n    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return m ? parseInt(m[1], 10) * 1000 : null;\n}\nfunction parseHeaders(headers, obj = {}) {\n    // For H2 support\n    if (!Array.isArray(headers)) return headers;\n    for(let i = 0; i < headers.length; i += 2){\n        const key = headers[i].toString().toLowerCase();\n        let val = obj[key];\n        if (!val) {\n            if (Array.isArray(headers[i + 1])) {\n                obj[key] = headers[i + 1];\n            } else {\n                obj[key] = headers[i + 1].toString(\"utf8\");\n            }\n        } else {\n            if (!Array.isArray(val)) {\n                val = [\n                    val\n                ];\n                obj[key] = val;\n            }\n            val.push(headers[i + 1].toString(\"utf8\"));\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (\"content-length\" in obj && \"content-disposition\" in obj) {\n        obj[\"content-disposition\"] = Buffer.from(obj[\"content-disposition\"]).toString(\"latin1\");\n    }\n    return obj;\n}\nfunction parseRawHeaders(headers) {\n    const ret = [];\n    let hasContentLength = false;\n    let contentDispositionIdx = -1;\n    for(let n = 0; n < headers.length; n += 2){\n        const key = headers[n + 0].toString();\n        const val = headers[n + 1].toString(\"utf8\");\n        if (key.length === 14 && (key === \"content-length\" || key.toLowerCase() === \"content-length\")) {\n            ret.push(key, val);\n            hasContentLength = true;\n        } else if (key.length === 19 && (key === \"content-disposition\" || key.toLowerCase() === \"content-disposition\")) {\n            contentDispositionIdx = ret.push(key, val) - 1;\n        } else {\n            ret.push(key, val);\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (hasContentLength && contentDispositionIdx !== -1) {\n        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString(\"latin1\");\n    }\n    return ret;\n}\nfunction isBuffer(buffer) {\n    // See, https://github.com/mcollina/undici/pull/319\n    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n}\nfunction validateHandler(handler, method, upgrade) {\n    if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n    }\n    if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n    }\n    if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n    }\n    if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== undefined) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n    }\n    if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n    } else {\n        if (typeof handler.onHeaders !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n    }\n}\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed(body) {\n    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n     : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));\n}\nfunction isErrored(body) {\n    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));\n}\nfunction isReadable(body) {\n    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));\n}\nfunction getSocketInfo(socket) {\n    return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n    };\n}\nasync function* convertIterableToBuffer(iterable) {\n    for await (const chunk of iterable){\n        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n    }\n}\nlet ReadableStream;\nfunction ReadableStreamFrom(iterable) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    if (ReadableStream.from) {\n        return ReadableStream.from(convertIterableToBuffer(iterable));\n    }\n    let iterator;\n    return new ReadableStream({\n        async start () {\n            iterator = iterable[Symbol.asyncIterator]();\n        },\n        async pull (controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n                queueMicrotask(()=>{\n                    controller.close();\n                });\n            } else {\n                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n                controller.enqueue(new Uint8Array(buf));\n            }\n            return controller.desiredSize > 0;\n        },\n        async cancel (reason) {\n            await iterator.return();\n        }\n    }, 0);\n}\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike(object) {\n    return object && typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && object[Symbol.toStringTag] === \"FormData\";\n}\nfunction throwIfAborted(signal) {\n    if (!signal) {\n        return;\n    }\n    if (typeof signal.throwIfAborted === \"function\") {\n        signal.throwIfAborted();\n    } else {\n        if (signal.aborted) {\n            // DOMException not available < v17.0.0\n            const err = new Error(\"The operation was aborted\");\n            err.name = \"AbortError\";\n            throw err;\n        }\n    }\n}\nlet events;\nfunction addAbortListener(signal, listener) {\n    if (typeof Symbol.dispose === \"symbol\") {\n        if (!events) {\n            events = __webpack_require__(/*! events */ \"events\");\n        }\n        if (typeof events.addAbortListener === \"function\" && \"aborted\" in signal) {\n            return events.addAbortListener(signal, listener);\n        }\n    }\n    if (\"addEventListener\" in signal) {\n        signal.addEventListener(\"abort\", listener, {\n            once: true\n        });\n        return ()=>signal.removeEventListener(\"abort\", listener);\n    }\n    signal.addListener(\"abort\", listener);\n    return ()=>signal.removeListener(\"abort\", listener);\n}\nconst hasToWellFormed = !!String.prototype.toWellFormed;\n/**\n * @param {string} val\n */ function toUSVString(val) {\n    if (hasToWellFormed) {\n        return `${val}`.toWellFormed();\n    } else if (nodeUtil.toUSVString) {\n        return nodeUtil.toUSVString(val);\n    }\n    return `${val}`;\n}\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = true;\nmodule.exports = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isReadableAborted,\n    isBlobLike,\n    parseOrigin,\n    parseURL,\n    getServerName,\n    isStream,\n    isIterable,\n    isAsyncIterable,\n    isDestroyed,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom,\n    isBuffer,\n    validateHandler,\n    getSocketInfo,\n    isFormDataLike,\n    buildURL,\n    throwIfAborted,\n    addAbortListener,\n    nodeMajor,\n    nodeMinor,\n    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU0sRUFBRUcsZUFBZSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1LLE1BQU1MLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRU0sb0JBQW9CLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFTyxJQUFJLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDekIsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFUyxTQUFTLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFFOUIsTUFBTSxDQUFDVSxXQUFXQyxVQUFVLEdBQUdDLFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQyxPQUFPRDtBQUVoRixTQUFTRSxPQUFRO0FBRWpCLFNBQVNDLFNBQVVDLEdBQUc7SUFDcEIsT0FBT0EsT0FBTyxPQUFPQSxRQUFRLFlBQVksT0FBT0EsSUFBSUMsSUFBSSxLQUFLLGNBQWMsT0FBT0QsSUFBSUUsRUFBRSxLQUFLO0FBQy9GO0FBRUEsbUlBQW1JO0FBQ25JLFNBQVNDLFdBQVlDLE1BQU07SUFDekIsT0FBTyxRQUFTQSxrQkFBa0JsQixRQUNoQ2tCLFVBQ0EsT0FBT0EsV0FBVyxZQUNqQixRQUFPQSxPQUFPckIsTUFBTSxLQUFLLGNBQ3hCLE9BQU9xQixPQUFPQyxXQUFXLEtBQUssVUFBUyxLQUN6QyxnQkFBZ0JDLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxPQUFPQyxXQUFXLENBQUM7QUFFbkQ7QUFFQSxTQUFTQyxTQUFVQyxH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RUFBRUEsSUFBSSxDQUFDO0FBQ2pCO0FBRUEsTUFBTTRGLHNCQUFzQnBHLE9BQU9xRyxNQUFNLENBQUM7QUFDMUNELG9CQUFvQkUsVUFBVSxHQUFHO0FBRWpDQyxPQUFPQyxPQUFPLEdBQUc7SUFDZko7SUFDQXJLO0lBQ0EwRztJQUNBRztJQUNBRTtJQUNBcUQ7SUFDQXZHO0lBQ0F4RDtJQUNBMkI7SUFDQWY7SUFDQXNCO0lBQ0F0QztJQUNBK0M7SUFDQUY7SUFDQWE7SUFDQTRCO0lBQ0FWO0lBQ0FMO0lBQ0FUO0lBQ0FiO0lBQ0FQO0lBQ0FrRjtJQUNBcEU7SUFDQXFDO0lBQ0FrQjtJQUNBNEI7SUFDQWpJO0lBQ0F3STtJQUNBSztJQUNBaks7SUFDQUM7SUFDQWtMLHlCQUF5Qm5MLFlBQVksTUFBT0EsY0FBYyxNQUFNQyxhQUFhO0FBQy9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanM/MGZiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsga0Rlc3Ryb3llZCwga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoJ2h0dHAnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcblxuY29uc3QgW25vZGVNYWpvciwgbm9kZU1pbm9yXSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLm1hcCh2ID0+IE51bWJlcih2KSlcblxuZnVuY3Rpb24gbm9wICgpIHt9XG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5vbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9mZXRjaC1ibG9iL2Jsb2IvOGFiNTg3ZDM0MDgwZGU5NDE0MGI1NGYwNzE2ODQ1MWU3ZDBiNjU1ZS9pbmRleC5qcyNMMjI5LUwyNDEgKE1JVCBMaWNlbnNlKVxuZnVuY3Rpb24gaXNCbG9iTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoQmxvYiAmJiBvYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB8fCAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gIClcbn1cblxuZnVuY3Rpb24gYnVpbGRVUkwgKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHVybC5pbmNsdWRlcygnPycpIHx8IHVybC5pbmNsdWRlcygnIycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBwYXJhbXMgY2Fubm90IGJlIHBhc3NlZCB3aGVuIHVybCBhbHJlYWR5IGNvbnRhaW5zIFwiP1wiIG9yIFwiI1wiLicpXG4gIH1cblxuICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcylcblxuICBpZiAoc3RyaW5naWZpZWQpIHtcbiAgICB1cmwgKz0gJz8nICsgc3RyaW5naWZpZWRcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkwgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghL15odHRwcz86Ly50ZXN0KHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoIS9eaHR0cHM/Oi8udGVzdCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmICFOdW1iZXIuaXNGaW5pdGUocGFyc2VJbnQodXJsLnBvcnQpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogcG9ydCBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRoICE9IG51bGwgJiYgdHlwZW9mIHVybC5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRoOiB0aGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRobmFtZSAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHBhdGhuYW1lOiB0aGUgcGF0aG5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwuaG9zdG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLmhvc3RuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBob3N0bmFtZTogdGhlIGhvc3RuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLm9yaWdpbiAhPSBudWxsICYmIHR5cGVvZiB1cmwub3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBvcmlnaW46IHRoZSBvcmlnaW4gbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHBvcnQgPSB1cmwucG9ydCAhPSBudWxsXG4gICAgICA/IHVybC5wb3J0XG4gICAgICA6ICh1cmwucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApXG4gICAgbGV0IG9yaWdpbiA9IHVybC5vcmlnaW4gIT0gbnVsbFxuICAgICAgPyB1cmwub3JpZ2luXG4gICAgICA6IGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3RuYW1lfToke3BvcnR9YFxuICAgIGxldCBwYXRoID0gdXJsLnBhdGggIT0gbnVsbFxuICAgICAgPyB1cmwucGF0aFxuICAgICAgOiBgJHt1cmwucGF0aG5hbWUgfHwgJyd9JHt1cmwuc2VhcmNoIHx8ICcnfWBcblxuICAgIGlmIChvcmlnaW4uZW5kc1dpdGgoJy8nKSkge1xuICAgICAgb3JpZ2luID0gb3JpZ2luLnN1YnN0cmluZygwLCBvcmlnaW4ubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICBpZiAocGF0aCAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgfVxuICAgIC8vIG5ldyBVUkwocGF0aCwgb3JpZ2luKSBpcyB1bnNhZmUgd2hlbiBgcGF0aGAgY29udGFpbnMgYW4gYWJzb2x1dGUgVVJMXG4gICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML1VSTDpcbiAgICAvLyBJZiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByZWxhdGl2ZSBVUkwsIHNlY29uZCBwYXJhbSBpcyByZXF1aXJlZCwgYW5kIHdpbGwgYmUgdXNlZCBhcyB0aGUgYmFzZSBVUkwuXG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGFuIGFic29sdXRlIFVSTCwgYSBnaXZlbiBzZWNvbmQgcGFyYW0gd2lsbCBiZSBpZ25vcmVkLlxuICAgIHVybCA9IG5ldyBVUkwob3JpZ2luICsgcGF0aClcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcGFyc2VPcmlnaW4gKHVybCkge1xuICB1cmwgPSBwYXJzZVVSTCh1cmwpXG5cbiAgaWYgKHVybC5wYXRobmFtZSAhPT0gJy8nIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdG5hbWUgKGhvc3QpIHtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICByZXR1cm4gaG9zdC5zdWJzdHIoMSwgaWR4IC0gMSlcbiAgfVxuXG4gIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignOicpXG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gaG9zdFxuXG4gIHJldHVybiBob3N0LnN1YnN0cigwLCBpZHgpXG59XG5cbi8vIElQIGFkZHJlc3NlcyBhcmUgbm90IHZhbGlkIHNlcnZlciBuYW1lcyBwZXIgUkZDNjA2NlxuLy8gPiBDdXJyZW50bHksIHRoZSBvbmx5IHNlcnZlciBuYW1lcyBzdXBwb3J0ZWQgYXJlIEROUyBob3N0bmFtZXNcbmZ1bmN0aW9uIGdldFNlcnZlck5hbWUgKGhvc3QpIHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgaG9zdCwgJ3N0cmluZycpXG5cbiAgY29uc3Qgc2VydmVybmFtZSA9IGdldEhvc3RuYW1lKGhvc3QpXG4gIGlmIChuZXQuaXNJUChzZXJ2ZXJuYW1lKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlcm5hbWVcbn1cblxuZnVuY3Rpb24gZGVlcENsb25lIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKVxufVxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpKVxufVxuXG5mdW5jdGlvbiBib2R5TGVuZ3RoIChib2R5KSB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLm9iamVjdE1vZGUgPT09IGZhbHNlICYmIHN0YXRlLmVuZGVkID09PSB0cnVlICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5sZW5ndGgpXG4gICAgICA/IHN0YXRlLmxlbmd0aFxuICAgICAgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVzdHJveWVkIChzdHJlYW0pIHtcbiAgcmV0dXJuICFzdHJlYW0gfHwgISEoc3RyZWFtLmRlc3Ryb3llZCB8fCBzdHJlYW1ba0Rlc3Ryb3llZF0pXG59XG5cbmZ1bmN0aW9uIGlzUmVhZGFibGVBYm9ydGVkIChzdHJlYW0pIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0gJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIHJldHVybiBpc0Rlc3Ryb3llZChzdHJlYW0pICYmIHN0YXRlICYmICFzdGF0ZS5lbmRFbWl0dGVkXG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKHN0cmVhbSwgZXJyKSB7XG4gIGlmICghaXNTdHJlYW0oc3RyZWFtKSB8fCBpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihzdHJlYW0pLmNvbnN0cnVjdG9yID09PSBJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzg1MDUvZmlsZXNcbiAgICAgIHN0cmVhbS5zb2NrZXQgPSBudWxsXG4gICAgfVxuXG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9IGVsc2UgaWYgKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKHN0cmVhbSwgZXJyKSA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSwgc3RyZWFtLCBlcnIpXG4gIH1cblxuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCAhPT0gdHJ1ZSkge1xuICAgIHN0cmVhbVtrRGVzdHJveWVkXSA9IHRydWVcbiAgfVxufVxuXG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9FWFBSID0gL3RpbWVvdXQ9KFxcZCspL1xuZnVuY3Rpb24gcGFyc2VLZWVwQWxpdmVUaW1lb3V0ICh2YWwpIHtcbiAgY29uc3QgbSA9IHZhbC50b1N0cmluZygpLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMTAwMCA6IG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChoZWFkZXJzLCBvYmogPSB7fSkge1xuICAvLyBGb3IgSDIgc3VwcG9ydFxuICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVycykpIHJldHVybiBoZWFkZXJzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyc1tpXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKClcbiAgICBsZXQgdmFsID0gb2JqW2tleV1cblxuICAgIGlmICghdmFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzW2kgKyAxXSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBoZWFkZXJzW2kgKyAxXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSBoZWFkZXJzW2kgKyAxXS50b1N0cmluZygndXRmOCcpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdXG4gICAgICAgIG9ialtrZXldID0gdmFsXG4gICAgICB9XG4gICAgICB2YWwucHVzaChoZWFkZXJzW2kgKyAxXS50b1N0cmluZygndXRmOCcpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoJ2NvbnRlbnQtbGVuZ3RoJyBpbiBvYmogJiYgJ2NvbnRlbnQtZGlzcG9zaXRpb24nIGluIG9iaikge1xuICAgIG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddID0gQnVmZmVyLmZyb20ob2JqWydjb250ZW50LWRpc3Bvc2l0aW9uJ10pLnRvU3RyaW5nKCdsYXRpbjEnKVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBwYXJzZVJhd0hlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgcmV0ID0gW11cbiAgbGV0IGhhc0NvbnRlbnRMZW5ndGggPSBmYWxzZVxuICBsZXQgY29udGVudERpc3Bvc2l0aW9uSWR4ID0gLTFcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSBoZWFkZXJzW24gKyAwXS50b1N0cmluZygpXG4gICAgY29uc3QgdmFsID0gaGVhZGVyc1tuICsgMV0udG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgaWYgKGtleS5sZW5ndGggPT09IDE0ICYmIChrZXkgPT09ICdjb250ZW50LWxlbmd0aCcgfHwga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWxlbmd0aCcpKSB7XG4gICAgICByZXQucHVzaChrZXksIHZhbClcbiAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSB0cnVlXG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxOSAmJiAoa2V5ID09PSAnY29udGVudC1kaXNwb3NpdGlvbicgfHwga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHtcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IHJldC5wdXNoKGtleSwgdmFsKSAtIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goa2V5LCB2YWwpXG4gICAgfVxuICB9XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ2NTI4XG4gIGlmIChoYXNDb250ZW50TGVuZ3RoICYmIGNvbnRlbnREaXNwb3NpdGlvbklkeCAhPT0gLTEpIHtcbiAgICByZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSA9IEJ1ZmZlci5mcm9tKHJldFtjb250ZW50RGlzcG9zaXRpb25JZHhdKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKGJ1ZmZlcikge1xuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvcHVsbC8zMTlcbiAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVIYW5kbGVyIChoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25Db25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQ29ubmVjdCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25FcnJvciBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQm9keVNlbnQgIT09ICdmdW5jdGlvbicgJiYgaGFuZGxlci5vbkJvZHlTZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Cb2R5U2VudCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25VcGdyYWRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25VcGdyYWRlIG1ldGhvZCcpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkhlYWRlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkhlYWRlcnMgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25EYXRhICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25EYXRhIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29tcGxldGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbXBsZXRlIG1ldGhvZCcpXG4gICAgfVxuICB9XG59XG5cbi8vIEEgYm9keSBpcyBkaXN0dXJiZWQgaWYgaXQgaGFzIGJlZW4gcmVhZCBmcm9tIGFuZCBpdCBjYW5ub3Rcbi8vIGJlIHJlLXVzZWQgd2l0aG91dCBsb3Npbmcgc3RhdGUgb3IgZGF0YS5cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkIChib2R5KSB7XG4gIHJldHVybiAhIShib2R5ICYmIChcbiAgICBzdHJlYW0uaXNEaXN0dXJiZWRcbiAgICAgID8gc3RyZWFtLmlzRGlzdHVyYmVkKGJvZHkpIHx8IGJvZHlba0JvZHlVc2VkXSAvLyBUT0RPIChmaXgpOiBXaHkgaXMgYm9keVtrQm9keVVzZWRdIG5lZWRlZD9cbiAgICAgIDogYm9keVtrQm9keVVzZWRdIHx8XG4gICAgICAgIGJvZHkucmVhZGFibGVEaWRSZWFkIHx8XG4gICAgICAgIChib2R5Ll9yZWFkYWJsZVN0YXRlICYmIGJvZHkuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQpIHx8XG4gICAgICAgIGlzUmVhZGFibGVBYm9ydGVkKGJvZHkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiAoXG4gICAgc3RyZWFtLmlzRXJyb3JlZFxuICAgICAgPyBzdHJlYW0uaXNFcnJvcmVkKGJvZHkpXG4gICAgICA6IC9zdGF0ZTogJ2Vycm9yZWQnLy50ZXN0KG5vZGVVdGlsLmluc3BlY3QoYm9keSlcbiAgICAgICkpKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChib2R5KSB7XG4gIHJldHVybiAhIShib2R5ICYmIChcbiAgICBzdHJlYW0uaXNSZWFkYWJsZVxuICAgICAgPyBzdHJlYW0uaXNSZWFkYWJsZShib2R5KVxuICAgICAgOiAvc3RhdGU6ICdyZWFkYWJsZScvLnRlc3Qobm9kZVV0aWwuaW5zcGVjdChib2R5KVxuICAgICAgKSkpXG59XG5cbmZ1bmN0aW9uIGdldFNvY2tldEluZm8gKHNvY2tldCkge1xuICByZXR1cm4ge1xuICAgIGxvY2FsQWRkcmVzczogc29ja2V0LmxvY2FsQWRkcmVzcyxcbiAgICBsb2NhbFBvcnQ6IHNvY2tldC5sb2NhbFBvcnQsXG4gICAgcmVtb3RlQWRkcmVzczogc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgcmVtb3RlUG9ydDogc29ja2V0LnJlbW90ZVBvcnQsXG4gICAgcmVtb3RlRmFtaWx5OiBzb2NrZXQucmVtb3RlRmFtaWx5LFxuICAgIHRpbWVvdXQ6IHNvY2tldC50aW1lb3V0LFxuICAgIGJ5dGVzV3JpdHRlbjogc29ja2V0LmJ5dGVzV3JpdHRlbixcbiAgICBieXRlc1JlYWQ6IHNvY2tldC5ieXRlc1JlYWRcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIGNvbnZlcnRJdGVyYWJsZVRvQnVmZmVyIChpdGVyYWJsZSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhYmxlKSB7XG4gICAgeWllbGQgQnVmZmVyLmlzQnVmZmVyKGNodW5rKSA/IGNodW5rIDogQnVmZmVyLmZyb20oY2h1bmspXG4gIH1cbn1cblxubGV0IFJlYWRhYmxlU3RyZWFtXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20gKGl0ZXJhYmxlKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgaWYgKFJlYWRhYmxlU3RyZWFtLmZyb20pIHtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW0uZnJvbShjb252ZXJ0SXRlcmFibGVUb0J1ZmZlcihpdGVyYWJsZSkpXG4gIH1cblxuICBsZXQgaXRlcmF0b3JcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICB7XG4gICAgICBhc3luYyBzdGFydCAoKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlIDogQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH1cbiAgICB9LFxuICAgIDBcbiAgKVxufVxuXG4vLyBUaGUgY2h1bmsgc2hvdWxkIGJlIGEgRm9ybURhdGEgaW5zdGFuY2UgYW5kIGNvbnRhaW5zXG4vLyBhbGwgdGhlIHJlcXVpcmVkIG1ldGhvZHMuXG5mdW5jdGlvbiBpc0Zvcm1EYXRhTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZGVsZXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuaGFzID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5zZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJ1xuICApXG59XG5cbmZ1bmN0aW9uIHRocm93SWZBYm9ydGVkIChzaWduYWwpIHtcbiAgaWYgKCFzaWduYWwpIHsgcmV0dXJuIH1cbiAgaWYgKHR5cGVvZiBzaWduYWwudGhyb3dJZkFib3J0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaWduYWwudGhyb3dJZkFib3J0ZWQoKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gRE9NRXhjZXB0aW9uIG5vdCBhdmFpbGFibGUgPCB2MTcuMC4wXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKVxuICAgICAgZXJyLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG5sZXQgZXZlbnRzXG5mdW5jdGlvbiBhZGRBYm9ydExpc3RlbmVyIChzaWduYWwsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sLmRpc3Bvc2UgPT09ICdzeW1ib2wnKSB7XG4gICAgaWYgKCFldmVudHMpIHtcbiAgICAgIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnRzLmFkZEFib3J0TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgJ2Fib3J0ZWQnIGluIHNpZ25hbCkge1xuICAgICAgcmV0dXJuIGV2ZW50cy5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgbGlzdGVuZXIpXG4gICAgfVxuICB9XG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gc2lnbmFsKSB7XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KVxuICAgIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgfVxuICBzaWduYWwuYWRkTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG59XG5cbmNvbnN0IGhhc1RvV2VsbEZvcm1lZCA9ICEhU3RyaW5nLnByb3RvdHlwZS50b1dlbGxGb3JtZWRcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKi9cbmZ1bmN0aW9uIHRvVVNWU3RyaW5nICh2YWwpIHtcbiAgaWYgKGhhc1RvV2VsbEZvcm1lZCkge1xuICAgIHJldHVybiBgJHt2YWx9YC50b1dlbGxGb3JtZWQoKVxuICB9IGVsc2UgaWYgKG5vZGVVdGlsLnRvVVNWU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5vZGVVdGlsLnRvVVNWU3RyaW5nKHZhbClcbiAgfVxuXG4gIHJldHVybiBgJHt2YWx9YFxufVxuXG5jb25zdCBrRW51bWVyYWJsZVByb3BlcnR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxua0VudW1lcmFibGVQcm9wZXJ0eS5lbnVtZXJhYmxlID0gdHJ1ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbm9wLFxuICBpc0Rpc3R1cmJlZCxcbiAgaXNFcnJvcmVkLFxuICBpc1JlYWRhYmxlLFxuICB0b1VTVlN0cmluZyxcbiAgaXNSZWFkYWJsZUFib3J0ZWQsXG4gIGlzQmxvYkxpa2UsXG4gIHBhcnNlT3JpZ2luLFxuICBwYXJzZVVSTCxcbiAgZ2V0U2VydmVyTmFtZSxcbiAgaXNTdHJlYW0sXG4gIGlzSXRlcmFibGUsXG4gIGlzQXN5bmNJdGVyYWJsZSxcbiAgaXNEZXN0cm95ZWQsXG4gIHBhcnNlUmF3SGVhZGVycyxcbiAgcGFyc2VIZWFkZXJzLFxuICBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQsXG4gIGRlc3Ryb3ksXG4gIGJvZHlMZW5ndGgsXG4gIGRlZXBDbG9uZSxcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICBpc0J1ZmZlcixcbiAgdmFsaWRhdGVIYW5kbGVyLFxuICBnZXRTb2NrZXRJbmZvLFxuICBpc0Zvcm1EYXRhTGlrZSxcbiAgYnVpbGRVUkwsXG4gIHRocm93SWZBYm9ydGVkLFxuICBhZGRBYm9ydExpc3RlbmVyLFxuICBub2RlTWFqb3IsXG4gIG5vZGVNaW5vcixcbiAgbm9kZUhhc0F1dG9TZWxlY3RGYW1pbHk6IG5vZGVNYWpvciA+IDE4IHx8IChub2RlTWFqb3IgPT09IDE4ICYmIG5vZGVNaW5vciA+PSAxMylcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwia0Rlc3Ryb3llZCIsImtCb2R5VXNlZCIsIkluY29taW5nTWVzc2FnZSIsInN0cmVhbSIsIm5ldCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiQmxvYiIsIm5vZGVVdGlsIiwic3RyaW5naWZ5Iiwibm9kZU1ham9yIiwibm9kZU1pbm9yIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInNwbGl0IiwibWFwIiwidiIsIk51bWJlciIsIm5vcCIsImlzU3RyZWFtIiwib2JqIiwicGlwZSIsIm9uIiwiaXNCbG9iTGlrZSIsIm9iamVjdCIsImFycmF5QnVmZmVyIiwidGVzdCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiYnVpbGRVUkwiLCJ1cmwiLCJxdWVyeVBhcmFtcyIsImluY2x1ZGVzIiwiRXJyb3IiLCJzdHJpbmdpZmllZCIsInBhcnNlVVJMIiwiVVJMIiwib3JpZ2luIiwicHJvdG9jb2wiLCJwb3J0IiwiaXNGaW5pdGUiLCJwYXJzZUludCIsInBhdGgiLCJwYXRobmFtZSIsImhvc3RuYW1lIiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwicGFyc2VPcmlnaW4iLCJoYXNoIiwiZ2V0SG9zdG5hbWUiLCJob3N0IiwiaWR4IiwiaW5kZXhPZiIsInN1YnN0ciIsImdldFNlcnZlck5hbWUiLCJzdHJpY3RFcXVhbCIsInNlcnZlcm5hbWUiLCJpc0lQIiwiZGVlcENsb25lIiwiSlNPTiIsInBhcnNlIiwiaXNBc3luY0l0ZXJhYmxlIiwiYXN5bmNJdGVyYXRvciIsImlzSXRlcmFibGUiLCJpdGVyYXRvciIsImJvZHlMZW5ndGgiLCJib2R5Iiwic3RhdGUiLCJfcmVhZGFibGVTdGF0ZSIsIm9iamVjdE1vZGUiLCJlbmRlZCIsInNpemUiLCJpc0J1ZmZlciIsImJ5dGVMZW5ndGgiLCJpc0Rlc3Ryb3llZCIsImRlc3Ryb3llZCIsImlzUmVhZGFibGVBYm9ydGVkIiwiZW5kRW1pdHRlZCIsImRlc3Ryb3kiLCJlcnIiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwic29ja2V0IiwibmV4dFRpY2siLCJlbWl0IiwiS0VFUEFMSVZFX1RJTUVPVVRfRVhQUiIsInBhcnNlS2VlcEFsaXZlVGltZW91dCIsInZhbCIsIm0iLCJ0b1N0cmluZyIsIm1hdGNoIiwicGFyc2VIZWFkZXJzIiwiaGVhZGVycyIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJCdWZmZXIiLCJmcm9tIiwicGFyc2VSYXdIZWFkZXJzIiwicmV0IiwiaGFzQ29udGVudExlbmd0aCIsImNvbnRlbnREaXNwb3NpdGlvbklkeCIsIm4iLCJidWZmZXIiLCJVaW50OEFycmF5IiwidmFsaWRhdGVIYW5kbGVyIiwiaGFuZGxlciIsIm1ldGhvZCIsInVwZ3JhZGUiLCJvbkNvbm5lY3QiLCJvbkVycm9yIiwib25Cb2R5U2VudCIsInVuZGVmaW5lZCIsIm9uVXBncmFkZSIsIm9uSGVhZGVycyIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJpc0Rpc3R1cmJlZCIsInJlYWRhYmxlRGlkUmVhZCIsImRhdGFFbWl0dGVkIiwiaXNFcnJvcmVkIiwiaW5zcGVjdCIsImlzUmVhZGFibGUiLCJnZXRTb2NrZXRJbmZvIiwibG9jYWxBZGRyZXNzIiwibG9jYWxQb3J0IiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJyZW1vdGVGYW1pbHkiLCJ0aW1lb3V0IiwiYnl0ZXNXcml0dGVuIiwiYnl0ZXNSZWFkIiwiY29udmVydEl0ZXJhYmxlVG9CdWZmZXIiLCJpdGVyYWJsZSIsImNodW5rIiwiUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbUZyb20iLCJzdGFydCIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwibmV4dCIsInF1ZXVlTWljcm90YXNrIiwiY2xvc2UiLCJidWYiLCJlbnF1ZXVlIiwiZGVzaXJlZFNpemUiLCJjYW5jZWwiLCJyZWFzb24iLCJyZXR1cm4iLCJpc0Zvcm1EYXRhTGlrZSIsImFwcGVuZCIsImRlbGV0ZSIsImdldCIsImdldEFsbCIsImhhcyIsInNldCIsInRocm93SWZBYm9ydGVkIiwic2lnbmFsIiwiYWJvcnRlZCIsIm5hbWUiLCJldmVudHMiLCJhZGRBYm9ydExpc3RlbmVyIiwibGlzdGVuZXIiLCJkaXNwb3NlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImhhc1RvV2VsbEZvcm1lZCIsIlN0cmluZyIsInByb3RvdHlwZSIsInRvV2VsbEZvcm1lZCIsInRvVVNWU3RyaW5nIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImNyZWF0ZSIsImVudW1lcmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIiwibm9kZUhhc0F1dG9TZWxlY3RGYW1pbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher-base.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher-base.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher.js\");\nconst { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { kDestroy, kClose, kDispatch, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst kDestroyed = Symbol(\"destroyed\");\nconst kClosed = Symbol(\"closed\");\nconst kOnDestroyed = Symbol(\"onDestroyed\");\nconst kOnClosed = Symbol(\"onClosed\");\nconst kInterceptedDispatch = Symbol(\"Intercepted Dispatch\");\nclass DispatcherBase extends Dispatcher {\n    constructor(){\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = null;\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors];\n    }\n    set interceptors(newInterceptors) {\n        if (newInterceptors) {\n            for(let i = newInterceptors.length - 1; i >= 0; i--){\n                const interceptor = this[kInterceptors][i];\n                if (typeof interceptor !== \"function\") {\n                    throw new InvalidArgumentError(\"interceptor must be an function\");\n                }\n            }\n        }\n        this[kInterceptors] = newInterceptors;\n    }\n    close(callback) {\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.close((err, data)=>{\n                    return err ? reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>callback(new ClientDestroyedError(), null));\n            return;\n        }\n        if (this[kClosed]) {\n            if (this[kOnClosed]) {\n                this[kOnClosed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = ()=>{\n            const callbacks = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kClose]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(onClosed);\n        });\n    }\n    destroy(err, callback) {\n        if (typeof err === \"function\") {\n            callback = err;\n            err = null;\n        }\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.destroy(err, (err, data)=>{\n                    return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            if (this[kOnDestroyed]) {\n                this[kOnDestroyed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        if (!err) {\n            err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed] = this[kOnDestroyed] || [];\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = ()=>{\n            const callbacks = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kDestroy](err).then(()=>{\n            queueMicrotask(onDestroyed);\n        });\n    }\n    [kInterceptedDispatch](opts, handler) {\n        if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n            this[kInterceptedDispatch] = this[kDispatch];\n            return this[kDispatch](opts, handler);\n        }\n        let dispatch = this[kDispatch].bind(this);\n        for(let i = this[kInterceptors].length - 1; i >= 0; i--){\n            dispatch = this[kInterceptors][i](dispatch);\n        }\n        this[kInterceptedDispatch] = dispatch;\n        return dispatch(opts, handler);\n    }\n    dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n            throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n            if (!opts || typeof opts !== \"object\") {\n                throw new InvalidArgumentError(\"opts must be an object.\");\n            }\n            if (this[kDestroyed] || this[kOnDestroyed]) {\n                throw new ClientDestroyedError();\n            }\n            if (this[kClosed]) {\n                throw new ClientClosedError();\n            }\n            return this[kInterceptedDispatch](opts, handler);\n        } catch (err) {\n            if (typeof handler.onError !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onError method\");\n            }\n            handler.onError(err);\n            return false;\n        }\n    }\n}\nmodule.exports = DispatcherBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQ0pDLG9CQUFvQixFQUNwQkMsaUJBQWlCLEVBQ2pCQyxvQkFBb0IsRUFDckIsR0FBR0gsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVJLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUUvRCxNQUFNUSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLFVBQVVELE9BQU87QUFDdkIsTUFBTUUsZUFBZUYsT0FBTztBQUM1QixNQUFNRyxZQUFZSCxPQUFPO0FBQ3pCLE1BQU1JLHVCQUF1QkosT0FBTztBQUVwQyxNQUFNSyx1QkFBdUJmO0lBQzNCZ0IsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNQLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNHLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNFLFVBQVUsR0FBRyxFQUFFO0lBQ3RCO0lBRUEsSUFBSUksWUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDUixXQUFXO0lBQ3pCO0lBRUEsSUFBSVMsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDUCxRQUFRO0lBQ3RCO0lBRUEsSUFBSVEsZUFBZ0I7UUFDbEIsT0FBTyxJQUFJLENBQUNYLGNBQWM7SUFDNUI7SUFFQSxJQUFJVyxhQUFjQyxlQUFlLEVBQUU7UUFDakMsSUFBSUEsaUJBQWlCO1lBQ25CLElBQUssSUFBSUMsSUFBSUQsZ0JBQWdCRSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO2dCQUNwRCxNQUFNRSxjQUFjLElBQUksQ0FBQ2YsY0FBYyxDQUFDYSxFQUFFO2dCQUMxQyxJQUFJLE9BQU9FLGdCQUFnQixZQUFZO29CQUNyQyxNQUFNLElBQUluQixxQkFBcUI7Z0JBQ2pDO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0ksY0FBYyxHQUFHWTtJQUN4QjtJQUVBSSxNQUFPQyxRQUFRLEVBQUU7UUFDZixJQUFJQSxhQUFhQyxXQUFXO1lBQzFCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztnQkFDM0IsSUFBSSxDQUFDTCxLQUFLLENBQUMsQ0FBQ00sS0FBS0M7b0JBQ2YsT0FBT0QsTUFBTUQsT0FBT0MsT0FBT0YsUUFBUUc7Z0JBQ3JDO1lBQ0Y7UUFDRjtRQUVBLElBQUksT0FBT04sYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSXJCLHFCQUFxQjtRQUNqQztRQUVBLElBQUksSUFBSSxDQUFDSyxXQUFXLEVBQUU7WUFDcEJ1QixlQUFlLElBQU1QLFNBQVMsSUFBSXZCLHdCQUF3QjtZQUMxRDtRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUNTLFFBQVEsRUFBRTtZQUNqQixJQUFJLElBQUksQ0FBQ0UsVUFBVSxFQUFFO2dCQUNuQixJQUFJLENBQUNBLFVBQVUsQ0FBQ29CLElBQUksQ0FBQ1I7WUFDdkIsT0FBTztnQkFDTE8sZUFBZSxJQUFNUCxTQUFTLE1BQU07WUFDdEM7WUFDQTtRQUNGO1FBRUEsSUFBSSxDQUFDZCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRSxVQUFVLENBQUNvQixJQUFJLENBQUNSO1FBRXJCLE1BQU1TLFdBQVc7WUFDZixNQUFNQyxZQUFZLElBQUksQ0FBQ3RCLFVBQVU7WUFDakMsSUFBSSxDQUFDQSxVQUFVLEdBQUc7WUFDbEIsSUFBSyxJQUFJUSxJQUFJLEdBQUdBLElBQUljLFVBQVViLE1BQU0sRUFBRUQsSUFBSztnQkFDekNjLFNBQVMsQ0FBQ2QsRUFBRSxDQUFDLE1BQU07WUFDckI7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQixJQUFJLENBQUNmLE9BQU8sR0FDVDhCLElBQUksQ0FBQyxJQUFNLElBQUksQ0FBQ0MsT0FBTyxJQUN2QkQsSUFBSSxDQUFDO1lBQ0pKLGVBQWVFO1FBQ2pCO0lBQ0o7SUFFQUcsUUFBU1AsR0FBRyxFQUFFTCxRQUFRLEVBQUU7UUFDdEIsSUFBSSxPQUFPSyxRQUFRLFlBQVk7WUFDN0JMLFdBQVdLO1lBQ1hBLE1BQU07UUFDUjtRQUVBLElBQUlMLGFBQWFDLFdBQVc7WUFDMUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO2dCQUMzQixJQUFJLENBQUNRLE9BQU8sQ0FBQ1AsS0FBSyxDQUFDQSxLQUFLQztvQkFDdEIsT0FBT0QsTUFBTSw0Q0FBNEMsR0FBR0QsT0FBT0MsT0FBT0YsUUFBUUc7Z0JBQ3BGO1lBQ0Y7UUFDRjtRQUVBLElBQUksT0FBT04sYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSXJCLHFCQUFxQjtRQUNqQztRQUVBLElBQUksSUFBSSxDQUFDSyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxJQUFJLENBQUNHLGFBQWEsRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxhQUFhLENBQUNxQixJQUFJLENBQUNSO1lBQzFCLE9BQU87Z0JBQ0xPLGVBQWUsSUFBTVAsU0FBUyxNQUFNO1lBQ3RDO1lBQ0E7UUFDRjtRQUVBLElBQUksQ0FBQ0ssS0FBSztZQUNSQSxNQUFNLElBQUk1QjtRQUNaO1FBRUEsSUFBSSxDQUFDTyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUksRUFBRTtRQUM3QyxJQUFJLENBQUNBLGFBQWEsQ0FBQ3FCLElBQUksQ0FBQ1I7UUFFeEIsTUFBTWEsY0FBYztZQUNsQixNQUFNSCxZQUFZLElBQUksQ0FBQ3ZCLGFBQWE7WUFDcEMsSUFBSSxDQUFDQSxhQUFhLEdBQUc7WUFDckIsSUFBSyxJQUFJUyxJQUFJLEdBQUdBLElBQUljLFVBQVViLE1BQU0sRUFBRUQsSUFBSztnQkFDekNjLFNBQVMsQ0FBQ2QsRUFBRSxDQUFDLE1BQU07WUFDckI7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQixJQUFJLENBQUNoQixTQUFTLENBQUN5QixLQUFLTSxJQUFJLENBQUM7WUFDdkJKLGVBQWVNO1FBQ2pCO0lBQ0Y7SUFFQSxDQUFDeEIscUJBQXFCLENBQUV5QixJQUFJLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDaEMsY0FBYyxJQUFJLElBQUksQ0FBQ0EsY0FBYyxDQUFDYyxNQUFNLEtBQUssR0FBRztZQUM1RCxJQUFJLENBQUNSLHFCQUFxQixHQUFHLElBQUksQ0FBQ1AsVUFBVTtZQUM1QyxPQUFPLElBQUksQ0FBQ0EsVUFBVSxDQUFDZ0MsTUFBTUM7UUFDL0I7UUFFQSxJQUFJQyxXQUFXLElBQUksQ0FBQ2xDLFVBQVUsQ0FBQ21DLElBQUksQ0FBQyxJQUFJO1FBQ3hDLElBQUssSUFBSXJCLElBQUksSUFBSSxDQUFDYixjQUFjLENBQUNjLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDeERvQixXQUFXLElBQUksQ0FBQ2pDLGNBQWMsQ0FBQ2EsRUFBRSxDQUFDb0I7UUFDcEM7UUFDQSxJQUFJLENBQUMzQixxQkFBcUIsR0FBRzJCO1FBQzdCLE9BQU9BLFNBQVNGLE1BQU1DO0lBQ3hCO0lBRUFDLFNBQVVGLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDM0MsTUFBTSxJQUFJcEMscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSTtZQUNGLElBQUksQ0FBQ21DLFFBQVEsT0FBT0EsU0FBUyxVQUFVO2dCQUNyQyxNQUFNLElBQUluQyxxQkFBcUI7WUFDakM7WUFFQSxJQUFJLElBQUksQ0FBQ0ssV0FBVyxJQUFJLElBQUksQ0FBQ0csYUFBYSxFQUFFO2dCQUMxQyxNQUFNLElBQUlWO1lBQ1o7WUFFQSxJQUFJLElBQUksQ0FBQ1MsUUFBUSxFQUFFO2dCQUNqQixNQUFNLElBQUlSO1lBQ1o7WUFFQSxPQUFPLElBQUksQ0FBQ1cscUJBQXFCLENBQUN5QixNQUFNQztRQUMxQyxFQUFFLE9BQU9WLEtBQUs7WUFDWixJQUFJLE9BQU9VLFFBQVFHLE9BQU8sS0FBSyxZQUFZO2dCQUN6QyxNQUFNLElBQUl2QyxxQkFBcUI7WUFDakM7WUFFQW9DLFFBQVFHLE9BQU8sQ0FBQ2I7WUFFaEIsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBYyxPQUFPQyxPQUFPLEdBQUc5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci1iYXNlLmpzPzEzZjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3Qge1xuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGtEZXN0cm95LCBrQ2xvc2UsIGtEaXNwYXRjaCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBrRGVzdHJveWVkID0gU3ltYm9sKCdkZXN0cm95ZWQnKVxuY29uc3Qga0Nsb3NlZCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IGtPbkRlc3Ryb3llZCA9IFN5bWJvbCgnb25EZXN0cm95ZWQnKVxuY29uc3Qga09uQ2xvc2VkID0gU3ltYm9sKCdvbkNsb3NlZCcpXG5jb25zdCBrSW50ZXJjZXB0ZWREaXNwYXRjaCA9IFN5bWJvbCgnSW50ZXJjZXB0ZWQgRGlzcGF0Y2gnKVxuXG5jbGFzcyBEaXNwYXRjaGVyQmFzZSBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IGZhbHNlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgIHRoaXNba0Nsb3NlZF0gPSBmYWxzZVxuICAgIHRoaXNba09uQ2xvc2VkXSA9IFtdXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trRGVzdHJveWVkXVxuICB9XG5cbiAgZ2V0IGNsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nsb3NlZF1cbiAgfVxuXG4gIGdldCBpbnRlcmNlcHRvcnMgKCkge1xuICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRvcnNdXG4gIH1cblxuICBzZXQgaW50ZXJjZXB0b3JzIChuZXdJbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gbmV3SW50ZXJjZXB0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpc1trSW50ZXJjZXB0b3JzXVtpXVxuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnRlcmNlcHRvciBtdXN0IGJlIGFuIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBuZXdJbnRlcmNlcHRvcnNcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpLCBudWxsKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25DbG9zZWRdKSB7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25DbG9zZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkNsb3NlZF1cbiAgICAgIHRoaXNba09uQ2xvc2VkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trQ2xvc2VdKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuZGVzdHJveSgpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZClcbiAgICAgIH0pXG4gIH1cblxuICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXJyXG4gICAgICBlcnIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBlcnJvciAqLyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgaWYgKHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IHRydWVcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSB0aGlzW2tPbkRlc3Ryb3llZF0gfHwgW11cbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uRGVzdHJveWVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25EZXN0cm95ZWRdXG4gICAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Rlc3Ryb3ldKGVycikudGhlbigoKSA9PiB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhvbkRlc3Ryb3llZClcbiAgICB9KVxuICB9XG5cbiAgW2tJbnRlcmNlcHRlZERpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghdGhpc1trSW50ZXJjZXB0b3JzXSB8fCB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0gPSB0aGlzW2tEaXNwYXRjaF1cbiAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9XG5cbiAgICBsZXQgZGlzcGF0Y2ggPSB0aGlzW2tEaXNwYXRjaF0uYmluZCh0aGlzKVxuICAgIGZvciAobGV0IGkgPSB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBkaXNwYXRjaCA9IHRoaXNba0ludGVyY2VwdG9yc11baV0oZGlzcGF0Y2gpXG4gICAgfVxuICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gZGlzcGF0Y2hcbiAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0gfHwgdGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXShvcHRzLCBoYW5kbGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci5vbkVycm9yKGVycilcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlckJhc2VcbiJdLCJuYW1lcyI6WyJEaXNwYXRjaGVyIiwicmVxdWlyZSIsIkNsaWVudERlc3Ryb3llZEVycm9yIiwiQ2xpZW50Q2xvc2VkRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImtEZXN0cm95Iiwia0Nsb3NlIiwia0Rpc3BhdGNoIiwia0ludGVyY2VwdG9ycyIsImtEZXN0cm95ZWQiLCJTeW1ib2wiLCJrQ2xvc2VkIiwia09uRGVzdHJveWVkIiwia09uQ2xvc2VkIiwia0ludGVyY2VwdGVkRGlzcGF0Y2giLCJEaXNwYXRjaGVyQmFzZSIsImNvbnN0cnVjdG9yIiwiZGVzdHJveWVkIiwiY2xvc2VkIiwiaW50ZXJjZXB0b3JzIiwibmV3SW50ZXJjZXB0b3JzIiwiaSIsImxlbmd0aCIsImludGVyY2VwdG9yIiwiY2xvc2UiLCJjYWxsYmFjayIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyIiwiZGF0YSIsInF1ZXVlTWljcm90YXNrIiwicHVzaCIsIm9uQ2xvc2VkIiwiY2FsbGJhY2tzIiwidGhlbiIsImRlc3Ryb3kiLCJvbkRlc3Ryb3llZCIsIm9wdHMiLCJoYW5kbGVyIiwiZGlzcGF0Y2giLCJiaW5kIiwib25FcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/dispatcher.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nclass Dispatcher extends EventEmitter {\n    dispatch() {\n        throw new Error(\"not implemented\");\n    }\n    close() {\n        throw new Error(\"not implemented\");\n    }\n    destroy() {\n        throw new Error(\"not implemented\");\n    }\n}\nmodule.exports = Dispatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsZUFBZUMsbUJBQU9BLENBQUM7QUFFN0IsTUFBTUMsbUJBQW1CRjtJQUN2QkcsV0FBWTtRQUNWLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBQyxRQUFTO1FBQ1AsTUFBTSxJQUFJRCxNQUFNO0lBQ2xCO0lBRUFFLFVBQVc7UUFDVCxNQUFNLElBQUlGLE1BQU07SUFDbEI7QUFDRjtBQUVBRyxPQUFPQyxPQUFPLEdBQUdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyLmpzP2ZjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmNsYXNzIERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkaXNwYXRjaCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiRGlzcGF0Y2hlciIsImRpc3BhdGNoIiwiRXJyb3IiLCJjbG9zZSIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/body.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/body.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Busboy = __webpack_require__(/*! @fastify/busboy */ \"(rsc)/./node_modules/@fastify/busboy/lib/main.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/fetch/formdata.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException, structuredClone } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isErrored } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ \"util/types\");\nconst { File: UndiciFile } = __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/undici/lib/fetch/file.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nlet ReadableStream = globalThis.ReadableStream;\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof ReadableStream) {\n        stream = object;\n    } else if (isBlobLike(object)) {\n        // 3. Otherwise, if object is a Blob object, set stream to the\n        //    result of running object’s get stream.\n        stream = object.stream();\n    } else {\n        // 4. Otherwise, set stream to a new ReadableStream object, and set\n        //    up stream.\n        stream = new ReadableStream({\n            async pull (controller) {\n                controller.enqueue(typeof source === \"string\" ? new TextEncoder().encode(source) : source);\n                queueMicrotask(()=>readableStreamClose(controller));\n            },\n            start () {},\n            type: undefined\n        });\n    }\n    // 5. Assert: stream is a ReadableStream object.\n    assert(isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === \"string\") {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = \"text/plain;charset=UTF-8\";\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isArrayBuffer(object)) {\n        // BufferSource/ArrayBuffer\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.slice());\n    } else if (ArrayBuffer.isView(object)) {\n        // BufferSource/ArrayBufferView\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    } else if (util.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, \"0\")}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with object’s entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const enc = new TextEncoder();\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]) // '\\r\\n'\n        ;\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object){\n            if (typeof value === \"string\") {\n                const chunk = enc.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n                blobParts.push(chunk);\n                length += chunk.byteLength;\n            } else {\n                const chunk = enc.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + \"\\r\\n\" + `Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`);\n                blobParts.push(chunk, value, rn);\n                if (typeof value.size === \"number\") {\n                    length += chunk.byteLength + value.size + rn.byteLength;\n                } else {\n                    hasUnknownSizeValue = true;\n                }\n            }\n        }\n        const chunk = enc.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) {\n            length = null;\n        }\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts){\n                if (part.stream) {\n                    yield* part.stream();\n                } else {\n                    yield part;\n                }\n            }\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = \"multipart/form-data; boundary=\" + boundary;\n    } else if (isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to object’s size.\n        length = object.size;\n        // If object’s type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) {\n            type = object.type;\n        }\n    } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) {\n            throw new TypeError(\"keepalive\");\n        }\n        // If object is disturbed or locked, then throw a TypeError.\n        if (util.isDisturbed(object) || object.locked) {\n            throw new TypeError(\"Response body object should not be disturbed or locked\");\n        }\n        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to source’s length.\n    if (typeof source === \"string\" || util.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n    }\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    // When running action is done, close stream.\n                    queueMicrotask(()=>{\n                        controller.close();\n                    });\n                } else {\n                    // Whenever one or more bytes are available and stream is not errored,\n                    // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                    // bytes into stream.\n                    if (!isErrored(stream)) {\n                        controller.enqueue(new Uint8Array(value));\n                    }\n                }\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: undefined\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream,\n        source,\n        length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n    if (!ReadableStream) {\n        // istanbul ignore next\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        assert(!util.isDisturbed(object), \"The body has already been consumed.\");\n        // istanbul ignore next\n        assert(!object.locked, \"The stream is locked.\");\n    }\n    // 2. Return the results of extracting object.\n    return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let « out1, out2 » be the result of teeing body’s stream.\n    const [out1, out2] = body.stream.tee();\n    const out2Clone = structuredClone(out2, {\n        transfer: [\n            out2\n        ]\n    });\n    // This, for whatever reasons, unrefs out2Clone which allows\n    // the process to exit by itself.\n    const [, finalClone] = out2Clone.tee();\n    // 2. Set body’s stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: finalClone,\n        length: body.length,\n        source: body.source\n    };\n}\nasync function* consumeBody(body) {\n    if (body) {\n        if (isUint8Array(body)) {\n            yield body;\n        } else {\n            const stream = body.stream;\n            if (util.isDisturbed(stream)) {\n                throw new TypeError(\"The body has already been consumed.\");\n            }\n            if (stream.locked) {\n                throw new TypeError(\"The stream is locked.\");\n            }\n            // Compat.\n            stream[kBodyUsed] = true;\n            yield* stream;\n        }\n    }\n}\nfunction throwIfAborted(state) {\n    if (state.aborted) {\n        throw new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n}\nfunction bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is this’s\n            // MIME type.\n            return specConsumeBody(this, (bytes)=>{\n                let mimeType = bodyMimeType(this);\n                if (mimeType === \"failure\") {\n                    mimeType = \"\";\n                } else if (mimeType) {\n                    mimeType = serializeAMimeType(mimeType);\n                }\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return specConsumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return specConsumeBody(this, utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return specConsumeBody(this, parseJSONFromBytes, instance);\n        },\n        async formData () {\n            webidl.brandCheck(this, instance);\n            throwIfAborted(this[kState]);\n            const contentType = this.headers.get(\"Content-Type\");\n            // If mimeType’s essence is \"multipart/form-data\", then:\n            if (/multipart\\/form-data/.test(contentType)) {\n                const headers = {};\n                for (const [key, value] of this.headers)headers[key.toLowerCase()] = value;\n                const responseFormData = new FormData();\n                let busboy;\n                try {\n                    busboy = new Busboy({\n                        headers,\n                        preservePath: true\n                    });\n                } catch (err) {\n                    throw new DOMException(`${err}`, \"AbortError\");\n                }\n                busboy.on(\"field\", (name, value)=>{\n                    responseFormData.append(name, value);\n                });\n                busboy.on(\"file\", (name, value, filename, encoding, mimeType)=>{\n                    const chunks = [];\n                    if (encoding === \"base64\" || encoding.toLowerCase() === \"base64\") {\n                        let base64chunk = \"\";\n                        value.on(\"data\", (chunk)=>{\n                            base64chunk += chunk.toString().replace(/[\\r\\n]/gm, \"\");\n                            const end = base64chunk.length - base64chunk.length % 4;\n                            chunks.push(Buffer.from(base64chunk.slice(0, end), \"base64\"));\n                            base64chunk = base64chunk.slice(end);\n                        });\n                        value.on(\"end\", ()=>{\n                            chunks.push(Buffer.from(base64chunk, \"base64\"));\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    } else {\n                        value.on(\"data\", (chunk)=>{\n                            chunks.push(chunk);\n                        });\n                        value.on(\"end\", ()=>{\n                            responseFormData.append(name, new File(chunks, filename, {\n                                type: mimeType\n                            }));\n                        });\n                    }\n                });\n                const busboyResolve = new Promise((resolve, reject)=>{\n                    busboy.on(\"finish\", resolve);\n                    busboy.on(\"error\", (err)=>reject(new TypeError(err)));\n                });\n                if (this.body !== null) for await (const chunk of consumeBody(this[kState].body))busboy.write(chunk);\n                busboy.end();\n                await busboyResolve;\n                return responseFormData;\n            } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n                // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n                // 1. Let entries be the result of parsing bytes.\n                let entries;\n                try {\n                    let text = \"\";\n                    // application/x-www-form-urlencoded parser will keep the BOM.\n                    // https://url.spec.whatwg.org/#concept-urlencoded-parser\n                    const textDecoder = new TextDecoder(\"utf-8\", {\n                        ignoreBOM: true\n                    });\n                    for await (const chunk of consumeBody(this[kState].body)){\n                        if (!isUint8Array(chunk)) {\n                            throw new TypeError(\"Expected Uint8Array chunk\");\n                        }\n                        text += textDecoder.decode(chunk, {\n                            stream: true\n                        });\n                    }\n                    text += textDecoder.decode();\n                    entries = new URLSearchParams(text);\n                } catch (err) {\n                    // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n                    // 2. If entries is failure, then throw a TypeError.\n                    throw Object.assign(new TypeError(), {\n                        cause: err\n                    });\n                }\n                // 3. Return a new FormData object whose entries are entries.\n                const formData = new FormData();\n                for (const [name, value] of entries){\n                    formData.append(name, value);\n                }\n                return formData;\n            } else {\n                // Wait a tick before checking if the request has been aborted.\n                // Otherwise, a TypeError can be thrown when an AbortError should.\n                await Promise.resolve();\n                throwIfAborted(this[kState]);\n                // Otherwise, throw a TypeError.\n                throw webidl.errors.exception({\n                    header: `${instance.name}.formData`,\n                    message: \"Could not parse content as FormData.\"\n                });\n            }\n        }\n    };\n    return methods;\n}\nfunction mixinBody(prototype) {\n    Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function specConsumeBody(object, convertBytesToJSValue, instance) {\n    webidl.brandCheck(object, instance);\n    throwIfAborted(object[kState]);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if (bodyUnusable(object[kState].body)) {\n        throw new TypeError(\"Body is unusable\");\n    }\n    // 2. Let promise be a new promise.\n    const promise = createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If object’s body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[kState].body == null) {\n        successSteps(new Uint8Array());\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read object’s body given successSteps,\n    //    errorSteps, and object’s relevant global object.\n    await fullyReadBody(object[kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its body’s stream is disturbed or locked.\n    return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) {\n        return \"\";\n    }\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n        buffer = buffer.subarray(3);\n    }\n    // 3. Process a queue with an instance of UTF-8’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = new TextDecoder().decode(buffer);\n    // 4. Return output.\n    return output;\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function parseJSONFromBytes(bytes) {\n    return JSON.parse(utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} object\n */ function bodyMimeType(object) {\n    const { headersList } = object[kState];\n    const contentType = headersList.get(\"content-type\");\n    if (contentType === null) {\n        return \"failure\";\n    }\n    return parseMIMEType(contentType);\n}\nmodule.exports = {\n    extractBody,\n    safelyExtractBody,\n    cloneBody,\n    mixinBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9ib2R5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUNKRSxrQkFBa0IsRUFDbEJDLFVBQVUsRUFDVkMsb0JBQW9CLEVBQ3BCQyxtQkFBbUIsRUFDbkJDLHFCQUFxQixFQUNyQkMsYUFBYSxFQUNkLEdBQUdQLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFUSxRQUFRLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFUyxNQUFNLEVBQUUsR0FBR1QsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFVSxNQUFNLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFVyxZQUFZLEVBQUVDLGVBQWUsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQztBQUNsRCxNQUFNLEVBQUVhLElBQUksRUFBRUMsTUFBTUMsVUFBVSxFQUFFLEdBQUdmLG1CQUFPQSxDQUFDO0FBQzNDLE1BQU0sRUFBRWdCLFNBQVMsRUFBRSxHQUFHaEIsbUJBQU9BLENBQUM7QUFDOUIsTUFBTWlCLFNBQVNqQixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVrQixTQUFTLEVBQUUsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRW1CLFlBQVksRUFBRUMsYUFBYSxFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUNoRCxNQUFNLEVBQUVjLE1BQU1PLFVBQVUsRUFBRSxHQUFHckIsbUJBQU9BLENBQUM7QUFDckMsTUFBTSxFQUFFc0IsYUFBYSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHdkIsbUJBQU9BLENBQUM7QUFFdEQsSUFBSXdCLGlCQUFpQkMsV0FBV0QsY0FBYztBQUU5QywrQkFBK0IsR0FDL0IsTUFBTVYsT0FBT0MsY0FBY007QUFFM0IsMERBQTBEO0FBQzFELFNBQVNLLFlB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QUFNLENBQUNsQixPQUFPO0lBQ3RDLE1BQU0wRyxjQUFjaUQsWUFBWS9DLEdBQUcsQ0FBQztJQUVwQyxJQUFJRixnQkFBZ0IsTUFBTTtRQUN4QixPQUFPO0lBQ1Q7SUFFQSxPQUFPN0YsY0FBYzZGO0FBQ3ZCO0FBRUFrRCxPQUFPQyxPQUFPLEdBQUc7SUFDZjVJO0lBQ0E4RDtJQUNBQztJQUNBNkQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvYm9keS5qcz84MDI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdXNib3kgPSByZXF1aXJlKCdAZmFzdGlmeS9idXNib3knKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCbG9iTGlrZSxcbiAgaXNSZWFkYWJsZVN0cmVhbUxpa2UsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgZnVsbHlSZWFkQm9keVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgRE9NRXhjZXB0aW9uLCBzdHJ1Y3R1cmVkQ2xvbmUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgQmxvYiwgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHsgaXNFcnJvcmVkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBpc1VpbnQ4QXJyYXksIGlzQXJyYXlCdWZmZXIgfSA9IHJlcXVpcmUoJ3V0aWwvdHlwZXMnKVxuY29uc3QgeyBGaWxlOiBVbmRpY2lGaWxlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5cbmxldCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW1cblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gTmF0aXZlRmlsZSA/PyBVbmRpY2lGaWxlXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbmZ1bmN0aW9uIGV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW0pIHtcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgLy8gMS4gTGV0IHN0cmVhbSBiZSBudWxsLlxuICBsZXQgc3RyZWFtID0gbnVsbFxuXG4gIC8vIDIuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbiBzZXQgc3RyZWFtIHRvIG9iamVjdC5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgc3RyZWFtID0gb2JqZWN0XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgYSBCbG9iIG9iamVjdCwgc2V0IHN0cmVhbSB0byB0aGVcbiAgICAvLyAgICByZXN1bHQgb2YgcnVubmluZyBvYmplY3TigJlzIGdldCBzdHJlYW0uXG4gICAgc3RyZWFtID0gb2JqZWN0LnN0cmVhbSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgc3RyZWFtIHRvIGEgbmV3IFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgYW5kIHNldFxuICAgIC8vICAgIHVwIHN0cmVhbS5cbiAgICBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc291cmNlKSA6IHNvdXJjZVxuICAgICAgICApXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlcikpXG4gICAgICB9LFxuICAgICAgc3RhcnQgKCkge30sXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gQXNzZXJ0OiBzdHJlYW0gaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QuXG4gIGFzc2VydChpc1JlYWRhYmxlU3RyZWFtTGlrZShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgLy8gQnVmZmVyU291cmNlL0FycmF5QnVmZmVyXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJWaWV3XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LmJ1ZmZlci5zbGljZShvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0LmJ5dGVPZmZzZXQgKyBvYmplY3QuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShvYmplY3QpKSB7XG4gICAgY29uc3QgYm91bmRhcnkgPSBgLS0tLWZvcm1kYXRhLXVuZGljaS0wJHtgJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTExKX1gLnBhZFN0YXJ0KDExLCAnMCcpfWBcbiAgICBjb25zdCBwcmVmaXggPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YWBcblxuICAgIC8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cbiAgICBjb25zdCBlc2NhcGUgPSAoc3RyKSA9PlxuICAgICAgc3RyLnJlcGxhY2UoL1xcbi9nLCAnJTBBJykucmVwbGFjZSgvXFxyL2csICclMEQnKS5yZXBsYWNlKC9cIi9nLCAnJTIyJylcbiAgICBjb25zdCBub3JtYWxpemVMaW5lZmVlZHMgPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICdcXHJcXG4nKVxuXG4gICAgLy8gU2V0IGFjdGlvbiB0byB0aGlzIHN0ZXA6IHJ1biB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuICAgIC8vIGVuY29kaW5nIGFsZ29yaXRobSwgd2l0aCBvYmplY3TigJlzIGVudHJ5IGxpc3QgYW5kIFVURi04LlxuICAgIC8vIC0gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGJvZHkgaXMgaW1tdXRhYmxlIGFuZCBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyd29yZHNcbiAgICAvLyAtIFRoYXQgdGhlIGNvbnRlbnQtbGVuZ3RoIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZS5cbiAgICAvLyAtIEFuZCB0aGF0IGFsbCBwYXJ0cyBhcmUgcHJlLWVuY29kZWQgYW5kIHJlYWR5IHRvIGJlIHNlbnQuXG5cbiAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKVxuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdXG4gICAgY29uc3Qgcm4gPSBuZXcgVWludDhBcnJheShbMTMsIDEwXSkgLy8gJ1xcclxcbidcbiAgICBsZW5ndGggPSAwXG4gICAgbGV0IGhhc1Vua25vd25TaXplVmFsdWUgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBlbmMuZW5jb2RlKHByZWZpeCArXG4gICAgICAgICAgYDsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICBgXFxyXFxuXFxyXFxuJHtub3JtYWxpemVMaW5lZmVlZHModmFsdWUpfVxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBlbmMuZW5jb2RlKGAke3ByZWZpeH07IG5hbWU9XCIke2VzY2FwZShub3JtYWxpemVMaW5lZmVlZHMobmFtZSkpfVwiYCArXG4gICAgICAgICAgKHZhbHVlLm5hbWUgPyBgOyBmaWxlbmFtZT1cIiR7ZXNjYXBlKHZhbHVlLm5hbWUpfVwiYCA6ICcnKSArICdcXHJcXG4nICtcbiAgICAgICAgICBgQ29udGVudC1UeXBlOiAke1xuICAgICAgICAgICAgdmFsdWUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgIH1cXHJcXG5cXHJcXG5gKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaywgdmFsdWUsIHJuKVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGggKyB2YWx1ZS5zaXplICsgcm4uYnl0ZUxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc1Vua25vd25TaXplVmFsdWUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaHVuayA9IGVuYy5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLWApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgYm91bmRhcnlcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KVxuICB9XG5cbiAgLy8gMTMuIExldCBib2R5IGJlIGEgYm9keSB3aG9zZSBzdHJlYW0gaXMgc3RyZWFtLCBzb3VyY2UgaXMgc291cmNlLFxuICAvLyBhbmQgbGVuZ3RoIGlzIGxlbmd0aC5cbiAgY29uc3QgYm9keSA9IHsgc3RyZWFtLCBzb3VyY2UsIGxlbmd0aCB9XG5cbiAgLy8gMTQuIFJldHVybiAoYm9keSwgdHlwZSkuXG4gIHJldHVybiBbYm9keSwgdHlwZV1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlpbml0LXNhZmVseS1leHRyYWN0XG5mdW5jdGlvbiBzYWZlbHlFeHRyYWN0Qm9keSAob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBSZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuICB9XG5cbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChib2R5KSB7XG4gIC8vIFRvIGNsb25lIGEgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jbG9uZVxuXG4gIC8vIDEuIExldCDCqyBvdXQxLCBvdXQyIMK7IGJlIHRoZSByZXN1bHQgb2YgdGVlaW5nIGJvZHnigJlzIHN0cmVhbS5cbiAgY29uc3QgW291dDEsIG91dDJdID0gYm9keS5zdHJlYW0udGVlKClcbiAgY29uc3Qgb3V0MkNsb25lID0gc3RydWN0dXJlZENsb25lKG91dDIsIHsgdHJhbnNmZXI6IFtvdXQyXSB9KVxuICAvLyBUaGlzLCBmb3Igd2hhdGV2ZXIgcmVhc29ucywgdW5yZWZzIG91dDJDbG9uZSB3aGljaCBhbGxvd3NcbiAgLy8gdGhlIHByb2Nlc3MgdG8gZXhpdCBieSBpdHNlbGYuXG4gIGNvbnN0IFssIGZpbmFsQ2xvbmVdID0gb3V0MkNsb25lLnRlZSgpXG5cbiAgLy8gMi4gU2V0IGJvZHnigJlzIHN0cmVhbSB0byBvdXQxLlxuICBib2R5LnN0cmVhbSA9IG91dDFcblxuICAvLyAzLiBSZXR1cm4gYSBib2R5IHdob3NlIHN0cmVhbSBpcyBvdXQyIGFuZCBvdGhlciBtZW1iZXJzIGFyZSBjb3BpZWQgZnJvbSBib2R5LlxuICByZXR1cm4ge1xuICAgIHN0cmVhbTogZmluYWxDbG9uZSxcbiAgICBsZW5ndGg6IGJvZHkubGVuZ3RoLFxuICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIGNvbnN1bWVCb2R5IChib2R5KSB7XG4gIGlmIChib2R5KSB7XG4gICAgaWYgKGlzVWludDhBcnJheShib2R5KSkge1xuICAgICAgeWllbGQgYm9keVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBib2R5LnN0cmVhbVxuXG4gICAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChzdHJlYW0pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBsb2NrZWQuJylcbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGF0LlxuICAgICAgc3RyZWFtW2tCb2R5VXNlZF0gPSB0cnVlXG5cbiAgICAgIHlpZWxkICogc3RyZWFtXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SWZBYm9ydGVkIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvZHlNaXhpbk1ldGhvZHMgKGluc3RhbmNlKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgYmxvYiAoKSB7XG4gICAgICAvLyBUaGUgYmxvYigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIEJsb2Igd2hvc2VcbiAgICAgIC8vIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgd2hvc2UgdHlwZSBhdHRyaWJ1dGUgaXMgdGhpc+KAmXNcbiAgICAgIC8vIE1JTUUgdHlwZS5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZSh0aGlzKVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSAnJ1xuICAgICAgICB9IGVsc2UgaWYgKG1pbWVUeXBlKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUobWltZVR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSBCbG9iIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gaXMgbWltZVR5cGUuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYXJyYXlCdWZmZXIgKCkge1xuICAgICAgLy8gVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgLy8gb2YgcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyXG4gICAgICAvLyB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICByZXR1cm4gc3BlY0NvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlclxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIHRleHQgKCkge1xuICAgICAgLy8gVGhlIHRleHQoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIFVURi04IGRlY29kZS5cbiAgICAgIHJldHVybiBzcGVjQ29uc3VtZUJvZHkodGhpcywgdXRmOERlY29kZUJ5dGVzLCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAganNvbiAoKSB7XG4gICAgICAvLyBUaGUganNvbigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgcGFyc2UgSlNPTiBmcm9tIGJ5dGVzLlxuICAgICAgcmV0dXJuIHNwZWNDb25zdW1lQm9keSh0aGlzLCBwYXJzZUpTT05Gcm9tQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBpbnN0YW5jZSlcblxuICAgICAgdGhyb3dJZkFib3J0ZWQodGhpc1trU3RhdGVdKVxuXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpXG5cbiAgICAgIC8vIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCB0aGVuOlxuICAgICAgaWYgKC9tdWx0aXBhcnRcXC9mb3JtLWRhdGEvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmhlYWRlcnMpIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWVcblxuICAgICAgICBjb25zdCByZXNwb25zZUZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcblxuICAgICAgICBsZXQgYnVzYm95XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBidXNib3kgPSBuZXcgQnVzYm95KHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVBhdGg6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGAke2Vycn1gLCAnQWJvcnRFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICBidXNib3kub24oJ2ZpZWxkJywgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgICAgIGJ1c2JveS5vbignZmlsZScsIChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUsIGVuY29kaW5nLCBtaW1lVHlwZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdXG5cbiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnIHx8IGVuY29kaW5nLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICBsZXQgYmFzZTY0Y2h1bmsgPSAnJ1xuXG4gICAgICAgICAgICB2YWx1ZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICBiYXNlNjRjaHVuayArPSBjaHVuay50b1N0cmluZygpLnJlcGxhY2UoL1tcXHJcXG5dL2dtLCAnJylcblxuICAgICAgICAgICAgICBjb25zdCBlbmQgPSBiYXNlNjRjaHVuay5sZW5ndGggLSBiYXNlNjRjaHVuay5sZW5ndGggJSA0XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKEJ1ZmZlci5mcm9tKGJhc2U2NGNodW5rLnNsaWNlKDAsIGVuZCksICdiYXNlNjQnKSlcblxuICAgICAgICAgICAgICBiYXNlNjRjaHVuayA9IGJhc2U2NGNodW5rLnNsaWNlKGVuZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB2YWx1ZS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbShiYXNlNjRjaHVuaywgJ2Jhc2U2NCcpKVxuICAgICAgICAgICAgICByZXNwb25zZUZvcm1EYXRhLmFwcGVuZChuYW1lLCBuZXcgRmlsZShjaHVua3MsIGZpbGVuYW1lLCB7IHR5cGU6IG1pbWVUeXBlIH0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFsdWUub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtRGF0YS5hcHBlbmQobmFtZSwgbmV3IEZpbGUoY2h1bmtzLCBmaWxlbmFtZSwgeyB0eXBlOiBtaW1lVHlwZSB9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGJ1c2JveVJlc29sdmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgYnVzYm95Lm9uKCdmaW5pc2gnLCByZXNvbHZlKVxuICAgICAgICAgIGJ1c2JveS5vbignZXJyb3InLCAoZXJyKSA9PiByZWplY3QobmV3IFR5cGVFcnJvcihlcnIpKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodGhpcy5ib2R5ICE9PSBudWxsKSBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCb2R5KHRoaXNba1N0YXRlXS5ib2R5KSkgYnVzYm95LndyaXRlKGNodW5rKVxuICAgICAgICBidXNib3kuZW5kKClcbiAgICAgICAgYXdhaXQgYnVzYm95UmVzb2x2ZVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZUZvcm1EYXRhXG4gICAgICB9IGVsc2UgaWYgKC9hcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZC8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCB0aGVuOlxuXG4gICAgICAgIC8vIDEuIExldCBlbnRyaWVzIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBieXRlcy5cbiAgICAgICAgbGV0IGVudHJpZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgdGV4dCA9ICcnXG4gICAgICAgICAgLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHBhcnNlciB3aWxsIGtlZXAgdGhlIEJPTS5cbiAgICAgICAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsZW5jb2RlZC1wYXJzZXJcbiAgICAgICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGlnbm9yZUJPTTogdHJ1ZSB9KVxuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJvZHkodGhpc1trU3RhdGVdLmJvZHkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheSBjaHVuaycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IHRleHREZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCArPSB0ZXh0RGVjb2Rlci5kZWNvZGUoKVxuICAgICAgICAgIGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRleHQpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBVbmNsZWFyIHdoZW4gbmV3IFVSTFNlYXJjaFBhcmFtcyBjYW4gZmFpbCBvbiBhIHN0cmluZy5cbiAgICAgICAgICAvLyAyLiBJZiBlbnRyaWVzIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCksIHsgY2F1c2U6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gUmV0dXJuIGEgbmV3IEZvcm1EYXRhIG9iamVjdCB3aG9zZSBlbnRyaWVzIGFyZSBlbnRyaWVzLlxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtRGF0YVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2FpdCBhIHRpY2sgYmVmb3JlIGNoZWNraW5nIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYSBUeXBlRXJyb3IgY2FuIGJlIHRocm93biB3aGVuIGFuIEFib3J0RXJyb3Igc2hvdWxkLlxuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKVxuXG4gICAgICAgIHRocm93SWZBYm9ydGVkKHRoaXNba1N0YXRlXSlcblxuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBgJHtpbnN0YW5jZS5uYW1lfS5mb3JtRGF0YWAsXG4gICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBwYXJzZSBjb250ZW50IGFzIEZvcm1EYXRhLidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5mdW5jdGlvbiBtaXhpbkJvZHkgKHByb3RvdHlwZSkge1xuICBPYmplY3QuYXNzaWduKHByb3RvdHlwZS5wcm90b3R5cGUsIGJvZHlNaXhpbk1ldGhvZHMocHJvdG90eXBlKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IG9iamVjdFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHVua25vd259IGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICogQHBhcmFtIHtSZXNwb25zZXxSZXF1ZXN0fSBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBzcGVjQ29uc3VtZUJvZHkgKG9iamVjdCwgY29udmVydEJ5dGVzVG9KU1ZhbHVlLCBpbnN0YW5jZSkge1xuICB3ZWJpZGwuYnJhbmRDaGVjayhvYmplY3QsIGluc3RhbmNlKVxuXG4gIHRocm93SWZBYm9ydGVkKG9iamVjdFtrU3RhdGVdKVxuXG4gIC8vIDEuIElmIG9iamVjdCBpcyB1bnVzYWJsZSwgdGhlbiByZXR1cm4gYSBwcm9taXNlIHJlamVjdGVkXG4gIC8vICAgIHdpdGggYSBUeXBlRXJyb3IuXG4gIGlmIChib2R5VW51c2FibGUob2JqZWN0W2tTdGF0ZV0uYm9keSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IGlzIHVudXNhYmxlJylcbiAgfVxuXG4gIC8vIDIuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGdpdmVuIGVycm9yIGJlIHRvIHJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGNvbnN0IGVycm9yU3RlcHMgPSAoZXJyb3IpID0+IHByb21pc2UucmVqZWN0KGVycm9yKVxuXG4gIC8vIDQuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGRhdGEgYmUgdG8gcmVzb2x2ZVxuICAvLyAgICBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICAvLyAgICB3aXRoIGRhdGEuIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzXG4gIC8vICAgIHdpdGggdGhhdCBleGNlcHRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUoZGF0YSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JTdGVwcyhlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDUuIElmIG9iamVjdOKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBzdWNjZXNzU3RlcHMgd2l0aCBhblxuICAvLyAgICBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICBpZiAob2JqZWN0W2tTdGF0ZV0uYm9keSA9PSBudWxsKSB7XG4gICAgc3VjY2Vzc1N0ZXBzKG5ldyBVaW50OEFycmF5KCkpXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLy8gNi4gT3RoZXJ3aXNlLCBmdWxseSByZWFkIG9iamVjdOKAmXMgYm9keSBnaXZlbiBzdWNjZXNzU3RlcHMsXG4gIC8vICAgIGVycm9yU3RlcHMsIGFuZCBvYmplY3TigJlzIHJlbGV2YW50IGdsb2JhbCBvYmplY3QuXG4gIGF3YWl0IGZ1bGx5UmVhZEJvZHkob2JqZWN0W2tTdGF0ZV0uYm9keSwgc3VjY2Vzc1N0ZXBzLCBlcnJvclN0ZXBzKVxuXG4gIC8vIDcuIFJldHVybiBwcm9taXNlLlxuICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG5mdW5jdGlvbiBib2R5VW51c2FibGUgKGJvZHkpIHtcbiAgLy8gQW4gb2JqZWN0IGluY2x1ZGluZyB0aGUgQm9keSBpbnRlcmZhY2UgbWl4aW4gaXNcbiAgLy8gc2FpZCB0byBiZSB1bnVzYWJsZSBpZiBpdHMgYm9keSBpcyBub24tbnVsbCBhbmRcbiAgLy8gaXRzIGJvZHnigJlzIHN0cmVhbSBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLlxuICByZXR1cm4gYm9keSAhPSBudWxsICYmIChib2R5LnN0cmVhbS5sb2NrZWQgfHwgdXRpbC5pc0Rpc3R1cmJlZChib2R5LnN0cmVhbSkpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHV0ZjhEZWNvZGVCeXRlcyAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyAxLiBMZXQgYnVmZmVyIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyB0aHJlZSBieXRlcyBmcm9tXG4gIC8vICAgIGlvUXVldWUsIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG5cbiAgLy8gMi4gSWYgYnVmZmVyIGlzIDB4RUYgMHhCQiAweEJGLCB0aGVuIHJlYWQgdGhyZWVcbiAgLy8gICAgYnl0ZXMgZnJvbSBpb1F1ZXVlLiAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgaWYgKGJ1ZmZlclswXSA9PT0gMHhFRiAmJiBidWZmZXJbMV0gPT09IDB4QkIgJiYgYnVmZmVyWzJdID09PSAweEJGKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDMpXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBVVEYtOOKAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuICBjb25zdCBvdXRwdXQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKVxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1qc29uLWJ5dGVzLXRvLWEtamF2YXNjcmlwdC12YWx1ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gcm9tQnl0ZXMgKGJ5dGVzKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVCeXRlcyhieXRlcykpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVzcG9uc2UnKS5SZXNwb25zZXxpbXBvcnQoJy4vcmVxdWVzdCcpLlJlcXVlc3R9IG9iamVjdFxuICovXG5mdW5jdGlvbiBib2R5TWltZVR5cGUgKG9iamVjdCkge1xuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBvYmplY3Rba1N0YXRlXVxuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnNMaXN0LmdldCgnY29udGVudC10eXBlJylcblxuICBpZiAoY29udGVudFR5cGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICByZXR1cm4gcGFyc2VNSU1FVHlwZShjb250ZW50VHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dHJhY3RCb2R5LFxuICBzYWZlbHlFeHRyYWN0Qm9keSxcbiAgY2xvbmVCb2R5LFxuICBtaXhpbkJvZHlcbn1cbiJdLCJuYW1lcyI6WyJCdXNib3kiLCJyZXF1aXJlIiwidXRpbCIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsImlzQmxvYkxpa2UiLCJpc1JlYWRhYmxlU3RyZWFtTGlrZSIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJmdWxseVJlYWRCb2R5IiwiRm9ybURhdGEiLCJrU3RhdGUiLCJ3ZWJpZGwiLCJET01FeGNlcHRpb24iLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJCbG9iIiwiRmlsZSIsIk5hdGl2ZUZpbGUiLCJrQm9keVVzZWQiLCJhc3NlcnQiLCJpc0Vycm9yZWQiLCJpc1VpbnQ4QXJyYXkiLCJpc0FycmF5QnVmZmVyIiwiVW5kaWNpRmlsZSIsInBhcnNlTUlNRVR5cGUiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJSZWFkYWJsZVN0cmVhbSIsImdsb2JhbFRoaXMiLCJleHRyYWN0Qm9keSIsIm9iamVjdCIsImtlZXBhbGl2ZSIsInN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZW5xdWV1ZSIsInNvdXJjZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwicXVldWVNaWNyb3Rhc2siLCJzdGFydCIsInR5cGUiLCJ1bmRlZmluZWQiLCJhY3Rpb24iLCJsZW5ndGgiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJpc0Zvcm1EYXRhTGlrZSIsImJvdW5kYXJ5IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGFkU3RhcnQiLCJwcmVmaXgiLCJlc2NhcGUiLCJzdHIiLCJyZXBsYWNlIiwibm9ybWFsaXplTGluZWZlZWRzIiwidmFsdWUiLCJlbmMiLCJibG9iUGFydHMiLCJybiIsImhhc1Vua25vd25TaXplVmFsdWUiLCJuYW1lIiwiY2h1bmsiLCJwdXNoIiwic2l6ZSIsInBhcnQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiVHlwZUVycm9yIiwiaXNEaXN0dXJiZWQiLCJsb2NrZWQiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIml0ZXJhdG9yIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImRlc2lyZWRTaXplIiwiY2FuY2VsIiwicmVhc29uIiwicmV0dXJuIiwiYm9keSIsInNhZmVseUV4dHJhY3RCb2R5IiwiY2xvbmVCb2R5Iiwib3V0MSIsIm91dDIiLCJ0ZWUiLCJvdXQyQ2xvbmUiLCJ0cmFuc2ZlciIsImZpbmFsQ2xvbmUiLCJjb25zdW1lQm9keSIsInRocm93SWZBYm9ydGVkIiwic3RhdGUiLCJhYm9ydGVkIiwiYm9keU1peGluTWV0aG9kcyIsImluc3RhbmNlIiwibWV0aG9kcyIsImJsb2IiLCJzcGVjQ29uc3VtZUJvZHkiLCJieXRlcyIsIm1pbWVUeXBlIiwiYm9keU1pbWVUeXBlIiwiYXJyYXlCdWZmZXIiLCJ0ZXh0IiwidXRmOERlY29kZUJ5dGVzIiwianNvbiIsInBhcnNlSlNPTkZyb21CeXRlcyIsImZvcm1EYXRhIiwiYnJhbmRDaGVjayIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImdldCIsInRlc3QiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInJlc3BvbnNlRm9ybURhdGEiLCJidXNib3kiLCJwcmVzZXJ2ZVBhdGgiLCJlcnIiLCJvbiIsImFwcGVuZCIsImZpbGVuYW1lIiwiZW5jb2RpbmciLCJjaHVua3MiLCJiYXNlNjRjaHVuayIsImVuZCIsImZyb20iLCJidXNib3lSZXNvbHZlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3cml0ZSIsImVudHJpZXMiLCJ0ZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwiaWdub3JlQk9NIiwiZGVjb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwiY2F1c2UiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJtZXNzYWdlIiwibWl4aW5Cb2R5IiwicHJvdG90eXBlIiwiY29udmVydEJ5dGVzVG9KU1ZhbHVlIiwiYm9keVVudXNhYmxlIiwicHJvbWlzZSIsImVycm9yU3RlcHMiLCJlcnJvciIsInN1Y2Nlc3NTdGVwcyIsImRhdGEiLCJlIiwic3ViYXJyYXkiLCJvdXRwdXQiLCJKU09OIiwicGFyc2UiLCJoZWFkZXJzTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/body.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/fetch/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { MessageChannel, receiveMessageOnPort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst corsSafeListedMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"POST\"\n];\nconst nullBodyStatus = [\n    101,\n    204,\n    205,\n    304\n];\nconst redirectStatus = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n    \"1\",\n    \"7\",\n    \"9\",\n    \"11\",\n    \"13\",\n    \"15\",\n    \"17\",\n    \"19\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"25\",\n    \"37\",\n    \"42\",\n    \"43\",\n    \"53\",\n    \"69\",\n    \"77\",\n    \"79\",\n    \"87\",\n    \"95\",\n    \"101\",\n    \"102\",\n    \"103\",\n    \"104\",\n    \"109\",\n    \"110\",\n    \"111\",\n    \"113\",\n    \"115\",\n    \"117\",\n    \"119\",\n    \"123\",\n    \"135\",\n    \"137\",\n    \"139\",\n    \"143\",\n    \"161\",\n    \"179\",\n    \"389\",\n    \"427\",\n    \"465\",\n    \"512\",\n    \"513\",\n    \"514\",\n    \"515\",\n    \"526\",\n    \"530\",\n    \"531\",\n    \"532\",\n    \"540\",\n    \"548\",\n    \"554\",\n    \"556\",\n    \"563\",\n    \"587\",\n    \"601\",\n    \"636\",\n    \"989\",\n    \"990\",\n    \"993\",\n    \"995\",\n    \"1719\",\n    \"1720\",\n    \"1723\",\n    \"2049\",\n    \"3659\",\n    \"4045\",\n    \"5060\",\n    \"5061\",\n    \"6000\",\n    \"6566\",\n    \"6665\",\n    \"6666\",\n    \"6667\",\n    \"6668\",\n    \"6669\",\n    \"6697\",\n    \"10080\"\n];\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n];\nconst requestRedirect = [\n    \"follow\",\n    \"manual\",\n    \"error\"\n];\nconst safeMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"TRACE\"\n];\nconst requestMode = [\n    \"navigate\",\n    \"same-origin\",\n    \"no-cors\",\n    \"cors\"\n];\nconst requestCredentials = [\n    \"omit\",\n    \"same-origin\",\n    \"include\"\n];\nconst requestCache = [\n    \"default\",\n    \"no-store\",\n    \"reload\",\n    \"no-cache\",\n    \"force-cache\",\n    \"only-if-cached\"\n];\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-type\",\n    // See https://github.com/nodejs/undici/issues/2021\n    // 'Content-Length' is a forbidden header name, which is typically\n    // removed in the Headers implementation. However, undici doesn't\n    // filter out headers, so we add it here.\n    \"content-length\"\n];\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n    \"half\"\n];\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = [\n    \"CONNECT\",\n    \"TRACE\",\n    \"TRACK\"\n];\nconst subresource = [\n    \"audio\",\n    \"audioworklet\",\n    \"font\",\n    \"image\",\n    \"manifest\",\n    \"paintworklet\",\n    \"script\",\n    \"style\",\n    \"track\",\n    \"video\",\n    \"xslt\",\n    \"\"\n];\n/** @type {globalThis['DOMException']} */ const DOMException = globalThis.DOMException ?? (()=>{\n    // DOMException was only made a global in Node v17.0.0,\n    // but fetch supports >= v16.8.\n    try {\n        atob(\"~\");\n    } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n    }\n})();\nlet channel;\n/** @type {globalThis['structuredClone']} */ const structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js\n// structuredClone was added in v17.0.0, but fetch supports v16.8\nfunction structuredClone(value, options = undefined) {\n    if (arguments.length === 0) {\n        throw new TypeError(\"missing argument\");\n    }\n    if (!channel) {\n        channel = new MessageChannel();\n    }\n    channel.port1.unref();\n    channel.port2.unref();\n    channel.port1.postMessage(value, options?.transfer);\n    return receiveMessageOnPort(channel.port2).message;\n};\nmodule.exports = {\n    DOMException,\n    structuredClone,\n    subresource,\n    forbiddenMethods,\n    requestBodyHeader,\n    referrerPolicy,\n    requestRedirect,\n    requestMode,\n    requestCredentials,\n    requestCache,\n    redirectStatus,\n    corsSafeListedMethods,\n    nullBodyStatus,\n    safeMethods,\n    badPorts,\n    requestDuplex\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFekQsTUFBTUMsd0JBQXdCO0lBQUM7SUFBTztJQUFRO0NBQU87QUFFckQsTUFBTUMsaUJBQWlCO0lBQUM7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUUzQyxNQUFNQyxpQkFBaUI7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFaEQsZ0RBQWdEO0FBQ2hELE1BQU1DLFdBQVc7SUFDZjtJQUFLO0lBQUs7SUFBSztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQy9HO0lBQU07SUFBTTtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQ3ZHO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUNsRztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFRO0lBQVE7SUFDcEc7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFDaEc7Q0FDRDtBQUVELHFFQUFxRTtBQUNyRSxNQUFNQyxpQkFBaUI7SUFDckI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyxrQkFBa0I7SUFBQztJQUFVO0lBQVU7Q0FBUTtBQUVyRCxNQUFNQyxjQUFjO0lBQUM7SUFBTztJQUFRO0lBQVc7Q0FBUTtBQUV2RCxNQUFNQyxjQUFjO0lBQUM7SUFBWTtJQUFlO0lBQVc7Q0FBTztBQUVsRSxNQUFNQyxxQkFBcUI7SUFBQztJQUFRO0lBQWU7Q0FBVTtBQUU3RCxNQUFNQyxlQUFlO0lBQ25CO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsMERBQTBEO0FBQzFELE1BQU1DLG9CQUFvQjtJQUN4QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLG1EQUFtRDtJQUNuRCxrRUFBa0U7SUFDbEUsaUVBQWlFO0lBQ2pFLHlDQUF5QztJQUN6QztDQUNEO0FBRUQsdURBQXVEO0FBQ3ZELE1BQU1DLGdCQUFnQjtJQUNwQjtDQUNEO0FBRUQsaURBQWlEO0FBQ2pELE1BQU1DLG1CQUFtQjtJQUFDO0lBQVc7SUFBUztDQUFRO0FBRXRELE1BQU1DLGNBQWM7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCx1Q0FBdUMsR0FDdkMsTUFBTUMsZUFBZUMsV0FBV0QsWUFBWSxJQUFJLENBQUM7SUFDL0MsdURBQXVEO0lBQ3ZELCtCQUErQjtJQUMvQixJQUFJO1FBQ0ZFLEtBQUs7SUFDUCxFQUFFLE9BQU9DLEtBQUs7UUFDWixPQUFPQyxPQUFPQyxjQUFjLENBQUNGLEtBQUtHLFdBQVc7SUFDL0M7QUFDRjtBQUVBLElBQUlDO0FBRUosMENBQTBDLEdBQzFDLE1BQU1DLGtCQUNKUCxXQUFXTyxlQUFlLElBQzFCLGdIQUFnSDtBQUNoSCxpRUFBaUU7QUFDakUsU0FBU0EsZ0JBQWlCQyxLQUFLLEVBQUVDLFVBQVVDLFNBQVM7SUFDbEQsSUFBSUMsVUFBVUMsTUFBTSxLQUFLLEdBQUc7UUFDMUIsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0lBRUEsSUFBSSxDQUFDUCxTQUFTO1FBQ1pBLFVBQVUsSUFBSXhCO0lBQ2hCO0lBQ0F3QixRQUFRUSxLQUFLLENBQUNDLEtBQUs7SUFDbkJULFFBQVFVLEtBQUssQ0FBQ0QsS0FBSztJQUNuQlQsUUFBUVEsS0FBSyxDQUFDRyxXQUFXLENBQUNULE9BQU9DLFNBQVNTO0lBQzFDLE9BQU9uQyxxQkFBcUJ1QixRQUFRVSxLQUFLLEVBQUVHLE9BQU87QUFDcEQ7QUFFRkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z0QjtJQUNBUTtJQUNBVDtJQUNBRDtJQUNBRjtJQUNBTjtJQUNBQztJQUNBRTtJQUNBQztJQUNBQztJQUNBUDtJQUNBRjtJQUNBQztJQUNBSztJQUNBSDtJQUNBUTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9jb25zdGFudHMuanM/MTFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNZXNzYWdlQ2hhbm5lbCwgcmVjZWl2ZU1lc3NhZ2VPblBvcnQgfSA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJylcblxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdQT1NUJ11cblxuY29uc3QgbnVsbEJvZHlTdGF0dXMgPSBbMTAxLCAyMDQsIDIwNSwgMzA0XVxuXG5jb25zdCByZWRpcmVjdFN0YXR1cyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Jsb2NrLWJhZC1wb3J0XG5jb25zdCBiYWRQb3J0cyA9IFtcbiAgJzEnLCAnNycsICc5JywgJzExJywgJzEzJywgJzE1JywgJzE3JywgJzE5JywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI1JywgJzM3JywgJzQyJywgJzQzJywgJzUzJywgJzY5JywgJzc3JywgJzc5JyxcbiAgJzg3JywgJzk1JywgJzEwMScsICcxMDInLCAnMTAzJywgJzEwNCcsICcxMDknLCAnMTEwJywgJzExMScsICcxMTMnLCAnMTE1JywgJzExNycsICcxMTknLCAnMTIzJywgJzEzNScsICcxMzcnLFxuICAnMTM5JywgJzE0MycsICcxNjEnLCAnMTc5JywgJzM4OScsICc0MjcnLCAnNDY1JywgJzUxMicsICc1MTMnLCAnNTE0JywgJzUxNScsICc1MjYnLCAnNTMwJywgJzUzMScsICc1MzInLFxuICAnNTQwJywgJzU0OCcsICc1NTQnLCAnNTU2JywgJzU2MycsICc1ODcnLCAnNjAxJywgJzYzNicsICc5ODknLCAnOTkwJywgJzk5MycsICc5OTUnLCAnMTcxOScsICcxNzIwJywgJzE3MjMnLFxuICAnMjA0OScsICczNjU5JywgJzQwNDUnLCAnNTA2MCcsICc1MDYxJywgJzYwMDAnLCAnNjU2NicsICc2NjY1JywgJzY2NjYnLCAnNjY2NycsICc2NjY4JywgJzY2NjknLCAnNjY5NycsXG4gICcxMDA4MCdcbl1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljaWVzXG5jb25zdCByZWZlcnJlclBvbGljeSA9IFtcbiAgJycsXG4gICduby1yZWZlcnJlcicsXG4gICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICdzYW1lLW9yaWdpbicsXG4gICdvcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbicsXG4gICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICd1bnNhZmUtdXJsJ1xuXVxuXG5jb25zdCByZXF1ZXN0UmVkaXJlY3QgPSBbJ2ZvbGxvdycsICdtYW51YWwnLCAnZXJyb3InXVxuXG5jb25zdCBzYWZlTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddXG5cbmNvbnN0IHJlcXVlc3RNb2RlID0gWyduYXZpZ2F0ZScsICdzYW1lLW9yaWdpbicsICduby1jb3JzJywgJ2NvcnMnXVxuXG5jb25zdCByZXF1ZXN0Q3JlZGVudGlhbHMgPSBbJ29taXQnLCAnc2FtZS1vcmlnaW4nLCAnaW5jbHVkZSddXG5cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IFtcbiAgJ2RlZmF1bHQnLFxuICAnbm8tc3RvcmUnLFxuICAncmVsb2FkJyxcbiAgJ25vLWNhY2hlJyxcbiAgJ2ZvcmNlLWNhY2hlJyxcbiAgJ29ubHktaWYtY2FjaGVkJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1ib2R5LWhlYWRlci1uYW1lXG5jb25zdCByZXF1ZXN0Qm9keUhlYWRlciA9IFtcbiAgJ2NvbnRlbnQtZW5jb2RpbmcnLFxuICAnY29udGVudC1sYW5ndWFnZScsXG4gICdjb250ZW50LWxvY2F0aW9uJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAyMVxuICAvLyAnQ29udGVudC1MZW5ndGgnIGlzIGEgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCB3aGljaCBpcyB0eXBpY2FsbHlcbiAgLy8gcmVtb3ZlZCBpbiB0aGUgSGVhZGVycyBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdW5kaWNpIGRvZXNuJ3RcbiAgLy8gZmlsdGVyIG91dCBoZWFkZXJzLCBzbyB3ZSBhZGQgaXQgaGVyZS5cbiAgJ2NvbnRlbnQtbGVuZ3RoJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZW51bWRlZi1yZXF1ZXN0ZHVwbGV4XG5jb25zdCByZXF1ZXN0RHVwbGV4ID0gW1xuICAnaGFsZidcbl1cblxuLy8gaHR0cDovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZm9yYmlkZGVuLW1ldGhvZFxuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IFsnQ09OTkVDVCcsICdUUkFDRScsICdUUkFDSyddXG5cbmNvbnN0IHN1YnJlc291cmNlID0gW1xuICAnYXVkaW8nLFxuICAnYXVkaW93b3JrbGV0JyxcbiAgJ2ZvbnQnLFxuICAnaW1hZ2UnLFxuICAnbWFuaWZlc3QnLFxuICAncGFpbnR3b3JrbGV0JyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0cmFjaycsXG4gICd2aWRlbycsXG4gICd4c2x0JyxcbiAgJydcbl1cblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydET01FeGNlcHRpb24nXX0gKi9cbmNvbnN0IERPTUV4Y2VwdGlvbiA9IGdsb2JhbFRoaXMuRE9NRXhjZXB0aW9uID8/ICgoKSA9PiB7XG4gIC8vIERPTUV4Y2VwdGlvbiB3YXMgb25seSBtYWRlIGEgZ2xvYmFsIGluIE5vZGUgdjE3LjAuMCxcbiAgLy8gYnV0IGZldGNoIHN1cHBvcnRzID49IHYxNi44LlxuICB0cnkge1xuICAgIGF0b2IoJ34nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikuY29uc3RydWN0b3JcbiAgfVxufSkoKVxuXG5sZXQgY2hhbm5lbFxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ3N0cnVjdHVyZWRDbG9uZSddfSAqL1xuY29uc3Qgc3RydWN0dXJlZENsb25lID1cbiAgZ2xvYmFsVGhpcy5zdHJ1Y3R1cmVkQ2xvbmUgPz9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjI3YWUyNGRjYzQyNTFiYWQ3MjZkOWQ4NGJhZjY3OGQxZjcwN2ZlZC9saWIvaW50ZXJuYWwvc3RydWN0dXJlZF9jbG9uZS5qc1xuICAvLyBzdHJ1Y3R1cmVkQ2xvbmUgd2FzIGFkZGVkIGluIHYxNy4wLjAsIGJ1dCBmZXRjaCBzdXBwb3J0cyB2MTYuOFxuICBmdW5jdGlvbiBzdHJ1Y3R1cmVkQ2xvbmUgKHZhbHVlLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgYXJndW1lbnQnKVxuICAgIH1cblxuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpXG4gICAgfVxuICAgIGNoYW5uZWwucG9ydDEudW5yZWYoKVxuICAgIGNoYW5uZWwucG9ydDIudW5yZWYoKVxuICAgIGNoYW5uZWwucG9ydDEucG9zdE1lc3NhZ2UodmFsdWUsIG9wdGlvbnM/LnRyYW5zZmVyKVxuICAgIHJldHVybiByZWNlaXZlTWVzc2FnZU9uUG9ydChjaGFubmVsLnBvcnQyKS5tZXNzYWdlXG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIERPTUV4Y2VwdGlvbixcbiAgc3RydWN0dXJlZENsb25lLFxuICBzdWJyZXNvdXJjZSxcbiAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVkaXJlY3RTdGF0dXMsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzLFxuICBiYWRQb3J0cyxcbiAgcmVxdWVzdER1cGxleFxufVxuIl0sIm5hbWVzIjpbIk1lc3NhZ2VDaGFubmVsIiwicmVjZWl2ZU1lc3NhZ2VPblBvcnQiLCJyZXF1aXJlIiwiY29yc1NhZmVMaXN0ZWRNZXRob2RzIiwibnVsbEJvZHlTdGF0dXMiLCJyZWRpcmVjdFN0YXR1cyIsImJhZFBvcnRzIiwicmVmZXJyZXJQb2xpY3kiLCJyZXF1ZXN0UmVkaXJlY3QiLCJzYWZlTWV0aG9kcyIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdEJvZHlIZWFkZXIiLCJyZXF1ZXN0RHVwbGV4IiwiZm9yYmlkZGVuTWV0aG9kcyIsInN1YnJlc291cmNlIiwiRE9NRXhjZXB0aW9uIiwiZ2xvYmFsVGhpcyIsImF0b2IiLCJlcnIiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsInN0cnVjdHVyZWRDbG9uZSIsInZhbHVlIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIlR5cGVFcnJvciIsInBvcnQxIiwidW5yZWYiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwidHJhbnNmZXIiLCJtZXNzYWdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/dataURL.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/dataURL.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! assert */ \"assert\");\nconst { atob } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { isomorphicDecode } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /(\\u000A|\\u000D|\\u0009|\\u0020)/ // eslint-disable-line\n;\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const HTTP_QUOTED_STRING_TOKENS = /[\\u0009|\\u0020-\\u007E|\\u0080-\\u00FF]/ // eslint-disable-line\n;\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function dataURLProcessor(dataURL) {\n    // 1. Assert: dataURL’s scheme is \"data\".\n    assert(dataURL.protocol === \"data:\");\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = collectASequenceOfCodePointsFast(\",\", input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) {\n        return \"failure\";\n    }\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === \"failure\") {\n            return \"failure\";\n        }\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n    }\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n    }\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function URLSerializer(url, excludeFragment = false) {\n    const href = url.href;\n    if (!excludeFragment) {\n        return href;\n    }\n    const hash = href.lastIndexOf(\"#\");\n    if (hash === -1) {\n        return href;\n    }\n    return href.slice(0, hash);\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = \"\";\n    // 2. While position doesn’t point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return percentDecode(bytes);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function percentDecode(input) {\n    // 1. Let output be an empty byte sequence.\n    /** @type {number[]} */ const output = [];\n    // 2. For each byte byte in input:\n    for(let i = 0; i < input.length; i++){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) {\n            output.push(byte);\n        // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n        // after byte in input are not in the ranges\n        // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n        // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n        // to output.\n        } else if (byte === 0x25 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {\n            output.push(0x25);\n        // 3. Otherwise:\n        } else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);\n            const bytePoint = Number.parseInt(nextTwoBytes, 16);\n            // 2. Append a byte whose value is bytePoint to output.\n            output.push(bytePoint);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return Uint8Array.from(output);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = collectASequenceOfCodePointsFast(\"/\", input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n        return \"failure\";\n    }\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) {\n        return \"failure\";\n    }\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = collectASequenceOfCodePointsFast(\";\", input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n        return \"failure\";\n    }\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = collectASequenceOfCodePoints((char)=>char !== \";\" && char !== \"=\", input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === \";\") {\n                continue;\n            }\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) {\n            break;\n        }\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            collectASequenceOfCodePointsFast(\";\", input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = collectASequenceOfCodePointsFast(\";\", input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) {\n                continue;\n            }\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeType’s parameters[parameterName] does not exist\n        // then set mimeType’s parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n            mimeType.parameters.set(parameterName, parameterValue);\n        }\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, \"\") // eslint-disable-line\n    ;\n    // 2. If data’s code point length divides by 4 leaving\n    // no remainder, then:\n    if (data.length % 4 === 0) {\n        // 1. If data ends with one or two U+003D (=) code points,\n        // then remove them from data.\n        data = data.replace(/=?=$/, \"\");\n    }\n    // 3. If data’s code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (data.length % 4 === 1) {\n        return \"failure\";\n    }\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data)) {\n        return \"failure\";\n    }\n    const binary = atob(data);\n    const bytes = new Uint8Array(binary.length);\n    for(let byte = 0; byte < binary.length; byte++){\n        bytes[byte] = binary.charCodeAt(byte);\n    }\n    return bytes;\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = \"\";\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== \"\\\\\", input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) {\n            break;\n        }\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === \"\\\\\") {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += \"\\\\\";\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) {\n        return value;\n    }\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function serializeAMimeType(mimeType) {\n    assert(mimeType !== \"failure\");\n    const { parameters, essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeType’s\n    //    type, U+002F (/), and mimeType’s subtype.\n    let serialization = essence;\n    // 2. For each name → value of mimeType’s parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += \";\";\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += \"=\";\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, \"\\\\$1\");\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} char\n */ function isHTTPWhiteSpace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \" \";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n */ function removeHTTPWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {string} char\n */ function isASCIIWhitespace(char) {\n    return char === \"\\r\" || char === \"\\n\" || char === \"\t\" || char === \"\\f\" || char === \" \";\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n */ function removeASCIIWhitespace(str, leading = true, trailing = true) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        for(; lead < str.length && isASCIIWhitespace(str[lead]); lead++);\n    }\n    if (trailing) {\n        for(; trail > 0 && isASCIIWhitespace(str[trail]); trail--);\n    }\n    return str.slice(lead, trail + 1);\n}\nmodule.exports = {\n    dataURLProcessor,\n    URLSerializer,\n    collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast,\n    stringPercentDecode,\n    parseMIMEType,\n    collectAnHTTPQuotedString,\n    serializeAMimeType\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9kYXRhVVJMLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRUUsZ0JBQWdCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFFckMsTUFBTUcsVUFBVSxJQUFJQztBQUVwQjs7Q0FFQyxHQUNELE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyx3QkFBd0IsZ0NBQWdDLHNCQUFzQjs7QUFDcEY7O0NBRUMsR0FDRCxNQUFNQyw0QkFBNEIsdUNBQXVDLHNCQUFzQjs7QUFFL0Ysb0RBQW9EO0FBQ3BELHlCQUF5QixHQUN6QixTQUFTQyxpQkFBa0JDLE9BQU87SUFDaEMseUNBQXlDO0lBQ3pDVixPQUFPVSxRQUFRQyxRQUFRLEtBQUs7SUFFNUIsZ0RBQWdEO0lBQ2hELDhDQUE4QztJQUM5QyxlQUFlO0lBQ2YsSUFBSUMsUUFBUUMsY0FBY0gsU0FBUztJQUVuQyxtREFBbUQ7SUFDbkRFLFFBQVFBLE1BQU1FLEtBQUssQ0FBQztJQUVwQiwrQ0FBK0M7SUFDL0MsTUFBTUMsV0FBVztRQUFFQSxVQUFVO0lBQUU7SUFFL0IsZ0RBQWdEO0lBQ2hELDZDQUE2QztJQUM3QyxpQ0FBaUM7SUFDakMsSUFBSUMsV0FBV0MsaUNBQ2IsS0FDQUwsT0FDQUc7SUFHRixpREFBaUQ7SUFDakQsaUJBQWlCO0lBQ2pCLG1EQUFtRDtJQUNuRCxxREFBcUQ7SUFDckQsb0RBQW9EO0lBQ3BELFVBQVU7SUFDVixNQUFNRyxpQkFBaUJGLFNBQVNHLE1BQU07SUFDdENILFdBQVdJLHNCQUFzQkosVUFBVSxNQUFNO0lBRWpELGdEQUFnRDtJQUNoRCxpQkFBaUI7SUFDakIsSUFBSUQsU0FBU0EsUUFBUSxJQUFJSCxNQUFNTyxNQUFNLEVBQUU7UUFDckMsT0FBTztJQUNUO0lBRUEsNEJBQTRCO0lBQzVCSixT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L2RhdGFVUkwuanM/NjY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBhdG9iIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBpc29tb3JwaGljRGVjb2RlIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gKi9cbmNvbnN0IEhUVFBfVE9LRU5fQ09ERVBPSU5UUyA9IC9eWyEjJCUmJyorLS5eX3x+QS1aYS16MC05XSskL1xuY29uc3QgSFRUUF9XSElURVNQQUNFX1JFR0VYID0gLyhcXHUwMDBBfFxcdTAwMER8XFx1MDAwOXxcXHUwMDIwKS8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1xdW90ZWQtc3RyaW5nLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyA9IC9bXFx1MDAwOXxcXHUwMDIwLVxcdTAwN0V8XFx1MDA4MC1cXHUwMEZGXS8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtcHJvY2Vzc29yXG4vKiogQHBhcmFtIHtVUkx9IGRhdGFVUkwgKi9cbmZ1bmN0aW9uIGRhdGFVUkxQcm9jZXNzb3IgKGRhdGFVUkwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBkYXRhVVJM4oCZcyBzY2hlbWUgaXMgXCJkYXRhXCIuXG4gIGFzc2VydChkYXRhVVJMLnByb3RvY29sID09PSAnZGF0YTonKVxuXG4gIC8vIDIuIExldCBpbnB1dCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIFVSTFxuICAvLyBzZXJpYWxpemVyIG9uIGRhdGFVUkwgd2l0aCBleGNsdWRlIGZyYWdtZW50XG4gIC8vIHNldCB0byB0cnVlLlxuICBsZXQgaW5wdXQgPSBVUkxTZXJpYWxpemVyKGRhdGFVUkwsIHRydWUpXG5cbiAgLy8gMy4gUmVtb3ZlIHRoZSBsZWFkaW5nIFwiZGF0YTpcIiBzdHJpbmcgZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSBpbnB1dC5zbGljZSg1KVxuXG4gIC8vIDQuIExldCBwb3NpdGlvbiBwb2ludCBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gNS4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBlcXVhbFxuICAvLyB0byBVKzAwMkMgKCwpLCBnaXZlbiBwb3NpdGlvbi5cbiAgbGV0IG1pbWVUeXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJywnLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA2LiBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gbWltZVR5cGUuXG4gIC8vIFVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiB3ZSBuZWVkIHRvIHN0b3JlIHRoZVxuICAvLyBsZW5ndGggYmVjYXVzZSBpZiB0aGUgbWltZXR5cGUgaGFzIHNwYWNlcyByZW1vdmVkLFxuICAvLyB0aGUgd3JvbmcgYW1vdW50IHdpbGwgYmUgc2xpY2VkIGZyb20gdGhlIGlucHV0IGluXG4gIC8vIHN0ZXAgIzlcbiAgY29uc3QgbWltZVR5cGVMZW5ndGggPSBtaW1lVHlwZS5sZW5ndGhcbiAgbWltZVR5cGUgPSByZW1vdmVBU0NJSVdoaXRlc3BhY2UobWltZVR5cGUsIHRydWUsIHRydWUpXG5cbiAgLy8gNy4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuXG4gIC8vIHJldHVybiBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA4LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA5LiBMZXQgZW5jb2RlZEJvZHkgYmUgdGhlIHJlbWFpbmRlciBvZiBpbnB1dC5cbiAgY29uc3QgZW5jb2RlZEJvZHkgPSBpbnB1dC5zbGljZShtaW1lVHlwZUxlbmd0aCArIDEpXG5cbiAgLy8gMTAuIExldCBib2R5IGJlIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGVuY29kZWRCb2R5LlxuICBsZXQgYm9keSA9IHN0cmluZ1BlcmNlbnREZWNvZGUoZW5jb2RlZEJvZHkpXG5cbiAgLy8gMTEuIElmIG1pbWVUeXBlIGVuZHMgd2l0aCBVKzAwM0IgKDspLCBmb2xsb3dlZCBieVxuICAvLyB6ZXJvIG9yIG1vcmUgVSswMDIwIFNQQUNFLCBmb2xsb3dlZCBieSBhbiBBU0NJSVxuICAvLyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBcImJhc2U2NFwiLCB0aGVuOlxuICBpZiAoLzsoXFx1MDAyMCl7MCx9YmFzZTY0JC9pLnRlc3QobWltZVR5cGUpKSB7XG4gICAgLy8gMS4gTGV0IHN0cmluZ0JvZHkgYmUgdGhlIGlzb21vcnBoaWMgZGVjb2RlIG9mIGJvZHkuXG4gICAgY29uc3Qgc3RyaW5nQm9keSA9IGlzb21vcnBoaWNEZWNvZGUoYm9keSlcblxuICAgIC8vIDIuIFNldCBib2R5IHRvIHRoZSBmb3JnaXZpbmctYmFzZTY0IGRlY29kZSBvZlxuICAgIC8vIHN0cmluZ0JvZHkuXG4gICAgYm9keSA9IGZvcmdpdmluZ0Jhc2U2NChzdHJpbmdCb2R5KVxuXG4gICAgLy8gMy4gSWYgYm9keSBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChib2R5ID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA0LiBSZW1vdmUgdGhlIGxhc3QgNiBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTYpXG5cbiAgICAvLyA1LiBSZW1vdmUgdHJhaWxpbmcgVSswMDIwIFNQQUNFIGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUsXG4gICAgLy8gaWYgYW55LlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvKFxcdTAwMjApKyQvLCAnJylcblxuICAgIC8vIDYuIFJlbW92ZSB0aGUgbGFzdCBVKzAwM0IgKDspIGNvZGUgcG9pbnQgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgLy8gMTIuIElmIG1pbWVUeXBlIHN0YXJ0cyB3aXRoIFUrMDAzQiAoOyksIHRoZW4gcHJlcGVuZFxuICAvLyBcInRleHQvcGxhaW5cIiB0byBtaW1lVHlwZS5cbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoJzsnKSkge1xuICAgIG1pbWVUeXBlID0gJ3RleHQvcGxhaW4nICsgbWltZVR5cGVcbiAgfVxuXG4gIC8vIDEzLiBMZXQgbWltZVR5cGVSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gIC8vIG1pbWVUeXBlLlxuICBsZXQgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gIC8vIDE0LiBJZiBtaW1lVHlwZVJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHNldFxuICAvLyBtaW1lVHlwZVJlY29yZCB0byB0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUkuXG4gIGlmIChtaW1lVHlwZVJlY29yZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKCd0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUknKVxuICB9XG5cbiAgLy8gMTUuIFJldHVybiBhIG5ldyBkYXRhOiBVUkwgc3RydWN0IHdob3NlIE1JTUVcbiAgLy8gdHlwZSBpcyBtaW1lVHlwZVJlY29yZCBhbmQgYm9keSBpcyBib2R5LlxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtc3RydWN0XG4gIHJldHVybiB7IG1pbWVUeXBlOiBtaW1lVHlwZVJlY29yZCwgYm9keSB9XG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuLyoqXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4Y2x1ZGVGcmFnbWVudFxuICovXG5mdW5jdGlvbiBVUkxTZXJpYWxpemVyICh1cmwsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGNvbnN0IGhyZWYgPSB1cmwuaHJlZlxuXG4gIGlmICghZXhjbHVkZUZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGhyZWZcbiAgfVxuXG4gIGNvbnN0IGhhc2ggPSBocmVmLmxhc3RJbmRleE9mKCcjJylcbiAgaWYgKGhhc2ggPT09IC0xKSB7XG4gICAgcmV0dXJuIGhyZWZcbiAgfVxuICByZXR1cm4gaHJlZi5zbGljZSgwLCBoYXNoKVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hLXNlcXVlbmNlLW9mLWNvZGUtcG9pbnRzXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IHN0cmluZykgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHJlc3VsdCA9ICcnXG5cbiAgLy8gMi4gV2hpbGUgcG9zaXRpb24gZG9lc27igJl0IHBvaW50IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCBhbmQgdGhlXG4gIC8vIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IG1lZXRzIHRoZSBjb25kaXRpb24gY29uZGl0aW9uOlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGggJiYgY29uZGl0aW9uKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSkpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhhdCBjb2RlIHBvaW50IHRvIHRoZSBlbmQgb2YgcmVzdWx0LlxuICAgIHJlc3VsdCArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQSBmYXN0ZXIgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyB0aGF0IG9ubHkgd29ya3Mgd2hlbiBjb21wYXJpbmcgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgKGNoYXIsIGlucHV0LCBwb3NpdGlvbikge1xuICBjb25zdCBpZHggPSBpbnB1dC5pbmRleE9mKGNoYXIsIHBvc2l0aW9uLnBvc2l0aW9uKVxuICBjb25zdCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlucHV0Lmxlbmd0aFxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydClcbiAgfVxuXG4gIHBvc2l0aW9uLnBvc2l0aW9uID0gaWR4XG4gIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RyaW5nLXBlcmNlbnQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBzdHJpbmdQZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIFVURi04IGVuY29kaW5nIG9mIGlucHV0LlxuICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKGlucHV0KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBieXRlcy5cbiAgcmV0dXJuIHBlcmNlbnREZWNvZGUoYnl0ZXMpXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0ICovXG5mdW5jdGlvbiBwZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgLy8gMi4gRm9yIGVhY2ggYnl0ZSBieXRlIGluIGlucHV0OlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZSA9IGlucHV0W2ldXG5cbiAgICAvLyAxLiBJZiBieXRlIGlzIG5vdCAweDI1ICglKSwgdGhlbiBhcHBlbmQgYnl0ZSB0byBvdXRwdXQuXG4gICAgaWYgKGJ5dGUgIT09IDB4MjUpIHtcbiAgICAgIG91dHB1dC5wdXNoKGJ5dGUpXG5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJ5dGUgaXMgMHgyNSAoJSkgYW5kIHRoZSBuZXh0IHR3byBieXRlc1xuICAgIC8vIGFmdGVyIGJ5dGUgaW4gaW5wdXQgYXJlIG5vdCBpbiB0aGUgcmFuZ2VzXG4gICAgLy8gMHgzMCAoMCkgdG8gMHgzOSAoOSksIDB4NDEgKEEpIHRvIDB4NDYgKEYpLFxuICAgIC8vIGFuZCAweDYxIChhKSB0byAweDY2IChmKSwgYWxsIGluY2x1c2l2ZSwgYXBwZW5kIGJ5dGVcbiAgICAvLyB0byBvdXRwdXQuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGJ5dGUgPT09IDB4MjUgJiZcbiAgICAgICEvXlswLTlBLUZhLWZdezJ9JC9pLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShpbnB1dFtpICsgMV0sIGlucHV0W2kgKyAyXSkpXG4gICAgKSB7XG4gICAgICBvdXRwdXQucHVzaCgweDI1KVxuXG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBMZXQgYnl0ZVBvaW50IGJlIHRoZSB0d28gYnl0ZXMgYWZ0ZXIgYnl0ZSBpbiBpbnB1dCxcbiAgICAgIC8vIGRlY29kZWQsIGFuZCB0aGVuIGludGVycHJldGVkIGFzIGhleGFkZWNpbWFsIG51bWJlci5cbiAgICAgIGNvbnN0IG5leHRUd29CeXRlcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXRbaSArIDFdLCBpbnB1dFtpICsgMl0pXG4gICAgICBjb25zdCBieXRlUG9pbnQgPSBOdW1iZXIucGFyc2VJbnQobmV4dFR3b0J5dGVzLCAxNilcblxuICAgICAgLy8gMi4gQXBwZW5kIGEgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBieXRlUG9pbnQgdG8gb3V0cHV0LlxuICAgICAgb3V0cHV0LnB1c2goYnl0ZVBvaW50KVxuXG4gICAgICAvLyAzLiBTa2lwIHRoZSBuZXh0IHR3byBieXRlcyBpbiBpbnB1dC5cbiAgICAgIGkgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBVaW50OEFycmF5LmZyb20ob3V0cHV0KVxufVxuXG4vLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWEtbWltZS10eXBlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlIChpbnB1dCkge1xuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZVxuICAvLyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKGlucHV0LCB0cnVlLCB0cnVlKVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCxcbiAgLy8gaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZVxuICAvLyBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDJGICgvKSBmcm9tXG4gIC8vIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgdHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcvJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNC4gSWYgdHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gIGlmICh0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gcmV0dXJuXG4gIC8vIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAyRiAoLykuKVxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNy4gTGV0IHN1YnR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2ZcbiAgLy8gY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOykgZnJvbSBpbnB1dCwgZ2l2ZW5cbiAgLy8gcG9zaXRpb24uXG4gIGxldCBzdWJ0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJzsnLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA4LiBSZW1vdmUgYW55IHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBmcm9tIHN1YnR5cGUuXG4gIHN1YnR5cGUgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShzdWJ0eXBlLCBmYWxzZSwgdHJ1ZSlcblxuICAvLyA5LiBJZiBzdWJ0eXBlIGlzIHRoZSBlbXB0eSBzdHJpbmcgb3IgZG9lcyBub3Qgc29sZWx5XG4gIC8vIGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlIHBvaW50cywgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHN1YnR5cGUubGVuZ3RoID09PSAwIHx8ICFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChzdWJ0eXBlKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IHR5cGVMb3dlcmNhc2UgPSB0eXBlLnRvTG93ZXJDYXNlKClcbiAgY29uc3Qgc3VidHlwZUxvd2VyY2FzZSA9IHN1YnR5cGUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIDEwLiBMZXQgbWltZVR5cGUgYmUgYSBuZXcgTUlNRSB0eXBlIHJlY29yZCB3aG9zZSB0eXBlXG4gIC8vIGlzIHR5cGUsIGluIEFTQ0lJIGxvd2VyY2FzZSwgYW5kIHN1YnR5cGUgaXMgc3VidHlwZSxcbiAgLy8gaW4gQVNDSUkgbG93ZXJjYXNlLlxuICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbWUtdHlwZVxuICBjb25zdCBtaW1lVHlwZSA9IHtcbiAgICB0eXBlOiB0eXBlTG93ZXJjYXNlLFxuICAgIHN1YnR5cGU6IHN1YnR5cGVMb3dlcmNhc2UsXG4gICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIHBhcmFtZXRlcnM6IG5ldyBNYXAoKSxcbiAgICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbWUtdHlwZS1lc3NlbmNlXG4gICAgZXNzZW5jZTogYCR7dHlwZUxvd2VyY2FzZX0vJHtzdWJ0eXBlTG93ZXJjYXNlfWBcbiAgfVxuXG4gIC8vIDExLiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAvLyAxLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDNCICg7KS4pXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIEhUVFBcbiAgICAvLyB3aGl0ZXNwYWNlIGZyb20gaW5wdXQgZ2l2ZW4gcG9zaXRpb24uXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAgICAgIGNoYXIgPT4gSFRUUF9XSElURVNQQUNFX1JFR0VYLnRlc3QoY2hhciksXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMy4gTGV0IHBhcmFtZXRlck5hbWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFcbiAgICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KVxuICAgIC8vIG9yIFUrMDAzRCAoPSkgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgbGV0IHBhcmFtZXRlck5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICc7JyAmJiBjaGFyICE9PSAnPScsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gNC4gU2V0IHBhcmFtZXRlck5hbWUgdG8gcGFyYW1ldGVyTmFtZSwgaW4gQVNDSUlcbiAgICAvLyBsb3dlcmNhc2UuXG4gICAgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNS4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbjpcbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgICAgLy8gVSswMDNCICg7KSwgdGhlbiBjb250aW51ZS5cbiAgICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICc7Jykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDNEICg9KS4pXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgcGFyYW1ldGVyVmFsdWUgYmUgbnVsbC5cbiAgICBsZXQgcGFyYW1ldGVyVmFsdWUgPSBudWxsXG5cbiAgICAvLyA4LiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAvLyBVKzAwMjIgKFwiKSwgdGhlbjpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKSB7XG4gICAgICAvLyAxLiBTZXQgcGFyYW1ldGVyVmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nXG4gICAgICAvLyBhbiBIVFRQIHF1b3RlZCBzdHJpbmcgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIC8vIGFuZCB0aGUgZXh0cmFjdC12YWx1ZSBmbGFnLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKGlucHV0LCBwb3NpdGlvbiwgdHJ1ZSlcblxuICAgICAgLy8gMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdFxuICAgICAgLy8gVSswMDNCICg7KSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgICAnOycsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKVxuXG4gICAgLy8gOS4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBTZXQgcGFyYW1ldGVyVmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nXG4gICAgICAvLyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspXG4gICAgICAvLyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAgIC8vIDIuIFJlbW92ZSBhbnkgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGZyb20gcGFyYW1ldGVyVmFsdWUuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHBhcmFtZXRlclZhbHVlLCBmYWxzZSwgdHJ1ZSlcblxuICAgICAgLy8gMy4gSWYgcGFyYW1ldGVyVmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBjb250aW51ZS5cbiAgICAgIGlmIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxMC4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWVcbiAgICAvLyAtIHBhcmFtZXRlck5hbWUgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAtIHBhcmFtZXRlck5hbWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgdG9rZW4gY29kZSBwb2ludHNcbiAgICAvLyAtIHBhcmFtZXRlclZhbHVlIHNvbGVseSBjb250YWlucyBIVFRQIHF1b3RlZC1zdHJpbmcgdG9rZW4gY29kZSBwb2ludHNcbiAgICAvLyAtIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdIGRvZXMgbm90IGV4aXN0XG4gICAgLy8gdGhlbiBzZXQgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gdG8gcGFyYW1ldGVyVmFsdWUuXG4gICAgaWYgKFxuICAgICAgcGFyYW1ldGVyTmFtZS5sZW5ndGggIT09IDAgJiZcbiAgICAgIEhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHBhcmFtZXRlck5hbWUpICYmXG4gICAgICAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwIHx8IEhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMudGVzdChwYXJhbWV0ZXJWYWx1ZSkpICYmXG4gICAgICAhbWltZVR5cGUucGFyYW1ldGVycy5oYXMocGFyYW1ldGVyTmFtZSlcbiAgICApIHtcbiAgICAgIG1pbWVUeXBlLnBhcmFtZXRlcnMuc2V0KHBhcmFtZXRlck5hbWUsIHBhcmFtZXRlclZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBSZXR1cm4gbWltZVR5cGUuXG4gIHJldHVybiBtaW1lVHlwZVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jZm9yZ2l2aW5nLWJhc2U2NC1kZWNvZGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAqL1xuZnVuY3Rpb24gZm9yZ2l2aW5nQmFzZTY0IChkYXRhKSB7XG4gIC8vIDEuIFJlbW92ZSBhbGwgQVNDSUkgd2hpdGVzcGFjZSBmcm9tIGRhdGEuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoL1tcXHUwMDA5XFx1MDAwQVxcdTAwMENcXHUwMDBEXFx1MDAyMF0vZywgJycpICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLy8gMi4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gbm8gcmVtYWluZGVyLCB0aGVuOlxuICBpZiAoZGF0YS5sZW5ndGggJSA0ID09PSAwKSB7XG4gICAgLy8gMS4gSWYgZGF0YSBlbmRzIHdpdGggb25lIG9yIHR3byBVKzAwM0QgKD0pIGNvZGUgcG9pbnRzLFxuICAgIC8vIHRoZW4gcmVtb3ZlIHRoZW0gZnJvbSBkYXRhLlxuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLz0/PSQvLCAnJylcbiAgfVxuXG4gIC8vIDMuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIGEgcmVtYWluZGVyIG9mIDEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhLmxlbmd0aCAlIDQgPT09IDEpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA0LiBJZiBkYXRhIGNvbnRhaW5zIGEgY29kZSBwb2ludCB0aGF0IGlzIG5vdCBvbmUgb2ZcbiAgLy8gIFUrMDAyQiAoKylcbiAgLy8gIFUrMDAyRiAoLylcbiAgLy8gIEFTQ0lJIGFscGhhbnVtZXJpY1xuICAvLyB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoL1teKy8wLTlBLVphLXpdLy50ZXN0KGRhdGEpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgYmluYXJ5ID0gYXRvYihkYXRhKVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpXG5cbiAgZm9yIChsZXQgYnl0ZSA9IDA7IGJ5dGUgPCBiaW5hcnkubGVuZ3RoOyBieXRlKyspIHtcbiAgICBieXRlc1tieXRlXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGJ5dGUpXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYW4taHR0cC1xdW90ZWQtc3RyaW5nXG4vLyB0ZXN0czogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2V4YW1wbGUtaHR0cC1xdW90ZWQtc3RyaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGV4dHJhY3RWYWx1ZVxuICovXG5mdW5jdGlvbiBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIChpbnB1dCwgcG9zaXRpb24sIGV4dHJhY3RWYWx1ZSkge1xuICAvLyAxLiBMZXQgcG9zaXRpb25TdGFydCBiZSBwb3NpdGlvbi5cbiAgY29uc3QgcG9zaXRpb25TdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgLy8gMi4gTGV0IHZhbHVlIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMy4gQXNzZXJ0OiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXRcbiAgLy8gaXMgVSswMDIyIChcIikuXG4gIGFzc2VydChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpXG5cbiAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHNcbiAgICAvLyB0aGF0IGFyZSBub3QgVSswMDIyIChcIikgb3IgVSswMDVDIChcXCkgZnJvbSBpbnB1dCwgZ2l2ZW5cbiAgICAvLyBwb3NpdGlvbiwgdG8gdmFsdWUuXG4gICAgdmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09ICdcXFxcJyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAyLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcXVvdGVPckJhY2tzbGFzaCBiZSB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW5cbiAgICAvLyBpbnB1dC5cbiAgICBjb25zdCBxdW90ZU9yQmFja3NsYXNoID0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNS4gSWYgcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwNUMgKFxcKSwgdGhlbjpcbiAgICBpZiAocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAvLyAxLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYXBwZW5kXG4gICAgICAvLyBVKzAwNUMgKFxcKSB0byB2YWx1ZSBhbmQgYnJlYWsuXG4gICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJ1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDYuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gQXNzZXJ0OiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDAyMiAoXCIpLlxuICAgICAgYXNzZXJ0KHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcIicpXG5cbiAgICAgIC8vIDIuIEJyZWFrLlxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyA2LiBJZiB0aGUgZXh0cmFjdC12YWx1ZSBmbGFnIGlzIHNldCwgdGhlbiByZXR1cm4gdmFsdWUuXG4gIGlmIChleHRyYWN0VmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB0aGUgY29kZSBwb2ludHMgZnJvbSBwb3NpdGlvblN0YXJ0IHRvIHBvc2l0aW9uLFxuICAvLyBpbmNsdXNpdmUsIHdpdGhpbiBpbnB1dC5cbiAgcmV0dXJuIGlucHV0LnNsaWNlKHBvc2l0aW9uU3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1taW1lLXR5cGVcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQU1pbWVUeXBlIChtaW1lVHlwZSkge1xuICBhc3NlcnQobWltZVR5cGUgIT09ICdmYWlsdXJlJylcbiAgY29uc3QgeyBwYXJhbWV0ZXJzLCBlc3NlbmNlIH0gPSBtaW1lVHlwZVxuXG4gIC8vIDEuIExldCBzZXJpYWxpemF0aW9uIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIG1pbWVUeXBl4oCZc1xuICAvLyAgICB0eXBlLCBVKzAwMkYgKC8pLCBhbmQgbWltZVR5cGXigJlzIHN1YnR5cGUuXG4gIGxldCBzZXJpYWxpemF0aW9uID0gZXNzZW5jZVxuXG4gIC8vIDIuIEZvciBlYWNoIG5hbWUg4oaSIHZhbHVlIG9mIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzOlxuICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgLy8gMS4gQXBwZW5kIFUrMDAzQiAoOykgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc7J1xuXG4gICAgLy8gMi4gQXBwZW5kIG5hbWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IG5hbWVcblxuICAgIC8vIDMuIEFwcGVuZCBVKzAwM0QgKD0pIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnPSdcblxuICAgIC8vIDQuIElmIHZhbHVlIGRvZXMgbm90IHNvbGVseSBjb250YWluIEhUVFAgdG9rZW4gY29kZVxuICAgIC8vICAgIHBvaW50cyBvciB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICAgIGlmICghSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodmFsdWUpKSB7XG4gICAgICAvLyAxLiBQcmVjZWRlIGVhY2ggb2NjdXJlbmNlIG9mIFUrMDAyMiAoXCIpIG9yXG4gICAgICAvLyAgICBVKzAwNUMgKFxcKSBpbiB2YWx1ZSB3aXRoIFUrMDA1QyAoXFwpLlxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oXFxcXHxcIikvZywgJ1xcXFwkMScpXG5cbiAgICAgIC8vIDIuIFByZXBlbmQgVSswMDIyIChcIikgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSA9ICdcIicgKyB2YWx1ZVxuXG4gICAgICAvLyAzLiBBcHBlbmQgVSswMDIyIChcIikgdG8gdmFsdWUuXG4gICAgICB2YWx1ZSArPSAnXCInXG4gICAgfVxuXG4gICAgLy8gNS4gQXBwZW5kIHZhbHVlIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSB2YWx1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHNlcmlhbGl6YXRpb24uXG4gIHJldHVybiBzZXJpYWxpemF0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICovXG5mdW5jdGlvbiBpc0hUVFBXaGl0ZVNwYWNlIChjaGFyKSB7XG4gIHJldHVybiBjaGFyID09PSAnXFxyJyB8fCBjaGFyID09PSAnXFxuJyB8fCBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICdcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSFRUUFdoaXRlc3BhY2UgKHN0ciwgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSkge1xuICBsZXQgbGVhZCA9IDBcbiAgbGV0IHRyYWlsID0gc3RyLmxlbmd0aCAtIDFcblxuICBpZiAobGVhZGluZykge1xuICAgIGZvciAoOyBsZWFkIDwgc3RyLmxlbmd0aCAmJiBpc0hUVFBXaGl0ZVNwYWNlKHN0cltsZWFkXSk7IGxlYWQrKyk7XG4gIH1cblxuICBpZiAodHJhaWxpbmcpIHtcbiAgICBmb3IgKDsgdHJhaWwgPiAwICYmIGlzSFRUUFdoaXRlU3BhY2Uoc3RyW3RyYWlsXSk7IHRyYWlsLS0pO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zbGljZShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNBU0NJSVdoaXRlc3BhY2UgKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09ICdcXHInIHx8IGNoYXIgPT09ICdcXG4nIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICdcXGYnIHx8IGNoYXIgPT09ICcgJ1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWxlYWRpbmctYW5kLXRyYWlsaW5nLWFzY2lpLXdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IHN0ci5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICBmb3IgKDsgbGVhZCA8IHN0ci5sZW5ndGggJiYgaXNBU0NJSVdoaXRlc3BhY2Uoc3RyW2xlYWRdKTsgbGVhZCsrKTtcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIGZvciAoOyB0cmFpbCA+IDAgJiYgaXNBU0NJSVdoaXRlc3BhY2Uoc3RyW3RyYWlsXSk7IHRyYWlsLS0pO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zbGljZShsZWFkLCB0cmFpbCArIDEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkYXRhVVJMUHJvY2Vzc29yLFxuICBVUkxTZXJpYWxpemVyLFxuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLFxuICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCxcbiAgc3RyaW5nUGVyY2VudERlY29kZSxcbiAgcGFyc2VNSU1FVHlwZSxcbiAgY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyxcbiAgc2VyaWFsaXplQU1pbWVUeXBlXG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImF0b2IiLCJpc29tb3JwaGljRGVjb2RlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiSFRUUF9UT0tFTl9DT0RFUE9JTlRTIiwiSFRUUF9XSElURVNQQUNFX1JFR0VYIiwiSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyIsImRhdGFVUkxQcm9jZXNzb3IiLCJkYXRhVVJMIiwicHJvdG9jb2wiLCJpbnB1dCIsIlVSTFNlcmlhbGl6ZXIiLCJzbGljZSIsInBvc2l0aW9uIiwibWltZVR5cGUiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCIsIm1pbWVUeXBlTGVuZ3RoIiwibGVuZ3RoIiwicmVtb3ZlQVNDSUlXaGl0ZXNwYWNlIiwiZW5jb2RlZEJvZHkiLCJib2R5Iiwic3RyaW5nUGVyY2VudERlY29kZSIsInRlc3QiLCJzdHJpbmdCb2R5IiwiZm9yZ2l2aW5nQmFzZTY0IiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJtaW1lVHlwZVJlY29yZCIsInBhcnNlTUlNRVR5cGUiLCJ1cmwiLCJleGNsdWRlRnJhZ21lbnQiLCJocmVmIiwiaGFzaCIsImxhc3RJbmRleE9mIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyIsImNvbmRpdGlvbiIsInJlc3VsdCIsImNoYXIiLCJpZHgiLCJpbmRleE9mIiwic3RhcnQiLCJieXRlcyIsImVuY29kZSIsInBlcmNlbnREZWNvZGUiLCJvdXRwdXQiLCJpIiwiYnl0ZSIsInB1c2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJuZXh0VHdvQnl0ZXMiLCJieXRlUG9pbnQiLCJOdW1iZXIiLCJwYXJzZUludCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwicmVtb3ZlSFRUUFdoaXRlc3BhY2UiLCJ0eXBlIiwic3VidHlwZSIsInR5cGVMb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsInN1YnR5cGVMb3dlcmNhc2UiLCJwYXJhbWV0ZXJzIiwiTWFwIiwiZXNzZW5jZSIsInBhcmFtZXRlck5hbWUiLCJwYXJhbWV0ZXJWYWx1ZSIsImNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmciLCJoYXMiLCJzZXQiLCJkYXRhIiwiYmluYXJ5IiwiY2hhckNvZGVBdCIsImV4dHJhY3RWYWx1ZSIsInBvc2l0aW9uU3RhcnQiLCJ2YWx1ZSIsInF1b3RlT3JCYWNrc2xhc2giLCJzZXJpYWxpemVBTWltZVR5cGUiLCJzZXJpYWxpemF0aW9uIiwibmFtZSIsImVudHJpZXMiLCJpc0hUVFBXaGl0ZVNwYWNlIiwic3RyIiwibGVhZGluZyIsInRyYWlsaW5nIiwibGVhZCIsInRyYWlsIiwiaXNBU0NJSVdoaXRlc3BhY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/dataURL.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/file.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/file.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { isBlobLike } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nclass File extends Blob {\n    constructor(fileBits, fileName, options = {}){\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"File constructor\"\n        });\n        fileBits = webidl.converters[\"sequence<BlobPart>\"](fileBits);\n        fileName = webidl.converters.USVString(fileName);\n        options = webidl.converters.FilePropertyBag(options);\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // Note: Blob handles this for us\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    2. Convert every character in t to ASCII lowercase.\n        let t = options.type;\n        let d;\n        // eslint-disable-next-line no-labels\n        substep: {\n            if (t) {\n                t = parseMIMEType(t);\n                if (t === \"failure\") {\n                    t = \"\";\n                    break substep;\n                }\n                t = serializeAMimeType(t).toLowerCase();\n            }\n            //    3. If the lastModified member is provided, let d be set to the\n            //    lastModified dictionary member. If it is not provided, set d to the\n            //    current date and time represented as the number of milliseconds since\n            //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n            d = options.lastModified;\n        }\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        super(processBlobParts(fileBits, options), {\n            type: t\n        });\n        this[kState] = {\n            name: n,\n            lastModified: d,\n            type: t\n        };\n    }\n    get name() {\n        webidl.brandCheck(this, File);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, File);\n        return this[kState].lastModified;\n    }\n    get type() {\n        webidl.brandCheck(this, File);\n        return this[kState].type;\n    }\n}\nclass FileLike {\n    constructor(blobLike, fileName, options = {}){\n        // TODO: argument idl type check\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    TODO\n        const t = options.type;\n        //    2. Convert every character in t to ASCII lowercase.\n        //    TODO\n        //    3. If the lastModified member is provided, let d be set to the\n        //    lastModified dictionary member. If it is not provided, set d to the\n        //    current date and time represented as the number of milliseconds since\n        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n        const d = options.lastModified ?? Date.now();\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        this[kState] = {\n            blobLike,\n            name: n,\n            type: t,\n            lastModified: d\n        };\n    }\n    stream(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.stream(...args);\n    }\n    arrayBuffer(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.arrayBuffer(...args);\n    }\n    slice(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.slice(...args);\n    }\n    text(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.text(...args);\n    }\n    get size() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.size;\n    }\n    get type() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.type;\n    }\n    get name() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\nObject.defineProperties(File.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"File\",\n        configurable: true\n    },\n    name: kEnumerableProperty,\n    lastModified: kEnumerableProperty\n});\nwebidl.converters.Blob = webidl.interfaceConverter(Blob);\nwebidl.converters.BlobPart = function(V, opts) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V, opts);\n        }\n    }\n    return webidl.converters.USVString(V, opts);\n};\nwebidl.converters[\"sequence<BlobPart>\"] = webidl.sequenceConverter(webidl.converters.BlobPart);\n// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag\nwebidl.converters.FilePropertyBag = webidl.dictionaryConverter([\n    {\n        key: \"lastModified\",\n        converter: webidl.converters[\"long long\"],\n        get defaultValue () {\n            return Date.now();\n        }\n    },\n    {\n        key: \"type\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"endings\",\n        converter: (value)=>{\n            value = webidl.converters.DOMString(value);\n            value = value.toLowerCase();\n            if (value !== \"native\") {\n                value = \"transparent\";\n            }\n            return value;\n        },\n        defaultValue: \"transparent\"\n    }\n]);\n/**\n * @see https://www.w3.org/TR/FileAPI/#process-blob-parts\n * @param {(NodeJS.TypedArray|Blob|string)[]} parts\n * @param {{ type: string, endings: string }} options\n */ function processBlobParts(parts, options) {\n    // 1. Let bytes be an empty sequence of bytes.\n    /** @type {NodeJS.TypedArray[]} */ const bytes = [];\n    // 2. For each element in parts:\n    for (const element of parts){\n        // 1. If element is a USVString, run the following substeps:\n        if (typeof element === \"string\") {\n            // 1. Let s be element.\n            let s = element;\n            // 2. If the endings member of options is \"native\", set s\n            //    to the result of converting line endings to native\n            //    of element.\n            if (options.endings === \"native\") {\n                s = convertLineEndingsNative(s);\n            }\n            // 3. Append the result of UTF-8 encoding s to bytes.\n            bytes.push(new TextEncoder().encode(s));\n        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {\n            // 2. If element is a BufferSource, get a copy of the\n            //    bytes held by the buffer source, and append those\n            //    bytes to bytes.\n            if (!element.buffer) {\n                bytes.push(new Uint8Array(element));\n            } else {\n                bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));\n            }\n        } else if (isBlobLike(element)) {\n            // 3. If element is a Blob, append the bytes it represents\n            //    to bytes.\n            bytes.push(element);\n        }\n    }\n    // 3. Return bytes.\n    return bytes;\n}\n/**\n * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native\n * @param {string} s\n */ function convertLineEndingsNative(s) {\n    // 1. Let native line ending be be the code point U+000A LF.\n    let nativeLineEnding = \"\\n\";\n    // 2. If the underlying platform’s conventions are to\n    //    represent newlines as a carriage return and line feed\n    //    sequence, set native line ending to the code point\n    //    U+000D CR followed by the code point U+000A LF.\n    if (process.platform === \"win32\") {\n        nativeLineEnding = \"\\r\\n\";\n    }\n    return s.replace(/\\r?\\n/g, nativeLineEnding);\n}\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike(object) {\n    return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && object[Symbol.toStringTag] === \"File\";\n}\nmodule.exports = {\n    File,\n    FileLike,\n    isFileLike\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxJQUFJLEVBQUVDLE1BQU1DLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzQyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVFLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVHLFVBQVUsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVJLE1BQU0sRUFBRSxHQUFHSixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVLLGFBQWEsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDdEQsTUFBTSxFQUFFTyxtQkFBbUIsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNRixhQUFhRDtJQUNqQlcsWUFBYUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDN0MsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEVQLE9BQU9RLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFtQjtRQUV0RUwsV0FBV0wsT0FBT1csVUFBVSxDQUFDLHFCQUFxQixDQUFDTjtRQUNuREMsV0FBV04sT0FBT1csVUFBVSxDQUFDQyxTQUFTLENBQUNOO1FBQ3ZDQyxVQUFVUCxPQUFPVyxVQUFVLENBQUNFLGVBQWUsQ0FBQ047UUFFNUMseUVBQXlFO1FBQ3pFLFdBQVc7UUFDWCxpQ0FBaUM7UUFFakMsd0RBQXdEO1FBQ3hELE1BQU1PLElBQUlSO1FBRVYsMEVBQTBFO1FBQzFFLFlBQVk7UUFFWiwwRUFBMEU7UUFDMUUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxxQ0FBcUM7UUFDckMseURBQXlEO1FBQ3pELElBQUlTLElBQUlSLFFBQVFTLElB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Ty9DLFdBQVcsS0FBSyxVQUFTLEtBQ3ZDK0MsTUFBTSxDQUFDM0MsT0FBT0MsV0FBVyxDQUFDLEtBQUs7QUFHckM7QUFFQTJDLE9BQU9DLE9BQU8sR0FBRztJQUFFckY7SUFBTThCO0lBQVVvRDtBQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9maWxlLmpzPzMzYjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQmxvYiwgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzQmxvYkxpa2UgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIEZpbGUgZXh0ZW5kcyBCbG9iIHtcbiAgY29uc3RydWN0b3IgKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVGhlIEZpbGUgY29uc3RydWN0b3IgaXMgaW52b2tlZCB3aXRoIHR3byBvciB0aHJlZSBwYXJhbWV0ZXJzLCBkZXBlbmRpbmdcbiAgICAvLyBvbiB3aGV0aGVyIHRoZSBvcHRpb25hbCBkaWN0aW9uYXJ5IHBhcmFtZXRlciBpcyB1c2VkLiBXaGVuIHRoZSBGaWxlKClcbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBpbnZva2VkLCB1c2VyIGFnZW50cyBtdXN0IHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdGaWxlIGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgZmlsZUJpdHMgPSB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8QmxvYlBhcnQ+J10oZmlsZUJpdHMpXG4gICAgZmlsZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZU5hbWUpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkZpbGVQcm9wZXJ0eUJhZyhvcHRpb25zKVxuXG4gICAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSByZXN1bHQgb2YgcHJvY2Vzc2luZyBibG9iIHBhcnRzIGdpdmVuIGZpbGVCaXRzIGFuZFxuICAgIC8vIG9wdGlvbnMuXG4gICAgLy8gTm90ZTogQmxvYiBoYW5kbGVzIHRoaXMgZm9yIHVzXG5cbiAgICAvLyAyLiBMZXQgbiBiZSB0aGUgZmlsZU5hbWUgYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IG4gPSBmaWxlTmFtZVxuXG4gICAgLy8gMy4gUHJvY2VzcyBGaWxlUHJvcGVydHlCYWcgZGljdGlvbmFyeSBhcmd1bWVudCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBzdWJzdGVwczpcblxuICAgIC8vICAgIDEuIElmIHRoZSB0eXBlIG1lbWJlciBpcyBwcm92aWRlZCBhbmQgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCB0XG4gICAgLy8gICAgYmUgc2V0IHRvIHRoZSB0eXBlIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiB0IGNvbnRhaW5zIGFueSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgb3V0c2lkZSB0aGUgcmFuZ2UgVSswMDIwIHRvIFUrMDA3RSwgdGhlbiBzZXQgdCB0byB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gICAgYW5kIHJldHVybiBmcm9tIHRoZXNlIHN1YnN0ZXBzLlxuICAgIC8vICAgIDIuIENvbnZlcnQgZXZlcnkgY2hhcmFjdGVyIGluIHQgdG8gQVNDSUkgbG93ZXJjYXNlLlxuICAgIGxldCB0ID0gb3B0aW9ucy50eXBlXG4gICAgbGV0IGRcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICBzdWJzdGVwOiB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0ID0gcGFyc2VNSU1FVHlwZSh0KVxuXG4gICAgICAgIGlmICh0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICB0ID0gJydcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgICAgYnJlYWsgc3Vic3RlcFxuICAgICAgICB9XG5cbiAgICAgICAgdCA9IHNlcmlhbGl6ZUFNaW1lVHlwZSh0KS50b0xvd2VyQ2FzZSgpXG4gICAgICB9XG5cbiAgICAgIC8vICAgIDMuIElmIHRoZSBsYXN0TW9kaWZpZWQgbWVtYmVyIGlzIHByb3ZpZGVkLCBsZXQgZCBiZSBzZXQgdG8gdGhlXG4gICAgICAvLyAgICBsYXN0TW9kaWZpZWQgZGljdGlvbmFyeSBtZW1iZXIuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgc2V0IGQgdG8gdGhlXG4gICAgICAvLyAgICBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcmVwcmVzZW50ZWQgYXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2VcbiAgICAgIC8vICAgIHRoZSBVbml4IEVwb2NoICh3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBEYXRlLm5vdygpIFtFQ01BLTI2Ml0pLlxuICAgICAgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkXG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIGEgbmV3IEZpbGUgb2JqZWN0IEYgc3VjaCB0aGF0OlxuICAgIC8vIEYgcmVmZXJzIHRvIHRoZSBieXRlcyBieXRlIHNlcXVlbmNlLlxuICAgIC8vIEYuc2l6ZSBpcyBzZXQgdG8gdGhlIG51bWJlciBvZiB0b3RhbCBieXRlcyBpbiBieXRlcy5cbiAgICAvLyBGLm5hbWUgaXMgc2V0IHRvIG4uXG4gICAgLy8gRi50eXBlIGlzIHNldCB0byB0LlxuICAgIC8vIEYubGFzdE1vZGlmaWVkIGlzIHNldCB0byBkLlxuXG4gICAgc3VwZXIocHJvY2Vzc0Jsb2JQYXJ0cyhmaWxlQml0cywgb3B0aW9ucyksIHsgdHlwZTogdCB9KVxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIG5hbWU6IG4sXG4gICAgICBsYXN0TW9kaWZpZWQ6IGQsXG4gICAgICB0eXBlOiB0XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGUpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm5hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGUpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGUpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnR5cGVcbiAgfVxufVxuXG5jbGFzcyBGaWxlTGlrZSB7XG4gIGNvbnN0cnVjdG9yIChibG9iTGlrZSwgZmlsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFRPRE86IGFyZ3VtZW50IGlkbCB0eXBlIGNoZWNrXG5cbiAgICAvLyBUaGUgRmlsZSBjb25zdHJ1Y3RvciBpcyBpbnZva2VkIHdpdGggdHdvIG9yIHRocmVlIHBhcmFtZXRlcnMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdGhlIG9wdGlvbmFsIGRpY3Rpb25hcnkgcGFyYW1ldGVyIGlzIHVzZWQuIFdoZW4gdGhlIEZpbGUoKVxuICAgIC8vIGNvbnN0cnVjdG9yIGlzIGludm9rZWQsIHVzZXIgYWdlbnRzIG11c3QgcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGJsb2IgcGFydHMgZ2l2ZW4gZmlsZUJpdHMgYW5kXG4gICAgLy8gb3B0aW9ucy5cblxuICAgIC8vIDIuIExldCBuIGJlIHRoZSBmaWxlTmFtZSBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3QgbiA9IGZpbGVOYW1lXG5cbiAgICAvLyAzLiBQcm9jZXNzIEZpbGVQcm9wZXJ0eUJhZyBkaWN0aW9uYXJ5IGFyZ3VtZW50IGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZ1xuICAgIC8vIHN1YnN0ZXBzOlxuXG4gICAgLy8gICAgMS4gSWYgdGhlIHR5cGUgbWVtYmVyIGlzIHByb3ZpZGVkIGFuZCBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IHRcbiAgICAvLyAgICBiZSBzZXQgdG8gdGhlIHR5cGUgZGljdGlvbmFyeSBtZW1iZXIuIElmIHQgY29udGFpbnMgYW55IGNoYXJhY3RlcnNcbiAgICAvLyAgICBvdXRzaWRlIHRoZSByYW5nZSBVKzAwMjAgdG8gVSswMDdFLCB0aGVuIHNldCB0IHRvIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAgICBhbmQgcmV0dXJuIGZyb20gdGhlc2Ugc3Vic3RlcHMuXG4gICAgLy8gICAgVE9ET1xuICAgIGNvbnN0IHQgPSBvcHRpb25zLnR5cGVcblxuICAgIC8vICAgIDIuIENvbnZlcnQgZXZlcnkgY2hhcmFjdGVyIGluIHQgdG8gQVNDSUkgbG93ZXJjYXNlLlxuICAgIC8vICAgIFRPRE9cblxuICAgIC8vICAgIDMuIElmIHRoZSBsYXN0TW9kaWZpZWQgbWVtYmVyIGlzIHByb3ZpZGVkLCBsZXQgZCBiZSBzZXQgdG8gdGhlXG4gICAgLy8gICAgbGFzdE1vZGlmaWVkIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHNldCBkIHRvIHRoZVxuICAgIC8vICAgIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSByZXByZXNlbnRlZCBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgIC8vICAgIHRoZSBVbml4IEVwb2NoICh3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBEYXRlLm5vdygpIFtFQ01BLTI2Ml0pLlxuICAgIGNvbnN0IGQgPSBvcHRpb25zLmxhc3RNb2RpZmllZCA/PyBEYXRlLm5vdygpXG5cbiAgICAvLyA0LiBSZXR1cm4gYSBuZXcgRmlsZSBvYmplY3QgRiBzdWNoIHRoYXQ6XG4gICAgLy8gRiByZWZlcnMgdG8gdGhlIGJ5dGVzIGJ5dGUgc2VxdWVuY2UuXG4gICAgLy8gRi5zaXplIGlzIHNldCB0byB0aGUgbnVtYmVyIG9mIHRvdGFsIGJ5dGVzIGluIGJ5dGVzLlxuICAgIC8vIEYubmFtZSBpcyBzZXQgdG8gbi5cbiAgICAvLyBGLnR5cGUgaXMgc2V0IHRvIHQuXG4gICAgLy8gRi5sYXN0TW9kaWZpZWQgaXMgc2V0IHRvIGQuXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBibG9iTGlrZSxcbiAgICAgIG5hbWU6IG4sXG4gICAgICB0eXBlOiB0LFxuICAgICAgbGFzdE1vZGlmaWVkOiBkXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnN0cmVhbSguLi5hcmdzKVxuICB9XG5cbiAgYXJyYXlCdWZmZXIgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UuYXJyYXlCdWZmZXIoLi4uYXJncylcbiAgfVxuXG4gIHNsaWNlICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNsaWNlKC4uLmFyZ3MpXG4gIH1cblxuICB0ZXh0ICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnRleHQoLi4uYXJncylcbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2l6ZVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS50eXBlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm5hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdGaWxlJ1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGUucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGaWxlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbmFtZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGFzdE1vZGlmaWVkOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5CbG9iID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihCbG9iKVxuXG53ZWJpZGwuY29udmVydGVycy5CbG9iUGFydCA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0Jykge1xuICAgIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHxcbiAgICAgIHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVilcbiAgICApIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoViwgb3B0cylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIG9wdHMpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCbG9iUGFydD4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQmxvYlBhcnRcbilcblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0ZpbGVBUEkvI2Rmbi1GaWxlUHJvcGVydHlCYWdcbndlYmlkbC5jb252ZXJ0ZXJzLkZpbGVQcm9wZXJ0eUJhZyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ2xhc3RNb2RpZmllZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10sXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKVxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogJ3R5cGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2VuZGluZ3MnLFxuICAgIGNvbnZlcnRlcjogKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh2YWx1ZSlcbiAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKVxuXG4gICAgICBpZiAodmFsdWUgIT09ICduYXRpdmUnKSB7XG4gICAgICAgIHZhbHVlID0gJ3RyYW5zcGFyZW50J1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZTogJ3RyYW5zcGFyZW50J1xuICB9XG5dKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0ZpbGVBUEkvI3Byb2Nlc3MtYmxvYi1wYXJ0c1xuICogQHBhcmFtIHsoTm9kZUpTLlR5cGVkQXJyYXl8QmxvYnxzdHJpbmcpW119IHBhcnRzXG4gKiBAcGFyYW0ge3sgdHlwZTogc3RyaW5nLCBlbmRpbmdzOiBzdHJpbmcgfX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwcm9jZXNzQmxvYlBhcnRzIChwYXJ0cywgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgYnl0ZXMgYmUgYW4gZW1wdHkgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gIC8qKiBAdHlwZSB7Tm9kZUpTLlR5cGVkQXJyYXlbXX0gKi9cbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIC8vIDIuIEZvciBlYWNoIGVsZW1lbnQgaW4gcGFydHM6XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBwYXJ0cykge1xuICAgIC8vIDEuIElmIGVsZW1lbnQgaXMgYSBVU1ZTdHJpbmcsIHJ1biB0aGUgZm9sbG93aW5nIHN1YnN0ZXBzOlxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIDEuIExldCBzIGJlIGVsZW1lbnQuXG4gICAgICBsZXQgcyA9IGVsZW1lbnRcblxuICAgICAgLy8gMi4gSWYgdGhlIGVuZGluZ3MgbWVtYmVyIG9mIG9wdGlvbnMgaXMgXCJuYXRpdmVcIiwgc2V0IHNcbiAgICAgIC8vICAgIHRvIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBsaW5lIGVuZGluZ3MgdG8gbmF0aXZlXG4gICAgICAvLyAgICBvZiBlbGVtZW50LlxuICAgICAgaWYgKG9wdGlvbnMuZW5kaW5ncyA9PT0gJ25hdGl2ZScpIHtcbiAgICAgICAgcyA9IGNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZShzKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBVVEYtOCBlbmNvZGluZyBzIHRvIGJ5dGVzLlxuICAgICAgYnl0ZXMucHVzaChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocykpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoZWxlbWVudCkgfHxcbiAgICAgIHR5cGVzLmlzVHlwZWRBcnJheShlbGVtZW50KVxuICAgICkge1xuICAgICAgLy8gMi4gSWYgZWxlbWVudCBpcyBhIEJ1ZmZlclNvdXJjZSwgZ2V0IGEgY29weSBvZiB0aGVcbiAgICAgIC8vICAgIGJ5dGVzIGhlbGQgYnkgdGhlIGJ1ZmZlciBzb3VyY2UsIGFuZCBhcHBlbmQgdGhvc2VcbiAgICAgIC8vICAgIGJ5dGVzIHRvIGJ5dGVzLlxuICAgICAgaWYgKCFlbGVtZW50LmJ1ZmZlcikgeyAvLyBBcnJheUJ1ZmZlclxuICAgICAgICBieXRlcy5wdXNoKG5ldyBVaW50OEFycmF5KGVsZW1lbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICBuZXcgVWludDhBcnJheShlbGVtZW50LmJ1ZmZlciwgZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVMZW5ndGgpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoZWxlbWVudCkpIHtcbiAgICAgIC8vIDMuIElmIGVsZW1lbnQgaXMgYSBCbG9iLCBhcHBlbmQgdGhlIGJ5dGVzIGl0IHJlcHJlc2VudHNcbiAgICAgIC8vICAgIHRvIGJ5dGVzLlxuICAgICAgYnl0ZXMucHVzaChlbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBieXRlcy5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRmlsZUFQSS8jY29udmVydC1saW5lLWVuZGluZ3MtdG8tbmF0aXZlXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0TGluZUVuZGluZ3NOYXRpdmUgKHMpIHtcbiAgLy8gMS4gTGV0IG5hdGl2ZSBsaW5lIGVuZGluZyBiZSBiZSB0aGUgY29kZSBwb2ludCBVKzAwMEEgTEYuXG4gIGxldCBuYXRpdmVMaW5lRW5kaW5nID0gJ1xcbidcblxuICAvLyAyLiBJZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybeKAmXMgY29udmVudGlvbnMgYXJlIHRvXG4gIC8vICAgIHJlcHJlc2VudCBuZXdsaW5lcyBhcyBhIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkXG4gIC8vICAgIHNlcXVlbmNlLCBzZXQgbmF0aXZlIGxpbmUgZW5kaW5nIHRvIHRoZSBjb2RlIHBvaW50XG4gIC8vICAgIFUrMDAwRCBDUiBmb2xsb3dlZCBieSB0aGUgY29kZSBwb2ludCBVKzAwMEEgTEYuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgbmF0aXZlTGluZUVuZGluZyA9ICdcXHJcXG4nXG4gIH1cblxuICByZXR1cm4gcy5yZXBsYWNlKC9cXHI/XFxuL2csIG5hdGl2ZUxpbmVFbmRpbmcpXG59XG5cbi8vIElmIHRoaXMgZnVuY3Rpb24gaXMgbW92ZWQgdG8gLi91dGlsLmpzLCBzb21lIHRvb2xzIChzdWNoIGFzXG4vLyByb2xsdXApIHdpbGwgd2FybiBhYm91dCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNjI5XG5mdW5jdGlvbiBpc0ZpbGVMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICAoTmF0aXZlRmlsZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYXRpdmVGaWxlKSB8fFxuICAgIG9iamVjdCBpbnN0YW5jZW9mIEZpbGUgfHwgKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnXG4gICAgKVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBGaWxlLCBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9XG4iXSwibmFtZXMiOlsiQmxvYiIsIkZpbGUiLCJOYXRpdmVGaWxlIiwicmVxdWlyZSIsInR5cGVzIiwia1N0YXRlIiwiaXNCbG9iTGlrZSIsIndlYmlkbCIsInBhcnNlTUlNRVR5cGUiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiY29uc3RydWN0b3IiLCJmaWxlQml0cyIsImZpbGVOYW1lIiwib3B0aW9ucyIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwiRmlsZVByb3BlcnR5QmFnIiwibiIsInQiLCJ0eXBlIiwiZCIsInN1YnN0ZXAiLCJ0b0xvd2VyQ2FzZSIsImxhc3RNb2RpZmllZCIsInByb2Nlc3NCbG9iUGFydHMiLCJuYW1lIiwiYnJhbmRDaGVjayIsIkZpbGVMaWtlIiwiYmxvYkxpa2UiLCJEYXRlIiwibm93Iiwic3RyZWFtIiwiYXJncyIsImFycmF5QnVmZmVyIiwic2xpY2UiLCJ0ZXh0Iiwic2l6ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiaW50ZXJmYWNlQ29udmVydGVyIiwiQmxvYlBhcnQiLCJWIiwib3B0cyIsInV0aWwiLCJUeXBlIiwic3RyaWN0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0FueUFycmF5QnVmZmVyIiwiQnVmZmVyU291cmNlIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiZGVmYXVsdFZhbHVlIiwiRE9NU3RyaW5nIiwicGFydHMiLCJieXRlcyIsImVsZW1lbnQiLCJzIiwiZW5kaW5ncyIsImNvbnZlcnRMaW5lRW5kaW5nc05hdGl2ZSIsInB1c2giLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImlzVHlwZWRBcnJheSIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIm5hdGl2ZUxpbmVFbmRpbmciLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJyZXBsYWNlIiwiaXNGaWxlTGlrZSIsIm9iamVjdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/formdata.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/fetch/formdata.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { isBlobLike, toUSVString, makeIterator } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { File: UndiciFile, FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/undici/lib/fetch/file.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { Blob, File: NativeFile } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {globalThis['File']} */ const File = NativeFile ?? UndiciFile;\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n    constructor(form){\n        if (form !== undefined) {\n            throw webidl.errors.conversionFailed({\n                prefix: \"FormData constructor\",\n                argument: \"Argument 1\",\n                types: [\n                    \"undefined\"\n                ]\n            });\n        }\n        this[kState] = [];\n    }\n    append(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.append\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with\n        // name, value, and filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. Append entry to this’s entry list.\n        this[kState].push(entry);\n    }\n    delete(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.delete\"\n        });\n        name = webidl.converters.USVString(name);\n        // The delete(name) method steps are to remove all entries whose name\n        // is name from this’s entry list.\n        this[kState] = this[kState].filter((entry)=>entry.name !== name);\n    }\n    get(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.get\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in this’s entry list,\n        // then return null.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx === -1) {\n            return null;\n        }\n        // 2. Return the value of the first entry whose name is name from\n        // this’s entry list.\n        return this[kState][idx].value;\n    }\n    getAll(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.getAll\"\n        });\n        name = webidl.converters.USVString(name);\n        // 1. If there is no entry whose name is name in this’s entry list,\n        // then return the empty list.\n        // 2. Return the values of all entries whose name is name, in order,\n        // from this’s entry list.\n        return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);\n    }\n    has(name) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.has\"\n        });\n        name = webidl.converters.USVString(name);\n        // The has(name) method steps are to return true if there is an entry\n        // whose name is name in this’s entry list; otherwise false.\n        return this[kState].findIndex((entry)=>entry.name === name) !== -1;\n    }\n    set(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"FormData.set\"\n        });\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // The set(name, value) and set(name, blobValue, filename) method steps\n        // are:\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name);\n        value = isBlobLike(value) ? webidl.converters.Blob(value, {\n            strict: false\n        }) : webidl.converters.USVString(value);\n        filename = arguments.length === 3 ? toUSVString(filename) : undefined;\n        // 2. Let entry be the result of creating an entry with name, value, and\n        // filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. If there are entries in this’s entry list whose name is name, then\n        // replace the first such entry with entry and remove the others.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx !== -1) {\n            this[kState] = [\n                ...this[kState].slice(0, idx),\n                entry,\n                ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)\n            ];\n        } else {\n            // 4. Otherwise, append entry to this’s entry list.\n            this[kState].push(entry);\n        }\n    }\n    entries() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key+value\");\n    }\n    keys() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, FormData);\n        return makeIterator(()=>this[kState].map((pair)=>[\n                    pair.name,\n                    pair.value\n                ]), \"FormData\", \"value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: FormData) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, FormData);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FormData.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n}\nFormData.prototype[Symbol.iterator] = FormData.prototype.entries;\nObject.defineProperties(FormData.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"FormData\",\n        configurable: true\n    }\n});\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */ function makeEntry(name, value, filename) {\n    // 1. Set name to the result of converting name into a scalar value string.\n    // \"To convert a string into a scalar value string, replace any surrogates\n    //  with U+FFFD.\"\n    // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end\n    name = Buffer.from(name).toString(\"utf8\");\n    // 2. If value is a string, then set value to the result of converting\n    //    value into a scalar value string.\n    if (typeof value === \"string\") {\n        value = Buffer.from(value).toString(\"utf8\");\n    } else {\n        // 3. Otherwise:\n        // 1. If value is not a File object, then set value to a new File object,\n        //    representing the same bytes, whose name attribute value is \"blob\"\n        if (!isFileLike(value)) {\n            value = value instanceof Blob ? new File([\n                value\n            ], \"blob\", {\n                type: value.type\n            }) : new FileLike(value, \"blob\", {\n                type: value.type\n            });\n        }\n        // 2. If filename is given, then set value to a new File object,\n        //    representing the same bytes, whose name attribute is filename.\n        if (filename !== undefined) {\n            /** @type {FilePropertyBag} */ const options = {\n                type: value.type,\n                lastModified: value.lastModified\n            };\n            value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([\n                value\n            ], filename, options) : new FileLike(value, filename, options);\n        }\n    }\n    // 4. Return an entry whose name is name and whose value is value.\n    return {\n        name,\n        value\n    };\n}\nmodule.exports = {\n    FormData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9mb3JtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMxRCxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLE1BQU1DLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDM0QsTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFTyxJQUFJLEVBQUVMLE1BQU1NLFVBQVUsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUUzQywrQkFBK0IsR0FDL0IsTUFBTUUsT0FBT00sY0FBY0w7QUFFM0Isd0NBQXdDO0FBQ3hDLE1BQU1NO0lBQ0pDLFlBQWFDLElBQUksQ0FBRTtRQUNqQixJQUFJQSxTQUFTQyxXQUFXO1lBQ3RCLE1BQU1OLE9BQU9PLE1BQU0sQ0FBQ0MsZ0JBQWdCLENBQUM7Z0JBQ25DQyxRQUFRO2dCQUNSQyxVQUFVO2dCQUNWQyxPQUFPO29CQUFDO2lCQUFZO1lBQ3RCO1FBQ0Y7UUFFQSxJQUFJLENBQUNoQixPQUFPLEdBQUcsRUFBRTtJQUNuQjtJQUVBaUIsT0FBUUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFdBQVdULFNBQVMsRUFBRTtRQUN6Q04sT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUViO1FBRXhCSCxPQUFPaUIsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQWtCO1FBRXJFLElBQUlELFVBQVVFLE1BQU0sS0FBSyxLQUFLLENBQUM3QixXQUFXdUIsUUFBUTtZQUNoRCxNQUFNLElBQUlPLFVBQ1I7UUFFSjtRQUVBLHVEQUF1RDtRQUV2RFIsT0FBT2IsT0FBT3NCLFVBQVUsQ0FBQ0MsU0FBUyxDQUFDVjtR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LGlCQUFpQjtJQUNqQiwrRkFBK0Y7SUFDL0ZGLE9BQU8wQyxPQUFPQyxJQUFJLENBQUMzQyxNQUFNNEMsUUFBUSxDQUFDO0lBRWxDLHNFQUFzRTtJQUN0RSx1Q0FBdUM7SUFDdkMsSUFBSSxPQUFPM0MsVUFBVSxVQUFVO1FBQzdCQSxRQUFReUMsT0FBT0MsSUFBSSxDQUFDMUMsT0FBTzJDLFFBQVEsQ0FBQztJQUN0QyxPQUFPO1FBQ0wsZ0JBQWdCO1FBRWhCLHlFQUF5RTtRQUN6RSx1RUFBdUU7UUFDdkUsSUFBSSxDQUFDMUQsV0FBV2UsUUFBUTtZQUN0QkEsUUFBUUEsaUJBQWlCYixPQUNyQixJQUFJTCxLQUFLO2dCQUFDa0I7YUFBTSxFQUFFLFFBQVE7Z0JBQUU0QyxNQUFNNUMsTUFBTTRDLElBQUk7WUFBQyxLQUM3QyxJQUFJNUQsU0FBU2dCLE9BQU8sUUFBUTtnQkFBRTRDLE1BQU01QyxNQUFNNEMsSUFBSTtZQUFDO1FBQ3JEO1FBRUEsZ0VBQWdFO1FBQ2hFLG9FQUFvRTtRQUNwRSxJQUFJM0MsYUFBYVQsV0FBVztZQUMxQiw0QkFBNEIsR0FDNUIsTUFBTXFELFVBQVU7Z0JBQ2RELE1BQU01QyxNQUFNNEMsSUFBSTtnQkFDaEJFLGNBQWM5QyxNQUFNOEMsWUFBWTtZQUNsQztZQUVBOUMsUUFBUSxjQUFlQSxpQkFBaUJaLGNBQWVZLGlCQUFpQmpCLGFBQ3BFLElBQUlELEtBQUs7Z0JBQUNrQjthQUFNLEVBQUVDLFVBQVU0QyxXQUM1QixJQUFJN0QsU0FBU2dCLE9BQU9DLFVBQVU0QztRQUNwQztJQUNGO0lBRUEsa0VBQWtFO0lBQ2xFLE9BQU87UUFBRTlDO1FBQU1DO0lBQU07QUFDdkI7QUFFQStDLE9BQU9DLE9BQU8sR0FBRztJQUFFM0Q7QUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvZm9ybWRhdGEuanM/ODY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc0Jsb2JMaWtlLCB0b1VTVlN0cmluZywgbWFrZUl0ZXJhdG9yIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IEZpbGU6IFVuZGljaUZpbGUsIEZpbGVMaWtlLCBpc0ZpbGVMaWtlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgQmxvYiwgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gTmF0aXZlRmlsZSA/PyBVbmRpY2lGaWxlXG5cbi8vIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jZm9ybWRhdGFcbmNsYXNzIEZvcm1EYXRhIHtcbiAgY29uc3RydWN0b3IgKGZvcm0pIHtcbiAgICBpZiAoZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICBwcmVmaXg6ICdGb3JtRGF0YSBjb25zdHJ1Y3RvcicsXG4gICAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCddXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba1N0YXRlXSA9IFtdXG4gIH1cblxuICBhcHBlbmQgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmFwcGVuZCcgfSlcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmICFpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYidcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcbiAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgICAgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpXG4gICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoXG4gICAgLy8gbmFtZSwgdmFsdWUsIGFuZCBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBBcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgfVxuXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmRlbGV0ZScgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIFRoZSBkZWxldGUobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZW1vdmUgYWxsIGVudHJpZXMgd2hvc2UgbmFtZVxuICAgIC8vIGlzIG5hbWUgZnJvbSB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHRoaXNba1N0YXRlXSA9IHRoaXNba1N0YXRlXS5maWx0ZXIoZW50cnkgPT4gZW50cnkubmFtZSAhPT0gbmFtZSlcbiAgfVxuXG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLmdldCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIDEuIElmIHRoZXJlIGlzIG5vIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0LFxuICAgIC8vIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgY29uc3QgaWR4ID0gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGZyb21cbiAgICAvLyB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV1baWR4XS52YWx1ZVxuICB9XG5cbiAgZ2V0QWxsIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZ2V0QWxsJyB9KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIGVtcHR5IGxpc3QuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGVudHJpZXMgd2hvc2UgbmFtZSBpcyBuYW1lLCBpbiBvcmRlcixcbiAgICAvLyBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVxuICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpXG4gIH1cblxuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdGb3JtRGF0YS5oYXMnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyBUaGUgaGFzKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYW4gZW50cnlcbiAgICAvLyB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSkgIT09IC0xXG4gIH1cblxuICBzZXQgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCB7IGhlYWRlcjogJ0Zvcm1EYXRhLnNldCcgfSlcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmICFpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnc2V0JyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYidcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRoZSBzZXQobmFtZSwgdmFsdWUpIGFuZCBzZXQobmFtZSwgYmxvYlZhbHVlLCBmaWxlbmFtZSkgbWV0aG9kIHN0ZXBzXG4gICAgLy8gYXJlOlxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSlcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSlcbiAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAgID8gdG9VU1ZTdHJpbmcoZmlsZW5hbWUpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aCBuYW1lLCB2YWx1ZSwgYW5kXG4gICAgLy8gZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGVudHJpZXMgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCB3aG9zZSBuYW1lIGlzIG5hbWUsIHRoZW5cbiAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBzdWNoIGVudHJ5IHdpdGggZW50cnkgYW5kIHJlbW92ZSB0aGUgb3RoZXJzLlxuICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSBbXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZSgwLCBpZHgpLFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cblxuICBlbnRyaWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiB0aGlzW2tTdGF0ZV0ubWFwKHBhaXIgPT4gW3BhaXIubmFtZSwgcGFpci52YWx1ZV0pLFxuICAgICAgJ0Zvcm1EYXRhJyxcbiAgICAgICdrZXkrdmFsdWUnXG4gICAgKVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gdGhpc1trU3RhdGVdLm1hcChwYWlyID0+IFtwYWlyLm5hbWUsIHBhaXIudmFsdWVdKSxcbiAgICAgICdGb3JtRGF0YScsXG4gICAgICAna2V5J1xuICAgIClcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gdGhpc1trU3RhdGVdLm1hcChwYWlyID0+IFtwYWlyLm5hbWUsIHBhaXIudmFsdWVdKSxcbiAgICAgICdGb3JtRGF0YScsXG4gICAgICAndmFsdWUnXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBzdHJpbmcsIGtleTogc3RyaW5nLCBzZWxmOiBGb3JtRGF0YSkgPT4gdm9pZH0gY2FsbGJhY2tGblxuICAgKiBAcGFyYW0ge3Vua25vd259IHRoaXNBcmdcbiAgICovXG4gIGZvckVhY2ggKGNhbGxiYWNrRm4sIHRoaXNBcmcgPSBnbG9iYWxUaGlzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRm9ybURhdGEuZm9yRWFjaCcgfSlcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2tGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZm9yRWFjaCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5cIlxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrRm4uYXBwbHkodGhpc0FyZywgW3ZhbHVlLCBrZXksIHRoaXNdKVxuICAgIH1cbiAgfVxufVxuXG5Gb3JtRGF0YS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEZvcm1EYXRhLnByb3RvdHlwZS5lbnRyaWVzXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZvcm1EYXRhLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRm9ybURhdGEnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY3JlYXRlLWFuLWVudHJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd8QmxvYn0gdmFsdWVcbiAqIEBwYXJhbSB7P3N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRyeSAobmFtZSwgdmFsdWUsIGZpbGVuYW1lKSB7XG4gIC8vIDEuIFNldCBuYW1lIHRvIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBuYW1lIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICAvLyBcIlRvIGNvbnZlcnQgYSBzdHJpbmcgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcsIHJlcGxhY2UgYW55IHN1cnJvZ2F0ZXNcbiAgLy8gIHdpdGggVStGRkZELlwiXG4gIC8vIHNlZTogaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxOC54L2RvY3MvYXBpL2J1ZmZlci5odG1sI2J1ZnRvc3RyaW5nZW5jb2Rpbmctc3RhcnQtZW5kXG4gIG5hbWUgPSBCdWZmZXIuZnJvbShuYW1lKS50b1N0cmluZygndXRmOCcpXG5cbiAgLy8gMi4gSWYgdmFsdWUgaXMgYSBzdHJpbmcsIHRoZW4gc2V0IHZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29udmVydGluZ1xuICAvLyAgICB2YWx1ZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZygndXRmOCcpXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gSWYgdmFsdWUgaXMgbm90IGEgRmlsZSBvYmplY3QsIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgdmFsdWUgaXMgXCJibG9iXCJcbiAgICBpZiAoIWlzRmlsZUxpa2UodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgQmxvYlxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sICdibG9iJywgeyB0eXBlOiB2YWx1ZS50eXBlIH0pXG4gICAgICAgIDogbmV3IEZpbGVMaWtlKHZhbHVlLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgIH1cblxuICAgIC8vIDIuIElmIGZpbGVuYW1lIGlzIGdpdmVuLCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIGlzIGZpbGVuYW1lLlxuICAgIGlmIChmaWxlbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKiogQHR5cGUge0ZpbGVQcm9wZXJ0eUJhZ30gKi9cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgIGxhc3RNb2RpZmllZDogdmFsdWUubGFzdE1vZGlmaWVkXG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gKE5hdGl2ZUZpbGUgJiYgdmFsdWUgaW5zdGFuY2VvZiBOYXRpdmVGaWxlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVuZGljaUZpbGVcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgb3B0aW9ucylcbiAgICAgICAgOiBuZXcgRmlsZUxpa2UodmFsdWUsIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBhbiBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgYW5kIHdob3NlIHZhbHVlIGlzIHZhbHVlLlxuICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBGb3JtRGF0YSB9XG4iXSwibmFtZXMiOlsiaXNCbG9iTGlrZSIsInRvVVNWU3RyaW5nIiwibWFrZUl0ZXJhdG9yIiwicmVxdWlyZSIsImtTdGF0ZSIsIkZpbGUiLCJVbmRpY2lGaWxlIiwiRmlsZUxpa2UiLCJpc0ZpbGVMaWtlIiwid2ViaWRsIiwiQmxvYiIsIk5hdGl2ZUZpbGUiLCJGb3JtRGF0YSIsImNvbnN0cnVjdG9yIiwiZm9ybSIsInVuZGVmaW5lZCIsImVycm9ycyIsImNvbnZlcnNpb25GYWlsZWQiLCJwcmVmaXgiLCJhcmd1bWVudCIsInR5cGVzIiwiYXBwZW5kIiwibmFtZSIsInZhbHVlIiwiZmlsZW5hbWUiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImxlbmd0aCIsIlR5cGVFcnJvciIsImNvbnZlcnRlcnMiLCJVU1ZTdHJpbmciLCJzdHJpY3QiLCJlbnRyeSIsIm1ha2VFbnRyeSIsInB1c2giLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXQiLCJpZHgiLCJmaW5kSW5kZXgiLCJnZXRBbGwiLCJtYXAiLCJoYXMiLCJzZXQiLCJzbGljZSIsImVudHJpZXMiLCJwYWlyIiwia2V5cyIsInZhbHVlcyIsImZvckVhY2giLCJjYWxsYmFja0ZuIiwidGhpc0FyZyIsImdsb2JhbFRoaXMiLCJrZXkiLCJhcHBseSIsInByb3RvdHlwZSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInRvU3RyaW5nVGFnIiwiY29uZmlndXJhYmxlIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwidHlwZSIsIm9wdGlvbnMiLCJsYXN0TW9kaWZpZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/formdata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/global.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fetch/global.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for(\"undici.globalOrigin.1\");\nfunction getGlobalOrigin() {\n    return globalThis[globalOrigin];\n}\nfunction setGlobalOrigin(newOrigin) {\n    if (newOrigin === undefined) {\n        Object.defineProperty(globalThis, globalOrigin, {\n            value: undefined,\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        return;\n    }\n    const parsedURL = new URL(newOrigin);\n    if (parsedURL.protocol !== \"http:\" && parsedURL.protocol !== \"https:\") {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n    }\n    Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nmodule.exports = {\n    getGlobalOrigin,\n    setGlobalOrigin\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxvREFBb0Q7QUFDcEQsNkJBQTZCO0FBQzdCLE1BQU1BLGVBQWVDLE9BQU9DLEdBQUcsQ0FBQztBQUVoQyxTQUFTQztJQUNQLE9BQU9DLFVBQVUsQ0FBQ0osYUFBYTtBQUNqQztBQUVBLFNBQVNLLGdCQUFpQkMsU0FBUztJQUNqQyxJQUFJQSxjQUFjQyxXQUFXO1FBQzNCQyxPQUFPQyxjQUFjLENBQUNMLFlBQVlKLGNBQWM7WUFDOUNVLE9BQU9IO1lBQ1BJLFVBQVU7WUFDVkMsWUFBWTtZQUNaQyxjQUFjO1FBQ2hCO1FBRUE7SUFDRjtJQUVBLE1BQU1DLFlBQVksSUFBSUMsSUFBSVQ7SUFFMUIsSUFBSVEsVUFBVUUsUUFBUSxLQUFLLFdBQVdGLFVBQVVFLFFBQVEsS0FBSyxVQUFVO1FBQ3JFLE1BQU0sSUFBSUMsVUFBVSxDQUFDLDZDQUE2QyxFQUFFSCxVQUFVRSxRQUFRLENBQUMsQ0FBQztJQUMxRjtJQUVBUixPQUFPQyxjQUFjLENBQUNMLFlBQVlKLGNBQWM7UUFDOUNVLE9BQU9JO1FBQ1BILFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQUssT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoQjtJQUNBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9nbG9iYWwuanM/NThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLCBpbmNyZWFzZSB0aGUgdmVyc2lvblxuLy8gbnVtYmVyIHRvIGF2b2lkIGNvbmZsaWN0cy5cbmNvbnN0IGdsb2JhbE9yaWdpbiA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxPcmlnaW4uMScpXG5cbmZ1bmN0aW9uIGdldEdsb2JhbE9yaWdpbiAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbE9yaWdpbl1cbn1cblxuZnVuY3Rpb24gc2V0R2xvYmFsT3JpZ2luIChuZXdPcmlnaW4pIHtcbiAgaWYgKG5ld09yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSlcblxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChuZXdPcmlnaW4pXG5cbiAgaWYgKHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBodHRwICYgaHR0cHMgdXJscyBhcmUgYWxsb3dlZCwgcmVjZWl2ZWQgJHtwYXJzZWRVUkwucHJvdG9jb2x9YClcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICB2YWx1ZTogcGFyc2VkVVJMLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEdsb2JhbE9yaWdpbixcbiAgc2V0R2xvYmFsT3JpZ2luXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsT3JpZ2luIiwiU3ltYm9sIiwiZm9yIiwiZ2V0R2xvYmFsT3JpZ2luIiwiZ2xvYmFsVGhpcyIsInNldEdsb2JhbE9yaWdpbiIsIm5ld09yaWdpbiIsInVuZGVmaW5lZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwYXJzZWRVUkwiLCJVUkwiLCJwcm90b2NvbCIsIlR5cGVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/headers.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/headers.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { kGuard } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { makeIterator, isValidHeaderName, isValidHeaderValue } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst kHeadersMap = Symbol(\"headers map\");\nconst kHeadersSortedMap = Symbol(\"headers map sorted\");\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    // Trimming the end with `.replace()` and a RegExp is typically subject to\n    // ReDoS. This is safer and faster.\n    let i = potentialValue.length;\n    while(/[\\r\\n\\t ]/.test(potentialValue.charAt(--i)));\n    return potentialValue.slice(0, i + 1).replace(/^[\\r\\n\\t ]+/, \"\");\n}\nfunction fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) {\n        for (const header of object){\n            // 1. If header does not contain exactly two items, then throw a TypeError.\n            if (header.length !== 2) {\n                throw webidl.errors.exception({\n                    header: \"Headers constructor\",\n                    message: `expected name/value pair to be length 2, found ${header.length}.`\n                });\n            }\n            // 2. Append (header’s first item, header’s second item) to headers.\n            headers.append(header[0], header[1]);\n        }\n    } else if (typeof object === \"object\" && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key → value in object,\n        //    append (key, value) to headers\n        for (const [key, value] of Object.entries(object)){\n            headers.append(key, value);\n        }\n    } else {\n        throw webidl.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }\n}\nclass HeadersList {\n    constructor(init){\n        /** @type {[string, string][]|null} */ this.cookies = null;\n        if (init instanceof HeadersList) {\n            this[kHeadersMap] = new Map(init[kHeadersMap]);\n            this[kHeadersSortedMap] = init[kHeadersSortedMap];\n            this.cookies = init.cookies;\n        } else {\n            this[kHeadersMap] = new Map(init);\n            this[kHeadersSortedMap] = null;\n        }\n    }\n    // https://fetch.spec.whatwg.org/#header-list-contains\n    contains(name) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        name = name.toLowerCase();\n        return this[kHeadersMap].has(name);\n    }\n    clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-append\n    append(name, value) {\n        this[kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    header’s name.\n        const lowercaseName = name.toLowerCase();\n        const exists = this[kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === \"cookie\" ? \"; \" : \", \";\n            this[kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else {\n            this[kHeadersMap].set(lowercaseName, {\n                name,\n                value\n            });\n        }\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies ??= [];\n            this.cookies.push(value);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-set\n    set(name, value) {\n        this[kHeadersSortedMap] = null;\n        const lowercaseName = name.toLowerCase();\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies = [\n                value\n            ];\n        }\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        return this[kHeadersMap].set(lowercaseName, {\n            name,\n            value\n        });\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-delete\n    delete(name) {\n        this[kHeadersSortedMap] = null;\n        name = name.toLowerCase();\n        if (name === \"set-cookie\") {\n            this.cookies = null;\n        }\n        return this[kHeadersMap].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-get\n    get(name) {\n        // 1. If list does not contain name, then return null.\n        if (!this.contains(name)) {\n            return null;\n        }\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return this[kHeadersMap].get(name.toLowerCase())?.value ?? null;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const [name, { value }] of this[kHeadersMap]){\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    get entries() {\n        const headers = {};\n        if (this[kHeadersMap].size) {\n            for (const { name, value } of this[kHeadersMap].values()){\n                headers[name] = value;\n            }\n        }\n        return headers;\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n    constructor(init = undefined){\n        this[kHeadersList] = new HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set this’s guard to \"none\".\n        this[kGuard] = \"none\";\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = webidl.converters.HeadersInit(init);\n            fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.append\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.append\",\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.append\",\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if headers’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n        // TODO\n        }\n        // 6. Otherwise, if headers’s guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // 7. Append (name, value) to headers’s header list.\n        // 8. If headers’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from headers\n        return this[kHeadersList].append(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.delete\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.delete\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. If this’s guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if this’s guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 6. If this’s header list does not contain name, then\n        //    return.\n        if (!this[kHeadersList].contains(name)) {\n            return;\n        }\n        // 7. Delete name from this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        return this[kHeadersList].delete(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.get\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.get\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return the result of getting name from this’s header\n        //    list.\n        return this[kHeadersList].get(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.has\"\n        });\n        name = webidl.converters.ByteString(name);\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.has\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return true if this’s header list contains name;\n        //    otherwise false.\n        return this[kHeadersList].contains(name);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, {\n            header: \"Headers.set\"\n        });\n        name = webidl.converters.ByteString(name);\n        value = webidl.converters.ByteString(value);\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.set\",\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If this’s guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if this’s guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if this’s guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this[kGuard] === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        } else if (this[kGuard] === \"request-no-cors\") {\n        // TODO\n        }\n        // 7. Set (name, value) in this’s header list.\n        // 8. If this’s guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        return this[kHeadersList].set(name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        webidl.brandCheck(this, Headers);\n        // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n        // 2. Return the values of all headers in this’s header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this[kHeadersList].cookies;\n        if (list) {\n            return [\n                ...list\n            ];\n        }\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [kHeadersSortedMap]() {\n        if (this[kHeadersList][kHeadersSortedMap]) {\n            return this[kHeadersList][kHeadersSortedMap];\n        }\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = [\n            ...this[kHeadersList]\n        ].sort((a, b)=>a[0] < b[0] ? -1 : 1);\n        const cookies = this[kHeadersList].cookies;\n        // 3. For each name of names:\n        for (const [name, value] of names){\n            // 1. If name is `set-cookie`, then:\n            if (name === \"set-cookie\") {\n                // 1. Let values be a list of all values of headers in list whose name\n                //    is a byte-case-insensitive match for name, in order.\n                // 2. For each value of values:\n                // 1. Append (name, value) to headers.\n                for (const value of cookies){\n                    headers.push([\n                        name,\n                        value\n                    ]);\n                }\n            } else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                assert(value !== null);\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        this[kHeadersList][kHeadersSortedMap] = headers;\n        // 4. Return headers.\n        return headers;\n    }\n    keys() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key\");\n    }\n    values() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"value\");\n    }\n    entries() {\n        webidl.brandCheck(this, Headers);\n        return makeIterator(()=>[\n                ...this[kHeadersSortedMap].values()\n            ], \"Headers\", \"key+value\");\n    }\n    /**\n   * @param {(value: string, key: string, self: Headers) => void} callbackFn\n   * @param {unknown} thisArg\n   */ forEach(callbackFn, thisArg = globalThis) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Headers.forEach\"\n        });\n        if (typeof callbackFn !== \"function\") {\n            throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n        }\n        for (const [key, value] of this){\n            callbackFn.apply(thisArg, [\n                value,\n                key,\n                this\n            ]);\n        }\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        webidl.brandCheck(this, Headers);\n        return this[kHeadersList];\n    }\n}\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    getSetCookie: kEnumerableProperty,\n    keys: kEnumerableProperty,\n    values: kEnumerableProperty,\n    entries: kEnumerableProperty,\n    forEach: kEnumerableProperty,\n    [Symbol.iterator]: {\n        enumerable: false\n    },\n    [Symbol.toStringTag]: {\n        value: \"Headers\",\n        configurable: true\n    }\n});\nwebidl.converters.HeadersInit = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (V[Symbol.iterator]) {\n            return webidl.converters[\"sequence<sequence<ByteString>>\"](V);\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V);\n    }\n    throw webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\n            \"sequence<sequence<ByteString>>\",\n            \"record<ByteString, ByteString>\"\n        ]\n    });\n};\nmodule.exports = {\n    fill,\n    Headers,\n    HeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlEQUFpRDtBQUVqRDtBQUVBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUUsbUJBQW1CLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUNKRyxZQUFZLEVBQ1pDLGlCQUFpQixFQUNqQkMsa0JBQWtCLEVBQ25CLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDM0IsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUM7QUFFdkIsTUFBTVEsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxvQkFBb0JELE9BQU87QUFFakM7OztDQUdDLEdBQ0QsU0FBU0UscUJBQXNCQyxjQUFjO0lBQzNDLHVEQUF1RDtJQUN2RCx1REFBdUQ7SUFDdkQsbUJBQW1CO0lBRW5CLDBFQUEwRTtJQUMxRSxtQ0FBbUM7SUFDbkMsSUFBSUMsSUFBSUQsZUFBZUUsTUFBTTtJQUM3QixNQUFPLFlBQVlDLElBQUksQ0FBQ0gsZUFBZUksTUFBTSxDQUFDLEVBQUVIO0lBQ2hELE9BQU9ELGVBQWVLLEtBQUssQ0FBQyxHQUFHSixJQUFJLEdBQUdLLE9BQU8sQ0FBQyxlQUFlO0FBQy9EO0FBRUEsU0FBU0MsS0FBTUMsT0FBTyxFQUFFQyxNQUFNO0lBQzVCLGdGQUFnRjtJQUVoRiw4REFBOEQ7SUFDOUQsMERBQTBEO0lBQzFELElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN6QixLQUFLLE1BQU1HLFVBQVVILE9BQVE7WUFDM0IsMkVBQTJFO1lBQzNFLElBQUlHLE9BQU9WLE1BQU0sS0FBSyxHQUFHO2dCQUN2QixNQUFNUixPQUFPbUIsTUFBTSxDQUFDQyxTQUFTLENBQUM7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d0IsU0FBUyxDQUFDakQsT0FBTztBQUU5REQsT0FBT21ELGdCQUFnQixDQUFDekIsUUFBUXdCLFNBQVMsRUFBRTtJQUN6Q3JELFFBQVExQjtJQUNSbUQsUUFBUW5EO0lBQ1IrQyxLQUFLL0M7SUFDTDJDLEtBQUszQztJQUNMaUQsS0FBS2pEO0lBQ0xrRSxjQUFjbEU7SUFDZHdFLE1BQU14RTtJQUNOc0QsUUFBUXREO0lBQ1I4QixTQUFTOUI7SUFDVHlFLFNBQVN6RTtJQUNULENBQUNPLE9BQU82QyxRQUFRLENBQUMsRUFBRTtRQUFFNkIsWUFBWTtJQUFNO0lBQ3ZDLENBQUMxRSxPQUFPMkUsV0FBVyxDQUFDLEVBQUU7UUFDcEJ0RCxPQUFPO1FBQ1B1RCxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQS9FLE9BQU9xRCxVQUFVLENBQUNDLFdBQVcsR0FBRyxTQUFVMEIsQ0FBQztJQUN6QyxJQUFJaEYsT0FBT2lGLElBQUksQ0FBQ0MsSUFBSSxDQUFDRixPQUFPLFVBQVU7UUFDcEMsSUFBSUEsQ0FBQyxDQUFDN0UsT0FBTzZDLFFBQVEsQ0FBQyxFQUFFO1lBQ3RCLE9BQU9oRCxPQUFPcUQsVUFBVSxDQUFDLGlDQUFpQyxDQUFDMkI7UUFDN0Q7UUFFQSxPQUFPaEYsT0FBT3FELFVBQVUsQ0FBQyxpQ0FBaUMsQ0FBQzJCO0lBQzdEO0lBRUEsTUFBTWhGLE9BQU9tQixNQUFNLENBQUNRLGdCQUFnQixDQUFDO1FBQ25DQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsT0FBTztZQUFDO1lBQWtDO1NBQWlDO0lBQzdFO0FBQ0Y7QUFFQXFELE9BQU9DLE9BQU8sR0FBRztJQUNmdkU7SUFDQXNDO0lBQ0FwQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9oZWFkZXJzLmpzPzBiYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IGtHdWFyZCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgbWFrZUl0ZXJhdG9yLFxuICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgaXNWYWxpZEhlYWRlclZhbHVlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBrSGVhZGVyc01hcCA9IFN5bWJvbCgnaGVhZGVycyBtYXAnKVxuY29uc3Qga0hlYWRlcnNTb3J0ZWRNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwIHNvcnRlZCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItdmFsdWUtbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gcG90ZW50aWFsVmFsdWVcbiAqL1xuZnVuY3Rpb24gaGVhZGVyVmFsdWVOb3JtYWxpemUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vICBUbyBub3JtYWxpemUgYSBieXRlIHNlcXVlbmNlIHBvdGVudGlhbFZhbHVlLCByZW1vdmVcbiAgLy8gIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgYnl0ZXMgZnJvbVxuICAvLyAgcG90ZW50aWFsVmFsdWUuXG5cbiAgLy8gVHJpbW1pbmcgdGhlIGVuZCB3aXRoIGAucmVwbGFjZSgpYCBhbmQgYSBSZWdFeHAgaXMgdHlwaWNhbGx5IHN1YmplY3QgdG9cbiAgLy8gUmVEb1MuIFRoaXMgaXMgc2FmZXIgYW5kIGZhc3Rlci5cbiAgbGV0IGkgPSBwb3RlbnRpYWxWYWx1ZS5sZW5ndGhcbiAgd2hpbGUgKC9bXFxyXFxuXFx0IF0vLnRlc3QocG90ZW50aWFsVmFsdWUuY2hhckF0KC0taSkpKTtcbiAgcmV0dXJuIHBvdGVudGlhbFZhbHVlLnNsaWNlKDAsIGkgKyAxKS5yZXBsYWNlKC9eW1xcclxcblxcdCBdKy8sICcnKVxufVxuXG5mdW5jdGlvbiBmaWxsIChoZWFkZXJzLCBvYmplY3QpIHtcbiAgLy8gVG8gZmlsbCBhIEhlYWRlcnMgb2JqZWN0IGhlYWRlcnMgd2l0aCBhIGdpdmVuIG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBzZXF1ZW5jZSwgdGhlbiBmb3IgZWFjaCBoZWFkZXIgaW4gb2JqZWN0OlxuICAvLyBOb3RlOiB3ZWJpZGwgY29udmVyc2lvbiB0byBhcnJheSBoYXMgYWxyZWFkeSBiZWVuIGRvbmUuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBvYmplY3QpIHtcbiAgICAgIC8vIDEuIElmIGhlYWRlciBkb2VzIG5vdCBjb250YWluIGV4YWN0bHkgdHdvIGl0ZW1zLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgICAgIG1lc3NhZ2U6IGBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kICR7aGVhZGVyLmxlbmd0aH0uYFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgKGhlYWRlcuKAmXMgZmlyc3QgaXRlbSwgaGVhZGVy4oCZcyBzZWNvbmQgaXRlbSkgdG8gaGVhZGVycy5cbiAgICAgIGhlYWRlcnMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiBudWxsIHNob3VsZCB0aHJvd1xuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBvYmplY3QgaXMgYSByZWNvcmQsIHRoZW4gZm9yIGVhY2gga2V5IOKGkiB2YWx1ZSBpbiBvYmplY3QsXG4gICAgLy8gICAgYXBwZW5kIChrZXksIHZhbHVlKSB0byBoZWFkZXJzXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc0xpc3Qge1xuICAvKiogQHR5cGUge1tzdHJpbmcsIHN0cmluZ11bXXxudWxsfSAqL1xuICBjb29raWVzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChpbml0KSB7XG4gICAgaWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXRba0hlYWRlcnNNYXBdKVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBpbml0W2tIZWFkZXJzU29ydGVkTWFwXVxuICAgICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0KVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci1saXN0LWNvbnRhaW5zXG4gIGNvbnRhaW5zIChuYW1lKSB7XG4gICAgLy8gQSBoZWFkZXIgbGlzdCBsaXN0IGNvbnRhaW5zIGEgaGVhZGVyIG5hbWUgbmFtZSBpZiBsaXN0XG4gICAgLy8gY29udGFpbnMgYSBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIG1hdGNoIGZvciBuYW1lLlxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5oYXMobmFtZSlcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzW2tIZWFkZXJzTWFwXS5jbGVhcigpXG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgdGhpcy5jb29raWVzID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtYXBwZW5kXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgbmFtZSB0byB0aGUgZmlyc3Qgc3VjaFxuICAgIC8vICAgIGhlYWRlcuKAmXMgbmFtZS5cbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgZXhpc3RzID0gdGhpc1trSGVhZGVyc01hcF0uZ2V0KGxvd2VyY2FzZU5hbWUpXG5cbiAgICAvLyAyLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGxvd2VyY2FzZU5hbWUgPT09ICdjb29raWUnID8gJzsgJyA6ICcsICdcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7XG4gICAgICAgIG5hbWU6IGV4aXN0cy5uYW1lLFxuICAgICAgICB2YWx1ZTogYCR7ZXhpc3RzLnZhbHVlfSR7ZGVsaW1pdGVyfSR7dmFsdWV9YFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgICB9XG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICB0aGlzLmNvb2tpZXMgPz89IFtdXG4gICAgICB0aGlzLmNvb2tpZXMucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zZXRcbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IFt2YWx1ZV1cbiAgICB9XG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IHRoZSB2YWx1ZSBvZlxuICAgIC8vICAgIHRoZSBmaXJzdCBzdWNoIGhlYWRlciB0byB2YWx1ZSBhbmQgcmVtb3ZlIHRoZVxuICAgIC8vICAgIG90aGVycy5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGFwcGVuZCBoZWFkZXIgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwgeyBuYW1lLCB2YWx1ZSB9KVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuXG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldFxuICBnZXQgKG5hbWUpIHtcbiAgICAvLyAxLiBJZiBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlbiByZXR1cm4gbnVsbC5cbiAgICBpZiAoIXRoaXMuY29udGFpbnMobmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsXG4gICAgLy8gICAgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSAweDJDIDB4MjAsIGluIG9yZGVyLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5nZXQobmFtZS50b0xvd2VyQ2FzZSgpKT8udmFsdWUgPz8gbnVsbFxuICB9XG5cbiAgKiBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgLy8gdXNlIHRoZSBsb3dlcmNhc2VkIG5hbWVcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB7IHZhbHVlIH1dIG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdXG4gICAgfVxuICB9XG5cbiAgZ2V0IGVudHJpZXMgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuXG4gICAgaWYgKHRoaXNba0hlYWRlcnNNYXBdLnNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlcnMtY2xhc3NcbmNsYXNzIEhlYWRlcnMge1xuICBjb25zdHJ1Y3RvciAoaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXNba0hlYWRlcnNMaXN0XSA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAvLyBUaGUgbmV3IEhlYWRlcnMoaW5pdCkgY29uc3RydWN0b3Igc3RlcHMgYXJlOlxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIGd1YXJkIHRvIFwibm9uZVwiLlxuICAgIHRoaXNba0d1YXJkXSA9ICdub25lJ1xuXG4gICAgLy8gMi4gSWYgaW5pdCBpcyBnaXZlbiwgdGhlbiBmaWxsIHRoaXMgd2l0aCBpbml0LlxuICAgIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdChpbml0KVxuICAgICAgZmlsbCh0aGlzLCBpbml0KVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1hcHBlbmRcbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHsgaGVhZGVyOiAnSGVhZGVycy5hcHBlbmQnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSlcblxuICAgIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gICAgLy8gMi4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSBvciB2YWx1ZSBpcyBub3QgYVxuICAgIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIHZhbHVlJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzW2tHdWFyZF0gPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH0gZWxzZSBpZiAodGhpc1trR3VhcmRdID09PSAncmVxdWVzdC1uby1jb3JzJykge1xuICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiOlxuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUsIHJldHVybi5cblxuICAgIC8vIDcuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc0xpc3RdLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1kZWxldGVcbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdIZWFkZXJzLmRlbGV0ZScgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5kZWxldGUnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgbmFtZVxuICAgIC8vICAgIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlciBuYW1lLCBhbmRcbiAgICAvLyAgICBuYW1lIGlzIG5vdCBhIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpc1xuICAgIC8vICAgIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09ICdyZXF1ZXN0LW5vLWNvcnMnKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBuYW1lLCB0aGVuXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIGlmICghdGhpc1trSGVhZGVyc0xpc3RdLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyA3LiBEZWxldGUgbmFtZSBmcm9tIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdIZWFkZXJzLmdldCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5nZXQnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXJcbiAgICAvLyAgICBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uZ2V0KG5hbWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtaGFzXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnSGVhZGVycy5oYXMnIH0pXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuaGFzJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgbmFtZTtcbiAgICAvLyAgICBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNMaXN0XS5jb250YWlucyhuYW1lKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLXNldFxuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgeyBoZWFkZXI6ICdIZWFkZXJzLnNldCcgfSlcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUpXG4gICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlKVxuXG4gICAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gICAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5zZXQnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuc2V0JyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiIGFuZFxuICAgIC8vICAgIG5hbWUvdmFsdWUgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXNba0d1YXJkXSA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gICAgfSBlbHNlIGlmICh0aGlzW2tHdWFyZF0gPT09ICdyZXF1ZXN0LW5vLWNvcnMnKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLy8gNy4gU2V0IChuYW1lLCB2YWx1ZSkgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpc1xuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF0uc2V0KG5hbWUsIHZhbHVlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWdldHNldGNvb2tpZVxuICBnZXRTZXRDb29raWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICAvLyAxLiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBTZXQtQ29va2llYCwgdGhlbiByZXR1cm4gwqsgwrsuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3Qgd2hvc2UgbmFtZSBpc1xuICAgIC8vICAgIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBgU2V0LUNvb2tpZWAsIGluIG9yZGVyLlxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXNba0hlYWRlcnNMaXN0XS5jb29raWVzXG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIFsuLi5saXN0XVxuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICBnZXQgW2tIZWFkZXJzU29ydGVkTWFwXSAoKSB7XG4gICAgaWYgKHRoaXNba0hlYWRlcnNMaXN0XVtrSGVhZGVyc1NvcnRlZE1hcF0pIHtcbiAgICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF1ba0hlYWRlcnNTb3J0ZWRNYXBdXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgYW4gZW1wdHkgbGlzdCBvZiBoZWFkZXJzIHdpdGggdGhlIGtleSBiZWluZyB0aGUgbmFtZVxuICAgIC8vICAgIGFuZCB2YWx1ZSB0aGUgdmFsdWUuXG4gICAgY29uc3QgaGVhZGVycyA9IFtdXG5cbiAgICAvLyAyLiBMZXQgbmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0IGhlYWRlciBuYW1lcyB0byBhIHNvcnRlZC1sb3dlcmNhc2VcbiAgICAvLyAgICBzZXQgd2l0aCBhbGwgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzIGluIGxpc3QuXG4gICAgY29uc3QgbmFtZXMgPSBbLi4udGhpc1trSGVhZGVyc0xpc3RdXS5zb3J0KChhLCBiKSA9PiBhWzBdIDwgYlswXSA/IC0xIDogMSlcbiAgICBjb25zdCBjb29raWVzID0gdGhpc1trSGVhZGVyc0xpc3RdLmNvb2tpZXNcblxuICAgIC8vIDMuIEZvciBlYWNoIG5hbWUgb2YgbmFtZXM6XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG5hbWVzKSB7XG4gICAgICAvLyAxLiBJZiBuYW1lIGlzIGBzZXQtY29va2llYCwgdGhlbjpcbiAgICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgLy8gMS4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBvZiBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgICAgICAvLyAgICBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgbmFtZSwgaW4gb3JkZXIuXG5cbiAgICAgICAgLy8gMi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICAgICAgICAvLyAxLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlOlxuXG4gICAgICAgIC8vIDEuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIGxpc3QuXG5cbiAgICAgICAgLy8gMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgICAgYXNzZXJ0KHZhbHVlICE9PSBudWxsKVxuXG4gICAgICAgIC8vIDMuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnMuXG4gICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgdmFsdWVdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0hlYWRlcnNMaXN0XVtrSGVhZGVyc1NvcnRlZE1hcF0gPSBoZWFkZXJzXG5cbiAgICAvLyA0LiBSZXR1cm4gaGVhZGVycy5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHJldHVybiBtYWtlSXRlcmF0b3IoXG4gICAgICAoKSA9PiBbLi4udGhpc1trSGVhZGVyc1NvcnRlZE1hcF0udmFsdWVzKCldLFxuICAgICAgJ0hlYWRlcnMnLFxuICAgICAgJ2tleSdcbiAgICApXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKFxuICAgICAgKCkgPT4gWy4uLnRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdLnZhbHVlcygpXSxcbiAgICAgICdIZWFkZXJzJyxcbiAgICAgICd2YWx1ZSdcbiAgICApXG4gIH1cblxuICBlbnRyaWVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihcbiAgICAgICgpID0+IFsuLi50aGlzW2tIZWFkZXJzU29ydGVkTWFwXS52YWx1ZXMoKV0sXG4gICAgICAnSGVhZGVycycsXG4gICAgICAna2V5K3ZhbHVlJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZywgc2VsZjogSGVhZGVycykgPT4gdm9pZH0gY2FsbGJhY2tGblxuICAgKiBAcGFyYW0ge3Vua25vd259IHRoaXNBcmdcbiAgICovXG4gIGZvckVhY2ggKGNhbGxiYWNrRm4sIHRoaXNBcmcgPSBnbG9iYWxUaGlzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdIZWFkZXJzLmZvckVhY2gnIH0pXG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICdIZWFkZXJzJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5cIlxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrRm4uYXBwbHkodGhpc0FyZywgW3ZhbHVlLCBrZXksIHRoaXNdKVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTGlzdF1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0U2V0Q29va2llOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB2YWx1ZXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVudHJpZXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZvckVhY2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdIZWFkZXJzJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQgPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoVltTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddKFYpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXShWKVxuICB9XG5cbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlsbCxcbiAgSGVhZGVycyxcbiAgSGVhZGVyc0xpc3Rcbn1cbiJdLCJuYW1lcyI6WyJrSGVhZGVyc0xpc3QiLCJyZXF1aXJlIiwia0d1YXJkIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIm1ha2VJdGVyYXRvciIsImlzVmFsaWRIZWFkZXJOYW1lIiwiaXNWYWxpZEhlYWRlclZhbHVlIiwid2ViaWRsIiwiYXNzZXJ0Iiwia0hlYWRlcnNNYXAiLCJTeW1ib2wiLCJrSGVhZGVyc1NvcnRlZE1hcCIsImhlYWRlclZhbHVlTm9ybWFsaXplIiwicG90ZW50aWFsVmFsdWUiLCJpIiwibGVuZ3RoIiwidGVzdCIsImNoYXJBdCIsInNsaWNlIiwicmVwbGFjZSIsImZpbGwiLCJoZWFkZXJzIiwib2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiaGVhZGVyIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImFwcGVuZCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImNvbnZlcnNpb25GYWlsZWQiLCJwcmVmaXgiLCJhcmd1bWVudCIsInR5cGVzIiwiSGVhZGVyc0xpc3QiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJjb29raWVzIiwiTWFwIiwiY29udGFpbnMiLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJoYXMiLCJjbGVhciIsImxvd2VyY2FzZU5hbWUiLCJleGlzdHMiLCJnZXQiLCJkZWxpbWl0ZXIiLCJzZXQiLCJwdXNoIiwiZGVsZXRlIiwiaXRlcmF0b3IiLCJzaXplIiwidmFsdWVzIiwiSGVhZGVycyIsInVuZGVmaW5lZCIsImNvbnZlcnRlcnMiLCJIZWFkZXJzSW5pdCIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiQnl0ZVN0cmluZyIsImludmFsaWRBcmd1bWVudCIsInR5cGUiLCJUeXBlRXJyb3IiLCJnZXRTZXRDb29raWUiLCJsaXN0IiwibmFtZXMiLCJzb3J0IiwiYSIsImIiLCJrZXlzIiwiZm9yRWFjaCIsImNhbGxiYWNrRm4iLCJ0aGlzQXJnIiwiZ2xvYmFsVGhpcyIsImFwcGx5IiwiZm9yIiwicHJvdG90eXBlIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsIlYiLCJ1dGlsIiwiVHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/index.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/fetch/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/undici/lib/fetch/response.js\");\nconst { Headers } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\");\nconst { Request, makeRequest } = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/undici/lib/fetch/request.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { safelyExtractBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/fetch/body.js\");\nconst { redirectStatus, nullBodyStatus, safeMethods, requestBodyHeader, subresource, DOMException } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst { Readable, pipeline } = __webpack_require__(/*! stream */ \"stream\");\nconst { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { dataURLProcessor, serializeAMimeType } = __webpack_require__(/*! ./dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { TransformStream } = __webpack_require__(/*! stream/web */ \"stream/web\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/./node_modules/undici/lib/global.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\n/** @type {import('buffer').resolveObjectURL} */ let resolveObjectURL;\nlet ReadableStream = globalThis.ReadableStream;\nclass Fetch extends EE {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n        // 2 terminated listeners get added per request,\n        // but only 1 gets removed. If there are 20 redirects,\n        // 21 listeners will be added.\n        // See https://github.com/nodejs/undici/issues/1711\n        // TODO (fix): Find and fix root cause for leaked listener.\n        this.setMaxListeners(21);\n    }\n    terminate(reason) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        this.state = \"terminated\";\n        this.connection?.destroy(reason);\n        this.emit(\"terminated\", reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        // 1. Set controller’s state to \"aborted\".\n        this.state = \"aborted\";\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) {\n            error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        }\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controller’s serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit(\"terminated\", error);\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, {\n        header: \"globalThis.fetch\"\n    });\n    // 1. Let p be a new promise.\n    const p = createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObject’s request.\n    const request = requestObject[kState];\n    // 4. If requestObject’s signal’s aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObject’s signal’s abort reason.\n        abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be request’s client’s global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // request’s service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === \"ServiceWorkerGlobalScope\") {\n        request.serviceWorkers = \"none\";\n    }\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be this’s relevant Realm.\n    const relevantRealm = null;\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObject’s signal:\n    addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        assert(controller != null);\n        // 3. Abort controller with requestObject’s signal’s abort reason.\n        controller.abort(requestObject.signal.reason);\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObject’s signal’s abort reason.\n        abortFetch(p, request, responseObject, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    const handleFetchDone = (response)=>finalizeAndReportTiming(response, \"fetch\");\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) {\n            return Promise.resolve();\n        }\n        // 2. If response’s aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controller’s serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return Promise.resolve();\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === \"error\") {\n            p.reject(Object.assign(new TypeError(\"fetch failed\"), {\n                cause: response.error\n            }));\n            return Promise.resolve();\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new Response();\n        responseObject[kState] = response;\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = response.headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject);\n    };\n    controller = fetching({\n        request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = \"other\") {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === \"error\" && response.aborted) {\n        return;\n    }\n    // 2. If response’s URL list is null or empty, then return.\n    if (!response.urlList?.length) {\n        return;\n    }\n    // 3. Let originalURL be response’s URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be response’s timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be response’s cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n    if (!urlIsHttpHttpsScheme(originalURL)) {\n        return;\n    }\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) {\n        return;\n    }\n    // 8. If response’s timing allow passed flag is not set, then:\n    if (!timingInfo.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = \"\";\n    }\n    // 9. Set timingInfo’s end time to the coarsened shared current time\n    // given global’s relevant settings object’s cross-origin isolated\n    // capability.\n    // TODO: given global’s relevant settings object’s cross-origin isolated\n    // capability?\n    timingInfo.endTime = coarsenedSharedCurrentTime();\n    // 10. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming(timingInfo, originalURL, initiatorType, globalThis1, cacheState) {\n    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {\n        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis1, cacheState);\n    }\n}\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n    // Note: AbortSignal.reason was added in node v17.2.0\n    // which would give us an undefined error to reject with.\n    // Remove this once node v16 is no longer supported.\n    if (!error) {\n        error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n    // 1. Reject promise with error.\n    p.reject(error);\n    // 2. If request’s body is not null and is readable, then cancel request’s\n    // body with error.\n    if (request.body != null && isReadable(request.body?.stream)) {\n        request.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) {\n        return;\n    }\n    // 4. Let response be responseObject’s response.\n    const response = responseObject[kState];\n    // 5. If response’s body is not null and is readable, then error response’s\n    // body with error.\n    if (response.body != null && isReadable(response.body?.stream)) {\n        response.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher// undici\n }) {\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If request’s client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to request’s client’s global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = createOpaqueTimingInfo({\n        startTime: currenTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n    };\n    // 7. If request’s body is a byte sequence, then set request’s body to\n    //    request’s body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    assert(!request.body || request.body.stream);\n    // 8. If request’s window is \"client\", then set request’s window to request’s\n    // client, if request’s client’s global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === \"client\") {\n        // TODO: What if request.client is null?\n        request.window = request.client?.globalObject?.constructor?.name === \"Window\" ? request.client : \"no-window\";\n    }\n    // 9. If request’s origin is \"client\", then set request’s origin to request’s\n    // client’s origin.\n    if (request.origin === \"client\") {\n        // TODO: What if request.client is null?\n        request.origin = request.client?.origin;\n    }\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If request’s policy container is \"client\", then:\n    if (request.policyContainer === \"client\") {\n        // 1. If request’s client is non-null, then set request’s policy\n        // container to a clone of request’s client’s policy container. [HTML]\n        if (request.client != null) {\n            request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n        } else {\n            // 2. Otherwise, set request’s policy container to a new policy\n            // container.\n            request.policyContainer = makePolicyContainer();\n        }\n    }\n    // 12. If request’s header list does not contain `Accept`, then:\n    if (!request.headersList.contains(\"accept\")) {\n        // 1. Let value be `*/*`.\n        const value = \"*/*\";\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on request’s destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to request’s header list.\n        request.headersList.append(\"accept\", value);\n    }\n    // 13. If request’s header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // request’s header list.\n    if (!request.headersList.contains(\"accept-language\")) {\n        request.headersList.append(\"accept-language\", \"*\");\n    }\n    // 14. If request’s priority is null, then use request’s initiator and\n    // destination appropriately in setting request’s priority to a\n    // user-agent-defined object.\n    if (request.priority === null) {\n    // TODO\n    }\n    // 15. If request is a subresource request, then:\n    if (subresource.includes(request.destination)) {\n    // TODO\n    }\n    // 16. Run main fetch given fetchParams.\n    mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If request’s local-URLs-only flag is set and request’s current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n        response = makeNetworkError(\"local URLs only\");\n    }\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If request’s referrer policy is the empty string, then set request’s\n    // referrer policy to request’s policy container’s referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = request.policyContainer.referrerPolicy;\n    }\n    // 8. If request’s referrer is not \"no-referrer\", then set request’s\n    // referrer to the result of invoking determine request’s referrer.\n    if (request.referrer !== \"no-referrer\") {\n        request.referrer = determineRequestsReferrer(request);\n    }\n    // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n    // conditions are true:\n    // - request’s current URL’s scheme is \"http\"\n    // - request’s current URL’s host is a domain\n    // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n        response = await (async ()=>{\n            const currentURL = requestCurrentURL(request);\n            if (// - request’s current URL’s origin is same origin with request’s origin,\n            //   and request’s response tainting is \"basic\"\n            sameOrigin(currentURL, request.url) && request.responseTainting === \"basic\" || // request’s current URL’s scheme is \"data\"\n            currentURL.protocol === \"data:\" || // - request’s mode is \"navigate\" or \"websocket\"\n            request.mode === \"navigate\" || request.mode === \"websocket\") {\n                // 1. Set request’s response tainting to \"basic\".\n                request.responseTainting = \"basic\";\n                // 2. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // request’s mode is \"same-origin\"\n            if (request.mode === \"same-origin\") {\n                // 1. Return a network error.\n                return makeNetworkError('request mode cannot be \"same-origin\"');\n            }\n            // request’s mode is \"no-cors\"\n            if (request.mode === \"no-cors\") {\n                // 1. If request’s redirect mode is not \"follow\", then return a network\n                // error.\n                if (request.redirect !== \"follow\") {\n                    return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n                }\n                // 2. Set request’s response tainting to \"opaque\".\n                request.responseTainting = \"opaque\";\n                // 3. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // request’s current URL’s scheme is not an HTTP(S) scheme\n            if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n                // Return a network error.\n                return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n            }\n            // - request’s use-CORS-preflight flag is set\n            // - request’s unsafe-request flag is set and either request’s method is\n            //   not a CORS-safelisted method or CORS-unsafe request-header names with\n            //   request’s header list is not empty\n            //    1. Set request’s response tainting to \"cors\".\n            //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n            //    given fetchParams and true.\n            //    3. If corsWithPreflightResponse is a network error, then clear cache\n            //    entries using request.\n            //    4. Return corsWithPreflightResponse.\n            // TODO\n            // Otherwise\n            //    1. Set request’s response tainting to \"cors\".\n            request.responseTainting = \"cors\";\n            //    2. Return the result of running HTTP fetch given fetchParams.\n            return await httpFetch(fetchParams);\n        })();\n    }\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n        return response;\n    }\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If request’s response tainting is \"cors\", then:\n        if (request.responseTainting === \"cors\") {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and response’s header list.\n        // TODO\n        // 2. If request’s credentials mode is not \"include\" and headerNames\n        // contains `*`, then set response’s CORS-exposed header-name list to\n        // all unique header names in response’s header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // response’s CORS-exposed header-name list to headerNames.\n        // TODO\n        }\n        // Set response to the following filtered response with response as its\n        // internal response, depending on request’s response tainting:\n        if (request.responseTainting === \"basic\") {\n            response = filterResponse(response, \"basic\");\n        } else if (request.responseTainting === \"cors\") {\n            response = filterResponse(response, \"cors\");\n        } else if (request.responseTainting === \"opaque\") {\n            response = filterResponse(response, \"opaque\");\n        } else {\n            assert(false);\n        }\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and response’s internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponse’s URL list is empty, then set it to a clone of\n    // request’s URL list.\n    if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request.urlList);\n    }\n    // 16. If request’s timing allow failed flag is unset, then set\n    // internalResponse’s timing allow passed flag.\n    if (!request.timingAllowFailed) {\n        response.timingAllowPassed = true;\n    }\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n    // internalResponse’s range-requested flag is set, and request’s header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains(\"range\")) {\n        response = internalResponse = makeNetworkError();\n    }\n    // 19. If response is not a network error and either request’s method is\n    // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n    // set internalResponse’s body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === \"HEAD\" || request.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If request’s integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));\n        // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === \"opaque\" || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match request’s integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!bytesMatch(bytes, request.integrity)) {\n                processBodyError(\"integrity mismatch\");\n                return;\n            }\n            // 2. Set response’s body to bytes as a body.\n            response.body = safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read response’s body given processBody and processBodyError.\n        await fullyReadBody(response.body, processBody, processBodyError);\n    } else {\n        // 21. Otherwise, run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response);\n    }\n}\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n        return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n    }\n    // 2. Let request be fetchParams’s request.\n    const { request } = fetchParams;\n    const { protocol: scheme } = requestCurrentURL(request);\n    // 3. Switch on request’s current URL’s scheme and run the associated steps:\n    switch(scheme){\n        case \"about:\":\n            {\n                // If request’s current URL’s path is the string \"blank\", then return a new response\n                // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n                // and body is the empty byte sequence as a body.\n                // Otherwise, return a network error.\n                return Promise.resolve(makeNetworkError(\"about scheme is not supported\"));\n            }\n        case \"blob:\":\n            {\n                if (!resolveObjectURL) {\n                    resolveObjectURL = (__webpack_require__(/*! buffer */ \"buffer\").resolveObjectURL);\n                }\n                // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n                const blobURLEntry = requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) {\n                    return Promise.resolve(makeNetworkError(\"NetworkError when attempting to fetch resource.\"));\n                }\n                const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());\n                // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== \"GET\" || !isBlobLike(blobURLEntryObject)) {\n                    return Promise.resolve(makeNetworkError(\"invalid method\"));\n                }\n                // 3. Let bodyWithType be the result of safely extracting blobURLEntry’s object.\n                const bodyWithType = safelyExtractBody(blobURLEntryObject);\n                // 4. Let body be bodyWithType’s body.\n                const body = bodyWithType[0];\n                // 5. Let length be body’s length, serialized and isomorphic encoded.\n                const length = isomorphicEncode(`${body.length}`);\n                // 6. Let type be bodyWithType’s type if it is non-null; otherwise the empty byte sequence.\n                const type = bodyWithType[1] ?? \"\";\n                // 7. Return a new response whose status message is `OK`, header list is\n                //    « (`Content-Length`, length), (`Content-Type`, type) », and body is body.\n                const response = makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-length\",\n                            {\n                                name: \"Content-Length\",\n                                value: length\n                            }\n                        ],\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: type\n                            }\n                        ]\n                    ]\n                });\n                response.body = body;\n                return Promise.resolve(response);\n            }\n        case \"data:\":\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on request’s current URL.\n                const currentURL = requestCurrentURL(request);\n                const dataURLStruct = dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === \"failure\") {\n                    return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"));\n                }\n                // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n                const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is « (`Content-Type`, mimeType) »,\n                //    and body is dataURLStruct’s body as a body.\n                return Promise.resolve(makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case \"file:\":\n            {\n                // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n                // When in doubt, return a network error.\n                return Promise.resolve(makeNetworkError(\"not implemented... yet...\"));\n            }\n        case \"http:\":\n        case \"https:\":\n            {\n                // Return the result of running HTTP fetch given fetchParams.\n                return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));\n            }\n        default:\n            {\n                return Promise.resolve(makeNetworkError(\"unknown scheme\"));\n            }\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParams’s request’s done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParams’s process response done is not null, then queue a fetch\n    // task to run fetchParams’s process response done given response, with\n    // fetchParams’s task destination.\n    if (fetchParams.processResponseDone != null) {\n        queueMicrotask(()=>fetchParams.processResponseDone(response));\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n    // 1. If response is a network error, then:\n    if (response.type === \"error\") {\n        // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n        response.urlList = [\n            fetchParams.request.urlList[0]\n        ];\n        // 2. Set response’s timing info to the result of creating an opaque timing\n        // info for fetchParams’s timing info.\n        response.timingInfo = createOpaqueTimingInfo({\n            startTime: fetchParams.timingInfo.startTime\n        });\n    }\n    // 2. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Set fetchParams’s request’s done flag.\n        fetchParams.request.done = true;\n        // If fetchParams’s process response end-of-body is not null,\n        // then queue a fetch task to run fetchParams’s process response\n        // end-of-body given response with fetchParams’s task destination.\n        if (fetchParams.processResponseEndOfBody != null) {\n            queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n        }\n    };\n    // 3. If fetchParams’s process response is non-null, then queue a fetch task\n    // to run fetchParams’s process response given response, with fetchParams’s\n    // task destination.\n    if (fetchParams.processResponse != null) {\n        queueMicrotask(()=>fetchParams.processResponse(response));\n    }\n    // 4. If response’s body is null, then run processResponseEndOfBody.\n    if (response.body == null) {\n        processResponseEndOfBody();\n    } else {\n        // 5. Otherwise:\n        // 1. Let transformStream be a new a TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,\n        // enqueues chunk in transformStream.\n        const identityTransformAlgorithm = (chunk, controller)=>{\n            controller.enqueue(chunk);\n        };\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm\n        // and flushAlgorithm set to processResponseEndOfBody.\n        const transformStream = new TransformStream({\n            start () {},\n            transform: identityTransformAlgorithm,\n            flush: processResponseEndOfBody\n        }, {\n            size () {\n                return 1;\n            }\n        }, {\n            size () {\n                return 1;\n            }\n        });\n        // 4. Set response’s body to the result of piping response’s body through transformStream.\n        response.body = {\n            stream: response.body.stream.pipeThrough(transformStream)\n        };\n    }\n    // 6. If fetchParams’s process response consume body is non-null, then:\n    if (fetchParams.processResponseConsumeBody != null) {\n        // 1. Let processBody given nullOrBytes be this step: run fetchParams’s\n        // process response consume body given response and nullOrBytes.\n        const processBody = (nullOrBytes)=>fetchParams.processResponseConsumeBody(response, nullOrBytes);\n        // 2. Let processBodyError be this step: run fetchParams’s process\n        // response consume body given response and failure.\n        const processBodyError = (failure)=>fetchParams.processResponseConsumeBody(response, failure);\n        // 3. If response’s body is null, then queue a fetch task to run processBody\n        // given null, with fetchParams’s task destination.\n        if (response.body == null) {\n            queueMicrotask(()=>processBody(null));\n        } else {\n            // 4. Otherwise, fully read response’s body given processBody, processBodyError,\n            // and fetchParams’s task destination.\n            return fullyReadBody(response.body, processBody, processBodyError);\n        }\n        return Promise.resolve();\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If request’s service-workers mode is \"all\", then:\n    if (request.serviceWorkers === \"all\") {\n    // TODO\n    }\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If request’s redirect mode is \"follow\", then set request’s\n        // service-workers mode to \"none\".\n        if (request.redirect === \"follow\") {\n            request.serviceWorkers = \"none\";\n        }\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        // 4. If request’s response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === \"cors\" && corsCheck(request, response) === \"failure\") {\n            return makeNetworkError(\"cors failure\");\n        }\n        // 5. If the TAO check for request and response returns failure, then set\n        // request’s timing allow failed flag.\n        if (TAOCheck(request, response) === \"failure\") {\n            request.timingAllowFailed = true;\n        }\n    }\n    // 7. If either request’s response tainting or response’s type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // request’s origin, request’s client, request’s destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n    }\n    // 8. If actualResponse’s status is a redirect status, then:\n    if (redirectStatus.includes(actualResponse.status)) {\n        // 1. If actualResponse’s status is not 303, request’s body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== \"manual\") {\n            fetchParams.controller.connection.destroy();\n        }\n        // 2. Switch on request’s redirect mode:\n        if (request.redirect === \"error\") {\n            // Set response to a network error.\n            response = makeNetworkError(\"unexpected redirect\");\n        } else if (request.redirect === \"manual\") {\n            // Set response to an opaque-redirect filtered response whose internal\n            // response is actualResponse.\n            // NOTE(spec): On the web this would return an `opaqueredirect` response,\n            // but that doesn't make sense server side.\n            // See https://github.com/nodejs/undici/issues/1193.\n            response = actualResponse;\n        } else if (request.redirect === \"follow\") {\n            // Set response to the result of running HTTP-redirect fetch given\n            // fetchParams and response.\n            response = await httpRedirectFetch(fetchParams, response);\n        } else {\n            assert(false);\n        }\n    }\n    // 9. Set response’s timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and response’s internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponse’s location URL given request’s current\n    // URL’s fragment.\n    let locationURL;\n    try {\n        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) {\n            return response;\n        }\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve(makeNetworkError(err));\n    }\n    // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!urlIsHttpHttpsScheme(locationURL)) {\n        return Promise.resolve(makeNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n    }\n    // 7. If request’s redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) {\n        return Promise.resolve(makeNetworkError(\"redirect count exceeded\"));\n    }\n    // 8. Increase request’s redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n    // request’s origin is not same origin with locationURL’s origin, then return\n    //  a network error.\n    if (request.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    }\n    // 10. If request’s response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    }\n    // 11. If actualResponse’s status is not 303, request’s body is non-null,\n    // and request’s body’s source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n        return Promise.resolve(makeNetworkError());\n    }\n    // 12. If one of the following is true\n    // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n    // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === \"POST\" || actualResponse.status === 303 && ![\n        \"GET\",\n        \"HEAD\"\n    ].includes(request.method)) {\n        // then:\n        // 1. Set request’s method to `GET` and request’s body to null.\n        request.method = \"GET\";\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // request’s header list.\n        for (const headerName of requestBodyHeader){\n            request.headersList.delete(headerName);\n        }\n    }\n    // 13. If request’s current URL’s origin is not same origin with locationURL’s\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from request’s header list.\n    if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete(\"authorization\");\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete(\"cookie\");\n        request.headersList.delete(\"host\");\n    }\n    // 14. If request’s body is non-null, then set request’s body to the first return\n    // value of safely extracting request’s body’s source.\n    if (request.body != null) {\n        assert(request.body.source != null);\n        request.body = safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParams’s cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n    //  redirect start time to timingInfo’s start time.\n    if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n    }\n    // 18. Append locationURL to request’s URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set request’s referrer policy on redirect on request and\n    // actualResponse.\n    setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If request’s window is \"no-window\" and request’s redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === \"no-window\" && request.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = makeRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParams’s request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === \"include\" || request.credentials === \"same-origin\" && request.responseTainting === \"basic\";\n    //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        \"POST\",\n        \"PUT\"\n    ].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n    }\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) {\n        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n    }\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n    //    list.\n    if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue);\n    }\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequest’s header list.\n    //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n    //    then:\n    if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n    }\n    //    11. If httpRequest’s referrer is a URL, then append\n    //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n    //     to httpRequest’s header list.\n    if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", isomorphicEncode(httpRequest.referrer.href));\n    }\n    //    12. Append a request `Origin` header for httpRequest.\n    appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    appendFetchMetadata(httpRequest);\n    //    14. If httpRequest’s header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequest’s header list.\n    if (!httpRequest.headersList.contains(\"user-agent\")) {\n        httpRequest.headersList.append(\"user-agent\", typeof esbuildDetection === \"undefined\" ? \"undici\" : \"node\");\n    }\n    //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequest’s cache mode to \"no-store\".\n    if (httpRequest.cache === \"default\" && (httpRequest.headersList.contains(\"if-modified-since\") || httpRequest.headersList.contains(\"if-none-match\") || httpRequest.headersList.contains(\"if-unmodified-since\") || httpRequest.headersList.contains(\"if-match\") || httpRequest.headersList.contains(\"if-range\"))) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequest’s header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n    if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains(\"cache-control\")) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\");\n    }\n    //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        // 1. If httpRequest’s header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains(\"pragma\")) {\n            httpRequest.headersList.append(\"pragma\", \"no-cache\");\n        }\n        // 2. If httpRequest’s header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n        if (!httpRequest.headersList.contains(\"cache-control\")) {\n            httpRequest.headersList.append(\"cache-control\", \"no-cache\");\n        }\n    }\n    //    18. If httpRequest’s header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n    if (httpRequest.headersList.contains(\"range\")) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\");\n    }\n    //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n    //    header if httpRequest’s header list contains that header’s name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains(\"accept-encoding\")) {\n        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n            httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\");\n        } else {\n            httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\");\n        }\n    }\n    httpRequest.headersList.delete(\"host\");\n    //    20. If includeCredentials is true, then:\n    if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n    }\n    //    21. If there’s a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequest’s cache mode to\n    //    \"no-store\".\n    if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    if (httpRequest.mode !== \"no-store\" && httpRequest.mode !== \"reload\") {\n    // TODO: cache\n    }\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.mode === \"only-if-cached\") {\n            return makeNetworkError(\"only if cached\");\n        }\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        // TODO: cache\n        }\n        // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n        // then:\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        // TODO: cache\n        }\n        // 5. If response is null, then:\n        if (response == null) {\n            // 1. Set response to forwardResponse.\n            response = forwardResponse;\n        // 2. Store httpRequest and forwardResponse in httpCache, as per the\n        // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n        // TODO: cache\n        }\n    }\n    // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequest’s header list contains `Range`, then set response’s\n    // range-requested flag.\n    if (httpRequest.headersList.contains(\"range\")) {\n        response.rangeRequested = true;\n    }\n    // 13. Set response’s request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If response’s status is 401, httpRequest’s response tainting is not\n    // \"cors\", includeCredentials is true, and request’s window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If response’s status is 407, then:\n    if (response.status === 407) {\n        // 1. If request’s window is \"no-window\", then return a network error.\n        if (request.window === \"no-window\") {\n            return makeNetworkError();\n        }\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 4. Prompt the end user as appropriate in request’s window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return makeNetworkError(\"proxy authentication required\");\n    }\n    // 16. If all of the following are true\n    if (// response’s status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    if (isAuthenticationFetch) {\n    // TODO\n    }\n    // 18. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                this.abort?.(err ?? new DOMException(\"The operation was aborted.\", \"AbortError\"));\n            }\n        }\n    };\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) {\n        request.cache = \"no-store\";\n    }\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? \"yes\" : \"no\" // eslint-disable-line no-unused-vars\n    ;\n    // 8. Switch on request’s mode:\n    if (request.mode === \"websocket\") {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n    } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n    }\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfo’s final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connection’s\n    //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n    //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to request’s header list.\n    //    4. Set timingInfo’s final network-request start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If request’s body is non-null, and request’s body’s source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of request’s body in that buffer. If the user agent reads from\n    //        request’s body beyond that buffer’s size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfo’s final network-response start time to the coarsened\n    //        shared current time given fetchParams’s cross-origin isolated capability,\n    //        immediately after the user agent’s HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfo’s final network-response start time above.\n    //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n    //        2. Otherwise, return a network error.\n    // To transmit request’s body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParams’s process request end-of-body is\n    // non-null, then queue a fetch task given fetchParams’s process request\n    // end-of-body and fetchParams’s task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    } else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParams’s process request body is non-null, then run\n            // fetchParams’s process request body given bytes’s length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If fetchParams’s process request end-of-body is non-null,\n            // then run fetchParams’s process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) {\n                fetchParams.processRequestEndOfBody();\n            }\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n            if (e.name === \"AbortError\") {\n                fetchParams.controller.abort();\n            } else {\n                fetchParams.controller.terminate(e);\n            }\n        };\n        // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParams’s task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream){\n                    yield* processBodyChunk(bytes);\n                }\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body, status, statusText, headersList, socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) {\n            response = makeResponse({\n                status,\n                statusText,\n                headersList,\n                socket\n            });\n        } else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = makeResponse({\n                status,\n                statusText,\n                headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === \"AbortError\") {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return makeAppropriateNetworkError(fetchParams, err);\n        }\n        return makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = ()=>{\n        fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        fetchParams.controller.abort(reason);\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    const stream = new ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        }\n    }, {\n        highWaterMark: 0,\n        size () {\n            return 1;\n        }\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set response’s body to a new body whose stream is stream.\n    response.body = {\n        stream\n    };\n    //    2. If response is not a network error and request’s cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.on(\"terminated\", onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done, value } = await fetchParams.controller.next();\n                if (isAborted(fetchParams)) {\n                    break;\n                }\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n                    // zlib doesn't like empty streams.\n                    bytes = undefined;\n                } else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for response’s message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                readableStreamClose(fetchParams.controller.controller);\n                finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParams’s controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            fetchParams.controller.controller.enqueue(new Uint8Array(bytes));\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (!fetchParams.controller.controller.desiredSize) {\n                return;\n            }\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if (isAborted(fetchParams)) {\n            // 1. Set response’s aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParams’s\n            //    controller’s serialized abort reason and an\n            //    implementation-defined realm.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n            }\n        } else {\n            // 3. Otherwise, if stream is readable, error stream with a TypeError.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n                    cause: isErrorLike(reason) ? reason : undefined\n                }));\n            }\n        }\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    async function dispatch({ body }) {\n        const url = requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === \"websocket\" ? \"websocket\" : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection } = fetchParams.controller;\n                    if (connection.destroyed) {\n                        abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n                    } else {\n                        fetchParams.controller.on(\"terminated\", abort);\n                        this.abort = connection.abort = abort;\n                    }\n                },\n                onHeaders (status, headersList, resume, statusText) {\n                    if (status < 200) {\n                        return;\n                    }\n                    let codings = [];\n                    let location = \"\";\n                    const headers = new Headers();\n                    // For H2, the headers are a plain JS object\n                    // We distinguish between them and iterate accordingly\n                    if (Array.isArray(headersList)) {\n                        for(let n = 0; n < headersList.length; n += 2){\n                            const key = headersList[n + 0].toString(\"latin1\");\n                            const val = headersList[n + 1].toString(\"latin1\");\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim());\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers.append(key, val);\n                        }\n                    } else {\n                        const keys = Object.keys(headersList);\n                        for (const key of keys){\n                            const val = headersList[key];\n                            if (key.toLowerCase() === \"content-encoding\") {\n                                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                                // \"All content-coding values are case-insensitive...\"\n                                codings = val.toLowerCase().split(\",\").map((x)=>x.trim()).reverse();\n                            } else if (key.toLowerCase() === \"location\") {\n                                location = val;\n                            }\n                            headers.append(key, val);\n                        }\n                    }\n                    this.body = new Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = request.redirect === \"follow\" && location && redirectStatus.includes(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (request.method !== \"HEAD\" && request.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !willFollow) {\n                        for (const coding of codings){\n                            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                            if (coding === \"x-gzip\" || coding === \"gzip\") {\n                                decoders.push(zlib.createGunzip({\n                                    // Be less strict when decoding compressed responses, since sometimes\n                                    // servers send slightly invalid responses that are still accepted\n                                    // by common browsers.\n                                    // Always using Z_SYNC_FLUSH is what cURL does.\n                                    flush: zlib.constants.Z_SYNC_FLUSH,\n                                    finishFlush: zlib.constants.Z_SYNC_FLUSH\n                                }));\n                            } else if (coding === \"deflate\") {\n                                decoders.push(zlib.createInflate());\n                            } else if (coding === \"br\") {\n                                decoders.push(zlib.createBrotliDecompress());\n                            } else {\n                                decoders.length = 0;\n                                break;\n                            }\n                        }\n                    }\n                    resolve({\n                        status,\n                        statusText,\n                        headersList: headers[kHeadersList],\n                        body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on(\"error\", ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) {\n                        return;\n                    }\n                    // 1. If one or more bytes have been transmitted from response’s\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and response’s header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfo’s encoded body size by bytes’s length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, headersList, socket) {\n                    if (status !== 101) {\n                        return;\n                    }\n                    const headers = new Headers();\n                    for(let n = 0; n < headersList.length; n += 2){\n                        const key = headersList[n + 0].toString(\"latin1\");\n                        const val = headersList[n + 1].toString(\"latin1\");\n                        headers.append(key, val);\n                    }\n                    resolve({\n                        status,\n                        statusText: STATUS_CODES[status],\n                        headersList: headers[kHeadersList],\n                        socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch,\n    Fetch,\n    fetching,\n    finalizeAndReportTiming\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpREFBaUQ7QUFFakQ7QUFFQSxNQUFNLEVBQ0pBLFFBQVEsRUFDUkMsZ0JBQWdCLEVBQ2hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsWUFBWSxFQUNiLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDNUIsTUFBTSxFQUFFRSxPQUFPLEVBQUVDLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUN6QyxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQ0pLLFVBQVUsRUFDVkMsbUJBQW1CLEVBQ25CQyxvQkFBb0IsRUFDcEJDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyx5QkFBeUIsRUFDekJDLG1CQUFtQixFQUNuQkMsaUJBQWlCLEVBQ2pCQyxrQ0FBa0MsRUFDbENDLDZDQUE2QyxFQUM3Q0Msc0JBQXNCLEVBQ3RCQyxtQkFBbUIsRUFDbkJDLFNBQVMsRUFDVEMsOEJBQThCLEVBQzlCQyx5QkFBeUIsRUFDekJDLDBCQUEwQixFQUMxQkMscUJBQXFCLEVBQ3JCQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsYUFBYSxFQUNiQyxtQkFBbUIsRUFDbkJDLGdCQUFnQixFQUNoQkMsVUFBVSxFQUNWQyxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNsQixHQUFHaEMsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVpQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR3BDLG1CQUFPQSxDQUFDO0FBQ3JELE1BQU1xQyxTQUFTckMsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFc0MsaUJBQWlCLEVBQUUsR0FBR3RDLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFDSnVDLGNBQWMs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RSxZQUFZeEMsVUFBVSxDQUFDN0IsU0FBUyxDQUFDSztvQkFFakNXLE9BQU9YO2dCQUNUO2dCQUVBMk4sV0FBV3BJLE1BQU0sRUFBRW5ELFdBQVcsRUFBRThILE1BQU07b0JBQ3BDLElBQUkzRSxXQUFXLEtBQUs7d0JBQ2xCO29CQUNGO29CQUVBLE1BQU1LLFVBQVUsSUFBSXRLO29CQUVwQixJQUFLLElBQUk2USxJQUFJLEdBQUdBLElBQUkvSixZQUFZSyxNQUFNLEVBQUUwSixLQUFLLEVBQUc7d0JBQzlDLE1BQU1DLE1BQU1oSyxXQUFXLENBQUMrSixJQUFJLEVBQUUsQ0FBQzNGLFFBQVEsQ0FBQzt3QkFDeEMsTUFBTTZGLE1BQU1qSyxXQUFXLENBQUMrSixJQUFJLEVBQUUsQ0FBQzNGLFFBQVEsQ0FBQzt3QkFFeENaLFFBQVF0QixNQUFNLENBQUM4SCxLQUFLQztvQkFDdEI7b0JBRUF2SyxRQUFRO3dCQUNOeUQ7d0JBQ0FtQixZQUFZMUgsWUFBWSxDQUFDdUcsT0FBTzt3QkFDaENuRCxhQUFhd0QsT0FBTyxDQUFDMUgsYUFBYTt3QkFDbENnTTtvQkFDRjtvQkFFQSxPQUFPO2dCQUNUO1lBQ0Y7SUFFSjtBQUNGO0FBRUEwRCxPQUFPQyxPQUFPLEdBQUc7SUFDZjNOO0lBQ0FkO0lBQ0FpRDtJQUNBVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9pbmRleC5qcz9kMjJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVzcG9uc2UsXG4gIG1ha2VOZXR3b3JrRXJyb3IsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIG1ha2VSZXNwb25zZVxufSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJylcbmNvbnN0IHtcbiAgYnl0ZXNNYXRjaCxcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIHJlcXVlc3RCYWRQb3J0LFxuICBUQU9DaGVjayxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGlzQmxvYkxpa2UsXG4gIHNhbWVPcmlnaW4sXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgdXJsSGFzSHR0cHNTY2hlbWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IHNhZmVseUV4dHJhY3RCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1cyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzLFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgc3VicmVzb3VyY2UsXG4gIERPTUV4Y2VwdGlvblxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga0hlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgeyBSZWFkYWJsZSwgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIsIGlzRXJyb3JlZCwgaXNSZWFkYWJsZSwgbm9kZU1ham9yLCBub2RlTWlub3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGRhdGFVUkxQcm9jZXNzb3IsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhVVJMJylcbmNvbnN0IHsgVHJhbnNmb3JtU3RyZWFtIH0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdidWZmZXInKS5yZXNvbHZlT2JqZWN0VVJMfSAqL1xubGV0IHJlc29sdmVPYmplY3RVUkxcbmxldCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW1cblxuY2xhc3MgRmV0Y2ggZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaGVyKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlclxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmR1bXAgPSBmYWxzZVxuICAgIHRoaXMuc3RhdGUgPSAnb25nb2luZydcbiAgICAvLyAyIHRlcm1pbmF0ZWQgbGlzdGVuZXJzIGdldCBhZGRlZCBwZXIgcmVxdWVzdCxcbiAgICAvLyBidXQgb25seSAxIGdldHMgcmVtb3ZlZC4gSWYgdGhlcmUgYXJlIDIwIHJlZGlyZWN0cyxcbiAgICAvLyAyMSBsaXN0ZW5lcnMgd2lsbCBiZSBhZGRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE3MTFcbiAgICAvLyBUT0RPIChmaXgpOiBGaW5kIGFuZCBmaXggcm9vdCBjYXVzZSBmb3IgbGVha2VkIGxpc3RlbmVyLlxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDIxKVxuICB9XG5cbiAgdGVybWluYXRlIChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KHJlYXNvbilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCByZWFzb24pXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtY29udHJvbGxlci1hYm9ydFxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAxLiBTZXQgY29udHJvbGxlcuKAmXMgc3RhdGUgdG8gXCJhYm9ydGVkXCIuXG4gICAgdGhpcy5zdGF0ZSA9ICdhYm9ydGVkJ1xuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrRXJyb3IgYmUgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIC8vIDMuIFNldCBlcnJvciB0byBmYWxsYmFja0Vycm9yIGlmIGl0IGlzIG5vdCBnaXZlbi5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIExldCBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShlcnJvcikuXG4gICAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIGNhdGNoIGl0LCBhbmQgbGV0XG4gICAgLy8gICAgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZmFsbGJhY2tFcnJvcikuXG5cbiAgICAvLyA1LiBTZXQgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gdG8gc2VyaWFsaXplZEVycm9yLlxuICAgIHRoaXMuc2VyaWFsaXplZEFib3J0UmVhc29uID0gZXJyb3JcblxuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShlcnJvcilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCBlcnJvcilcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtbWV0aG9kXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIGluaXQgPSB7fSkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnZ2xvYmFsVGhpcy5mZXRjaCcgfSlcblxuICAvLyAxLiBMZXQgcCBiZSBhIG5ldyBwcm9taXNlLlxuICBjb25zdCBwID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAvLyAyLiBMZXQgcmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gIC8vIFJlcXVlc3QgYXMgY29uc3RydWN0b3Igd2l0aCBpbnB1dCBhbmQgaW5pdCBhcyBhcmd1bWVudHMuIElmIHRoaXMgdGhyb3dzXG4gIC8vIGFuIGV4Y2VwdGlvbiwgcmVqZWN0IHAgd2l0aCBpdCBhbmQgcmV0dXJuIHAuXG4gIGxldCByZXF1ZXN0T2JqZWN0XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwLnJlamVjdChlKVxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDMuIExldCByZXF1ZXN0IGJlIHJlcXVlc3RPYmplY3TigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0T2JqZWN0W2tTdGF0ZV1cblxuICAvLyA0LiBJZiByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gIGlmIChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgLy8gMS4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIG51bGwsIGFuZFxuICAgIC8vICAgIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgbnVsbCwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgLy8gMi4gUmV0dXJuIHAuXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gNS4gTGV0IGdsb2JhbE9iamVjdCBiZSByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gIGNvbnN0IGdsb2JhbE9iamVjdCA9IHJlcXVlc3QuY2xpZW50Lmdsb2JhbE9iamVjdFxuXG4gIC8vIDYuIElmIGdsb2JhbE9iamVjdCBpcyBhIFNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZSBvYmplY3QsIHRoZW4gc2V0XG4gIC8vIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICBpZiAoZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1NlcnZpY2VXb3JrZXJHbG9iYWxTY29wZScpIHtcbiAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gIH1cblxuICAvLyA3LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlT2JqZWN0ID0gbnVsbFxuXG4gIC8vIDguIExldCByZWxldmFudFJlYWxtIGJlIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICBjb25zdCByZWxldmFudFJlYWxtID0gbnVsbFxuXG4gIC8vIDkuIExldCBsb2NhbGx5QWJvcnRlZCBiZSBmYWxzZS5cbiAgbGV0IGxvY2FsbHlBYm9ydGVkID0gZmFsc2VcblxuICAvLyAxMC4gTGV0IGNvbnRyb2xsZXIgYmUgbnVsbC5cbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsXG5cbiAgLy8gMTEuIEFkZCB0aGUgZm9sbG93aW5nIGFib3J0IHN0ZXBzIHRvIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbDpcbiAgYWRkQWJvcnRMaXN0ZW5lcihcbiAgICByZXF1ZXN0T2JqZWN0LnNpZ25hbCxcbiAgICAoKSA9PiB7XG4gICAgICAvLyAxLiBTZXQgbG9jYWxseUFib3J0ZWQgdG8gdHJ1ZS5cbiAgICAgIGxvY2FsbHlBYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBBc3NlcnQ6IGNvbnRyb2xsZXIgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoY29udHJvbGxlciAhPSBudWxsKVxuXG4gICAgICAvLyAzLiBBYm9ydCBjb250cm9sbGVyIHdpdGggcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBjb250cm9sbGVyLmFib3J0KHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgICAgLy8gNC4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LFxuICAgICAgLy8gICAgYW5kIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuICAgIH1cbiAgKVxuXG4gIC8vIDEyLiBMZXQgaGFuZGxlRmV0Y2hEb25lIGdpdmVuIHJlc3BvbnNlIHJlc3BvbnNlIGJlIHRvIGZpbmFsaXplIGFuZFxuICAvLyByZXBvcnQgdGltaW5nIHdpdGggcmVzcG9uc2UsIGdsb2JhbE9iamVjdCwgYW5kIFwiZmV0Y2hcIi5cbiAgY29uc3QgaGFuZGxlRmV0Y2hEb25lID0gKHJlc3BvbnNlKSA9PlxuICAgIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCAnZmV0Y2gnKVxuXG4gIC8vIDEzLiBTZXQgY29udHJvbGxlciB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZmV0Y2ggZ2l2ZW4gcmVxdWVzdCxcbiAgLy8gd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIGhhbmRsZUZldGNoRG9uZSwgYW5kIHByb2Nlc3NSZXNwb25zZVxuICAvLyBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdWJzdGVwczpcblxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAvLyAxLiBJZiBsb2NhbGx5QWJvcnRlZCBpcyB0cnVlLCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKGxvY2FsbHlBYm9ydGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvLyAyLiBJZiByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgLy8gMS4gTGV0IGRlc2VyaWFsaXplZEVycm9yIGJlIHRoZSByZXN1bHQgb2YgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkXG4gICAgICAvLyAgICBhYm9ydCByZWFzb24gZ2l2ZW4gY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kXG4gICAgICAvLyAgICByZWxldmFudFJlYWxtLlxuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGFuZFxuICAgICAgLy8gICAgZGVzZXJpYWxpemVkRXJyb3IuXG5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlamVjdCBwIHdpdGggYSBUeXBlRXJyb3JcbiAgICAvLyBhbmQgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBwLnJlamVjdChcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCdmZXRjaCBmYWlsZWQnKSwgeyBjYXVzZTogcmVzcG9uc2UuZXJyb3IgfSlcbiAgICAgIClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZU9iamVjdCB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgcmVsZXZhbnRSZWFsbS5cbiAgICByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXSA9IHJlc3BvbnNlXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0XG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSAnaW1tdXRhYmxlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNS4gUmVzb2x2ZSBwIHdpdGggcmVzcG9uc2VPYmplY3QuXG4gICAgcC5yZXNvbHZlKHJlc3BvbnNlT2JqZWN0KVxuICB9XG5cbiAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBkaXNwYXRjaGVyOiBpbml0LmRpc3BhdGNoZXIgPz8gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIC8vIHVuZGljaVxuICB9KVxuXG4gIC8vIDE0LiBSZXR1cm4gcC5cbiAgcmV0dXJuIHAucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtYW5kLXJlcG9ydC10aW1pbmdcbmZ1bmN0aW9uIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nIChyZXNwb25zZSwgaW5pdGlhdG9yVHlwZSA9ICdvdGhlcicpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgJiYgcmVzcG9uc2UuYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIG51bGwgb3IgZW1wdHksIHRoZW4gcmV0dXJuLlxuICBpZiAoIXJlc3BvbnNlLnVybExpc3Q/Lmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMy4gTGV0IG9yaWdpbmFsVVJMIGJlIHJlc3BvbnNl4oCZcyBVUkwgbGlzdFswXS5cbiAgY29uc3Qgb3JpZ2luYWxVUkwgPSByZXNwb25zZS51cmxMaXN0WzBdXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IHJlc3BvbnNlLnRpbWluZ0luZm9cblxuICAvLyA1LiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gIC8vIDYuIElmIG9yaWdpbmFsVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybi5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShvcmlnaW5hbFVSTCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDcuIElmIHRpbWluZ0luZm8gaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmICh0aW1pbmdJbmZvID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA4LiBJZiByZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnIGlzIG5vdCBzZXQsIHRoZW46XG4gIGlmICghdGltaW5nSW5mby50aW1pbmdBbGxvd1Bhc3NlZCkge1xuICAgIC8vICAxLiBTZXQgdGltaW5nSW5mbyB0byBhIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gb3BhcXVlIHRpbWluZyBpbmZvIGZvciB0aW1pbmdJbmZvLlxuICAgIHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWVcbiAgICB9KVxuXG4gICAgLy8gIDIuIFNldCBjYWNoZVN0YXRlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgY2FjaGVTdGF0ZSA9ICcnXG4gIH1cblxuICAvLyA5LiBTZXQgdGltaW5nSW5mb+KAmXMgZW5kIHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lXG4gIC8vIGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgLy8gVE9ETzogZ2l2ZW4gZ2xvYmFs4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5P1xuICB0aW1pbmdJbmZvLmVuZFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSgpXG5cbiAgLy8gMTAuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMS4gTWFyayByZXNvdXJjZSB0aW1pbmcgZm9yIHRpbWluZ0luZm8sIG9yaWdpbmFsVVJMLCBpbml0aWF0b3JUeXBlLFxuICAvLyBnbG9iYWwsIGFuZCBjYWNoZVN0YXRlLlxuICBtYXJrUmVzb3VyY2VUaW1pbmcoXG4gICAgdGltaW5nSW5mbyxcbiAgICBvcmlnaW5hbFVSTCxcbiAgICBpbml0aWF0b3JUeXBlLFxuICAgIGdsb2JhbFRoaXMsXG4gICAgY2FjaGVTdGF0ZVxuICApXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9yZXNvdXJjZS10aW1pbmcvI2Rmbi1tYXJrLXJlc291cmNlLXRpbWluZ1xuZnVuY3Rpb24gbWFya1Jlc291cmNlVGltaW5nICh0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSwgZ2xvYmFsVGhpcywgY2FjaGVTdGF0ZSkge1xuICBpZiAobm9kZU1ham9yID4gMTggfHwgKG5vZGVNYWpvciA9PT0gMTggJiYgbm9kZU1pbm9yID49IDIpKSB7XG4gICAgcGVyZm9ybWFuY2UubWFya1Jlc291cmNlVGltaW5nKHRpbWluZ0luZm8sIG9yaWdpbmFsVVJMLmhyZWYsIGluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0LWZldGNoXG5mdW5jdGlvbiBhYm9ydEZldGNoIChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgZXJyb3IpIHtcbiAgLy8gTm90ZTogQWJvcnRTaWduYWwucmVhc29uIHdhcyBhZGRlZCBpbiBub2RlIHYxNy4yLjBcbiAgLy8gd2hpY2ggd291bGQgZ2l2ZSB1cyBhbiB1bmRlZmluZWQgZXJyb3IgdG8gcmVqZWN0IHdpdGguXG4gIC8vIFJlbW92ZSB0aGlzIG9uY2Ugbm9kZSB2MTYgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cbiAgaWYgKCFlcnJvcikge1xuICAgIGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpXG4gIH1cblxuICAvLyAxLiBSZWplY3QgcHJvbWlzZSB3aXRoIGVycm9yLlxuICBwLnJlamVjdChlcnJvcilcblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBjYW5jZWwgcmVxdWVzdOKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXF1ZXN0LmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXF1ZXN0LmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZU9iamVjdCBpcyBudWxsLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlT2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2UuXG4gIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXVxuXG4gIC8vIDUuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciByZXNwb25zZeKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVzcG9uc2UuYm9keT8uc3RyZWFtKSkge1xuICAgIHJlc3BvbnNlLmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoaW5nXG5mdW5jdGlvbiBmZXRjaGluZyAoe1xuICByZXF1ZXN0LFxuICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gIHByb2Nlc3NSZXNwb25zZSxcbiAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgdXNlUGFyYWxsZWxRdWV1ZSA9IGZhbHNlLFxuICBkaXNwYXRjaGVyIC8vIHVuZGljaVxufSkge1xuICAvLyAxLiBMZXQgdGFza0Rlc3RpbmF0aW9uIGJlIG51bGwuXG4gIGxldCB0YXNrRGVzdGluYXRpb24gPSBudWxsXG5cbiAgLy8gMi4gTGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IGJlIGZhbHNlLlxuICBsZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgPSBmYWxzZVxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGNsaWVudCBpcyBub24tbnVsbCwgdGhlbjpcbiAgaWYgKHJlcXVlc3QuY2xpZW50ICE9IG51bGwpIHtcbiAgICAvLyAxLiBTZXQgdGFza0Rlc3RpbmF0aW9uIHRvIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgICB0YXNrRGVzdGluYXRpb24gPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAgIC8vIDIuIFNldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGNyb3NzLW9yaWdpblxuICAgIC8vIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgPVxuICAgICAgcmVxdWVzdC5jbGllbnQuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHlcbiAgfVxuXG4gIC8vIDQuIElmIHVzZVBhcmFsbGVsUXVldWUgaXMgdHJ1ZSwgdGhlbiBzZXQgdGFza0Rlc3RpbmF0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gc3RhcnRpbmcgYSBuZXcgcGFyYWxsZWwgcXVldWUuXG4gIC8vIFRPRE9cblxuICAvLyA1LiBMZXQgdGltaW5nSW5mbyBiZSBhIG5ldyBmZXRjaCB0aW1pbmcgaW5mbyB3aG9zZSBzdGFydCB0aW1lIGFuZFxuICAvLyBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgYXJlIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlblxuICAvLyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgY3VycmVuVGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICBjb25zdCB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW5UaW1lXG4gIH0pXG5cbiAgLy8gNi4gTGV0IGZldGNoUGFyYW1zIGJlIGEgbmV3IGZldGNoIHBhcmFtcyB3aG9zZVxuICAvLyByZXF1ZXN0IGlzIHJlcXVlc3QsXG4gIC8vIHRpbWluZyBpbmZvIGlzIHRpbWluZ0luZm8sXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBib2R5IGNodW5rIGxlbmd0aCBpcyBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgLy8gcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGlzIHByb2Nlc3NSZXNwb25zZSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAvLyB0YXNrIGRlc3RpbmF0aW9uIGlzIHRhc2tEZXN0aW5hdGlvbixcbiAgLy8gYW5kIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5IGlzIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICBjb250cm9sbGVyOiBuZXcgRmV0Y2goZGlzcGF0Y2hlciksXG4gICAgcmVxdWVzdCxcbiAgICB0aW1pbmdJbmZvLFxuICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gICAgdGFza0Rlc3RpbmF0aW9uLFxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIGEgYnl0ZSBzZXF1ZW5jZSwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0b1xuICAvLyAgICByZXF1ZXN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgLy8gTk9URTogU2luY2UgZmV0Y2hpbmcgaXMgb25seSBjYWxsZWQgZnJvbSBmZXRjaCwgYm9keSBzaG91bGQgYWxyZWFkeSBiZVxuICAvLyBleHRyYWN0ZWQuXG4gIGFzc2VydCghcmVxdWVzdC5ib2R5IHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pXG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwiY2xpZW50XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHdpbmRvdyB0byByZXF1ZXN04oCZc1xuICAvLyBjbGllbnQsIGlmIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdCBpcyBhIFdpbmRvdyBvYmplY3Q7IG90aGVyd2lzZVxuICAvLyBcIm5vLXdpbmRvd1wiLlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qud2luZG93ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50Py5nbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnV2luZG93J1xuICAgICAgICA/IHJlcXVlc3QuY2xpZW50XG4gICAgICAgIDogJ25vLXdpbmRvdydcbiAgfVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW504oCZcyBvcmlnaW4uXG4gIGlmIChyZXF1ZXN0Lm9yaWdpbiA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBUT0RPOiBXaGF0IGlmIHJlcXVlc3QuY2xpZW50IGlzIG51bGw/XG4gICAgcmVxdWVzdC5vcmlnaW4gPSByZXF1ZXN0LmNsaWVudD8ub3JpZ2luXG4gIH1cblxuICAvLyAxMC4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgLy8gVE9ET1xuXG4gIC8vIDExLiBJZiByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVyIGlzIFwiY2xpZW50XCIsIHRoZW46XG4gIGlmIChyZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHBvbGljeVxuICAgIC8vIGNvbnRhaW5lciB0byBhIGNsb25lIG9mIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgcG9saWN5IGNvbnRhaW5lci4gW0hUTUxdXG4gICAgaWYgKHJlcXVlc3QuY2xpZW50ICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gY2xvbmVQb2xpY3lDb250YWluZXIoXG4gICAgICAgIHJlcXVlc3QuY2xpZW50LnBvbGljeUNvbnRhaW5lclxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAyLiBPdGhlcndpc2UsIHNldCByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVyIHRvIGEgbmV3IHBvbGljeVxuICAgICAgLy8gY29udGFpbmVyLlxuICAgICAgcmVxdWVzdC5wb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKClcbiAgICB9XG4gIH1cblxuICAvLyAxMi4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQWNjZXB0YCwgdGhlbjpcbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQnKSkge1xuICAgIC8vIDEuIExldCB2YWx1ZSBiZSBgKi8qYC5cbiAgICBjb25zdCB2YWx1ZSA9ICcqLyonXG5cbiAgICAvLyAyLiBBIHVzZXIgYWdlbnQgc2hvdWxkIHNldCB2YWx1ZSB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50LCBpZlxuICAgIC8vIGFueSwgc3dpdGNoaW5nIG9uIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uOlxuICAgIC8vIFwiZG9jdW1lbnRcIlxuICAgIC8vIFwiZnJhbWVcIlxuICAgIC8vIFwiaWZyYW1lXCJcbiAgICAvLyBgdGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksKi8qO3E9MC44YFxuICAgIC8vIFwiaW1hZ2VcIlxuICAgIC8vIGBpbWFnZS9wbmcsaW1hZ2Uvc3ZnK3htbCxpbWFnZS8qO3E9MC44LCovKjtxPTAuNWBcbiAgICAvLyBcInN0eWxlXCJcbiAgICAvLyBgdGV4dC9jc3MsKi8qO3E9MC4xYFxuICAgIC8vIFRPRE9cblxuICAgIC8vIDMuIEFwcGVuZCBgQWNjZXB0YC92YWx1ZSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0JywgdmFsdWUpXG4gIH1cblxuICAvLyAxMy4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQWNjZXB0LUxhbmd1YWdlYCwgdGhlblxuICAvLyB1c2VyIGFnZW50cyBzaG91bGQgYXBwZW5kIGBBY2NlcHQtTGFuZ3VhZ2VgL2FuIGFwcHJvcHJpYXRlIHZhbHVlIHRvXG4gIC8vIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1sYW5ndWFnZScpKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1sYW5ndWFnZScsICcqJylcbiAgfVxuXG4gIC8vIDE0LiBJZiByZXF1ZXN04oCZcyBwcmlvcml0eSBpcyBudWxsLCB0aGVuIHVzZSByZXF1ZXN04oCZcyBpbml0aWF0b3IgYW5kXG4gIC8vIGRlc3RpbmF0aW9uIGFwcHJvcHJpYXRlbHkgaW4gc2V0dGluZyByZXF1ZXN04oCZcyBwcmlvcml0eSB0byBhXG4gIC8vIHVzZXItYWdlbnQtZGVmaW5lZCBvYmplY3QuXG4gIGlmIChyZXF1ZXN0LnByaW9yaXR5ID09PSBudWxsKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTUuIElmIHJlcXVlc3QgaXMgYSBzdWJyZXNvdXJjZSByZXF1ZXN0LCB0aGVuOlxuICBpZiAoc3VicmVzb3VyY2UuaW5jbHVkZXMocmVxdWVzdC5kZXN0aW5hdGlvbikpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxNi4gUnVuIG1haW4gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gIG1haW5GZXRjaChmZXRjaFBhcmFtcylcbiAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycilcbiAgICB9KVxuXG4gIC8vIDE3LiBSZXR1cm4gZmV0Y2hQYXJhbSdzIGNvbnRyb2xsZXJcbiAgcmV0dXJuIGZldGNoUGFyYW1zLmNvbnRyb2xsZXJcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWFpbi1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gbWFpbkZldGNoIChmZXRjaFBhcmFtcywgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBsb2NhbC1VUkxzLW9ubHkgZmxhZyBpcyBzZXQgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzXG4gIC8vIG5vdCBsb2NhbCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5sb2NhbFVSTHNPbmx5ICYmICF1cmxJc0xvY2FsKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignbG9jYWwgVVJMcyBvbmx5JylcbiAgfVxuXG4gIC8vIDQuIFJ1biByZXBvcnQgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdmlvbGF0aW9ucyBmb3IgcmVxdWVzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDUuIFVwZ3JhZGUgcmVxdWVzdCB0byBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgaWYgYXBwcm9wcmlhdGUuXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTChyZXF1ZXN0KVxuXG4gIC8vIDYuIElmIHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGEgYmFkIHBvcnQsIHNob3VsZCBmZXRjaGluZyByZXF1ZXN0XG4gIC8vIGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudCwgb3Igc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50XG4gIC8vIFNlY3VyaXR5IFBvbGljeSByZXR1cm5zIGJsb2NrZWQsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3RCYWRQb3J0KHJlcXVlc3QpID09PSAnYmxvY2tlZCcpIHtcbiAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2JhZCBwb3J0JylcbiAgfVxuICAvLyBUT0RPOiBzaG91bGQgZmV0Y2hpbmcgcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnQ/XG4gIC8vIFRPRE86IHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3k/XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyIHBvbGljeSB0byByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVy4oCZcyByZWZlcnJlciBwb2xpY3kuXG4gIGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSByZXF1ZXN0LnBvbGljeUNvbnRhaW5lci5yZWZlcnJlclBvbGljeVxuICB9XG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgdG8gdGhlIHJlc3VsdCBvZiBpbnZva2luZyBkZXRlcm1pbmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gIGlmIChyZXF1ZXN0LnJlZmVycmVyICE9PSAnbm8tcmVmZXJyZXInKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdClcbiAgfVxuXG4gIC8vIDkuIFNldCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIHRvIFwiaHR0cHNcIiBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgXCJodHRwXCJcbiAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgaG9zdCBpcyBhIGRvbWFpblxuICAvLyAtIE1hdGNoaW5nIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IHBlciBLbm93biBIU1RTIEhvc3QgRG9tYWluIE5hbWVcbiAgLy8gICBNYXRjaGluZyByZXN1bHRzIGluIGVpdGhlciBhIHN1cGVyZG9tYWluIG1hdGNoIHdpdGggYW4gYXNzZXJ0ZWRcbiAgLy8gICBpbmNsdWRlU3ViRG9tYWlucyBkaXJlY3RpdmUgb3IgYSBjb25ncnVlbnQgbWF0Y2ggKHdpdGggb3Igd2l0aG91dCBhblxuICAvLyAgIGFzc2VydGVkIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSkuIFtIU1RTXVxuICAvLyBUT0RPXG5cbiAgLy8gMTAuIElmIHJlY3Vyc2l2ZSBpcyBmYWxzZSwgdGhlbiBydW4gdGhlIHJlbWFpbmluZyBzdGVwcyBpbiBwYXJhbGxlbC5cbiAgLy8gVE9ET1xuXG4gIC8vIDExLiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuIHNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgLy8gdGhlIHN0ZXBzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudDpcbiAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgb3JpZ2luLFxuICAgICAgICAvLyAgIGFuZCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImJhc2ljXCJcbiAgICAgICAgKHNhbWVPcmlnaW4oY3VycmVudFVSTCwgcmVxdWVzdC51cmwpICYmIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykgfHxcbiAgICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIlxuICAgICAgICAoY3VycmVudFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgfHxcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICAgIChyZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JylcbiAgICAgICkge1xuICAgICAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJiYXNpY1wiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnYmFzaWMnXG5cbiAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgIHJldHVybiBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcInNhbWUtb3JpZ2luXCJcbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgICAgLy8gMS4gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3JlcXVlc3QgbW9kZSBjYW5ub3QgYmUgXCJzYW1lLW9yaWdpblwiJylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25vLWNvcnMnKSB7XG4gICAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgbm90IFwiZm9sbG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAgICAgICAvLyBlcnJvci5cbiAgICAgICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdmb2xsb3cnKSB7XG4gICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgICAncmVkaXJlY3QgbW9kZSBjYW5ub3QgYmUgXCJmb2xsb3dcIiBmb3IgXCJuby1jb3JzXCIgcmVxdWVzdCdcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJvcGFxdWVcIi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ29wYXF1ZSdcblxuICAgICAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZVxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJylcbiAgICAgIH1cblxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1c2UtQ09SUy1wcmVmbGlnaHQgZmxhZyBpcyBzZXRcbiAgICAgIC8vIC0gcmVxdWVzdOKAmXMgdW5zYWZlLXJlcXVlc3QgZmxhZyBpcyBzZXQgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgICAgIC8vICAgbm90IGEgQ09SUy1zYWZlbGlzdGVkIG1ldGhvZCBvciBDT1JTLXVuc2FmZSByZXF1ZXN0LWhlYWRlciBuYW1lcyB3aXRoXG4gICAgICAvLyAgIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGlzIG5vdCBlbXB0eVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgLy8gICAgMi4gTGV0IGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2hcbiAgICAgIC8vICAgIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICAgICAgLy8gICAgMy4gSWYgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gY2xlYXIgY2FjaGVcbiAgICAgIC8vICAgIGVudHJpZXMgdXNpbmcgcmVxdWVzdC5cbiAgICAgIC8vICAgIDQuIFJldHVybiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlLlxuICAgICAgLy8gVE9ET1xuXG4gICAgICAvLyBPdGhlcndpc2VcbiAgICAgIC8vICAgIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImNvcnNcIi5cbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdjb3JzJ1xuXG4gICAgICAvLyAgICAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gYXdhaXQgaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgIH0pKClcbiAgfVxuXG4gIC8vIDEyLiBJZiByZWN1cnNpdmUgaXMgdHJ1ZSwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gIGlmIChyZWN1cnNpdmUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8vIDEzLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZFxuICAvLyByZXNwb25zZSwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJiAhcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIC8vIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiLCB0aGVuOlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgLy8gMS4gTGV0IGhlYWRlck5hbWVzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgIC8vIGdpdmVuIGBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc2AgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUgaXMgbm90IFwiaW5jbHVkZVwiIGFuZCBoZWFkZXJOYW1lc1xuICAgICAgLy8gY29udGFpbnMgYCpgLCB0aGVuIHNldCByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QgdG9cbiAgICAgIC8vIGFsbCB1bmlxdWUgaGVhZGVyIG5hbWVzIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgaGVhZGVyTmFtZXMgaXMgbm90IG51bGwgb3IgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAgIC8vIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0byBoZWFkZXJOYW1lcy5cbiAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAgIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2Jhc2ljJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnY29ycycpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnb3BhcXVlJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDE0LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLFxuICAvLyBhbmQgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlIG90aGVyd2lzZS5cbiAgbGV0IGludGVybmFsUmVzcG9uc2UgPVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gMCA/IHJlc3BvbnNlIDogcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuXG4gIC8vIDE1LiBJZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eSwgdGhlbiBzZXQgaXQgdG8gYSBjbG9uZSBvZlxuICAvLyByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgaWYgKGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QucHVzaCguLi5yZXF1ZXN0LnVybExpc3QpXG4gIH1cblxuICAvLyAxNi4gSWYgcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnIGlzIHVuc2V0LCB0aGVuIHNldFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcuXG4gIGlmICghcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCkge1xuICAgIHJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTcuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGFueSBvZiB0aGUgZm9sbG93aW5nIHJldHVybnNcbiAgLy8gYmxvY2tlZFxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBpdHMgTUlNRSB0eXBlXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBub3NuaWZmXG4gIC8vIFRPRE9cblxuICAvLyAxOC4gSWYgcmVzcG9uc2XigJlzIHR5cGUgaXMgXCJvcGFxdWVcIiwgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDIwNixcbiAgLy8gaW50ZXJuYWxSZXNwb25zZeKAmXMgcmFuZ2UtcmVxdWVzdGVkIGZsYWcgaXMgc2V0LCBhbmQgcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZSBhbmQgaW50ZXJuYWxSZXNwb25zZVxuICAvLyB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJyAmJlxuICAgIGludGVybmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgJiZcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkICYmXG4gICAgIXJlcXVlc3QuaGVhZGVycy5jb250YWlucygncmFuZ2UnKVxuICApIHtcbiAgICByZXNwb25zZSA9IGludGVybmFsUmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKClcbiAgfVxuXG4gIC8vIDE5LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gIC8vIGBIRUFEYCBvciBgQ09OTkVDVGAsIG9yIGludGVybmFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsXG4gIC8vIHNldCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R5IHRvIG51bGwgYW5kIGRpc3JlZ2FyZCBhbnkgZW5xdWV1aW5nIHRvd2FyZFxuICAvLyBpdCAoaWYgYW55KS5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJlxuICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnIHx8XG4gICAgICBudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cykpXG4gICkge1xuICAgIGludGVybmFsUmVzcG9uc2UuYm9keSA9IG51bGxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXAgPSB0cnVlXG4gIH1cblxuICAvLyAyMC4gSWYgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICBpZiAocmVxdWVzdC5pbnRlZ3JpdHkpIHtcbiAgICAvLyAxLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXNcbiAgICAvLyBhbmQgYSBuZXR3b3JrIGVycm9yLlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAocmVhc29uKSA9PlxuICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIG1ha2VOZXR3b3JrRXJyb3IocmVhc29uKSlcblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwib3BhcXVlXCIsIG9yIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsXG4gICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzQm9keUVycm9yKHJlc3BvbnNlLmVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5ID0gKGJ5dGVzKSA9PiB7XG4gICAgICAvLyAxLiBJZiBieXRlcyBkbyBub3QgbWF0Y2ggcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLFxuICAgICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuIFtTUkldXG4gICAgICBpZiAoIWJ5dGVzTWF0Y2goYnl0ZXMsIHJlcXVlc3QuaW50ZWdyaXR5KSkge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKCdpbnRlZ3JpdHkgbWlzbWF0Y2gnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJ5dGVzIGFzIGEgYm9keS5cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShieXRlcylbMF1cblxuICAgICAgLy8gMy4gUnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gNC4gRnVsbHkgcmVhZCByZXNwb25zZeKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keSBhbmQgcHJvY2Vzc0JvZHlFcnJvci5cbiAgICBhd2FpdCBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIDIxLiBPdGhlcndpc2UsIHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1zY2hlbWUtZmV0Y2hcbi8vIGdpdmVuIGEgZmV0Y2ggcGFyYW1zIGZldGNoUGFyYW1zXG5mdW5jdGlvbiBzY2hlbWVGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gTm90ZTogc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgZGVzdHJveWVkIG9uIHJlZGlyZWN0LCB3aGljaCBzZXRzIGZldGNoUGFyYW1zIHRvIGFcbiAgLy8gY2FuY2VsbGVkIHN0YXRlLCB3ZSBkbyBub3Qgd2FudCB0aGlzIGNvbmRpdGlvbiB0byB0cmlnZ2VyICp1bmxlc3MqIHRoZXJlIGhhdmUgYmVlblxuICAvLyBubyByZWRpcmVjdHMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTc3NlxuICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpICYmIGZldGNoUGFyYW1zLnJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKSlcbiAgfVxuXG4gIC8vIDIuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCB7IHJlcXVlc3QgfSA9IGZldGNoUGFyYW1zXG5cbiAgY29uc3QgeyBwcm90b2NvbDogc2NoZW1lIH0gPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGFuZCBydW4gdGhlIGFzc29jaWF0ZWQgc3RlcHM6XG4gIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgY2FzZSAnYWJvdXQ6Jzoge1xuICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHBhdGggaXMgdGhlIHN0cmluZyBcImJsYW5rXCIsIHRoZW4gcmV0dXJuIGEgbmV3IHJlc3BvbnNlXG4gICAgICAvLyB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLCBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIGB0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOGApIMK7LFxuICAgICAgLy8gYW5kIGJvZHkgaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UgYXMgYSBib2R5LlxuXG4gICAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Fib3V0IHNjaGVtZSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuICAgIGNhc2UgJ2Jsb2I6Jzoge1xuICAgICAgaWYgKCFyZXNvbHZlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJlc29sdmVPYmplY3RVUkwgPSByZXF1aXJlKCdidWZmZXInKS5yZXNvbHZlT2JqZWN0VVJMXG4gICAgICB9XG5cbiAgICAgIC8vIDEuIExldCBibG9iVVJMRW50cnkgYmUgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGJsb2IgVVJMIGVudHJ5LlxuICAgICAgY29uc3QgYmxvYlVSTEVudHJ5ID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvYmxvYi83YjBlYmFjY2M2MmI1NjZhMTk2NTM5NmU1YmU3YmIyYmMwNmY4NDFmL0ZpbGVBUEkvdXJsL3Jlc291cmNlcy9mZXRjaC10ZXN0cy5qcyNMNTItTDU2XG4gICAgICAvLyBCdWZmZXIucmVzb2x2ZU9iamVjdFVSTCBkb2VzIG5vdCBpZ25vcmUgVVJMIHF1ZXJpZXMuXG4gICAgICBpZiAoYmxvYlVSTEVudHJ5LnNlYXJjaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnlPYmplY3QgPSByZXNvbHZlT2JqZWN0VVJMKGJsb2JVUkxFbnRyeS50b1N0cmluZygpKVxuXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgLCBibG9iVVJMRW50cnkgaXMgbnVsbCwgb3IgYmxvYlVSTEVudHJ54oCZc1xuICAgICAgLy8gICAgb2JqZWN0IGlzIG5vdCBhIEJsb2Igb2JqZWN0LCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnIHx8ICFpc0Jsb2JMaWtlKGJsb2JVUkxFbnRyeU9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdpbnZhbGlkIG1ldGhvZCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgYm9keVdpdGhUeXBlIGJlIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3RpbmcgYmxvYlVSTEVudHJ54oCZcyBvYmplY3QuXG4gICAgICBjb25zdCBib2R5V2l0aFR5cGUgPSBzYWZlbHlFeHRyYWN0Qm9keShibG9iVVJMRW50cnlPYmplY3QpXG5cbiAgICAgIC8vIDQuIExldCBib2R5IGJlIGJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgIGNvbnN0IGJvZHkgPSBib2R5V2l0aFR5cGVbMF1cblxuICAgICAgLy8gNS4gTGV0IGxlbmd0aCBiZSBib2R54oCZcyBsZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7Ym9keS5sZW5ndGh9YClcblxuICAgICAgLy8gNi4gTGV0IHR5cGUgYmUgYm9keVdpdGhUeXBl4oCZcyB0eXBlIGlmIGl0IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gICAgICBjb25zdCB0eXBlID0gYm9keVdpdGhUeXBlWzFdID8/ICcnXG5cbiAgICAgIC8vIDcuIFJldHVybiBhIG5ldyByZXNwb25zZSB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLCBoZWFkZXIgbGlzdCBpc1xuICAgICAgLy8gICAgwqsgKGBDb250ZW50LUxlbmd0aGAsIGxlbmd0aCksIChgQ29udGVudC1UeXBlYCwgdHlwZSkgwrssIGFuZCBib2R5IGlzIGJvZHkuXG4gICAgICBjb25zdCByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7XG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgWydjb250ZW50LWxlbmd0aCcsIHsgbmFtZTogJ0NvbnRlbnQtTGVuZ3RoJywgdmFsdWU6IGxlbmd0aCB9XSxcbiAgICAgICAgICBbJ2NvbnRlbnQtdHlwZScsIHsgbmFtZTogJ0NvbnRlbnQtVHlwZScsIHZhbHVlOiB0eXBlIH1dXG4gICAgICAgIF1cbiAgICAgIH0pXG5cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBib2R5XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgfVxuICAgIGNhc2UgJ2RhdGE6Jzoge1xuICAgICAgLy8gMS4gTGV0IGRhdGFVUkxTdHJ1Y3QgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZVxuICAgICAgLy8gICAgZGF0YTogVVJMIHByb2Nlc3NvciBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgICAgY29uc3QgZGF0YVVSTFN0cnVjdCA9IGRhdGFVUkxQcm9jZXNzb3IoY3VycmVudFVSTClcblxuICAgICAgLy8gMi4gSWYgZGF0YVVSTFN0cnVjdCBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhXG4gICAgICAvLyAgICBuZXR3b3JrIGVycm9yLlxuICAgICAgaWYgKGRhdGFVUkxTdHJ1Y3QgPT09ICdmYWlsdXJlJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkwnKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IG1pbWVUeXBlIGJlIGRhdGFVUkxTdHJ1Y3TigJlzIE1JTUUgdHlwZSwgc2VyaWFsaXplZC5cbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKGRhdGFVUkxTdHJ1Y3QubWltZVR5cGUpXG5cbiAgICAgIC8vIDQuIFJldHVybiBhIHJlc3BvbnNlIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsXG4gICAgICAvLyAgICBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIG1pbWVUeXBlKSDCuyxcbiAgICAgIC8vICAgIGFuZCBib2R5IGlzIGRhdGFVUkxTdHJ1Y3TigJlzIGJvZHkgYXMgYSBib2R5LlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlUmVzcG9uc2Uoe1xuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzTGlzdDogW1xuICAgICAgICAgIFsnY29udGVudC10eXBlJywgeyBuYW1lOiAnQ29udGVudC1UeXBlJywgdmFsdWU6IG1pbWVUeXBlIH1dXG4gICAgICAgIF0sXG4gICAgICAgIGJvZHk6IHNhZmVseUV4dHJhY3RCb2R5KGRhdGFVUkxTdHJ1Y3QuYm9keSlbMF1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBjYXNlICdmaWxlOic6IHtcbiAgICAgIC8vIEZvciBub3csIHVuZm9ydHVuYXRlIGFzIGl0IGlzLCBmaWxlIFVSTHMgYXJlIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gICAgICAvLyBXaGVuIGluIGRvdWJ0LCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdub3QgaW1wbGVtZW50ZWQuLi4geWV0Li4uJykpXG4gICAgfVxuICAgIGNhc2UgJ2h0dHA6JzpcbiAgICBjYXNlICdodHRwczonOiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG5cbiAgICAgIHJldHVybiBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBtYWtlTmV0d29ya0Vycm9yKGVycikpXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigndW5rbm93biBzY2hlbWUnKSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLXJlc3BvbnNlXG5mdW5jdGlvbiBmaW5hbGl6ZVJlc3BvbnNlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAvLyAyLCBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGlzIG5vdCBudWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2hcbiAgLy8gdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBnaXZlbiByZXNwb25zZSwgd2l0aFxuICAvLyBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUocmVzcG9uc2UpKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1maW5hbGVcbmZ1bmN0aW9uIGZldGNoRmluYWxlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuOlxuICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIC8vIDEuIFNldCByZXNwb25zZeKAmXMgVVJMIGxpc3QgdG8gwqsgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTCBsaXN0WzBdIMK7LlxuICAgIHJlc3BvbnNlLnVybExpc3QgPSBbZmV0Y2hQYXJhbXMucmVxdWVzdC51cmxMaXN0WzBdXVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmdcbiAgICAvLyBpbmZvIGZvciBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gICAgcmVzcG9uc2UudGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgc3RhcnRUaW1lOiBmZXRjaFBhcmFtcy50aW1pbmdJbmZvLnN0YXJ0VGltZVxuICAgIH0pXG4gIH1cblxuICAvLyAyLiBMZXQgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IGJlIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIGNvbnN0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9ICgpID0+IHtcbiAgICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgICAvLyBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBlbmQtb2YtYm9keSBpcyBub3QgbnVsbCxcbiAgICAvLyB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2VcbiAgICAvLyBlbmQtb2YtYm9keSBnaXZlbiByZXNwb25zZSB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgIT0gbnVsbCkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KHJlc3BvbnNlKSlcbiAgICB9XG4gIH1cblxuICAvLyAzLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBpcyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2tcbiAgLy8gdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlLCB3aXRoIGZldGNoUGFyYW1z4oCZc1xuICAvLyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpKVxuICB9XG5cbiAgLy8gNC4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCwgdGhlbiBydW4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KClcbiAgfSBlbHNlIHtcbiAgLy8gNS4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gTGV0IHRyYW5zZm9ybVN0cmVhbSBiZSBhIG5ldyBhIFRyYW5zZm9ybVN0cmVhbS5cblxuICAgIC8vIDIuIExldCBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gd2hpY2gsIGdpdmVuIGNodW5rLFxuICAgIC8vIGVucXVldWVzIGNodW5rIGluIHRyYW5zZm9ybVN0cmVhbS5cbiAgICBjb25zdCBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSA9IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgIH1cblxuICAgIC8vIDMuIFNldCB1cCB0cmFuc2Zvcm1TdHJlYW0gd2l0aCB0cmFuc2Zvcm1BbGdvcml0aG0gc2V0IHRvIGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtXG4gICAgLy8gYW5kIGZsdXNoQWxnb3JpdGhtIHNldCB0byBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBzdGFydCAoKSB7fSxcbiAgICAgIHRyYW5zZm9ybTogaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0sXG4gICAgICBmbHVzaDogcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5XG4gICAgfSwge1xuICAgICAgc2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDQuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byB0aGUgcmVzdWx0IG9mIHBpcGluZyByZXNwb25zZeKAmXMgYm9keSB0aHJvdWdoIHRyYW5zZm9ybVN0cmVhbS5cbiAgICByZXNwb25zZS5ib2R5ID0geyBzdHJlYW06IHJlc3BvbnNlLmJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKHRyYW5zZm9ybVN0cmVhbSkgfVxuICB9XG5cbiAgLy8gNi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIG5vbi1udWxsLCB0aGVuOlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkgIT0gbnVsbCkge1xuICAgIC8vIDEuIExldCBwcm9jZXNzQm9keSBnaXZlbiBudWxsT3JCeXRlcyBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaFBhcmFtc+KAmXNcbiAgICAvLyBwcm9jZXNzIHJlc3BvbnNlIGNvbnN1bWUgYm9keSBnaXZlbiByZXNwb25zZSBhbmQgbnVsbE9yQnl0ZXMuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAobnVsbE9yQnl0ZXMpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5KHJlc3BvbnNlLCBudWxsT3JCeXRlcylcblxuICAgIC8vIDIuIExldCBwcm9jZXNzQm9keUVycm9yIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzXG4gICAgLy8gcmVzcG9uc2UgY29uc3VtZSBib2R5IGdpdmVuIHJlc3BvbnNlIGFuZCBmYWlsdXJlLlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZmFpbHVyZSkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHkocmVzcG9uc2UsIGZhaWx1cmUpXG5cbiAgICAvLyAzLiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHlcbiAgICAvLyBnaXZlbiBudWxsLCB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICAgIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHByb2Nlc3NCb2R5KG51bGwpKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA0LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgcmVzcG9uc2XigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IsXG4gICAgICAvLyBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgICByZXR1cm4gZnVsbHlSZWFkQm9keShyZXNwb25zZS5ib2R5LCBwcm9jZXNzQm9keSwgcHJvY2Vzc0JvZHlFcnJvcilcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBMZXQgYWN0dWFsUmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IGFjdHVhbFJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA1LiBJZiByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSBpcyBcImFsbFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9PT0gJ2FsbCcpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA2LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBtYWtlQ09SU1ByZWZsaWdodCBpcyB0cnVlIGFuZCBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpcyB0cnVlOlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgXCJmb2xsb3dcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgICAvLyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgcmVzcG9uc2UgYW5kIGFjdHVhbFJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgIC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goZmV0Y2hQYXJhbXMpXG5cbiAgICAvLyA0LiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBhbmQgYSBDT1JTIGNoZWNrXG4gICAgLy8gZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnICYmXG4gICAgICBjb3JzQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZSdcbiAgICApIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdjb3JzIGZhaWx1cmUnKVxuICAgIH1cblxuICAgIC8vIDUuIElmIHRoZSBUQU8gY2hlY2sgZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAvLyByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcuXG4gICAgaWYgKFRBT0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIElmIGVpdGhlciByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBvciByZXNwb25zZeKAmXMgdHlwZVxuICAvLyBpcyBcIm9wYXF1ZVwiLCBhbmQgdGhlIGNyb3NzLW9yaWdpbiByZXNvdXJjZSBwb2xpY3kgY2hlY2sgd2l0aFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4sIHJlcXVlc3TigJlzIGNsaWVudCwgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24sXG4gIC8vIGFuZCBhY3R1YWxSZXNwb25zZSByZXR1cm5zIGJsb2NrZWQsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnIHx8IHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnKSAmJlxuICAgIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayhcbiAgICAgIHJlcXVlc3Qub3JpZ2luLFxuICAgICAgcmVxdWVzdC5jbGllbnQsXG4gICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uLFxuICAgICAgYWN0dWFsUmVzcG9uc2VcbiAgICApID09PSAnYmxvY2tlZCdcbiAgKSB7XG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2Jsb2NrZWQnKVxuICB9XG5cbiAgLy8gOC4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbjpcbiAgaWYgKHJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKGFjdHVhbFJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAvLyAxLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm90IG51bGwsXG4gICAgLy8gYW5kIHRoZSBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHVzZXIgYWdlbnRzIG1heSwgYW5kIGFyZSBldmVuXG4gICAgLy8gZW5jb3VyYWdlZCB0bywgdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODhcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvLyAyLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZTpcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigndW5leHBlY3RlZCByZWRpcmVjdCcpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnbWFudWFsJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzcG9uc2UgaXMgYWN0dWFsUmVzcG9uc2UuXG4gICAgICAvLyBOT1RFKHNwZWMpOiBPbiB0aGUgd2ViIHRoaXMgd291bGQgcmV0dXJuIGFuIGBvcGFxdWVyZWRpcmVjdGAgcmVzcG9uc2UsXG4gICAgICAvLyBidXQgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2VydmVyIHNpZGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzExOTMuXG4gICAgICByZXNwb25zZSA9IGFjdHVhbFJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLXJlZGlyZWN0IGZldGNoIGdpdmVuXG4gICAgICAvLyBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDkuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcmVkaXJlY3QtZmV0Y2hcbmZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZCByZXNwb25zZSxcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGNvbnN0IGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgIDogcmVzcG9uc2VcblxuICAvLyAzLiBMZXQgbG9jYXRpb25VUkwgYmUgYWN0dWFsUmVzcG9uc2XigJlzIGxvY2F0aW9uIFVSTCBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50XG4gIC8vIFVSTOKAmXMgZnJhZ21lbnQuXG4gIGxldCBsb2NhdGlvblVSTFxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KS5oYXNoXG4gICAgKVxuXG4gICAgLy8gNC4gSWYgbG9jYXRpb25VUkwgaXMgbnVsbCwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gNS4gSWYgbG9jYXRpb25VUkwgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICB9XG5cbiAgLy8gNi4gSWYgbG9jYXRpb25VUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyBlcnJvci5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShsb2NhdGlvblVSTCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJykpXG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBpcyAyMCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAyMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigncmVkaXJlY3QgY291bnQgZXhjZWVkZWQnKSlcbiAgfVxuXG4gIC8vIDguIEluY3JlYXNlIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGJ5IDEuXG4gIHJlcXVlc3QucmVkaXJlY3RDb3VudCArPSAxXG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcImNvcnNcIiwgbG9jYXRpb25VUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIGFuZFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzIG9yaWdpbiwgdGhlbiByZXR1cm5cbiAgLy8gIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QubW9kZSA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJlxuICAgICFzYW1lT3JpZ2luKHJlcXVlc3QsIGxvY2F0aW9uVVJMKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJykpXG4gIH1cblxuICAvLyAxMC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGxvY2F0aW9uVVJMIGluY2x1ZGVzXG4gIC8vIGNyZWRlbnRpYWxzLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICkpXG4gIH1cblxuICAvLyAxMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmXG4gICAgcmVxdWVzdC5ib2R5ICE9IG51bGwgJiZcbiAgICByZXF1ZXN0LmJvZHkuc291cmNlID09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCkpXG4gIH1cblxuICAvLyAxMi4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAxIG9yIDMwMiBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYFxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAzIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgIG9yIGBIRUFEYFxuICBpZiAoXG4gICAgKFszMDEsIDMwMl0uaW5jbHVkZXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB8fFxuICAgIChhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJlxuICAgICAgIVsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpXG4gICkge1xuICAgIC8vIHRoZW46XG4gICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBgR0VUYCBhbmQgcmVxdWVzdOKAmXMgYm9keSB0byBudWxsLlxuICAgIHJlcXVlc3QubWV0aG9kID0gJ0dFVCdcbiAgICByZXF1ZXN0LmJvZHkgPSBudWxsXG5cbiAgICAvLyAyLiBGb3IgZWFjaCBoZWFkZXJOYW1lIG9mIHJlcXVlc3QtYm9keS1oZWFkZXIgbmFtZSwgZGVsZXRlIGhlYWRlck5hbWUgZnJvbVxuICAgIC8vIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiByZXF1ZXN0Qm9keUhlYWRlcikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoaGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMy4gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBsb2NhdGlvblVSTOKAmXNcbiAgLy8gICAgIG9yaWdpbiwgdGhlbiBmb3IgZWFjaCBoZWFkZXJOYW1lIG9mIENPUlMgbm9uLXdpbGRjYXJkIHJlcXVlc3QtaGVhZGVyIG5hbWUsXG4gIC8vICAgICBkZWxldGUgaGVhZGVyTmFtZSBmcm9tIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCksIGxvY2F0aW9uVVJMKSkge1xuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb3JzLW5vbi13aWxkY2FyZC1yZXF1ZXN0LWhlYWRlci1uYW1lXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2F1dGhvcml6YXRpb24nKVxuXG4gICAgLy8gXCJDb29raWVcIiBhbmQgXCJIb3N0XCIgYXJlIGZvcmJpZGRlbiByZXF1ZXN0LWhlYWRlcnMsIHdoaWNoIHVuZGljaSBkb2Vzbid0IGltcGxlbWVudC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnY29va2llJylcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0byB0aGUgZmlyc3QgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIHNhZmVseSBleHRyYWN0aW5nIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgICByZXF1ZXN0LmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShyZXF1ZXN0LmJvZHkuc291cmNlKVswXVxuICB9XG5cbiAgLy8gMTUuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAxNi4gU2V0IHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IGVuZCB0aW1lIGFuZCBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGhlXG4gIC8vIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgdGltaW5nSW5mby5yZWRpcmVjdEVuZFRpbWUgPSB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSA9XG4gICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgLy8gMTcuIElmIHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IHN0YXJ0IHRpbWUgaXMgMCwgdGhlbiBzZXQgdGltaW5nSW5mb+KAmXNcbiAgLy8gIHJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGltaW5nSW5mb+KAmXMgc3RhcnQgdGltZS5cbiAgaWYgKHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPT09IDApIHtcbiAgICB0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID0gdGltaW5nSW5mby5zdGFydFRpbWVcbiAgfVxuXG4gIC8vIDE4LiBBcHBlbmQgbG9jYXRpb25VUkwgdG8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlcXVlc3QudXJsTGlzdC5wdXNoKGxvY2F0aW9uVVJMKVxuXG4gIC8vIDE5LiBJbnZva2Ugc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBvbiByZWRpcmVjdCBvbiByZXF1ZXN0IGFuZFxuICAvLyBhY3R1YWxSZXNwb25zZS5cbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0LCBhY3R1YWxSZXNwb25zZSlcblxuICAvLyAyMC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICByZXR1cm4gbWFpbkZldGNoKGZldGNoUGFyYW1zLCB0cnVlKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLW9yLWNhY2hlLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya09yQ2FjaGVGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggPSBmYWxzZSxcbiAgaXNOZXdDb25uZWN0aW9uRmV0Y2ggPSBmYWxzZVxuKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBodHRwRmV0Y2hQYXJhbXMgYmUgbnVsbC5cbiAgbGV0IGh0dHBGZXRjaFBhcmFtcyA9IG51bGxcblxuICAvLyAzLiBMZXQgaHR0cFJlcXVlc3QgYmUgbnVsbC5cbiAgbGV0IGh0dHBSZXF1ZXN0ID0gbnVsbFxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0b3JlZFJlc3BvbnNlIGJlIG51bGwuXG4gIC8vIFRPRE86IGNhY2hlXG5cbiAgLy8gNi4gTGV0IGh0dHBDYWNoZSBiZSBudWxsLlxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNy4gTGV0IHRoZSByZXZhbGlkYXRpbmdGbGFnIGJlIHVuc2V0LlxuICBjb25zdCByZXZhbGlkYXRpbmdGbGFnID0gZmFsc2VcblxuICAvLyA4LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIgYW5kIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXNcbiAgLy8gICAgXCJlcnJvclwiLCB0aGVuIHNldCBodHRwRmV0Y2hQYXJhbXMgdG8gZmV0Y2hQYXJhbXMgYW5kIGh0dHBSZXF1ZXN0IHRvXG4gIC8vICAgIHJlcXVlc3QuXG4gIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycgJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgIGh0dHBGZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zXG4gICAgaHR0cFJlcXVlc3QgPSByZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gU2V0IGh0dHBSZXF1ZXN0IHRvIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgICBodHRwUmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHJlcXVlc3QpXG5cbiAgICAvLyAyLiBTZXQgaHR0cEZldGNoUGFyYW1zIHRvIGEgY29weSBvZiBmZXRjaFBhcmFtcy5cbiAgICBodHRwRmV0Y2hQYXJhbXMgPSB7IC4uLmZldGNoUGFyYW1zIH1cblxuICAgIC8vIDMuIFNldCBodHRwRmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QgdG8gaHR0cFJlcXVlc3QuXG4gICAgaHR0cEZldGNoUGFyYW1zLnJlcXVlc3QgPSBodHRwUmVxdWVzdFxuICB9XG5cbiAgLy8gICAgMy4gTGV0IGluY2x1ZGVDcmVkZW50aWFscyBiZSB0cnVlIGlmIG9uZSBvZlxuICBjb25zdCBpbmNsdWRlQ3JlZGVudGlhbHMgPVxuICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJyB8fFxuICAgIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnc2FtZS1vcmlnaW4nICYmXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpXG5cbiAgLy8gICAgNC4gTGV0IGNvbnRlbnRMZW5ndGggYmUgaHR0cFJlcXVlc3TigJlzIGJvZHnigJlzIGxlbmd0aCwgaWYgaHR0cFJlcXVlc3TigJlzXG4gIC8vICAgIGJvZHkgaXMgbm9uLW51bGw7IG90aGVyd2lzZSBudWxsLlxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaHR0cFJlcXVlc3QuYm9keSA/IGh0dHBSZXF1ZXN0LmJvZHkubGVuZ3RoIDogbnVsbFxuXG4gIC8vICAgIDUuIExldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgYmUgbnVsbC5cbiAgbGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IG51bGxcblxuICAvLyAgICA2LiBJZiBodHRwUmVxdWVzdOKAmXMgYm9keSBpcyBudWxsIGFuZCBodHRwUmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYCBvclxuICAvLyAgICBgUFVUYCwgdGhlbiBzZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvIGAwYC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJlxuICAgIFsnUE9TVCcsICdQVVQnXS5pbmNsdWRlcyhodHRwUmVxdWVzdC5tZXRob2QpXG4gICkge1xuICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9ICcwJ1xuICB9XG5cbiAgLy8gICAgNy4gSWYgY29udGVudExlbmd0aCBpcyBub24tbnVsbCwgdGhlbiBzZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvXG4gIC8vICAgIGNvbnRlbnRMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSA9IGlzb21vcnBoaWNFbmNvZGUoYCR7Y29udGVudExlbmd0aH1gKVxuICB9XG5cbiAgLy8gICAgOC4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgQ29udGVudC1MZW5ndGhgL2NvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QuXG4gIGlmIChjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgIT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY29udGVudC1sZW5ndGgnLCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUpXG4gIH1cblxuICAvLyAgICA5LiBJZiBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgaXMgbm9uLW51bGwsIHRoZW4gYXBwZW5kIChgQ29udGVudC1MZW5ndGhgLFxuICAvLyAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUpIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICAxMC4gSWYgY29udGVudExlbmd0aCBpcyBub24tbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIGtlZXBhbGl2ZSBpcyB0cnVlLFxuICAvLyAgICB0aGVuOlxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGh0dHBSZXF1ZXN0LmtlZXBhbGl2ZSkge1xuICAgIC8vIE5PVEU6IGtlZXBhbGl2ZSBpcyBhIG5vb3Agb3V0c2lkZSBvZiBicm93c2VyIGNvbnRleHQuXG4gIH1cblxuICAvLyAgICAxMS4gSWYgaHR0cFJlcXVlc3TigJlzIHJlZmVycmVyIGlzIGEgVVJMLCB0aGVuIGFwcGVuZFxuICAvLyAgICBgUmVmZXJlcmAvaHR0cFJlcXVlc3TigJlzIHJlZmVycmVyLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQsXG4gIC8vICAgICB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5yZWZlcnJlciBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncmVmZXJlcicsIGlzb21vcnBoaWNFbmNvZGUoaHR0cFJlcXVlc3QucmVmZXJyZXIuaHJlZikpXG4gIH1cblxuICAvLyAgICAxMi4gQXBwZW5kIGEgcmVxdWVzdCBgT3JpZ2luYCBoZWFkZXIgZm9yIGh0dHBSZXF1ZXN0LlxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDEzLiBBcHBlbmQgdGhlIEZldGNoIG1ldGFkYXRhIGhlYWRlcnMgZm9yIGh0dHBSZXF1ZXN0LiBbRkVUQ0gtTUVUQURBVEFdXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEoaHR0cFJlcXVlc3QpXG5cbiAgLy8gICAgMTQuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBVc2VyLUFnZW50YCwgdGhlblxuICAvLyAgICB1c2VyIGFnZW50cyBzaG91bGQgYXBwZW5kIGBVc2VyLUFnZW50YC9kZWZhdWx0IGBVc2VyLUFnZW50YCB2YWx1ZSB0b1xuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3VzZXItYWdlbnQnKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgndXNlci1hZ2VudCcsIHR5cGVvZiBlc2J1aWxkRGV0ZWN0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRpY2knIDogJ25vZGUnKVxuICB9XG5cbiAgLy8gICAgMTUuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwiZGVmYXVsdFwiIGFuZCBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QgY29udGFpbnMgYElmLU1vZGlmaWVkLVNpbmNlYCwgYElmLU5vbmUtTWF0Y2hgLFxuICAvLyAgICBgSWYtVW5tb2RpZmllZC1TaW5jZWAsIGBJZi1NYXRjaGAsIG9yIGBJZi1SYW5nZWAsIHRoZW4gc2V0XG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnZGVmYXVsdCcgJiZcbiAgICAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1vZGlmaWVkLXNpbmNlJykgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1ub25lLW1hdGNoJykgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi11bm1vZGlmaWVkLXNpbmNlJykgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tYXRjaCcpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtcmFuZ2UnKSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAxNi4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1jYWNoZVwiLCBodHRwUmVxdWVzdOKAmXMgcHJldmVudFxuICAvLyAgICBuby1jYWNoZSBjYWNoZS1jb250cm9sIGhlYWRlciBtb2RpZmljYXRpb24gZmxhZyBpcyB1bnNldCwgYW5kXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENhY2hlLUNvbnRyb2xgL2BtYXgtYWdlPTBgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tY2FjaGUnICYmXG4gICAgIWh0dHBSZXF1ZXN0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uICYmXG4gICAgIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJylcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ21heC1hZ2U9MCcpXG4gIH1cblxuICAvLyAgICAxNy4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1zdG9yZVwiIG9yIFwicmVsb2FkXCIsIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ3JlbG9hZCcpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUHJhZ21hYCwgdGhlbiBhcHBlbmRcbiAgICAvLyBgUHJhZ21hYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdwcmFnbWEnKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdwcmFnbWEnLCAnbm8tY2FjaGUnKVxuICAgIH1cblxuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCxcbiAgICAvLyB0aGVuIGFwcGVuZCBgQ2FjaGUtQ29udHJvbGAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbm8tY2FjaGUnKVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDE4LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYEFjY2VwdC1FbmNvZGluZ2AvYGlkZW50aXR5YCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5JylcbiAgfVxuXG4gIC8vICAgIDE5LiBNb2RpZnkgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IHBlciBIVFRQLiBEbyBub3QgYXBwZW5kIGEgZ2l2ZW5cbiAgLy8gICAgaGVhZGVyIGlmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyB0aGF0IGhlYWRlcuKAmXMgbmFtZS5cbiAgLy8gICAgVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4NSNpc3N1ZWNvbW1lbnQtODk2NTYwMTI5XG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1lbmNvZGluZycpKSB7XG4gICAgaWYgKHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2JyLCBnemlwLCBkZWZsYXRlJylcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScpXG4gICAgfVxuICB9XG5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JylcblxuICAvLyAgICAyMC4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIHRoZW46XG4gIGlmIChpbmNsdWRlQ3JlZGVudGlhbHMpIHtcbiAgICAvLyAxLiBJZiB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZCB0byBibG9jayBjb29raWVzIGZvciBodHRwUmVxdWVzdFxuICAgIC8vIChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQXV0aG9yaXphdGlvbmAsIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vICAgIDIxLiBJZiB0aGVyZeKAmXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeSwgdXNlIGl0IGFzIGFwcHJvcHJpYXRlLlxuICAvLyAgICBUT0RPOiBwcm94eS1hdXRoZW50aWNhdGlvblxuXG4gIC8vICAgIDIyLiBTZXQgaHR0cENhY2hlIHRvIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGVcbiAgLy8gICAgcGFydGl0aW9uLCBnaXZlbiBodHRwUmVxdWVzdC5cbiAgLy8gICAgVE9ETzogY2FjaGVcblxuICAvLyAgICAyMy4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvXG4gIC8vICAgIFwibm8tc3RvcmVcIi5cbiAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAyNC4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgbmVpdGhlciBcIm5vLXN0b3JlXCIgbm9yIFwicmVsb2FkXCIsXG4gIC8vICAgIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5tb2RlICE9PSAnbm8tc3RvcmUnICYmIGh0dHBSZXF1ZXN0Lm1vZGUgIT09ICdyZWxvYWQnKSB7XG4gICAgLy8gVE9ETzogY2FjaGVcbiAgfVxuXG4gIC8vIDkuIElmIGFib3J0ZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgLy8gVE9ET1xuXG4gIC8vIDEwLiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgIC8vIDEuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiwgdGhlbiByZXR1cm4gYVxuICAgIC8vIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKGh0dHBSZXF1ZXN0Lm1vZGUgPT09ICdvbmx5LWlmLWNhY2hlZCcpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdvbmx5IGlmIGNhY2hlZCcpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGZvcndhcmRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrIGZldGNoXG4gICAgLy8gZ2l2ZW4gaHR0cEZldGNoUGFyYW1zLCBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBpc05ld0Nvbm5lY3Rpb25GZXRjaC5cbiAgICBjb25zdCBmb3J3YXJkUmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya0ZldGNoKFxuICAgICAgaHR0cEZldGNoUGFyYW1zLFxuICAgICAgaW5jbHVkZUNyZWRlbnRpYWxzLFxuICAgICAgaXNOZXdDb25uZWN0aW9uRmV0Y2hcbiAgICApXG5cbiAgICAvLyAzLiBJZiBodHRwUmVxdWVzdOKAmXMgbWV0aG9kIGlzIHVuc2FmZSBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXNcbiAgICAvLyBpbiB0aGUgcmFuZ2UgMjAwIHRvIDM5OSwgaW5jbHVzaXZlLCBpbnZhbGlkYXRlIGFwcHJvcHJpYXRlIHN0b3JlZFxuICAgIC8vIHJlc3BvbnNlcyBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGUgXCJJbnZhbGlkYXRpb25cIiBjaGFwdGVyIG9mIEhUVFBcbiAgICAvLyBDYWNoaW5nLCBhbmQgc2V0IHN0b3JlZFJlc3BvbnNlIHRvIG51bGwuIFtIVFRQLUNBQ0hJTkddXG4gICAgaWYgKFxuICAgICAgIXNhZmVNZXRob2RzLmluY2x1ZGVzKGh0dHBSZXF1ZXN0Lm1ldGhvZCkgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzIDw9IDM5OVxuICAgICkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB0aGUgcmV2YWxpZGF0aW5nRmxhZyBpcyBzZXQgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDMwNCxcbiAgICAvLyB0aGVuOlxuICAgIGlmIChyZXZhbGlkYXRpbmdGbGFnICYmIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG5cbiAgICAvLyA1LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2UgdG8gZm9yd2FyZFJlc3BvbnNlLlxuICAgICAgcmVzcG9uc2UgPSBmb3J3YXJkUmVzcG9uc2VcblxuICAgICAgLy8gMi4gU3RvcmUgaHR0cFJlcXVlc3QgYW5kIGZvcndhcmRSZXNwb25zZSBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGVcbiAgICAgIC8vIFwiU3RvcmluZyBSZXNwb25zZXMgaW4gQ2FjaGVzXCIgY2hhcHRlciBvZiBIVFRQIENhY2hpbmcuIFtIVFRQLUNBQ0hJTkddXG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cbiAgfVxuXG4gIC8vIDExLiBTZXQgcmVzcG9uc2XigJlzIFVSTCBsaXN0IHRvIGEgY2xvbmUgb2YgaHR0cFJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXNwb25zZS51cmxMaXN0ID0gWy4uLmh0dHBSZXF1ZXN0LnVybExpc3RdXG5cbiAgLy8gMTIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZeKAmXNcbiAgLy8gcmFuZ2UtcmVxdWVzdGVkIGZsYWcuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnKSkge1xuICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgcmVxdWVzdC1pbmNsdWRlcy1jcmVkZW50aWFscyB0byBpbmNsdWRlQ3JlZGVudGlhbHMuXG4gIHJlc3BvbnNlLnJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzID0gaW5jbHVkZUNyZWRlbnRpYWxzXG5cbiAgLy8gMTQuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDAxLCBodHRwUmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgbm90XG4gIC8vIFwiY29yc1wiLCBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSwgYW5kIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudFxuICAvLyBzZXR0aW5ncyBvYmplY3QsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxNS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDcsIHRoZW46XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNykge1xuICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnbm8td2luZG93Jykge1xuICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoKVxuICAgIH1cblxuICAgIC8vIDIuID8/P1xuXG4gICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDQuIFByb21wdCB0aGUgZW5kIHVzZXIgYXMgYXBwcm9wcmlhdGUgaW4gcmVxdWVzdOKAmXMgd2luZG93IGFuZCBzdG9yZVxuICAgIC8vIHRoZSByZXN1bHQgYXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeS4gW0hUVFAtQVVUSF1cbiAgICAvLyBUT0RPOiBJbnZva2Ugc29tZSBraW5kIG9mIGNhbGxiYWNrP1xuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW5cbiAgICAvLyBmZXRjaFBhcmFtcy5cbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3Byb3h5IGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJylcbiAgfVxuXG4gIC8vIDE2LiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICBpZiAoXG4gICAgLy8gcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MjFcbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDQyMSAmJlxuICAgIC8vIGlzTmV3Q29ubmVjdGlvbkZldGNoIGlzIGZhbHNlXG4gICAgIWlzTmV3Q29ubmVjdGlvbkZldGNoICYmXG4gICAgLy8gcmVxdWVzdOKAmXMgYm9keSBpcyBudWxsLCBvciByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbm9uLW51bGxcbiAgICAocmVxdWVzdC5ib2R5ID09IG51bGwgfHwgcmVxdWVzdC5ib2R5LnNvdXJjZSAhPSBudWxsKVxuICApIHtcbiAgICAvLyB0aGVuOlxuXG4gICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlXG4gICAgLy8gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMsIGlzQXV0aGVudGljYXRpb25GZXRjaCwgYW5kIHRydWUuXG5cbiAgICAvLyBUT0RPIChzcGVjKTogVGhlIHNwZWMgZG9lc24ndCBzcGVjaWZ5IHRoaXMgYnV0IHdlIG5lZWQgdG8gY2FuY2VsXG4gICAgLy8gdGhlIGFjdGl2ZSByZXNwb25zZSBiZWZvcmUgd2UgY2FuIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjkzXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuXG4gICAgcmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya09yQ2FjaGVGZXRjaChcbiAgICAgIGZldGNoUGFyYW1zLFxuICAgICAgaXNBdXRoZW50aWNhdGlvbkZldGNoLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgfVxuXG4gIC8vIDE3LiBJZiBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggaXMgdHJ1ZSwgdGhlbiBjcmVhdGUgYW4gYXV0aGVudGljYXRpb24gZW50cnlcbiAgaWYgKGlzQXV0aGVudGljYXRpb25GZXRjaCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE4LiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya0ZldGNoIChcbiAgZmV0Y2hQYXJhbXMsXG4gIGluY2x1ZGVDcmVkZW50aWFscyA9IGZhbHNlLFxuICBmb3JjZU5ld0Nvbm5lY3Rpb24gPSBmYWxzZVxuKSB7XG4gIGFzc2VydCghZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uIHx8IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95ZWQpXG5cbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uID0ge1xuICAgIGFib3J0OiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgZGVzdHJveSAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgICB0aGlzLmFib3J0Py4oZXJyID8/IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA0LiBMZXQgaHR0cENhY2hlIGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGUgcGFydGl0aW9uLFxuICAvLyBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPOiBjYWNoZVxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNS4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICByZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gNi4gTGV0IG5ldHdvcmtQYXJ0aXRpb25LZXkgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgbmV0d29ya1xuICAvLyBwYXJ0aXRpb24ga2V5IGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA3LiBMZXQgbmV3Q29ubmVjdGlvbiBiZSBcInllc1wiIGlmIGZvcmNlTmV3Q29ubmVjdGlvbiBpcyB0cnVlOyBvdGhlcndpc2VcbiAgLy8gXCJub1wiLlxuICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gJ3llcycgOiAnbm8nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyA4LiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgbW9kZTpcbiAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLFxuICAgIC8vIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIGNvbm5lY3Rpb24sIGdpdmVuXG4gICAgLy8gbmV0d29ya1BhcnRpdGlvbktleSwgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbixcbiAgICAvLyBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBmb3JjZU5ld0Nvbm5lY3Rpb24uXG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gOS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIGNvbm5lY3Rpb24gaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlbiBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXNcbiAgLy8gICAgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cblxuICAvLyAgICAzLiBJZiBjb25uZWN0aW9uIGlzIG5vdCBhbiBIVFRQLzIgY29ubmVjdGlvbiwgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gICAgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIGFwcGVuZCAoYFRyYW5zZmVyLUVuY29kaW5nYCxcbiAgLy8gICAgYGNodW5rZWRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICA0LiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gICAgY2FwYWJpbGl0eS5cblxuICAvLyAgICA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBtYWtpbmcgYW4gSFRUUCByZXF1ZXN0IG92ZXIgY29ubmVjdGlvblxuICAvLyAgICB1c2luZyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBjYXZlYXRzOlxuXG4gIC8vICAgICAgICAtIEZvbGxvdyB0aGUgcmVsZXZhbnQgcmVxdWlyZW1lbnRzIGZyb20gSFRUUC4gW0hUVFBdIFtIVFRQLVNFTUFOVElDU11cbiAgLy8gICAgICAgIFtIVFRQLUNPTkRdIFtIVFRQLUNBQ0hJTkddIFtIVFRQLUFVVEhdXG5cbiAgLy8gICAgICAgIC0gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLFxuICAvLyAgICAgICAgdGhlbiB0aGUgdXNlciBhZ2VudCBtYXkgaGF2ZSBhIGJ1ZmZlciBvZiB1cCB0byA2NCBraWJpYnl0ZXMgYW5kIHN0b3JlXG4gIC8vICAgICAgICBhIHBhcnQgb2YgcmVxdWVzdOKAmXMgYm9keSBpbiB0aGF0IGJ1ZmZlci4gSWYgdGhlIHVzZXIgYWdlbnQgcmVhZHMgZnJvbVxuICAvLyAgICAgICAgcmVxdWVzdOKAmXMgYm9keSBiZXlvbmQgdGhhdCBidWZmZXLigJlzIHNpemUgYW5kIHRoZSB1c2VyIGFnZW50IG5lZWRzIHRvXG4gIC8vICAgICAgICByZXNlbmQgcmVxdWVzdCwgdGhlbiBpbnN0ZWFkIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgICAgIC0gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgICAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSxcbiAgLy8gICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZVxuICAvLyAgICAgICAgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXIgYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXNcbiAgLy8gICAgICAgIGxpbmUgZm9yIEhUVFAvMS54KS5cblxuICAvLyAgICAgICAgLSBXYWl0IHVudGlsIGFsbCB0aGUgaGVhZGVycyBhcmUgdHJhbnNtaXR0ZWQuXG5cbiAgLy8gICAgICAgIC0gQW55IHJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIDEwMCB0byAxOTksIGluY2x1c2l2ZSxcbiAgLy8gICAgICAgIGFuZCBpcyBub3QgMTAxLCBhcmUgdG8gYmUgaWdub3JlZCwgZXhjZXB0IGZvciB0aGUgcHVycG9zZXMgb2Ygc2V0dGluZ1xuICAvLyAgICAgICAgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIGFib3ZlLlxuXG4gIC8vICAgIC0gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFRyYW5zZmVyLUVuY29kaW5nYC9gY2h1bmtlZGAgYW5kXG4gIC8vICAgIHJlc3BvbnNlIGlzIHRyYW5zZmVycmVkIHZpYSBIVFRQLzEuMCBvciBvbGRlciwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vICAgIGVycm9yLlxuXG4gIC8vICAgIC0gSWYgdGhlIEhUVFAgcmVxdWVzdCByZXN1bHRzIGluIGEgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZSBkaWFsb2csIHRoZW46XG5cbiAgLy8gICAgICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QsIG1ha2UgdGhlXG4gIC8vICAgICAgICBkaWFsb2cgYXZhaWxhYmxlIGluIHJlcXVlc3TigJlzIHdpbmRvdy5cblxuICAvLyAgICAgICAgMi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vIFRvIHRyYW5zbWl0IHJlcXVlc3TigJlzIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuICBsZXQgcmVxdWVzdEJvZHkgPSBudWxsXG4gIC8vIDEuIElmIGJvZHkgaXMgbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpc1xuICAvLyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdFxuICAvLyBlbmQtb2YtYm9keSBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJvZHkgaXMgbm9uLW51bGw6XG5cbiAgICAvLyAgICAxLiBMZXQgcHJvY2Vzc0JvZHlDaHVuayBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gYXN5bmMgZnVuY3Rpb24gKiAoYnl0ZXMpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOiB0cmFuc21pdCBieXRlcy5cbiAgICAgIHlpZWxkIGJ5dGVzXG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW5cbiAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBnaXZlbiBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg/LihieXRlcy5ieXRlTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBwcm9jZXNzRW5kT2ZCb2R5IGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsXG4gICAgICAvLyB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBnaXZlbiBlIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBlIGlzIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbiwgdGhlbiBhYm9ydCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSW5jcmVtZW50YWxseSByZWFkIHJlcXVlc3TigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHlDaHVuaywgcHJvY2Vzc0VuZE9mQm9keSxcbiAgICAvLyBwcm9jZXNzQm9keUVycm9yLCBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgcmVxdWVzdEJvZHkgPSAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QuYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHByb2Nlc3NCb2R5Q2h1bmsoYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0VuZE9mQm9keSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzb2NrZXQgaXMgb25seSBwcm92aWRlZCBmb3Igd2Vic29ja2V0c1xuICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0gPSBhd2FpdCBkaXNwYXRjaCh7IGJvZHk6IHJlcXVlc3RCb2R5IH0pXG5cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCA9ICgpID0+IGl0ZXJhdG9yLm5leHQoKVxuXG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDEwLiBJZiBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAvLyAxLiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICAgIC8vIDIuIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLCBlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKVxuICB9XG5cbiAgLy8gMTEuIExldCBwdWxsQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHJlc3VtZXMgdGhlIG9uZ29pbmcgZmV0Y2hcbiAgLy8gaWYgaXQgaXMgc3VzcGVuZGVkLlxuICBjb25zdCBwdWxsQWxnb3JpdGhtID0gKCkgPT4ge1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lKClcbiAgfVxuXG4gIC8vIDEyLiBMZXQgY2FuY2VsQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFib3J0cyBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gY29udHJvbGxlciB3aXRoIHJlYXNvbiwgZ2l2ZW4gcmVhc29uLlxuICBjb25zdCBjYW5jZWxBbGdvcml0aG0gPSAocmVhc29uKSA9PiB7XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydChyZWFzb24pXG4gIH1cblxuICAvLyAxMy4gTGV0IGhpZ2hXYXRlck1hcmsgYmUgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4gbnVtYmVyLCBjaG9zZW4gYnlcbiAgLy8gdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNC4gTGV0IHNpemVBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWNjZXB0cyBhIGNodW5rIG9iamVjdFxuICAvLyBhbmQgcmV0dXJucyBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiwgbm9uLWluZmluaXRlIG51bWJlciwgY2hvc2VuIGJ5IHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIExldCBzdHJlYW0gYmUgYSBuZXcgUmVhZGFibGVTdHJlYW0uXG4gIC8vIDE2LiBTZXQgdXAgc3RyZWFtIHdpdGggcHVsbEFsZ29yaXRobSBzZXQgdG8gcHVsbEFsZ29yaXRobSxcbiAgLy8gY2FuY2VsQWxnb3JpdGhtIHNldCB0byBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgc2V0IHRvXG4gIC8vIGhpZ2hXYXRlck1hcmssIGFuZCBzaXplQWxnb3JpdGhtIHNldCB0byBzaXplQWxnb3JpdGhtLlxuICBpZiAoIVJlYWRhYmxlU3RyZWFtKSB7XG4gICAgUmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW1cbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICB7XG4gICAgICBhc3luYyBzdGFydCAoY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBhd2FpdCBwdWxsQWxnb3JpdGhtKGNvbnRyb2xsZXIpXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgY2FuY2VsQWxnb3JpdGhtKHJlYXNvbilcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IDAsXG4gICAgICBzaXplICgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICAvLyAxNy4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBhIG5ldyBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0uXG4gIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbSB9XG5cbiAgLy8gICAgMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpc1xuICAvLyAgICBub3QgXCJuby1zdG9yZVwiLCB0aGVuIHVwZGF0ZSByZXNwb25zZSBpbiBodHRwQ2FjaGUgZm9yIHJlcXVlc3QuXG4gIC8vICAgIFRPRE9cblxuICAvLyAgICAzLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWRcbiAgLy8gICAgdG8gYmxvY2sgY29va2llcyBmb3IgcmVxdWVzdCAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuIHJ1biB0aGVcbiAgLy8gICAgXCJzZXQtY29va2llLXN0cmluZ1wiIHBhcnNpbmcgYWxnb3JpdGhtIChzZWUgc2VjdGlvbiA1LjIgb2YgW0NPT0tJRVNdKSBvblxuICAvLyAgICB0aGUgdmFsdWUgb2YgZWFjaCBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgLy8gICAgYFNldC1Db29raWVgIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCwgaWYgYW55LCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gIC8vICAgIFRPRE9cblxuICAvLyAxOC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE5LiBSdW4gdGhlc2Ugc3RlcHMgaW4gcGFyYWxsZWw6XG5cbiAgLy8gICAgMS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZDpcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIG9uQWJvcnRlZClcbiAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gMS4gV2hpbGUgdHJ1ZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyAxLTMuIFNlZSBvbkRhdGEuLi5cblxuICAgICAgLy8gNC4gU2V0IGJ5dGVzIHRvIHRoZSByZXN1bHQgb2YgaGFuZGxpbmcgY29udGVudCBjb2RpbmdzIGdpdmVuXG4gICAgICAvLyBjb2RpbmdzIGFuZCBieXRlcy5cbiAgICAgIGxldCBieXRlc1xuICAgICAgbGV0IGlzRmFpbHVyZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0KClcblxuICAgICAgICBpZiAoaXNBYm9ydGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBieXRlcyA9IGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkICYmICF0aW1pbmdJbmZvLmVuY29kZWRCb2R5U2l6ZSkge1xuICAgICAgICAgIC8vIHpsaWIgZG9lc24ndCBsaWtlIGVtcHR5IHN0cmVhbXMuXG4gICAgICAgICAgYnl0ZXMgPSB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlcyA9IGVyclxuXG4gICAgICAgICAgLy8gZXJyIG1heSBiZSBwcm9wYWdhdGVkIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHJlYWRhYmxlc3RyZWFtLmNhbmNlbCxcbiAgICAgICAgICAvLyB3aGljaCBtaWdodCBub3QgYmUgYW4gZXJyb3IuIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDA5XG4gICAgICAgICAgaXNGYWlsdXJlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgdGhlIGJ5dGVzIHRyYW5zbWlzc2lvbiBmb3IgcmVzcG9uc2XigJlzIG1lc3NhZ2VcbiAgICAgICAgLy8gYm9keSBpcyBkb25lIG5vcm1hbGx5IGFuZCBzdHJlYW0gaXMgcmVhZGFibGUsIHRoZW4gY2xvc2VcbiAgICAgICAgLy8gc3RyZWFtLCBmaW5hbGl6ZSByZXNwb25zZSBmb3IgZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLCBhbmRcbiAgICAgICAgLy8gYWJvcnQgdGhlc2UgaW4tcGFyYWxsZWwgc3RlcHMuXG4gICAgICAgIHJlYWRhYmxlU3RyZWFtQ2xvc2UoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyKVxuXG4gICAgICAgIGZpbmFsaXplUmVzcG9uc2UoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBkZWNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgdGltaW5nSW5mby5kZWNvZGVkQm9keVNpemUgKz0gYnl0ZXM/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgICAvLyA2LiBJZiBieXRlcyBpcyBmYWlsdXJlLCB0aGVuIHRlcm1pbmF0ZSBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChpc0ZhaWx1cmUpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoYnl0ZXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA3LiBFbnF1ZXVlIGEgVWludDhBcnJheSB3cmFwcGluZyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGJ5dGVzXG4gICAgICAvLyBpbnRvIHN0cmVhbS5cbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcblxuICAgICAgLy8gOC4gSWYgc3RyZWFtIGlzIGVycm9yZWQsIHRoZW4gdGVybWluYXRlIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKGlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDkuIElmIHN0cmVhbSBkb2VzbuKAmXQgbmVlZCBtb3JlIGRhdGEgYXNrIHRoZSB1c2VyIGFnZW50IHRvIHN1c3BlbmRcbiAgICAgIC8vIHRoZSBvbmdvaW5nIGZldGNoLlxuICAgICAgaWYgKCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gICAgMi4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgZnVuY3Rpb24gb25BYm9ydGVkIChyZWFzb24pIHtcbiAgICAvLyAyLiBJZiBmZXRjaFBhcmFtcyBpcyBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZy5cbiAgICAgIHJlc3BvbnNlLmFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciBzdHJlYW0gd2l0aCB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGdpdmVuIGZldGNoUGFyYW1z4oCZc1xuICAgICAgLy8gICAgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kIGFuXG4gICAgICAvLyAgICBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHJlYWxtLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHN0cmVhbSBpcyByZWFkYWJsZSwgZXJyb3Igc3RyZWFtIHdpdGggYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihuZXcgVHlwZUVycm9yKCd0ZXJtaW5hdGVkJywge1xuICAgICAgICAgIGNhdXNlOiBpc0Vycm9yTGlrZShyZWFzb24pID8gcmVhc29uIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyA1LiBPdGhlcndpc2UsIHRoZSB1c2VyIGFnZW50IHNob3VsZCBjbG9zZSBjb25uZWN0aW9uIHVubGVzcyBpdCB3b3VsZCBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGRvIHNvLlxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgfVxuXG4gIC8vIDIwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGRpc3BhdGNoICh7IGJvZHkgfSkge1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uJykuQWdlbnR9ICovXG4gICAgY29uc3QgYWdlbnQgPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZ2VudC5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgcGF0aDogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBib2R5OiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXIuaXNNb2NrQWN0aXZlID8gcmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keS5zb3VyY2UgOiBib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNMaXN0LmVudHJpZXMsXG4gICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgdXBncmFkZTogcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JyA/ICd3ZWJzb2NrZXQnIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICBhYm9ydDogbnVsbCxcblxuICAgICAgICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCBjb25uZWN0aW9uIGhlcmU/XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIGFib3J0KVxuICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkhlYWRlcnMgKHN0YXR1cywgaGVhZGVyc0xpc3QsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgPCAyMDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RpbmdzID0gW11cbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSAnJ1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcblxuICAgICAgICAgIC8vIEZvciBIMiwgdGhlIGhlYWRlcnMgYXJlIGEgcGxhaW4gSlMgb2JqZWN0XG4gICAgICAgICAgLy8gV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVtIGFuZCBpdGVyYXRlIGFjY29yZGluZ2x5XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyc0xpc3QpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnNMaXN0Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNMaXN0W24gKyAwXS50b1N0cmluZygnbGF0aW4xJylcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gaGVhZGVyc0xpc3RbbiArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKVxuICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWVuY29kaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgICAgIC8vIFwiQWxsIGNvbnRlbnQtY29kaW5nIHZhbHVlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4uLlwiXG4gICAgICAgICAgICAgICAgY29kaW5ncyA9IHZhbC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnNMaXN0KVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBoZWFkZXJzTGlzdFtrZXldXG4gICAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtZW5jb2RpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi0zLjEuMi4xXG4gICAgICAgICAgICAgICAgLy8gXCJBbGwgY29udGVudC1jb2RpbmcgdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLi4uXCJcbiAgICAgICAgICAgICAgICBjb2RpbmdzID0gdmFsLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKS5tYXAoKHgpID0+IHgudHJpbSgpKS5yZXZlcnNlKClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdmFsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkgPSBuZXcgUmVhZGFibGUoeyByZWFkOiByZXN1bWUgfSlcblxuICAgICAgICAgIGNvbnN0IGRlY29kZXJzID0gW11cblxuICAgICAgICAgIGNvbnN0IHdpbGxGb2xsb3cgPSByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93JyAmJlxuICAgICAgICAgICAgbG9jYXRpb24gJiZcbiAgICAgICAgICAgIHJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHN0YXR1cylcblxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LUVuY29kaW5nXG4gICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdDT05ORUNUJyAmJiAhbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoc3RhdHVzKSAmJiAhd2lsbEZvbGxvdykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2Rpbmcgb2YgY29kaW5ncykge1xuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMi5odG1sI3NlY3Rpb24tNy4yXG4gICAgICAgICAgICAgIGlmIChjb2RpbmcgPT09ICd4LWd6aXAnIHx8IGNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUd1bnppcCh7XG4gICAgICAgICAgICAgICAgICAvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAgIC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgLy8gYnkgY29tbW9uIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlSW5mbGF0ZSgpKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMubGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzTGlzdDogaGVhZGVyc1trSGVhZGVyc0xpc3RdLFxuICAgICAgICAgICAgYm9keTogZGVjb2RlcnMubGVuZ3RoXG4gICAgICAgICAgICAgID8gcGlwZWxpbmUodGhpcy5ib2R5LCAuLi5kZWNvZGVycywgKCkgPT4geyB9KVxuICAgICAgICAgICAgICA6IHRoaXMuYm9keS5vbignZXJyb3InLCAoKSA9PiB7fSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRhdGEgKGNodW5rKSB7XG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMS4gSWYgb25lIG9yIG1vcmUgYnl0ZXMgaGF2ZSBiZWVuIHRyYW5zbWl0dGVkIGZyb20gcmVzcG9uc2XigJlzXG4gICAgICAgICAgLy8gbWVzc2FnZSBib2R5LCB0aGVuOlxuXG4gICAgICAgICAgLy8gIDEuIExldCBieXRlcyBiZSB0aGUgdHJhbnNtaXR0ZWQgYnl0ZXMuXG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBjaHVua1xuXG4gICAgICAgICAgLy8gIDIuIExldCBjb2RpbmdzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgICAgICAvLyAgZ2l2ZW4gYENvbnRlbnQtRW5jb2RpbmdgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgICAgLy8gIFNlZSBwdWxsQWxnb3JpdGhtLlxuXG4gICAgICAgICAgLy8gIDMuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGVuY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUgKz0gYnl0ZXMuYnl0ZUxlbmd0aFxuXG4gICAgICAgICAgLy8gIDQuIFNlZSBwdWxsQWxnb3JpdGhtLi4uXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnB1c2goYnl0ZXMpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db21wbGV0ZSAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkID0gdHJ1ZVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnB1c2gobnVsbClcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5Py5kZXN0cm95KGVycm9yKVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyb3IpXG5cbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25VcGdyYWRlIChzdGF0dXMsIGhlYWRlcnNMaXN0LCBzb2NrZXQpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG5cbiAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnNMaXN0Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXJzTGlzdFtuICsgMF0udG9TdHJpbmcoJ2xhdGluMScpXG4gICAgICAgICAgICBjb25zdCB2YWwgPSBoZWFkZXJzTGlzdFtuICsgMV0udG9TdHJpbmcoJ2xhdGluMScpXG5cbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogU1RBVFVTX0NPREVTW3N0YXR1c10sXG4gICAgICAgICAgICBoZWFkZXJzTGlzdDogaGVhZGVyc1trSGVhZGVyc0xpc3RdLFxuICAgICAgICAgICAgc29ja2V0XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmZXRjaCxcbiAgRmV0Y2gsXG4gIGZldGNoaW5nLFxuICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZ1xufVxuIl0sIm5hbWVzIjpbIlJlc3BvbnNlIiwibWFrZU5ldHdvcmtFcnJvciIsIm1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvciIsImZpbHRlclJlc3BvbnNlIiwibWFrZVJlc3BvbnNlIiwicmVxdWlyZSIsIkhlYWRlcnMiLCJSZXF1ZXN0IiwibWFrZVJlcXVlc3QiLCJ6bGliIiwiYnl0ZXNNYXRjaCIsIm1ha2VQb2xpY3lDb250YWluZXIiLCJjbG9uZVBvbGljeUNvbnRhaW5lciIsInJlcXVlc3RCYWRQb3J0IiwiVEFPQ2hlY2siLCJhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsInJlcXVlc3RDdXJyZW50VVJMIiwic2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsImNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8iLCJhcHBlbmRGZXRjaE1ldGFkYXRhIiwiY29yc0NoZWNrIiwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrIiwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciIsImNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwiaXNCbG9iTGlrZSIsInNhbWVPcmlnaW4iLCJpc0NhbmNlbGxlZCIsImlzQWJvcnRlZCIsImlzRXJyb3JMaWtlIiwiZnVsbHlSZWFkQm9keSIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJpc29tb3JwaGljRW5jb2RlIiwidXJsSXNMb2NhbCIsInVybElzSHR0cEh0dHBzU2NoZW1lIiwidXJsSGFzSHR0cHNTY2hlbWUiLCJrU3RhdGUiLCJrSGVhZGVycyIsImtHdWFyZCIsImtSZWFsbSIsImFzc2VydCIsInNhZmVseUV4dHJhY3RCb2R5IiwicmVkaXJlY3RTdGF0dXMiLCJudWxsQm9keVN0YXR1cyIsInNhZmVNZXRob2RzIiwicmVxdWVzdEJvZHlIZWFkZXIiLCJzdWJyZXNvdXJjZSIsIkRPTUV4Y2VwdGlvbiIsImtIZWFkZXJzTGlzdCIsIkVFIiwiUmVhZGFibGUiLCJwaXBlbGluZSIsImFkZEFib3J0TGlzdGVuZXIiLCJpc0Vycm9yZWQiLCJpc1JlYWRhYmxlIiwibm9kZU1ham9yIiwibm9kZU1pbm9yIiwiZGF0YVVSTFByb2Nlc3NvciIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsIlRyYW5zZm9ybVN0cmVhbSIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJ3ZWJpZGwiLCJTVEFUVVNfQ09ERVMiLCJyZXNvbHZlT2JqZWN0VVJMIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwiRmV0Y2giLCJjb25zdHJ1Y3RvciIsImRpc3BhdGNoZXIiLCJjb25uZWN0aW9uIiwiZHVtcCIsInN0YXRlIiwic2V0TWF4TGlzdGVuZXJzIiwidGVybWluYXRlIiwicmVhc29uIiwiZGVzdHJveSIsImVtaXQiLCJhYm9ydCIsImVycm9yIiwic2VyaWFsaXplZEFib3J0UmVhc29uIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiaGVhZGVyIiwicCIsInJlcXVlc3RPYmplY3QiLCJlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcXVlc3QiLCJzaWduYWwiLCJhYm9ydGVkIiwiYWJvcnRGZXRjaCIsImdsb2JhbE9iamVjdCIsImNsaWVudCIsIm5hbWUiLCJzZXJ2aWNlV29ya2VycyIsInJlc3BvbnNlT2JqZWN0IiwicmVsZXZhbnRSZWFsbSIsImxvY2FsbHlBYm9ydGVkIiwiY29udHJvbGxlciIsImhhbmRsZUZldGNoRG9uZSIsInJlc3BvbnNlIiwiZmluYWxpemVBbmRSZXBvcnRUaW1pbmciLCJwcm9jZXNzUmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJjYXVzZSIsImhlYWRlcnNMaXN0IiwiZmV0Y2hpbmciLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkiLCJpbml0aWF0b3JUeXBlIiwidXJsTGlzdCIsImxlbmd0aCIsIm9yaWdpbmFsVVJMIiwidGltaW5nSW5mbyIsImNhY2hlU3RhdGUiLCJ0aW1pbmdBbGxvd1Bhc3NlZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJtYXJrUmVzb3VyY2VUaW1pbmciLCJwZXJmb3JtYW5jZSIsImhyZWYiLCJib2R5Iiwic3RyZWFtIiwiY2FuY2VsIiwiY2F0Y2giLCJlcnIiLCJjb2RlIiwicHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgiLCJwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5IiwidXNlUGFyYWxsZWxRdWV1ZSIsInRhc2tEZXN0aW5hdGlvbiIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IiwiY3VycmVuVGltZSIsImZldGNoUGFyYW1zIiwid2luZG93Iiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwiY29udGFpbnMiLCJ2YWx1ZSIsImFwcGVuZCIsInByaW9yaXR5IiwiaW5jbHVkZXMiLCJkZXN0aW5hdGlvbiIsIm1haW5GZXRjaCIsInJlY3Vyc2l2ZSIsImxvY2FsVVJMc09ubHkiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyIiwiY3VycmVudFVSTCIsInVybCIsInJlc3BvbnNlVGFpbnRpbmciLCJwcm90b2NvbCIsIm1vZGUiLCJzY2hlbWVGZXRjaCIsInJlZGlyZWN0IiwiaHR0cEZldGNoIiwic3RhdHVzIiwiaW50ZXJuYWxSZXNwb25zZSIsInB1c2giLCJ0aW1pbmdBbGxvd0ZhaWxlZCIsInJhbmdlUmVxdWVzdGVkIiwiaGVhZGVycyIsIm1ldGhvZCIsImludGVncml0eSIsInByb2Nlc3NCb2R5RXJyb3IiLCJmZXRjaEZpbmFsZSIsInByb2Nlc3NCb2R5IiwiYnl0ZXMiLCJyZWRpcmVjdENvdW50Iiwic2NoZW1lIiwiYmxvYlVSTEVudHJ5Iiwic2VhcmNoIiwiYmxvYlVSTEVudHJ5T2JqZWN0IiwidG9TdHJpbmciLCJib2R5V2l0aFR5cGUiLCJzdGF0dXNUZXh0IiwiZGF0YVVSTFN0cnVjdCIsIm1pbWVUeXBlIiwiZmluYWxpemVSZXNwb25zZSIsImRvbmUiLCJwcm9jZXNzUmVzcG9uc2VEb25lIiwicXVldWVNaWNyb3Rhc2siLCJpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSIsImNodW5rIiwiZW5xdWV1ZSIsInRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwidHJhbnNmb3JtIiwiZmx1c2giLCJzaXplIiwicGlwZVRocm91Z2giLCJudWxsT3JCeXRlcyIsImZhaWx1cmUiLCJhY3R1YWxSZXNwb25zZSIsImh0dHBOZXR3b3JrT3JDYWNoZUZldGNoIiwiaHR0cFJlZGlyZWN0RmV0Y2giLCJsb2NhdGlvblVSTCIsImhhc2giLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic291cmNlIiwiaGVhZGVyTmFtZSIsImRlbGV0ZSIsInJlZGlyZWN0RW5kVGltZSIsInBvc3RSZWRpcmVjdFN0YXJ0VGltZSIsInJlZGlyZWN0U3RhcnRUaW1lIiwiaXNBdXRoZW50aWNhdGlvbkZldGNoIiwiaXNOZXdDb25uZWN0aW9uRmV0Y2giLCJodHRwRmV0Y2hQYXJhbXMiLCJodHRwUmVxdWVzdCIsImh0dHBDYWNoZSIsInJldmFsaWRhdGluZ0ZsYWciLCJpbmNsdWRlQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUiLCJrZWVwYWxpdmUiLCJVUkwiLCJlc2J1aWxkRGV0ZWN0aW9uIiwiY2FjaGUiLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImZvcndhcmRSZXNwb25zZSIsImh0dHBOZXR3b3JrRmV0Y2giLCJyZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyIsImZvcmNlTmV3Q29ubmVjdGlvbiIsImRlc3Ryb3llZCIsIm5ld0Nvbm5lY3Rpb24iLCJyZXF1ZXN0Qm9keSIsInByb2Nlc3NCb2R5Q2h1bmsiLCJieXRlTGVuZ3RoIiwicHJvY2Vzc0VuZE9mQm9keSIsInNvY2tldCIsImRpc3BhdGNoIiwiaXRlcmF0b3IiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwibmV4dCIsInB1bGxBbGdvcml0aG0iLCJyZXN1bWUiLCJjYW5jZWxBbGdvcml0aG0iLCJwdWxsIiwiaGlnaFdhdGVyTWFyayIsIm9uIiwib25BYm9ydGVkIiwiaXNGYWlsdXJlIiwidW5kZWZpbmVkIiwiZW5kZWQiLCJlbmNvZGVkQm9keVNpemUiLCJkZWNvZGVkQm9keVNpemUiLCJVaW50OEFycmF5IiwiZGVzaXJlZFNpemUiLCJhZ2VudCIsInBhdGgiLCJwYXRobmFtZSIsImlzTW9ja0FjdGl2ZSIsImVudHJpZXMiLCJtYXhSZWRpcmVjdGlvbnMiLCJ1cGdyYWRlIiwib25Db25uZWN0Iiwib25IZWFkZXJzIiwiY29kaW5ncyIsImxvY2F0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwibiIsImtleSIsInZhbCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJtYXAiLCJ4IiwidHJpbSIsImtleXMiLCJyZXZlcnNlIiwicmVhZCIsImRlY29kZXJzIiwid2lsbEZvbGxvdyIsImNvZGluZyIsImNyZWF0ZUd1bnppcCIsImNvbnN0YW50cyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwib2ZmIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/request.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/request.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */ \nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/fetch/body.js\");\nconst { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\");\nconst { FinalizationRegistry } = __webpack_require__(/*! ../compat/dispatcher-weakref */ \"(rsc)/./node_modules/undici/lib/compat/dispatcher-weakref.js\")();\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { forbiddenMethods, corsSafeListedMethods, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { kEnumerableProperty } = util;\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! events */ \"events\");\nlet TransformStream = globalThis.TransformStream;\nconst kInit = Symbol(\"init\");\nconst kAbortController = Symbol(\"abortController\");\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort })=>{\n    signal.removeEventListener(\"abort\", abort);\n});\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n    // https://fetch.spec.whatwg.org/#dom-request\n    constructor(input, init = {}){\n        if (input === kInit) {\n            return;\n        }\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Request constructor\"\n        });\n        input = webidl.converters.RequestInfo(input);\n        init = webidl.converters.RequestInit(init);\n        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n        this[kRealm] = {\n            settingsObject: {\n                baseUrl: getGlobalOrigin(),\n                get origin () {\n                    return this.baseUrl?.origin;\n                },\n                policyContainer: makePolicyContainer()\n            }\n        };\n        // 1. Let request be null.\n        let request = null;\n        // 2. Let fallbackMode be null.\n        let fallbackMode = null;\n        // 3. Let baseURL be this’s relevant settings object’s API base URL.\n        const baseUrl = this[kRealm].settingsObject.baseUrl;\n        // 4. Let signal be null.\n        let signal = null;\n        // 5. If input is a string, then:\n        if (typeof input === \"string\") {\n            // 1. Let parsedURL be the result of parsing input with baseURL.\n            // 2. If parsedURL is failure, then throw a TypeError.\n            let parsedURL;\n            try {\n                parsedURL = new URL(input, baseUrl);\n            } catch (err) {\n                throw new TypeError(\"Failed to parse URL from \" + input, {\n                    cause: err\n                });\n            }\n            // 3. If parsedURL includes credentials, then throw a TypeError.\n            if (parsedURL.username || parsedURL.password) {\n                throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \" + input);\n            }\n            // 4. Set request to a new request whose URL is parsedURL.\n            request = makeRequest({\n                urlList: [\n                    parsedURL\n                ]\n            });\n            // 5. Set fallbackMode to \"cors\".\n            fallbackMode = \"cors\";\n        } else {\n            // 6. Otherwise:\n            // 7. Assert: input is a Request object.\n            assert(input instanceof Request);\n            // 8. Set request to input’s request.\n            request = input[kState];\n            // 9. Set signal to input’s signal.\n            signal = input[kSignal];\n        }\n        // 7. Let origin be this’s relevant settings object’s origin.\n        const origin = this[kRealm].settingsObject.origin;\n        // 8. Let window be \"client\".\n        let window = \"client\";\n        // 9. If request’s window is an environment settings object and its origin\n        // is same origin with origin, then set window to request’s window.\n        if (request.window?.constructor?.name === \"EnvironmentSettingsObject\" && sameOrigin(request.window, origin)) {\n            window = request.window;\n        }\n        // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n        if (init.window != null) {\n            throw new TypeError(`'window' option '${window}' must be null`);\n        }\n        // 11. If init[\"window\"] exists, then set window to \"no-window\".\n        if (\"window\" in init) {\n            window = \"no-window\";\n        }\n        // 12. Set request to a new request with the following properties:\n        request = makeRequest({\n            // URL request’s URL.\n            // undici implementation note: this is set as the first item in request's urlList in makeRequest\n            // method request’s method.\n            method: request.method,\n            // header list A copy of request’s header list.\n            // undici implementation note: headersList is cloned in makeRequest\n            headersList: request.headersList,\n            // unsafe-request flag Set.\n            unsafeRequest: request.unsafeRequest,\n            // client This’s relevant settings object.\n            client: this[kRealm].settingsObject,\n            // window window.\n            window,\n            // priority request’s priority.\n            priority: request.priority,\n            // origin request’s origin. The propagation of the origin is only significant for navigation requests\n            // being handled by a service worker. In this scenario a request can have an origin that is different\n            // from the current client.\n            origin: request.origin,\n            // referrer request’s referrer.\n            referrer: request.referrer,\n            // referrer policy request’s referrer policy.\n            referrerPolicy: request.referrerPolicy,\n            // mode request’s mode.\n            mode: request.mode,\n            // credentials mode request’s credentials mode.\n            credentials: request.credentials,\n            // cache mode request’s cache mode.\n            cache: request.cache,\n            // redirect mode request’s redirect mode.\n            redirect: request.redirect,\n            // integrity metadata request’s integrity metadata.\n            integrity: request.integrity,\n            // keepalive request’s keepalive.\n            keepalive: request.keepalive,\n            // reload-navigation flag request’s reload-navigation flag.\n            reloadNavigation: request.reloadNavigation,\n            // history-navigation flag request’s history-navigation flag.\n            historyNavigation: request.historyNavigation,\n            // URL list A clone of request’s URL list.\n            urlList: [\n                ...request.urlList\n            ]\n        });\n        // 13. If init is not empty, then:\n        if (Object.keys(init).length > 0) {\n            // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n            if (request.mode === \"navigate\") {\n                request.mode = \"same-origin\";\n            }\n            // 2. Unset request’s reload-navigation flag.\n            request.reloadNavigation = false;\n            // 3. Unset request’s history-navigation flag.\n            request.historyNavigation = false;\n            // 4. Set request’s origin to \"client\".\n            request.origin = \"client\";\n            // 5. Set request’s referrer to \"client\"\n            request.referrer = \"client\";\n            // 6. Set request’s referrer policy to the empty string.\n            request.referrerPolicy = \"\";\n            // 7. Set request’s URL to request’s current URL.\n            request.url = request.urlList[request.urlList.length - 1];\n            // 8. Set request’s URL list to « request’s URL ».\n            request.urlList = [\n                request.url\n            ];\n        }\n        // 14. If init[\"referrer\"] exists, then:\n        if (init.referrer !== undefined) {\n            // 1. Let referrer be init[\"referrer\"].\n            const referrer = init.referrer;\n            // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n            if (referrer === \"\") {\n                request.referrer = \"no-referrer\";\n            } else {\n                // 1. Let parsedReferrer be the result of parsing referrer with\n                // baseURL.\n                // 2. If parsedReferrer is failure, then throw a TypeError.\n                let parsedReferrer;\n                try {\n                    parsedReferrer = new URL(referrer, baseUrl);\n                } catch (err) {\n                    throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, {\n                        cause: err\n                    });\n                }\n                // 3. If one of the following is true\n                // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n                // - parsedReferrer’s origin is not same origin with origin\n                // then set request’s referrer to \"client\".\n                if (parsedReferrer.protocol === \"about:\" && parsedReferrer.hostname === \"client\" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {\n                    request.referrer = \"client\";\n                } else {\n                    // 4. Otherwise, set request’s referrer to parsedReferrer.\n                    request.referrer = parsedReferrer;\n                }\n            }\n        }\n        // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n        // to it.\n        if (init.referrerPolicy !== undefined) {\n            request.referrerPolicy = init.referrerPolicy;\n        }\n        // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n        let mode;\n        if (init.mode !== undefined) {\n            mode = init.mode;\n        } else {\n            mode = fallbackMode;\n        }\n        // 17. If mode is \"navigate\", then throw a TypeError.\n        if (mode === \"navigate\") {\n            throw webidl.errors.exception({\n                header: \"Request constructor\",\n                message: \"invalid request mode navigate.\"\n            });\n        }\n        // 18. If mode is non-null, set request’s mode to mode.\n        if (mode != null) {\n            request.mode = mode;\n        }\n        // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n        // to it.\n        if (init.credentials !== undefined) {\n            request.credentials = init.credentials;\n        }\n        // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n        if (init.cache !== undefined) {\n            request.cache = init.cache;\n        }\n        // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n        // not \"same-origin\", then throw a TypeError.\n        if (request.cache === \"only-if-cached\" && request.mode !== \"same-origin\") {\n            throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n        }\n        // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n        if (init.redirect !== undefined) {\n            request.redirect = init.redirect;\n        }\n        // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n        if (init.integrity !== undefined && init.integrity != null) {\n            request.integrity = String(init.integrity);\n        }\n        // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n        if (init.keepalive !== undefined) {\n            request.keepalive = Boolean(init.keepalive);\n        }\n        // 25. If init[\"method\"] exists, then:\n        if (init.method !== undefined) {\n            // 1. Let method be init[\"method\"].\n            let method = init.method;\n            // 2. If method is not a method or method is a forbidden method, then\n            // throw a TypeError.\n            if (!isValidHTTPToken(init.method)) {\n                throw TypeError(`'${init.method}' is not a valid HTTP method.`);\n            }\n            if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n                throw TypeError(`'${init.method}' HTTP method is unsupported.`);\n            }\n            // 3. Normalize method.\n            method = normalizeMethod(init.method);\n            // 4. Set request’s method to method.\n            request.method = method;\n        }\n        // 26. If init[\"signal\"] exists, then set signal to it.\n        if (init.signal !== undefined) {\n            signal = init.signal;\n        }\n        // 27. Set this’s request to request.\n        this[kState] = request;\n        // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n        // Realm.\n        // TODO: could this be simplified with AbortSignal.any\n        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        this[kSignal][kRealm] = this[kRealm];\n        // 29. If signal is not null, then make this’s signal follow signal.\n        if (signal != null) {\n            if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n                throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n            }\n            if (signal.aborted) {\n                ac.abort(signal.reason);\n            } else {\n                // Keep a strong ref to ac while request object\n                // is alive. This is needed to prevent AbortController\n                // from being prematurely garbage collected.\n                // See, https://github.com/nodejs/undici/issues/1926.\n                this[kAbortController] = ac;\n                const acRef = new WeakRef(ac);\n                const abort = function() {\n                    const ac = acRef.deref();\n                    if (ac !== undefined) {\n                        ac.abort(this.reason);\n                    }\n                };\n                // Third-party AbortControllers may not work with these.\n                // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n                try {\n                    // If the max amount of listeners is equal to the default, increase it\n                    // This is only available in node >= v19.9.0\n                    if (typeof getMaxListeners === \"function\" && getMaxListeners(signal) === defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    } else if (getEventListeners(signal, \"abort\").length >= defaultMaxListeners) {\n                        setMaxListeners(100, signal);\n                    }\n                } catch  {}\n                util.addAbortListener(signal, abort);\n                requestFinalizer.register(ac, {\n                    signal,\n                    abort\n                });\n            }\n        }\n        // 30. Set this’s headers to a new Headers object with this’s relevant\n        // Realm, whose header list is request’s header list and guard is\n        // \"request\".\n        this[kHeaders] = new Headers();\n        this[kHeaders][kHeadersList] = request.headersList;\n        this[kHeaders][kGuard] = \"request\";\n        this[kHeaders][kRealm] = this[kRealm];\n        // 31. If this’s request’s mode is \"no-cors\", then:\n        if (mode === \"no-cors\") {\n            // 1. If this’s request’s method is not a CORS-safelisted method,\n            // then throw a TypeError.\n            if (!corsSafeListedMethods.includes(request.method)) {\n                throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n            }\n            // 2. Set this’s headers’s guard to \"request-no-cors\".\n            this[kHeaders][kGuard] = \"request-no-cors\";\n        }\n        // 32. If init is not empty, then:\n        if (Object.keys(init).length !== 0) {\n            // 1. Let headers be a copy of this’s headers and its associated header\n            // list.\n            let headers = new Headers(this[kHeaders]);\n            // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n            if (init.headers !== undefined) {\n                headers = init.headers;\n            }\n            // 3. Empty this’s headers’s header list.\n            this[kHeaders][kHeadersList].clear();\n            // 4. If headers is a Headers object, then for each header in its header\n            // list, append header’s name/header’s value to this’s headers.\n            if (headers.constructor.name === \"Headers\") {\n                for (const [key, val] of headers){\n                    this[kHeaders].append(key, val);\n                }\n            } else {\n                // 5. Otherwise, fill this’s headers with headers.\n                fillHeaders(this[kHeaders], headers);\n            }\n        }\n        // 33. Let inputBody be input’s request’s body if input is a Request\n        // object; otherwise null.\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        // 34. If either init[\"body\"] exists and is non-null or inputBody is\n        // non-null, and request’s method is `GET` or `HEAD`, then throw a\n        // TypeError.\n        if ((init.body != null || inputBody != null) && (request.method === \"GET\" || request.method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        // 35. Let initBody be null.\n        let initBody = null;\n        // 36. If init[\"body\"] exists and is non-null, then:\n        if (init.body != null) {\n            // 1. Let Content-Type be null.\n            // 2. Set initBody and Content-Type to the result of extracting\n            // init[\"body\"], with keepalive set to request’s keepalive.\n            const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n            initBody = extractedBody;\n            // 3, If Content-Type is non-null and this’s headers’s header list does\n            // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n            // this’s headers.\n            if (contentType && !this[kHeaders][kHeadersList].contains(\"content-type\")) {\n                this[kHeaders].append(\"content-type\", contentType);\n            }\n        }\n        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n        // inputBody.\n        const inputOrInitBody = initBody ?? inputBody;\n        // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n        // null, then:\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n            // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n            //    then throw a TypeError.\n            if (initBody != null && init.duplex == null) {\n                throw new TypeError(\"RequestInit: duplex option is required when sending a body.\");\n            }\n            // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n            // then throw a TypeError.\n            if (request.mode !== \"same-origin\" && request.mode !== \"cors\") {\n                throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n            }\n            // 3. Set this’s request’s use-CORS-preflight flag.\n            request.useCORSPreflightFlag = true;\n        }\n        // 39. Let finalBody be inputOrInitBody.\n        let finalBody = inputOrInitBody;\n        // 40. If initBody is null and inputBody is non-null, then:\n        if (initBody == null && inputBody != null) {\n            // 1. If input is unusable, then throw a TypeError.\n            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n                throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\");\n            }\n            // 2. Set finalBody to the result of creating a proxy for inputBody.\n            if (!TransformStream) {\n                TransformStream = (__webpack_require__(/*! stream/web */ \"stream/web\").TransformStream);\n            }\n            // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n            const identityTransform = new TransformStream();\n            inputBody.stream.pipeThrough(identityTransform);\n            finalBody = {\n                source: inputBody.source,\n                length: inputBody.length,\n                stream: identityTransform.readable\n            };\n        }\n        // 41. Set this’s request’s body to finalBody.\n        this[kState].body = finalBody;\n    }\n    // Returns request’s HTTP method, which is \"GET\" by default.\n    get method() {\n        webidl.brandCheck(this, Request);\n        // The method getter steps are to return this’s request’s method.\n        return this[kState].method;\n    }\n    // Returns the URL of request as a string.\n    get url() {\n        webidl.brandCheck(this, Request);\n        // The url getter steps are to return this’s request’s URL, serialized.\n        return URLSerializer(this[kState].url);\n    }\n    // Returns a Headers object consisting of the headers associated with request.\n    // Note that headers added in the network layer by the user agent will not\n    // be accounted for in this object, e.g., the \"Host\" header.\n    get headers() {\n        webidl.brandCheck(this, Request);\n        // The headers getter steps are to return this’s headers.\n        return this[kHeaders];\n    }\n    // Returns the kind of resource requested by request, e.g., \"document\"\n    // or \"script\".\n    get destination() {\n        webidl.brandCheck(this, Request);\n        // The destination getter are to return this’s request’s destination.\n        return this[kState].destination;\n    }\n    // Returns the referrer of request. Its value can be a same-origin URL if\n    // explicitly set in init, the empty string to indicate no referrer, and\n    // \"about:client\" when defaulting to the global’s default. This is used\n    // during fetching to determine the value of the `Referer` header of the\n    // request being made.\n    get referrer() {\n        webidl.brandCheck(this, Request);\n        // 1. If this’s request’s referrer is \"no-referrer\", then return the\n        // empty string.\n        if (this[kState].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        // 2. If this’s request’s referrer is \"client\", then return\n        // \"about:client\".\n        if (this[kState].referrer === \"client\") {\n            return \"about:client\";\n        }\n        // Return this’s request’s referrer, serialized.\n        return this[kState].referrer.toString();\n    }\n    // Returns the referrer policy associated with request.\n    // This is used during fetching to compute the value of the request’s\n    // referrer.\n    get referrerPolicy() {\n        webidl.brandCheck(this, Request);\n        // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n        return this[kState].referrerPolicy;\n    }\n    // Returns the mode associated with request, which is a string indicating\n    // whether the request will use CORS, or will be restricted to same-origin\n    // URLs.\n    get mode() {\n        webidl.brandCheck(this, Request);\n        // The mode getter steps are to return this’s request’s mode.\n        return this[kState].mode;\n    }\n    // Returns the credentials mode associated with request,\n    // which is a string indicating whether credentials will be sent with the\n    // request always, never, or only when sent to a same-origin URL.\n    get credentials() {\n        // The credentials getter steps are to return this’s request’s credentials mode.\n        return this[kState].credentials;\n    }\n    // Returns the cache mode associated with request,\n    // which is a string indicating how the request will\n    // interact with the browser’s cache when fetching.\n    get cache() {\n        webidl.brandCheck(this, Request);\n        // The cache getter steps are to return this’s request’s cache mode.\n        return this[kState].cache;\n    }\n    // Returns the redirect mode associated with request,\n    // which is a string indicating how redirects for the\n    // request will be handled during fetching. A request\n    // will follow redirects by default.\n    get redirect() {\n        webidl.brandCheck(this, Request);\n        // The redirect getter steps are to return this’s request’s redirect mode.\n        return this[kState].redirect;\n    }\n    // Returns request’s subresource integrity metadata, which is a\n    // cryptographic hash of the resource being fetched. Its value\n    // consists of multiple hashes separated by whitespace. [SRI]\n    get integrity() {\n        webidl.brandCheck(this, Request);\n        // The integrity getter steps are to return this’s request’s integrity\n        // metadata.\n        return this[kState].integrity;\n    }\n    // Returns a boolean indicating whether or not request can outlive the\n    // global in which it was created.\n    get keepalive() {\n        webidl.brandCheck(this, Request);\n        // The keepalive getter steps are to return this’s request’s keepalive.\n        return this[kState].keepalive;\n    }\n    // Returns a boolean indicating whether or not request is for a reload\n    // navigation.\n    get isReloadNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isReloadNavigation getter steps are to return true if this’s\n        // request’s reload-navigation flag is set; otherwise false.\n        return this[kState].reloadNavigation;\n    }\n    // Returns a boolean indicating whether or not request is for a history\n    // navigation (a.k.a. back-foward navigation).\n    get isHistoryNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isHistoryNavigation getter steps are to return true if this’s request’s\n        // history-navigation flag is set; otherwise false.\n        return this[kState].historyNavigation;\n    }\n    // Returns the signal associated with request, which is an AbortSignal\n    // object indicating whether or not request has been aborted, and its\n    // abort event handler.\n    get signal() {\n        webidl.brandCheck(this, Request);\n        // The signal getter steps are to return this’s signal.\n        return this[kSignal];\n    }\n    get body() {\n        webidl.brandCheck(this, Request);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Request);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    get duplex() {\n        webidl.brandCheck(this, Request);\n        return \"half\";\n    }\n    // Returns a clone of request.\n    clone() {\n        webidl.brandCheck(this, Request);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw new TypeError(\"unusable\");\n        }\n        // 2. Let clonedRequest be the result of cloning this’s request.\n        const clonedRequest = cloneRequest(this[kState]);\n        // 3. Let clonedRequestObject be the result of creating a Request object,\n        // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n        const clonedRequestObject = new Request(kInit);\n        clonedRequestObject[kState] = clonedRequest;\n        clonedRequestObject[kRealm] = this[kRealm];\n        clonedRequestObject[kHeaders] = new Headers();\n        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;\n        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        // 4. Make clonedRequestObject’s signal follow this’s signal.\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n            ac.abort(this.signal.reason);\n        } else {\n            util.addAbortListener(this.signal, ()=>{\n                ac.abort(this.signal.reason);\n            });\n        }\n        clonedRequestObject[kSignal] = ac.signal;\n        // 4. Return clonedRequestObject.\n        return clonedRequestObject;\n    }\n}\nmixinBody(Request);\nfunction makeRequest(init) {\n    // https://fetch.spec.whatwg.org/#requests\n    const request = {\n        method: \"GET\",\n        localURLsOnly: false,\n        unsafeRequest: false,\n        body: null,\n        client: null,\n        reservedClient: null,\n        replacesClientId: \"\",\n        window: \"client\",\n        keepalive: false,\n        serviceWorkers: \"all\",\n        initiator: \"\",\n        destination: \"\",\n        priority: null,\n        origin: \"client\",\n        policyContainer: \"client\",\n        referrer: \"client\",\n        referrerPolicy: \"\",\n        mode: \"no-cors\",\n        useCORSPreflightFlag: false,\n        credentials: \"same-origin\",\n        useCredentials: false,\n        cache: \"default\",\n        redirect: \"follow\",\n        integrity: \"\",\n        cryptoGraphicsNonceMetadata: \"\",\n        parserMetadata: \"\",\n        reloadNavigation: false,\n        historyNavigation: false,\n        userActivation: false,\n        taintedOrigin: false,\n        redirectCount: 0,\n        responseTainting: \"basic\",\n        preventNoCacheCacheControlHeaderModification: false,\n        done: false,\n        timingAllowFailed: false,\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n    };\n    request.url = request.urlList[0];\n    return request;\n}\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest(request) {\n    // To clone a request request, run these steps:\n    // 1. Let newRequest be a copy of request, except for its body.\n    const newRequest = makeRequest({\n        ...request,\n        body: null\n    });\n    // 2. If request’s body is non-null, set newRequest’s body to the\n    // result of cloning request’s body.\n    if (request.body != null) {\n        newRequest.body = cloneBody(request.body);\n    }\n    // 3. Return newRequest.\n    return newRequest;\n}\nObject.defineProperties(Request.prototype, {\n    method: kEnumerableProperty,\n    url: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    signal: kEnumerableProperty,\n    duplex: kEnumerableProperty,\n    destination: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    isHistoryNavigation: kEnumerableProperty,\n    isReloadNavigation: kEnumerableProperty,\n    keepalive: kEnumerableProperty,\n    integrity: kEnumerableProperty,\n    cache: kEnumerableProperty,\n    credentials: kEnumerableProperty,\n    attribute: kEnumerableProperty,\n    referrerPolicy: kEnumerableProperty,\n    referrer: kEnumerableProperty,\n    mode: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Request\",\n        configurable: true\n    }\n});\nwebidl.converters.Request = webidl.interfaceConverter(Request);\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (V instanceof Request) {\n        return webidl.converters.Request(V);\n    }\n    return webidl.converters.USVString(V);\n};\nwebidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n    {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    },\n    {\n        key: \"body\",\n        converter: webidl.nullableConverter(webidl.converters.BodyInit)\n    },\n    {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n    },\n    {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        allowedValues: referrerPolicy\n    },\n    {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#concept-request-mode\n        allowedValues: requestMode\n    },\n    {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcredentials\n        allowedValues: requestCredentials\n    },\n    {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcache\n        allowedValues: requestCache\n    },\n    {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestredirect\n        allowedValues: requestRedirect\n    },\n    {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n    },\n    {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n    },\n    {\n        key: \"signal\",\n        converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, {\n                strict: false\n            }))\n    },\n    {\n        key: \"window\",\n        converter: webidl.converters.any\n    },\n    {\n        key: \"duplex\",\n        converter: webidl.converters.DOMString,\n        allowedValues: requestDuplex\n    }\n]);\nmodule.exports = {\n    Request,\n    makeRequest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixHQUUzQjtBQUVBLE1BQU0sRUFBRUEsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUN0RCxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDNUQsTUFBTSxFQUFFSyxvQkFBb0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN6QyxNQUFNTSxPQUFPTixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQ0pPLGdCQUFnQixFQUNoQkMsVUFBVSxFQUNWQyxlQUFlLEVBQ2ZDLG1CQUFtQixFQUNwQixHQUFHVixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSlcsZ0JBQWdCLEVBQ2hCQyxxQkFBcUIsRUFDckJDLGNBQWMsRUFDZEMsZUFBZSxFQUNmQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsWUFBWSxFQUNaQyxhQUFhLEVBQ2QsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFbUIsbUJBQW1CLEVBQUUsR0FBR2I7QUFDaEMsTUFBTSxFQUFFYyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHeEIsbUJBQU9BLENBQUM7QUFDOUQsTUFBTSxFQUFFeUIsTUFBTSxFQUFFLEdBQUd6QixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUUwQixlQUFlLEVBQUUsR0FBRzFCLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRTJCLGFBQWEsRUFBRSxHQUFHM0IsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFNEIsWUFBWSxFQUFFLEdBQUc1QixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNNkIsU0FBUzdCLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRThCLGVBQWUs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LE9BQU95QixVQUFVLENBQUM0SCxTQUFTO1FBQ3RDQyxlQUFlN0o7SUFDakI7Q0FDRDtBQUVEaUssT0FBT0MsT0FBTyxHQUFHO0lBQUV6STtJQUFTdUI7QUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVxdWVzdC5qcz8yMzBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHsgSGVhZGVycywgZmlsbDogZmlsbEhlYWRlcnMsIEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi4vY29tcGF0L2Rpc3BhdGNoZXItd2Vha3JlZicpKClcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBub3JtYWxpemVNZXRob2QsXG4gIG1ha2VQb2xpY3lDb250YWluZXJcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBmb3JiaWRkZW5NZXRob2RzLFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVxdWVzdER1cGxleFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbFxuY29uc3QgeyBrSGVhZGVycywga1NpZ25hbCwga1N0YXRlLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGFVUkwnKVxuY29uc3QgeyBrSGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBnZXRNYXhMaXN0ZW5lcnMsIHNldE1heExpc3RlbmVycywgZ2V0RXZlbnRMaXN0ZW5lcnMsIGRlZmF1bHRNYXhMaXN0ZW5lcnMgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cbmxldCBUcmFuc2Zvcm1TdHJlYW0gPSBnbG9iYWxUaGlzLlRyYW5zZm9ybVN0cmVhbVxuXG5jb25zdCBrSW5pdCA9IFN5bWJvbCgnaW5pdCcpXG5jb25zdCBrQWJvcnRDb250cm9sbGVyID0gU3ltYm9sKCdhYm9ydENvbnRyb2xsZXInKVxuXG5jb25zdCByZXF1ZXN0RmluYWxpemVyID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IHNpZ25hbCwgYWJvcnQgfSkgPT4ge1xuICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0XG4gIGNvbnN0cnVjdG9yIChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09PSBrSW5pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InIH0pXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0KVxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdChpbml0KVxuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdFxuICAgIHRoaXNba1JlYWxtXSA9IHtcbiAgICAgIHNldHRpbmdzT2JqZWN0OiB7XG4gICAgICAgIGJhc2VVcmw6IGdldEdsb2JhbE9yaWdpbigpLFxuICAgICAgICBnZXQgb3JpZ2luICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsPy5vcmlnaW5cbiAgICAgICAgfSxcbiAgICAgICAgcG9saWN5Q29udGFpbmVyOiBtYWtlUG9saWN5Q29udGFpbmVyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBudWxsLlxuICAgIGxldCByZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrTW9kZSBiZSBudWxsLlxuICAgIGxldCBmYWxsYmFja01vZGUgPSBudWxsXG5cbiAgICAvLyAzLiBMZXQgYmFzZVVSTCBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVXJsID0gdGhpc1trUmVhbG1dLnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDQuIExldCBzaWduYWwgYmUgbnVsbC5cbiAgICBsZXQgc2lnbmFsID0gbnVsbFxuXG4gICAgLy8gNS4gSWYgaW5wdXQgaXMgYSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGlucHV0IHdpdGggYmFzZVVSTC5cbiAgICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgbGV0IHBhcnNlZFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCwgYmFzZVVybClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJyArIGlucHV0LCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgcGFyc2VkVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSB8fCBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnUmVxdWVzdCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZnJvbSBhIFVSTCB0aGF0IGluY2x1ZGVzIGNyZWRlbnRpYWxzOiAnICtcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3QgdG8gYSBuZXcgcmVxdWVzdCB3aG9zZSBVUkwgaXMgcGFyc2VkVVJMLlxuICAgICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgdXJsTGlzdDogW3BhcnNlZFVSTF0gfSlcblxuICAgICAgLy8gNS4gU2V0IGZhbGxiYWNrTW9kZSB0byBcImNvcnNcIi5cbiAgICAgIGZhbGxiYWNrTW9kZSA9ICdjb3JzJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyA2LiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDcuIEFzc2VydDogaW5wdXQgaXMgYSBSZXF1ZXN0IG9iamVjdC5cbiAgICAgIGFzc2VydChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpXG5cbiAgICAgIC8vIDguIFNldCByZXF1ZXN0IHRvIGlucHV04oCZcyByZXF1ZXN0LlxuICAgICAgcmVxdWVzdCA9IGlucHV0W2tTdGF0ZV1cblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXRba1NpZ25hbF1cbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgb3JpZ2luIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgb3JpZ2luLlxuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5vcmlnaW5cblxuICAgIC8vIDguIExldCB3aW5kb3cgYmUgXCJjbGllbnRcIi5cbiAgICBsZXQgd2luZG93ID0gJ2NsaWVudCdcblxuICAgIC8vIDkuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QgYW5kIGl0cyBvcmlnaW5cbiAgICAvLyBpcyBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpbiwgdGhlbiBzZXQgd2luZG93IHRvIHJlcXVlc3TigJlzIHdpbmRvdy5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LndpbmRvdz8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0JyAmJlxuICAgICAgc2FtZU9yaWdpbihyZXF1ZXN0LndpbmRvdywgb3JpZ2luKVxuICAgICkge1xuICAgICAgd2luZG93ID0gcmVxdWVzdC53aW5kb3dcbiAgICB9XG5cbiAgICAvLyAxMC4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChpbml0LndpbmRvdyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnd2luZG93JyBvcHRpb24gJyR7d2luZG93fScgbXVzdCBiZSBudWxsYClcbiAgICB9XG5cbiAgICAvLyAxMS4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMsIHRoZW4gc2V0IHdpbmRvdyB0byBcIm5vLXdpbmRvd1wiLlxuICAgIGlmICgnd2luZG93JyBpbiBpbml0KSB7XG4gICAgICB3aW5kb3cgPSAnbm8td2luZG93J1xuICAgIH1cblxuICAgIC8vIDEyLiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgICAvLyBVUkwgcmVxdWVzdOKAmXMgVVJMLlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgaXMgc2V0IGFzIHRoZSBmaXJzdCBpdGVtIGluIHJlcXVlc3QncyB1cmxMaXN0IGluIG1ha2VSZXF1ZXN0XG4gICAgICAvLyBtZXRob2QgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIC8vIGhlYWRlciBsaXN0IEEgY29weSBvZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIHVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiBoZWFkZXJzTGlzdCBpcyBjbG9uZWQgaW4gbWFrZVJlcXVlc3RcbiAgICAgIGhlYWRlcnNMaXN0OiByZXF1ZXN0LmhlYWRlcnNMaXN0LFxuICAgICAgLy8gdW5zYWZlLXJlcXVlc3QgZmxhZyBTZXQuXG4gICAgICB1bnNhZmVSZXF1ZXN0OiByZXF1ZXN0LnVuc2FmZVJlcXVlc3QsXG4gICAgICAvLyBjbGllbnQgVGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgY2xpZW50OiB0aGlzW2tSZWFsbV0uc2V0dGluZ3NPYmplY3QsXG4gICAgICAvLyB3aW5kb3cgd2luZG93LlxuICAgICAgd2luZG93LFxuICAgICAgLy8gcHJpb3JpdHkgcmVxdWVzdOKAmXMgcHJpb3JpdHkuXG4gICAgICBwcmlvcml0eTogcmVxdWVzdC5wcmlvcml0eSxcbiAgICAgIC8vIG9yaWdpbiByZXF1ZXN04oCZcyBvcmlnaW4uIFRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgb3JpZ2luIGlzIG9ubHkgc2lnbmlmaWNhbnQgZm9yIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAgICAgIC8vIGJlaW5nIGhhbmRsZWQgYnkgYSBzZXJ2aWNlIHdvcmtlci4gSW4gdGhpcyBzY2VuYXJpbyBhIHJlcXVlc3QgY2FuIGhhdmUgYW4gb3JpZ2luIHRoYXQgaXMgZGlmZmVyZW50XG4gICAgICAvLyBmcm9tIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICAvLyByZWZlcnJlciByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICAgIHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgLy8gcmVmZXJyZXIgcG9saWN5IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgLy8gbW9kZSByZXF1ZXN04oCZcyBtb2RlLlxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgLy8gY3JlZGVudGlhbHMgbW9kZSByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICAvLyBjYWNoZSBtb2RlIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIC8vIHJlZGlyZWN0IG1vZGUgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgLy8gaW50ZWdyaXR5IG1ldGFkYXRhIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YS5cbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICAvLyBrZWVwYWxpdmUgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAga2VlcGFsaXZlOiByZXF1ZXN0LmtlZXBhbGl2ZSxcbiAgICAgIC8vIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAvLyBVUkwgbGlzdCBBIGNsb25lIG9mIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QudXJsTGlzdF1cbiAgICB9KVxuXG4gICAgLy8gMTMuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChPYmplY3Qua2V5cyhpbml0KS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiBzZXQgaXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICByZXF1ZXN0Lm1vZGUgPSAnc2FtZS1vcmlnaW4nXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFVuc2V0IHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyAzLiBVbnNldCByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIFwiY2xpZW50XCIuXG4gICAgICByZXF1ZXN0Lm9yaWdpbiA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDUuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiXG4gICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcblxuICAgICAgLy8gNi4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9ICcnXG5cbiAgICAgIC8vIDcuIFNldCByZXF1ZXN04oCZcyBVUkwgdG8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3TigJlzIFVSTCBsaXN0IHRvIMKrIHJlcXVlc3TigJlzIFVSTCDCuy5cbiAgICAgIHJlcXVlc3QudXJsTGlzdCA9IFtyZXF1ZXN0LnVybF1cbiAgICB9XG5cbiAgICAvLyAxNC4gSWYgaW5pdFtcInJlZmVycmVyXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVmZXJyZXIgYmUgaW5pdFtcInJlZmVycmVyXCJdLlxuICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyXG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwibm8tcmVmZXJyZXJcIi5cbiAgICAgIGlmIChyZWZlcnJlciA9PT0gJycpIHtcbiAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICduby1yZWZlcnJlcidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBwYXJzZWRSZWZlcnJlciBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgcmVmZXJyZXIgd2l0aFxuICAgICAgICAvLyBiYXNlVVJMLlxuICAgICAgICAvLyAyLiBJZiBwYXJzZWRSZWZlcnJlciBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBsZXQgcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIsIGJhc2VVcmwpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlZmVycmVyIFwiJHtyZWZlcnJlcn1cIiBpcyBub3QgYSB2YWxpZCBVUkwuYCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIHNjaGVtZSBpcyBcImFib3V0XCIgYW5kIHBhdGggaXMgdGhlIHN0cmluZyBcImNsaWVudFwiXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW5cbiAgICAgICAgLy8gdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJzZWRSZWZlcnJlci5wcm90b2NvbCA9PT0gJ2Fib3V0OicgJiYgcGFyc2VkUmVmZXJyZXIuaG9zdG5hbWUgPT09ICdjbGllbnQnKSB8fFxuICAgICAgICAgIChvcmlnaW4gJiYgIXNhbWVPcmlnaW4ocGFyc2VkUmVmZXJyZXIsIHRoaXNba1JlYWxtXS5zZXR0aW5nc09iamVjdC5iYXNlVXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICdjbGllbnQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gcGFyc2VkUmVmZXJyZXIuXG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IHBhcnNlZFJlZmVycmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNS4gSWYgaW5pdFtcInJlZmVycmVyUG9saWN5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5XG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQucmVmZXJyZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3lcbiAgICB9XG5cbiAgICAvLyAxNi4gTGV0IG1vZGUgYmUgaW5pdFtcIm1vZGVcIl0gaWYgaXQgZXhpc3RzLCBhbmQgZmFsbGJhY2tNb2RlIG90aGVyd2lzZS5cbiAgICBsZXQgbW9kZVxuICAgIGlmIChpbml0Lm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbW9kZSA9IGluaXQubW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gZmFsbGJhY2tNb2RlXG4gICAgfVxuXG4gICAgLy8gMTcuIElmIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChtb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0IG1vZGUgbmF2aWdhdGUuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgbW9kZSBpcyBub24tbnVsbCwgc2V0IHJlcXVlc3TigJlzIG1vZGUgdG8gbW9kZS5cbiAgICBpZiAobW9kZSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0Lm1vZGUgPSBtb2RlXG4gICAgfVxuXG4gICAgLy8gMTkuIElmIGluaXRbXCJjcmVkZW50aWFsc1wiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGVcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFsc1xuICAgIH1cblxuICAgIC8vIDE4LiBJZiBpbml0W1wiY2FjaGVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LmNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY2FjaGUgPSBpbml0LmNhY2hlXG4gICAgfVxuXG4gICAgLy8gMjEuIElmIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiIGFuZCByZXF1ZXN04oCZcyBtb2RlIGlzXG4gICAgLy8gbm90IFwic2FtZS1vcmlnaW5cIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAocmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ29ubHktaWYtY2FjaGVkJyBjYW4gYmUgc2V0IG9ubHkgd2l0aCAnc2FtZS1vcmlnaW4nIG1vZGVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDIyLiBJZiBpbml0W1wicmVkaXJlY3RcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0XG4gICAgfVxuXG4gICAgLy8gMjMuIElmIGluaXRbXCJpbnRlZ3JpdHlcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgdG8gaXQuXG4gICAgaWYgKGluaXQuaW50ZWdyaXR5ICE9PSB1bmRlZmluZWQgJiYgaW5pdC5pbnRlZ3JpdHkgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5pbnRlZ3JpdHkgPSBTdHJpbmcoaW5pdC5pbnRlZ3JpdHkpXG4gICAgfVxuXG4gICAgLy8gMjQuIElmIGluaXRbXCJrZWVwYWxpdmVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBrZWVwYWxpdmUgdG8gaXQuXG4gICAgaWYgKGluaXQua2VlcGFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3Qua2VlcGFsaXZlID0gQm9vbGVhbihpbml0LmtlZXBhbGl2ZSlcbiAgICB9XG5cbiAgICAvLyAyNS4gSWYgaW5pdFtcIm1ldGhvZFwiXSBleGlzdHMsIHRoZW46XG4gICAgaWYgKGluaXQubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCBtZXRob2QgYmUgaW5pdFtcIm1ldGhvZFwiXS5cbiAgICAgIGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZFxuXG4gICAgICAvLyAyLiBJZiBtZXRob2QgaXMgbm90IGEgbWV0aG9kIG9yIG1ldGhvZCBpcyBhIGZvcmJpZGRlbiBtZXRob2QsIHRoZW5cbiAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKGluaXQubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYCcke2luaXQubWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYClcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmJpZGRlbk1ldGhvZHMuaW5kZXhPZihtZXRob2QudG9VcHBlckNhc2UoKSkgIT09IC0xKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgJyR7aW5pdC5tZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBOb3JtYWxpemUgbWV0aG9kLlxuICAgICAgbWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKGluaXQubWV0aG9kKVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIG1ldGhvZC5cbiAgICAgIHJlcXVlc3QubWV0aG9kID0gbWV0aG9kXG4gICAgfVxuXG4gICAgLy8gMjYuIElmIGluaXRbXCJzaWduYWxcIl0gZXhpc3RzLCB0aGVuIHNldCBzaWduYWwgdG8gaXQuXG4gICAgaWYgKGluaXQuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNpZ25hbCA9IGluaXQuc2lnbmFsXG4gICAgfVxuXG4gICAgLy8gMjcuIFNldCB0aGlz4oCZcyByZXF1ZXN0IHRvIHJlcXVlc3QuXG4gICAgdGhpc1trU3RhdGVdID0gcmVxdWVzdFxuXG4gICAgLy8gMjguIFNldCB0aGlz4oCZcyBzaWduYWwgdG8gYSBuZXcgQWJvcnRTaWduYWwgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbS5cbiAgICAvLyBUT0RPOiBjb3VsZCB0aGlzIGJlIHNpbXBsaWZpZWQgd2l0aCBBYm9ydFNpZ25hbC5hbnlcbiAgICAvLyAoaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tYWJvcnRzaWduYWwtYW55KVxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgdGhpc1trU2lnbmFsXSA9IGFjLnNpZ25hbFxuICAgIHRoaXNba1NpZ25hbF1ba1JlYWxtXSA9IHRoaXNba1JlYWxtXVxuXG4gICAgLy8gMjkuIElmIHNpZ25hbCBpcyBub3QgbnVsbCwgdGhlbiBtYWtlIHRoaXPigJlzIHNpZ25hbCBmb2xsb3cgc2lnbmFsLlxuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKFxuICAgICAgICAhc2lnbmFsIHx8XG4gICAgICAgIHR5cGVvZiBzaWduYWwuYWJvcnRlZCAhPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogbWVtYmVyIHNpZ25hbCBpcyBub3Qgb2YgdHlwZSBBYm9ydFNpZ25hbC5cIlxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYy5hYm9ydChzaWduYWwucmVhc29uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCBhIHN0cm9uZyByZWYgdG8gYWMgd2hpbGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgLy8gaXMgYWxpdmUuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnQgQWJvcnRDb250cm9sbGVyXG4gICAgICAgIC8vIGZyb20gYmVpbmcgcHJlbWF0dXJlbHkgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE5MjYuXG4gICAgICAgIHRoaXNba0Fib3J0Q29udHJvbGxlcl0gPSBhY1xuXG4gICAgICAgIGNvbnN0IGFjUmVmID0gbmV3IFdlYWtSZWYoYWMpXG4gICAgICAgIGNvbnN0IGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IGFjID0gYWNSZWYuZGVyZWYoKVxuICAgICAgICAgIGlmIChhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYy5hYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlyZC1wYXJ0eSBBYm9ydENvbnRyb2xsZXJzIG1heSBub3Qgd29yayB3aXRoIHRoZXNlLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMTkxMCNpc3N1ZWNvbW1lbnQtMTQ2NDQ5NTYxOS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJZiB0aGUgbWF4IGFtb3VudCBvZiBsaXN0ZW5lcnMgaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQsIGluY3JlYXNlIGl0XG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBub2RlID49IHYxOS45LjBcbiAgICAgICAgICBpZiAodHlwZW9mIGdldE1heExpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRNYXhMaXN0ZW5lcnMoc2lnbmFsKSA9PT0gZGVmYXVsdE1heExpc3RlbmVycykge1xuICAgICAgICAgICAgc2V0TWF4TGlzdGVuZXJzKDEwMCwgc2lnbmFsKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0RXZlbnRMaXN0ZW5lcnMoc2lnbmFsLCAnYWJvcnQnKS5sZW5ndGggPj0gZGVmYXVsdE1heExpc3RlbmVycykge1xuICAgICAgICAgICAgc2V0TWF4TGlzdGVuZXJzKDEwMCwgc2lnbmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGFib3J0KVxuICAgICAgICByZXF1ZXN0RmluYWxpemVyLnJlZ2lzdGVyKGFjLCB7IHNpZ25hbCwgYWJvcnQgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMC4gU2V0IHRoaXPigJlzIGhlYWRlcnMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLCB3aG9zZSBoZWFkZXIgbGlzdCBpcyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBhbmQgZ3VhcmQgaXNcbiAgICAvLyBcInJlcXVlc3RcIi5cbiAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKClcbiAgICB0aGlzW2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVxdWVzdC5oZWFkZXJzTGlzdFxuICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSAncmVxdWVzdCdcbiAgICB0aGlzW2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG5cbiAgICAvLyAzMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIiwgdGhlbjpcbiAgICBpZiAobW9kZSA9PT0gJ25vLWNvcnMnKSB7XG4gICAgICAvLyAxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGEgQ09SUy1zYWZlbGlzdGVkIG1ldGhvZCxcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoIWNvcnNTYWZlTGlzdGVkTWV0aG9kcy5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgJyR7cmVxdWVzdC5tZXRob2R9IGlzIHVuc3VwcG9ydGVkIGluIG5vLWNvcnMgbW9kZS5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkIHRvIFwicmVxdWVzdC1uby1jb3JzXCIuXG4gICAgICB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdID0gJ3JlcXVlc3Qtbm8tY29ycydcbiAgICB9XG5cbiAgICAvLyAzMi4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgYSBjb3B5IG9mIHRoaXPigJlzIGhlYWRlcnMgYW5kIGl0cyBhc3NvY2lhdGVkIGhlYWRlclxuICAgICAgLy8gbGlzdC5cbiAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpc1trSGVhZGVyc10pXG5cbiAgICAgIC8vIDIuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBzZXQgaGVhZGVycyB0byBpbml0W1wiaGVhZGVyc1wiXS5cbiAgICAgIGlmIChpbml0LmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEVtcHR5IHRoaXPigJlzIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICAgICAgdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XS5jbGVhcigpXG5cbiAgICAgIC8vIDQuIElmIGhlYWRlcnMgaXMgYSBIZWFkZXJzIG9iamVjdCwgdGhlbiBmb3IgZWFjaCBoZWFkZXIgaW4gaXRzIGhlYWRlclxuICAgICAgLy8gbGlzdCwgYXBwZW5kIGhlYWRlcuKAmXMgbmFtZS9oZWFkZXLigJlzIHZhbHVlIHRvIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgICBpZiAoaGVhZGVycy5jb25zdHJ1Y3Rvci5uYW1lID09PSAnSGVhZGVycycpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICB0aGlzW2tIZWFkZXJzXS5hcHBlbmQoa2V5LCB2YWwpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDUuIE90aGVyd2lzZSwgZmlsbCB0aGlz4oCZcyBoZWFkZXJzIHdpdGggaGVhZGVycy5cbiAgICAgICAgZmlsbEhlYWRlcnModGhpc1trSGVhZGVyc10sIGhlYWRlcnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzMuIExldCBpbnB1dEJvZHkgYmUgaW5wdXTigJlzIHJlcXVlc3TigJlzIGJvZHkgaWYgaW5wdXQgaXMgYSBSZXF1ZXN0XG4gICAgLy8gb2JqZWN0OyBvdGhlcndpc2UgbnVsbC5cbiAgICBjb25zdCBpbnB1dEJvZHkgPSBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dFtrU3RhdGVdLmJvZHkgOiBudWxsXG5cbiAgICAvLyAzNC4gSWYgZWl0aGVyIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwgb3IgaW5wdXRCb2R5IGlzXG4gICAgLy8gbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYEdFVGAgb3IgYEhFQURgLCB0aGVuIHRocm93IGFcbiAgICAvLyBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgKGluaXQuYm9keSAhPSBudWxsIHx8IGlucHV0Qm9keSAhPSBudWxsKSAmJlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5LicpXG4gICAgfVxuXG4gICAgLy8gMzUuIExldCBpbml0Qm9keSBiZSBudWxsLlxuICAgIGxldCBpbml0Qm9keSA9IG51bGxcblxuICAgIC8vIDM2LiBJZiBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0LmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gTGV0IENvbnRlbnQtVHlwZSBiZSBudWxsLlxuICAgICAgLy8gMi4gU2V0IGluaXRCb2R5IGFuZCBDb250ZW50LVR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nXG4gICAgICAvLyBpbml0W1wiYm9keVwiXSwgd2l0aCBrZWVwYWxpdmUgc2V0IHRvIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShcbiAgICAgICAgaW5pdC5ib2R5LFxuICAgICAgICByZXF1ZXN0LmtlZXBhbGl2ZVxuICAgICAgKVxuICAgICAgaW5pdEJvZHkgPSBleHRyYWN0ZWRCb2R5XG5cbiAgICAgIC8vIDMsIElmIENvbnRlbnQtVHlwZSBpcyBub24tbnVsbCBhbmQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QgZG9lc1xuICAgICAgLy8gbm90IGNvbnRhaW4gYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIGBDb250ZW50LVR5cGVgL0NvbnRlbnQtVHlwZSB0b1xuICAgICAgLy8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XS5jb250YWlucygnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgdGhpc1trSGVhZGVyc10uYXBwZW5kKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzNy4gTGV0IGlucHV0T3JJbml0Qm9keSBiZSBpbml0Qm9keSBpZiBpdCBpcyBub24tbnVsbDsgb3RoZXJ3aXNlXG4gICAgLy8gaW5wdXRCb2R5LlxuICAgIGNvbnN0IGlucHV0T3JJbml0Qm9keSA9IGluaXRCb2R5ID8/IGlucHV0Qm9keVxuXG4gICAgLy8gMzguIElmIGlucHV0T3JJbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5wdXRPckluaXRCb2R54oCZcyBzb3VyY2UgaXNcbiAgICAvLyBudWxsLCB0aGVuOlxuICAgIGlmIChpbnB1dE9ySW5pdEJvZHkgIT0gbnVsbCAmJiBpbnB1dE9ySW5pdEJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbml0W1wiZHVwbGV4XCJdIGRvZXMgbm90IGV4aXN0LFxuICAgICAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpbml0Qm9keSAhPSBudWxsICYmIGluaXQuZHVwbGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdEluaXQ6IGR1cGxleCBvcHRpb24gaXMgcmVxdWlyZWQgd2hlbiBzZW5kaW5nIGEgYm9keS4nKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5laXRoZXIgXCJzYW1lLW9yaWdpblwiIG5vciBcImNvcnNcIixcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nICYmIHJlcXVlc3QubW9kZSAhPT0gJ2NvcnMnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0lmIHJlcXVlc3QgaXMgbWFkZSBmcm9tIFJlYWRhYmxlU3RyZWFtLCBtb2RlIHNob3VsZCBiZSBcInNhbWUtb3JpZ2luXCIgb3IgXCJjb3JzXCInXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMy4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnLlxuICAgICAgcmVxdWVzdC51c2VDT1JTUHJlZmxpZ2h0RmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyAzOS4gTGV0IGZpbmFsQm9keSBiZSBpbnB1dE9ySW5pdEJvZHkuXG4gICAgbGV0IGZpbmFsQm9keSA9IGlucHV0T3JJbml0Qm9keVxuXG4gICAgLy8gNDAuIElmIGluaXRCb2R5IGlzIG51bGwgYW5kIGlucHV0Qm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdEJvZHkgPT0gbnVsbCAmJiBpbnB1dEJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5wdXQgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChpbnB1dEJvZHkuc3RyZWFtKSB8fCBpbnB1dEJvZHkuc3RyZWFtLmxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29uc3RydWN0IGEgUmVxdWVzdCB3aXRoIGEgUmVxdWVzdCBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCBmaW5hbEJvZHkgdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIHByb3h5IGZvciBpbnB1dEJvZHkuXG4gICAgICBpZiAoIVRyYW5zZm9ybVN0cmVhbSkge1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0vd2ViJykuVHJhbnNmb3JtU3RyZWFtXG4gICAgICB9XG5cbiAgICAgIC8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWNyZWF0ZS1hLXByb3h5XG4gICAgICBjb25zdCBpZGVudGl0eVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKVxuICAgICAgaW5wdXRCb2R5LnN0cmVhbS5waXBlVGhyb3VnaChpZGVudGl0eVRyYW5zZm9ybSlcbiAgICAgIGZpbmFsQm9keSA9IHtcbiAgICAgICAgc291cmNlOiBpbnB1dEJvZHkuc291cmNlLFxuICAgICAgICBsZW5ndGg6IGlucHV0Qm9keS5sZW5ndGgsXG4gICAgICAgIHN0cmVhbTogaWRlbnRpdHlUcmFuc2Zvcm0ucmVhZGFibGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0MS4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIGJvZHkgdG8gZmluYWxCb2R5LlxuICAgIHRoaXNba1N0YXRlXS5ib2R5ID0gZmluYWxCb2R5XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlcXVlc3TigJlzIEhUVFAgbWV0aG9kLCB3aGljaCBpcyBcIkdFVFwiIGJ5IGRlZmF1bHQuXG4gIGdldCBtZXRob2QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbWV0aG9kIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm1ldGhvZFxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgVVJMIG9mIHJlcXVlc3QgYXMgYSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIFVSTCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzW2tTdGF0ZV0udXJsKVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIEhlYWRlcnMgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgdGhlIGhlYWRlcnMgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIE5vdGUgdGhhdCBoZWFkZXJzIGFkZGVkIGluIHRoZSBuZXR3b3JrIGxheWVyIGJ5IHRoZSB1c2VyIGFnZW50IHdpbGwgbm90XG4gIC8vIGJlIGFjY291bnRlZCBmb3IgaW4gdGhpcyBvYmplY3QsIGUuZy4sIHRoZSBcIkhvc3RcIiBoZWFkZXIuXG4gIGdldCBoZWFkZXJzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGhlYWRlcnMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgaGVhZGVycy5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc11cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGtpbmQgb2YgcmVzb3VyY2UgcmVxdWVzdGVkIGJ5IHJlcXVlc3QsIGUuZy4sIFwiZG9jdW1lbnRcIlxuICAvLyBvciBcInNjcmlwdFwiLlxuICBnZXQgZGVzdGluYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgZGVzdGluYXRpb24gZ2V0dGVyIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24uXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5kZXN0aW5hdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgb2YgcmVxdWVzdC4gSXRzIHZhbHVlIGNhbiBiZSBhIHNhbWUtb3JpZ2luIFVSTCBpZlxuICAvLyBleHBsaWNpdGx5IHNldCBpbiBpbml0LCB0aGUgZW1wdHkgc3RyaW5nIHRvIGluZGljYXRlIG5vIHJlZmVycmVyLCBhbmRcbiAgLy8gXCJhYm91dDpjbGllbnRcIiB3aGVuIGRlZmF1bHRpbmcgdG8gdGhlIGdsb2JhbOKAmXMgZGVmYXVsdC4gVGhpcyBpcyB1c2VkXG4gIC8vIGR1cmluZyBmZXRjaGluZyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBgUmVmZXJlcmAgaGVhZGVyIG9mIHRoZVxuICAvLyByZXF1ZXN0IGJlaW5nIG1hZGUuXG4gIGdldCByZWZlcnJlciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgdGhlbiByZXR1cm4gdGhlXG4gICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICduby1yZWZlcnJlcicpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwiY2xpZW50XCIsIHRoZW4gcmV0dXJuXG4gICAgLy8gXCJhYm91dDpjbGllbnRcIi5cbiAgICBpZiAodGhpc1trU3RhdGVdLnJlZmVycmVyID09PSAnY2xpZW50Jykge1xuICAgICAgcmV0dXJuICdhYm91dDpjbGllbnQnXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXIudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgcG9saWN5IGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHVzZWQgZHVyaW5nIGZldGNoaW5nIHRvIGNvbXB1dGUgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlci5cbiAgZ2V0IHJlZmVycmVyUG9saWN5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZmVycmVyUG9saWN5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LCB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nXG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2lsbCB1c2UgQ09SUywgb3Igd2lsbCBiZSByZXN0cmljdGVkIHRvIHNhbWUtb3JpZ2luXG4gIC8vIFVSTHMuXG4gIGdldCBtb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1vZGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm1vZGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNyZWRlbnRpYWxzIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgd2hldGhlciBjcmVkZW50aWFscyB3aWxsIGJlIHNlbnQgd2l0aCB0aGVcbiAgLy8gcmVxdWVzdCBhbHdheXMsIG5ldmVyLCBvciBvbmx5IHdoZW4gc2VudCB0byBhIHNhbWUtb3JpZ2luIFVSTC5cbiAgZ2V0IGNyZWRlbnRpYWxzICgpIHtcbiAgICAvLyBUaGUgY3JlZGVudGlhbHMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjYWNoZSBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIGhvdyB0aGUgcmVxdWVzdCB3aWxsXG4gIC8vIGludGVyYWN0IHdpdGggdGhlIGJyb3dzZXLigJlzIGNhY2hlIHdoZW4gZmV0Y2hpbmcuXG4gIGdldCBjYWNoZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBjYWNoZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjYWNoZSBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY2FjaGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZGlyZWN0IG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHJlZGlyZWN0cyBmb3IgdGhlXG4gIC8vIHJlcXVlc3Qgd2lsbCBiZSBoYW5kbGVkIGR1cmluZyBmZXRjaGluZy4gQSByZXF1ZXN0XG4gIC8vIHdpbGwgZm9sbG93IHJlZGlyZWN0cyBieSBkZWZhdWx0LlxuICBnZXQgcmVkaXJlY3QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZGlyZWN0XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlcXVlc3TigJlzIHN1YnJlc291cmNlIGludGVncml0eSBtZXRhZGF0YSwgd2hpY2ggaXMgYVxuICAvLyBjcnlwdG9ncmFwaGljIGhhc2ggb2YgdGhlIHJlc291cmNlIGJlaW5nIGZldGNoZWQuIEl0cyB2YWx1ZVxuICAvLyBjb25zaXN0cyBvZiBtdWx0aXBsZSBoYXNoZXMgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2UuIFtTUkldXG4gIGdldCBpbnRlZ3JpdHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaW50ZWdyaXR5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGludGVncml0eVxuICAgIC8vIG1ldGFkYXRhLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaW50ZWdyaXR5XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgY2FuIG91dGxpdmUgdGhlXG4gIC8vIGdsb2JhbCBpbiB3aGljaCBpdCB3YXMgY3JlYXRlZC5cbiAgZ2V0IGtlZXBhbGl2ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBrZWVwYWxpdmUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ua2VlcGFsaXZlXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgcmVsb2FkXG4gIC8vIG5hdmlnYXRpb24uXG4gIGdldCBpc1JlbG9hZE5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNSZWxvYWROYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXNcbiAgICAvLyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVsb2FkTmF2aWdhdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGlzIGZvciBhIGhpc3RvcnlcbiAgLy8gbmF2aWdhdGlvbiAoYS5rLmEuIGJhY2stZm93YXJkIG5hdmlnYXRpb24pLlxuICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc0hpc3RvcnlOYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVxdWVzdOKAmXNcbiAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmhpc3RvcnlOYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBzaWduYWwgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGFuIEFib3J0U2lnbmFsXG4gIC8vIG9iamVjdCBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgYW5kIGl0c1xuICAvLyBhYm9ydCBldmVudCBoYW5kbGVyLlxuICBnZXQgc2lnbmFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHNpZ25hbCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBzaWduYWwuXG4gICAgcmV0dXJuIHRoaXNba1NpZ25hbF1cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICBnZXQgZHVwbGV4ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICdoYWxmJ1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlcXVlc3QuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCB0aGlzLmJvZHk/LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gTGV0IGNsb25lZFJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlcXVlc3Qgb2JqZWN0LFxuICAgIC8vIGdpdmVuIGNsb25lZFJlcXVlc3QsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgY2xvbmVkUmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGtJbml0KVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba1N0YXRlXSA9IGNsb25lZFJlcXVlc3RcbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKClcbiAgICBjbG9uZWRSZXF1ZXN0T2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gY2xvbmVkUmVxdWVzdC5oZWFkZXJzTGlzdFxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba0hlYWRlcnNdW2tHdWFyZF0gPSB0aGlzW2tIZWFkZXJzXVtrR3VhcmRdXG4gICAgY2xvbmVkUmVxdWVzdE9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHRoaXNba0hlYWRlcnNdW2tSZWFsbV1cblxuICAgIC8vIDQuIE1ha2UgY2xvbmVkUmVxdWVzdE9iamVjdOKAmXMgc2lnbmFsIGZvbGxvdyB0aGlz4oCZcyBzaWduYWwuXG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgYWMuYWJvcnQodGhpcy5zaWduYWwucmVhc29uKVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoXG4gICAgICAgIHRoaXMuc2lnbmFsLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgYWMuYWJvcnQodGhpcy5zaWduYWwucmVhc29uKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICAgIGNsb25lZFJlcXVlc3RPYmplY3Rba1NpZ25hbF0gPSBhYy5zaWduYWxcblxuICAgIC8vIDQuIFJldHVybiBjbG9uZWRSZXF1ZXN0T2JqZWN0LlxuICAgIHJldHVybiBjbG9uZWRSZXF1ZXN0T2JqZWN0XG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlcXVlc3QpXG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0IChpbml0KSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0c1xuICBjb25zdCByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbG9jYWxVUkxzT25seTogZmFsc2UsXG4gICAgdW5zYWZlUmVxdWVzdDogZmFsc2UsXG4gICAgYm9keTogbnVsbCxcbiAgICBjbGllbnQ6IG51bGwsXG4gICAgcmVzZXJ2ZWRDbGllbnQ6IG51bGwsXG4gICAgcmVwbGFjZXNDbGllbnRJZDogJycsXG4gICAgd2luZG93OiAnY2xpZW50JyxcbiAgICBrZWVwYWxpdmU6IGZhbHNlLFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnYWxsJyxcbiAgICBpbml0aWF0b3I6ICcnLFxuICAgIGRlc3RpbmF0aW9uOiAnJyxcbiAgICBwcmlvcml0eTogbnVsbCxcbiAgICBvcmlnaW46ICdjbGllbnQnLFxuICAgIHBvbGljeUNvbnRhaW5lcjogJ2NsaWVudCcsXG4gICAgcmVmZXJyZXI6ICdjbGllbnQnLFxuICAgIHJlZmVycmVyUG9saWN5OiAnJyxcbiAgICBtb2RlOiAnbm8tY29ycycsXG4gICAgdXNlQ09SU1ByZWZsaWdodEZsYWc6IGZhbHNlLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIHVzZUNyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICBjYWNoZTogJ2RlZmF1bHQnLFxuICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICBpbnRlZ3JpdHk6ICcnLFxuICAgIGNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YTogJycsXG4gICAgcGFyc2VyTWV0YWRhdGE6ICcnLFxuICAgIHJlbG9hZE5hdmlnYXRpb246IGZhbHNlLFxuICAgIGhpc3RvcnlOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICB1c2VyQWN0aXZhdGlvbjogZmFsc2UsXG4gICAgdGFpbnRlZE9yaWdpbjogZmFsc2UsXG4gICAgcmVkaXJlY3RDb3VudDogMCxcbiAgICByZXNwb25zZVRhaW50aW5nOiAnYmFzaWMnLFxuICAgIHByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uOiBmYWxzZSxcbiAgICBkb25lOiBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd0ZhaWxlZDogZmFsc2UsXG4gICAgLi4uaW5pdCxcbiAgICBoZWFkZXJzTGlzdDogaW5pdC5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdC5oZWFkZXJzTGlzdClcbiAgICAgIDogbmV3IEhlYWRlcnNMaXN0KClcbiAgfVxuICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFswXVxuICByZXR1cm4gcmVxdWVzdFxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlcXVlc3QgKHJlcXVlc3QpIHtcbiAgLy8gVG8gY2xvbmUgYSByZXF1ZXN0IHJlcXVlc3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBMZXQgbmV3UmVxdWVzdCBiZSBhIGNvcHkgb2YgcmVxdWVzdCwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgLi4ucmVxdWVzdCwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHNldCBuZXdSZXF1ZXN04oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXF1ZXN04oCZcyBib2R5LlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXF1ZXN0LmJvZHkgPSBjbG9uZUJvZHkocmVxdWVzdC5ib2R5KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG5ld1JlcXVlc3QuXG4gIHJldHVybiBuZXdSZXF1ZXN0XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZHVwbGV4OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZXN0aW5hdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzSGlzdG9yeU5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzUmVsb2FkTmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2VlcGFsaXZlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbnRlZ3JpdHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNhY2hlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYXR0cmlidXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlclBvbGljeToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1vZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFJlcXVlc3RcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RpbmZvXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdChWKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxufVxuXG53ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEFib3J0U2lnbmFsXG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgeyBzdHJpY3Q6IGZhbHNlIH1cbiAgICAgIClcbiAgICApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd3aW5kb3cnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkdXBsZXgnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3REdXBsZXhcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IFJlcXVlc3QsIG1ha2VSZXF1ZXN0IH1cbiJdLCJuYW1lcyI6WyJleHRyYWN0Qm9keSIsIm1peGluQm9keSIsImNsb25lQm9keSIsInJlcXVpcmUiLCJIZWFkZXJzIiwiZmlsbCIsImZpbGxIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsInV0aWwiLCJpc1ZhbGlkSFRUUFRva2VuIiwic2FtZU9yaWdpbiIsIm5vcm1hbGl6ZU1ldGhvZCIsIm1ha2VQb2xpY3lDb250YWluZXIiLCJmb3JiaWRkZW5NZXRob2RzIiwiY29yc1NhZmVMaXN0ZWRNZXRob2RzIiwicmVmZXJyZXJQb2xpY3kiLCJyZXF1ZXN0UmVkaXJlY3QiLCJyZXF1ZXN0TW9kZSIsInJlcXVlc3RDcmVkZW50aWFscyIsInJlcXVlc3RDYWNoZSIsInJlcXVlc3REdXBsZXgiLCJrRW51bWVyYWJsZVByb3BlcnR5Iiwia0hlYWRlcnMiLCJrU2lnbmFsIiwia1N0YXRlIiwia0d1YXJkIiwia1JlYWxtIiwid2ViaWRsIiwiZ2V0R2xvYmFsT3JpZ2luIiwiVVJMU2VyaWFsaXplciIsImtIZWFkZXJzTGlzdCIsImFzc2VydCIsImdldE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsImdldEV2ZW50TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsIlRyYW5zZm9ybVN0cmVhbSIsImdsb2JhbFRoaXMiLCJrSW5pdCIsIlN5bWJvbCIsImtBYm9ydENvbnRyb2xsZXIiLCJyZXF1ZXN0RmluYWxpemVyIiwic2lnbmFsIiwiYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVxdWVzdCIsImNvbnN0cnVjdG9yIiwiaW5wdXQiLCJpbml0IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIlJlcXVlc3RJbml0Iiwic2V0dGluZ3NPYmplY3QiLCJiYXNlVXJsIiwib3JpZ2luIiwicG9saWN5Q29udGFpbmVyIiwicmVxdWVzdCIsImZhbGxiYWNrTW9kZSIsInBhcnNlZFVSTCIsIlVSTCIsImVyciIsIlR5cGVFcnJvciIsImNhdXNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm1ha2VSZXF1ZXN0IiwidXJsTGlzdCIsIndpbmRvdyIsIm5hbWUiLCJtZXRob2QiLCJoZWFkZXJzTGlzdCIsInVuc2FmZVJlcXVlc3QiLCJjbGllbnQiLCJwcmlvcml0eSIsInJlZmVycmVyIiwibW9kZSIsImNyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWRpcmVjdCIsImludGVncml0eSIsImtlZXBhbGl2ZSIsInJlbG9hZE5hdmlnYXRpb24iLCJoaXN0b3J5TmF2aWdhdGlvbiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ1cmwiLCJ1bmRlZmluZWQiLCJwYXJzZWRSZWZlcnJlciIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJtZXNzYWdlIiwiU3RyaW5nIiwiQm9vbGVhbiIsImluZGV4T2YiLCJ0b1VwcGVyQ2FzZSIsImFjIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWFzb24iLCJhY1JlZiIsIldlYWtSZWYiLCJkZXJlZiIsImFkZEFib3J0TGlzdGVuZXIiLCJyZWdpc3RlciIsImluY2x1ZGVzIiwiaGVhZGVycyIsImNsZWFyIiwia2V5IiwidmFsIiwiYXBwZW5kIiwiaW5wdXRCb2R5IiwiYm9keSIsImluaXRCb2R5IiwiZXh0cmFjdGVkQm9keSIsImNvbnRlbnRUeXBlIiwiY29udGFpbnMiLCJpbnB1dE9ySW5pdEJvZHkiLCJzb3VyY2UiLCJkdXBsZXgiLCJ1c2VDT1JTUHJlZmxpZ2h0RmxhZyIsImZpbmFsQm9keSIsImlzRGlzdHVyYmVkIiwic3RyZWFtIiwibG9ja2VkIiwiaWRlbnRpdHlUcmFuc2Zvcm0iLCJwaXBlVGhyb3VnaCIsInJlYWRhYmxlIiwiYnJhbmRDaGVjayIsImRlc3RpbmF0aW9uIiwidG9TdHJpbmciLCJpc1JlbG9hZE5hdmlnYXRpb24iLCJpc0hpc3RvcnlOYXZpZ2F0aW9uIiwiYm9keVVzZWQiLCJjbG9uZSIsImNsb25lZFJlcXVlc3QiLCJjbG9uZVJlcXVlc3QiLCJjbG9uZWRSZXF1ZXN0T2JqZWN0IiwibG9jYWxVUkxzT25seSIsInJlc2VydmVkQ2xpZW50IiwicmVwbGFjZXNDbGllbnRJZCIsInNlcnZpY2VXb3JrZXJzIiwiaW5pdGlhdG9yIiwidXNlQ3JlZGVudGlhbHMiLCJjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGEiLCJwYXJzZXJNZXRhZGF0YSIsInVzZXJBY3RpdmF0aW9uIiwidGFpbnRlZE9yaWdpbiIsInJlZGlyZWN0Q291bnQiLCJyZXNwb25zZVRhaW50aW5nIiwicHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24iLCJkb25lIiwidGltaW5nQWxsb3dGYWlsZWQiLCJuZXdSZXF1ZXN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsImF0dHJpYnV0ZSIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJWIiwiVVNWU3RyaW5nIiwiQWJvcnRTaWduYWwiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiY29udmVydGVyIiwiQnl0ZVN0cmluZyIsIkhlYWRlcnNJbml0IiwibnVsbGFibGVDb252ZXJ0ZXIiLCJCb2R5SW5pdCIsIkRPTVN0cmluZyIsImFsbG93ZWRWYWx1ZXMiLCJib29sZWFuIiwic3RyaWN0IiwiYW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/response.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/fetch/response.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\");\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/fetch/body.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { kEnumerableProperty } = util;\nconst { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\nconst { redirectStatus, nullBodyStatus, DOMException } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/fetch/formdata.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/fetch/global.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n    // Creates network error Response.\n    static error() {\n        // TODO\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        // The static error() method steps are to return the result of creating a\n        // Response object, given a new network error, \"immutable\", and this’s\n        // relevant Realm.\n        const responseObject = new Response();\n        responseObject[kState] = makeNetworkError();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response-json\n    static json(data, init = {}) {\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.json\"\n        });\n        if (init !== null) {\n            init = webidl.converters.ResponseInit(init);\n        }\n        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n        const bytes = new TextEncoder(\"utf-8\").encode(serializeJavascriptValueToJSONString(data));\n        // 2. Let body be the result of extracting bytes.\n        const body = extractBody(bytes);\n        // 3. Let responseObject be the result of creating a Response object, given a new response,\n        //    \"response\", and this’s relevant Realm.\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"response\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n        initializeResponse(responseObject, init, {\n            body: body[0],\n            type: \"application/json\"\n        });\n        // 5. Return responseObject.\n        return responseObject;\n    }\n    // Creates a redirect Response that redirects to url with status status.\n    static redirect(url, status = 302) {\n        const relevantRealm = {\n            settingsObject: {}\n        };\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"Response.redirect\"\n        });\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        // 1. Let parsedURL be the result of parsing url with current settings\n        // object’s API base URL.\n        // 2. If parsedURL is failure, then throw a TypeError.\n        // TODO: base-URL?\n        let parsedURL;\n        try {\n            parsedURL = new URL(url, getGlobalOrigin());\n        } catch (err) {\n            throw Object.assign(new TypeError(\"Failed to parse URL from \" + url), {\n                cause: err\n            });\n        }\n        // 3. If status is not a redirect status, then throw a RangeError.\n        if (!redirectStatus.includes(status)) {\n            throw new RangeError(\"Invalid status code \" + status);\n        }\n        // 4. Let responseObject be the result of creating a Response object,\n        // given a new response, \"immutable\", and this’s relevant Realm.\n        const responseObject = new Response();\n        responseObject[kRealm] = relevantRealm;\n        responseObject[kHeaders][kGuard] = \"immutable\";\n        responseObject[kHeaders][kRealm] = relevantRealm;\n        // 5. Set responseObject’s response’s status to status.\n        responseObject[kState].status = status;\n        // 6. Let value be parsedURL, serialized and isomorphic encoded.\n        const value = isomorphicEncode(URLSerializer(parsedURL));\n        // 7. Append `Location`/value to responseObject’s response’s header list.\n        responseObject[kState].headersList.append(\"location\", value);\n        // 8. Return responseObject.\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response\n    constructor(body = null, init = {}){\n        if (body !== null) {\n            body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        // TODO\n        this[kRealm] = {\n            settingsObject: {}\n        };\n        // 1. Set this’s response to a new response.\n        this[kState] = makeResponse({});\n        // 2. Set this’s headers to a new Headers object with this’s relevant\n        // Realm, whose header list is this’s response’s header list and guard\n        // is \"response\".\n        this[kHeaders] = new Headers();\n        this[kHeaders][kGuard] = \"response\";\n        this[kHeaders][kHeadersList] = this[kState].headersList;\n        this[kHeaders][kRealm] = this[kRealm];\n        // 3. Let bodyWithType be null.\n        let bodyWithType = null;\n        // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n        if (body != null) {\n            const [extractedBody, type] = extractBody(body);\n            bodyWithType = {\n                body: extractedBody,\n                type\n            };\n        }\n        // 5. Perform initialize a response given this, init, and bodyWithType.\n        initializeResponse(this, init, bodyWithType);\n    }\n    // Returns response’s type, e.g., \"cors\".\n    get type() {\n        webidl.brandCheck(this, Response);\n        // The type getter steps are to return this’s response’s type.\n        return this[kState].type;\n    }\n    // Returns response’s URL, if it has one; otherwise the empty string.\n    get url() {\n        webidl.brandCheck(this, Response);\n        const urlList = this[kState].urlList;\n        // The url getter steps are to return the empty string if this’s\n        // response’s URL is null; otherwise this’s response’s URL,\n        // serialized with exclude fragment set to true.\n        const url = urlList[urlList.length - 1] ?? null;\n        if (url === null) {\n            return \"\";\n        }\n        return URLSerializer(url, true);\n    }\n    // Returns whether response was obtained through a redirect.\n    get redirected() {\n        webidl.brandCheck(this, Response);\n        // The redirected getter steps are to return true if this’s response’s URL\n        // list has more than one item; otherwise false.\n        return this[kState].urlList.length > 1;\n    }\n    // Returns response’s status.\n    get status() {\n        webidl.brandCheck(this, Response);\n        // The status getter steps are to return this’s response’s status.\n        return this[kState].status;\n    }\n    // Returns whether response’s status is an ok status.\n    get ok() {\n        webidl.brandCheck(this, Response);\n        // The ok getter steps are to return true if this’s response’s status is an\n        // ok status; otherwise false.\n        return this[kState].status >= 200 && this[kState].status <= 299;\n    }\n    // Returns response’s status message.\n    get statusText() {\n        webidl.brandCheck(this, Response);\n        // The statusText getter steps are to return this’s response’s status\n        // message.\n        return this[kState].statusText;\n    }\n    // Returns response’s headers as Headers.\n    get headers() {\n        webidl.brandCheck(this, Response);\n        // The headers getter steps are to return this’s headers.\n        return this[kHeaders];\n    }\n    get body() {\n        webidl.brandCheck(this, Response);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Response);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    // Returns a clone of response.\n    clone() {\n        webidl.brandCheck(this, Response);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body && this.body.locked) {\n            throw webidl.errors.exception({\n                header: \"Response.clone\",\n                message: \"Body has already been consumed.\"\n            });\n        }\n        // 2. Let clonedResponse be the result of cloning this’s response.\n        const clonedResponse = cloneResponse(this[kState]);\n        // 3. Return the result of creating a Response object, given\n        // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n        const clonedResponseObject = new Response();\n        clonedResponseObject[kState] = clonedResponse;\n        clonedResponseObject[kRealm] = this[kRealm];\n        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n        return clonedResponseObject;\n    }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n    type: kEnumerableProperty,\n    url: kEnumerableProperty,\n    status: kEnumerableProperty,\n    ok: kEnumerableProperty,\n    redirected: kEnumerableProperty,\n    statusText: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Response\",\n        configurable: true\n    }\n});\nObject.defineProperties(Response, {\n    json: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    error: kEnumerableProperty\n});\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n    // To clone a response response, run these steps:\n    // 1. If response is a filtered response, then return a new identical\n    // filtered response whose internal response is a clone of response’s\n    // internal response.\n    if (response.internalResponse) {\n        return filterResponse(cloneResponse(response.internalResponse), response.type);\n    }\n    // 2. Let newResponse be a copy of response, except for its body.\n    const newResponse = makeResponse({\n        ...response,\n        body: null\n    });\n    // 3. If response’s body is non-null, then set newResponse’s body to the\n    // result of cloning response’s body.\n    if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n    }\n    // 4. Return newResponse.\n    return newResponse;\n}\nfunction makeResponse(init) {\n    return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n        urlList: init.urlList ? [\n            ...init.urlList\n        ] : []\n    };\n}\nfunction makeNetworkError(reason) {\n    const isError = isErrorLike(reason);\n    return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError ? reason : new Error(reason ? String(reason) : reason),\n        aborted: reason && reason.name === \"AbortError\"\n    });\n}\nfunction makeFilteredResponse(response, state) {\n    state = {\n        internalResponse: response,\n        ...state\n    };\n    return new Proxy(response, {\n        get (target, p) {\n            return p in state ? state[p] : target[p];\n        },\n        set (target, p, value) {\n            assert(!(p in state));\n            target[p] = value;\n            return true;\n        }\n    });\n}\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (type === \"basic\") {\n        // A basic filtered response is a filtered response whose type is \"basic\"\n        // and header list excludes any headers in internal response’s header list\n        // whose name is a forbidden response-header name.\n        // Note: undici does not implement forbidden response-header names\n        return makeFilteredResponse(response, {\n            type: \"basic\",\n            headersList: response.headersList\n        });\n    } else if (type === \"cors\") {\n        // A CORS filtered response is a filtered response whose type is \"cors\"\n        // and header list excludes any headers in internal response’s header\n        // list whose name is not a CORS-safelisted response-header name, given\n        // internal response’s CORS-exposed header-name list.\n        // Note: undici does not implement CORS-safelisted response-header names\n        return makeFilteredResponse(response, {\n            type: \"cors\",\n            headersList: response.headersList\n        });\n    } else if (type === \"opaque\") {\n        // An opaque filtered response is a filtered response whose type is\n        // \"opaque\", URL list is the empty list, status is 0, status message\n        // is the empty byte sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaque\",\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: \"\",\n            body: null\n        });\n    } else if (type === \"opaqueredirect\") {\n        // An opaque-redirect filtered response is a filtered response whose type\n        // is \"opaqueredirect\", status is 0, status message is the empty byte\n        // sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaqueredirect\",\n            status: 0,\n            statusText: \"\",\n            headersList: [],\n            body: null\n        });\n    } else {\n        assert(false);\n    }\n}\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n    // 1. Assert: fetchParams is canceled.\n    assert(isCancelled(fetchParams));\n    // 2. Return an aborted network error if fetchParams is aborted;\n    // otherwise return a network error.\n    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException(\"The operation was aborted.\", \"AbortError\"), {\n        cause: err\n    })) : makeNetworkError(Object.assign(new DOMException(\"Request was cancelled.\"), {\n        cause: err\n    }));\n}\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    //    throw a RangeError.\n    if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n    }\n    // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n    //    then throw a TypeError.\n    if (\"statusText\" in init && init.statusText != null) {\n        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n        if (!isValidReasonPhrase(String(init.statusText))) {\n            throw new TypeError(\"Invalid statusText\");\n        }\n    }\n    // 3. Set response’s response’s status to init[\"status\"].\n    if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n    }\n    // 4. Set response’s response’s status message to init[\"statusText\"].\n    if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n    }\n    // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n    if (\"headers\" in init && init.headers != null) {\n        fill(response[kHeaders], init.headers);\n    }\n    // 6. If body was given, then:\n    if (body) {\n        // 1. If response's status is a null body status, then throw a TypeError.\n        if (nullBodyStatus.includes(response.status)) {\n            throw webidl.errors.exception({\n                header: \"Response constructor\",\n                message: \"Invalid response status code \" + response.status\n            });\n        }\n        // 2. Set response's body to body's body.\n        response[kState].body = body.body;\n        // 3. If body's type is non-null and response's header list does not contain\n        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n        if (body.type != null && !response[kState].headersList.contains(\"Content-Type\")) {\n            response[kState].headersList.append(\"content-type\", body.type);\n        }\n    }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function(V) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V);\n    }\n    if (isBlobLike(V)) {\n        return webidl.converters.Blob(V, {\n            strict: false\n        });\n    }\n    if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n        return webidl.converters.BufferSource(V);\n    }\n    if (util.isFormDataLike(V)) {\n        return webidl.converters.FormData(V, {\n            strict: false\n        });\n    }\n    if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function(V) {\n    if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V);\n    }\n    // Note: the spec doesn't include async iterables,\n    // this is an undici extension.\n    if (V?.[Symbol.asyncIterator]) {\n        return V;\n    }\n    return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n    {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 200\n    },\n    {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    }\n]);\nmodule.exports = {\n    makeNetworkError,\n    makeResponse,\n    makeAppropriateNetworkError,\n    filterResponse,\n    Response,\n    cloneResponse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLElBQUksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMvQyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDdEQsTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSyxtQkFBbUIsRUFBRSxHQUFHRDtBQUNoQyxNQUFNLEVBQ0pFLG1CQUFtQixFQUNuQkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsb0NBQW9DLEVBQ3BDQyxXQUFXLEVBQ1hDLGdCQUFnQixFQUNqQixHQUFHWixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSmEsY0FBYyxFQUNkQyxjQUFjLEVBQ2RDLFlBQVksRUFDYixHQUFHZixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRWdCLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHbkIsbUJBQU9BLENBQUM7QUFDckQsTUFBTSxFQUFFb0IsTUFBTSxFQUFFLEdBQUdwQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVxQixRQUFRLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRXNCLGVBQWUsRUFBRSxHQUFHdEIsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFFdUIsYUFBYSxFQUFFLEdBQUd2QixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUV3QixZQUFZLEVBQUUsR0FBR3hCLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU15QixTQUFTekIsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFMEIsS0FBSyxFQUFFLEdBQUcxQixtQkFBT0EsQ0FBQztBQUUxQixNQUFNMkIsaUJBQWlCQyxXQUFXRCxjQUFjLElBQUkzQixvRUFBb0M7QUFFeEYsZ0RBQWdEO0FBQ2hELE1BQU02QjtJQUNKLGtDQUFrQztJQUNsQyxPQUFPQyxRQUFTO1FBQ2QsT0FBTztRQUNQLE1BQU1DLGdCQUFnQjtZQUFFQyxnQkFBZ0IsQ0FBQztRQUFFO1FBRTNDLHlFQUF5RTtRQUN6RSxzRUFBc0U7UUFDdEUsa0JBQWtCO1FBQ2xCLE1BQU1DLGlCQUFpQixJQUFJSjtRQUMzQkksY0FBYyxDQUFDakIsT0FBTyxHQUFHa0I7UUFDekJELGNBQWMsQ0FBQ2QsT0FBTyxHQUFHWTtRQUN6QkUsY0FBYyxDQUFDaEIsU0FBUyxDQUFDTyxhQUFhLEdBQUdTLGNBQWMsQ0FBQ2pCLE9BQU8sQ0FBQ21CLFdBQVc7UUFDM0VGLGNBQWMsQ0FBQ2hCLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHO1FBQ25DZSxjQUFjLENBQUNoQixTQUFTLENBQUNFLE9BQU8sR0FBR1k7UUFDbkMsT0FBT0U7SUFDVDtJQUVBLG1EQUFtRDtJQUNuRCxPQUFPRyxLQUFNQyxJQUFJLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDNUJsQixPQUFPbUIsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQWdCO1FBRW5FLElBQUlILFNBQVMsTUFBTTtZQUNqQkEsT0FBT2xCLE9BQU9zQixVQUFVLENBQUNDLFlBQVksQ0FBQ0w7UUFDeEM7UUFFQSx5RkFBeUY7UUFDekYsTUFBTU0sUUFBUSxJQUFJQyxZQUFZLFNBQVNDLE1BQU0sQ0FDM0NwQyxxQ0FBcUMyQjtRQUd2QyxpREFBaUQ7UUFDakQsTUFBTVUsT0FBTzlDLFlBQVkyQztRQUV6QiwyRkFBMkY7UUFDM0YsNENBQTRDO1FBQzVDLE1BQU1iLGdCQUFnQjtZQUFFQyxnQkFBZ0IsQ0FBQztRQUFFO1FBQzNDLE1BQU1DLGlCQUFpQixJQUFJSjtRQUMzQkksY0FBYyxDQUFDZCxPQUFPLEdBQUdZO1FBQ3pCRSxjQUFjLENBQUNoQixTQUFTLENBQUNDLE9BQU8sR0FBRztRQUNuQ2UsY0FBYyxDQUFDaEIsU0FBUyxDQUFDRSxPQUFPLEdBQUdZO1FBRW5DLCtGQUErRjtRQUMvRmlCLG1CQUFtQmYsZ0JBQWdCSyxNQUFNO1lBQUVTLE1BQU1BLElBQUksQ0FBQyxFQUFFO1lBQUVFLE1BQU07UUFBbUI7UUFFbkYsNEJBQTRCO1FBQzVCLE9BQU9oQjtJQUNUO0lBRUEsd0VBQXdFO0lBQ3hFLE9BQU9pQixTQUFVQyxHQUFHLEVBQUVDLFNBQVMsR0FBRyxFQUFFO1FBQ2xDLE1BQU1yQixnQkFBZ0I7WUFBRUMsZ0JBQWdCLENBQUM7UUFBRTtRQUUzQ1osT0FBT21CLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFvQjtRQUV2RVUsTUFBTS9CLE9BQU9zQixVQUFVLENBQUNXLFNBQVMsQ0FBQ0Y7UUFDbENDLFNBQVNoQyxPQUFPc0IsVUFBVSxDQUFDLGlCQUFpQixDQUFDVTtRQUU3QyxzRUFBc0U7UUFDdEUseUJBQXlCO1FBQ3pCLHNEQUFzRDtRQUN0RCxrQkFBa0I7UUFDbEIsSUFBSUU7UUFDSixJQUFJO1lBQ0ZBLFlBQVksSUFBSUMsSUFBSUosS0FBSzdCO1FBQzNCLEVBQUUsT0FBT2tDLEtBQUs7WUFDWixNQUFNQyxPQUFPQyxNQUFNLENBQUMsSUFBSUMsVUFBVSw4QkFBOEJSLE1BQU07Z0JBQ3BFUyxPQUFPSjtZQUNUO1FBQ0Y7UUFFQSxrRUFBa0U7UUFDbEUsSUFBSSxDQUFDM0MsZUFBZWdELFFBQVEsQ0FBQ1QsU0FBUztZQUNwQyxNQUFNLElBQUlVLFdBQVcseUJBQXlCVjtRQUNoRDtRQUVBLHFFQUFxRTtRQUNyRSxnRUFBZ0U7UUFDaEUsTUFBTW5CLGlCQUFpQixJQUFJSjtRQUMzQkksY0FBYyxDQUFDZCxPQUFPLEdBQUdZO1FBQ3pCRSxjQUFjLENBQUNoQixTQUFTLENBQUNDLE9BQU8sR0FBRztRQUNuQ2UsY0FBYyxDQUFDaEIsU0FBUyxDQUFDRSxPQUFPLEdBQUdZO1FBRW5DLHVEQUF1RDtRQUN2REUsY0FBYyxDQUFDakIsT0FBTyxDQUFDb0MsTUFBTSxHQUFHQTtRQUVoQyxnRUFBZ0U7UUFDaEUsTUFBTVcsUUFBUW5ELGlCQUFpQlcsY0FBYytCO1FBRTdDLHlFQUF5RTtRQUN6RXJCLGNBQWMsQ0FBQ2pCLE9BQU8sQ0FBQ21CLFdBQVcsQ0FBQzZCLE1BQU0sQ0FBQyxZQUFZRDtRQUV0RCw0QkFBNEI7UUFDNUIsT0FBTzlCO0lBQ1Q7SUFFQSw4Q0FBOEM7SUFDOUNnQyxZQUFhbEIsT0FBTyxJQUFJLEVBQUVULE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkMsSUFBSVMsU0FBUyxNQUFNO1lBQ2pCQSxPQUFPM0IsT0FBT3NCLFVBQVUsQ0FBQ3dCLFFBQVEsQ0FBQ25CO1FBQ3BDO1FBRUFULE9BQU9sQixPQUFPc0IsVUFBVSxDQUFDQyxZQUFZLENBQUNMO1FBRXRDLE9BQU87UUFDUCxJQUFJLENBQUNuQixPQUFPLEdBQUc7WUFBRWEsZ0JBQWdCLENBQUM7UUFBRTtRQUVwQyw0Q0FBNEM7UUFDNUMsSUFBSSxDQUFDaEIsT0FBTyxHQUFHbUQsYUFBYSxDQUFDO1FBRTdCLHFFQUFxRTtRQUNyRSxzRUFBc0U7UUFDdEUsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQ2xELFNBQVMsR0FBRyxJQUFJcEI7UUFDckIsSUFBSSxDQUFDb0IsU0FBUyxDQUFDQyxPQUFPLEdBQUc7UUFDekIsSUFBSSxDQUFDRCxTQUFTLENBQUNPLGFBQWEsR0FBRyxJQUFJLENBQUNSLE9BQU8sQ0FBQ21CLFdBQVc7UUFDdkQsSUFBSSxDQUFDbEIsU0FBUyxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBRXJDLCtCQUErQjtRQUMvQixJQUFJaUQsZUFBZTtRQUVuQixrRkFBa0Y7UUFDbEYsSUFBSXJCLFFBQVEsTUFBTTtZQUNoQixNQUFNLENBQUNzQixlQUFlcEIsS0FBSyxHQUFHaEQsWUFBWThDO1lBQzFDcUIsZUFBZTtnQkFBRXJCLE1BQU1zQjtnQkFBZXBCO1lBQUs7UUFDN0M7UUFFQSx1RUFBdUU7UUFDdkVELG1CQUFtQixJQUFJLEVBQUVWLE1BQU04QjtJQUNqQztJQUVBLHlDQUF5QztJQUN6QyxJQUFJbkIsT0FBUTtRQUNWN0IsT0FBT2tELFVBQVUsQ0FBQyxJQUFJLEVBQUV6QztRQUV4Qiw4REFBOEQ7UUFDOUQsT0FBTyxJQUFJLENBQUNiLE9BQU8sQ0FBQ2lDLElBQUk7SUFDMUI7SUFFQSxxRUFBcUU7SUFDckUsSUFBSUUsTUFBTztRQUNUL0IsT0FBT2tELFVBQVUsQ0FBQyxJQUFJLEVBQUV6QztRQUV4QixNQUFNMEMsVUFBVSxJQUFJLENBQUN2RCxPQUFPLENBQUN1RCxPQUFPO1FBRXBDLGdFQUFnRTtRQUNoRSwyREFBMkQ7UUFDM0QsZ0RBQWdEO1FBQ2hELE1BQU1wQixNQUFNb0IsT0FBTyxDQUFDQSxRQUFRQyxNQUFNLEdBQUcsRUFBRSxJQUFJO1FBRTNDLElBQUlyQixRQUFRLE1BQU07WUFDaEIsT0FBTztRQUNUO1FBRUEsT0FBTzVCLGNBQWM0QixLQUFLO0lBQzVCO0lBRUEsNERBQTREO0lBQzVELElBQUlzQixhQUFjO1FBQ2hCckQsT0FBT2tELFVBQVUsQ0FBQyxJQUFJLEVBQUV6QztRQUV4QiwwRUFBMEU7UUFDMUUsZ0RBQWdEO1FBQ2hELE9BQU8sSUFBSSxDQUFDYixPQUFPLENBQUN1RCxPQUFPLENBQUNDLE1BQU0sR0FBRztJQUN2QztJQUVBLDZCQUE2QjtJQUM3QixJQUFJcEIsU0FBVTtRQUNaaEMsT0FBT2tELFVBQVUsQ0FBQyxJQUFJLEVBQUV6QztRQUV4QixrRUFBa0U7UUFDbEUsT0FBTyxJQUFJLENBQUNiLE9BQU8sQ0FBQ29DLE1BQU07SUFDNUI7SUFFQSxxREFBcUQ7SUFDckQsSUFBSXNCLEtBQU07UUFDUnRELE9BQU9rRCxVQUFVLENBQUMsSUFBSSxFQUFFekM7UUFFeEIsMkVBQTJFO1FBQzNFLDhCQUE4QjtRQUM5QixPQUFPLElBQUksQ0FBQ2IsT0FBTyxDQUFDb0MsTUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDcEMsT0FBTyxDQUFDb0MsTUFBTSxJQUFJO0lBQzlEO0lBRUEscUNBQXFDO0lBQ3JDLElBQUl1QixhQUFjO1FBQ2hCdkQsT0FBT2tELFVBQVUsQ0FBQyxJQUFJLEVBQUV6QztRQUV4QixxRUFBcUU7UUFDckUsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDYixPQUFPLENBQUMyRCxVQUFVO0lBQ2hDO0lBRUEseUNBQXlDO0lBQ3pDLElBQUlDLFVBQVc7UUFDYnhELE9BQU9rRCxVQUFVLENBQUMsSUFBSSxFQUFFekM7UUFFeEIseURBQXlEO1FBQ3pELE9BQU8sSUFBSSxDQUFDWixTQUFTO0lBQ3ZCO0lBRUEsSUFBSThCLE9BQVE7UUFDVjNCLE9BQU9rRCxVQUFVLENBQUMsSUFBSSxFQUFFekM7UUFFeEIsT0FBTyxJQUFJLENBQUNiLE9BQU8sQ0FBQytCLElBQUksR0FBRyxJQUFJLENBQUMvQixPQUFPLENBQUMrQixJQUFJLENBQUM4QixNQUFNLEdBQUc7SUFDeEQ7SUFFQSxJQUFJQyxXQUFZO1FBQ2QxRCxPQUFPa0QsVUFBVSxDQUFDLElBQUksRUFBRXpDO1FBRXhCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ2IsT0FBTyxDQUFDK0IsSUFBSSxJQUFJM0MsS0FBSzJFLFdBQVcsQ0FBQyxJQUFJLENBQUMvRCxPQUFPLENBQUMrQixJQUFJLENBQUM4QixNQUFNO0lBQ3pFO0lBRUEsK0JBQStCO0lBQy9CRyxRQUFTO1FBQ1A1RCxPQUFPa0QsVUFBVSxDQUFDLElBQUksRUFBRXpDO1FBRXhCLGtEQUFrRDtRQUNsRCxJQUFJLElBQUksQ0FBQ2lELFFBQVEsSUFBSyxJQUFJLENBQUMvQixJQUFJLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNrQyxNQUFNLEVBQUc7WUFDcEQsTUFBTTdELE9BQU84RCxNQUFNLENBQUNDLFNBQVMsQ0FBQztnQkFDNUIxQyxRQUFRO2dCQUNSMkMsU0FBUztZQUNYO1FBQ0Y7UUFFQSxrRUFBa0U7UUFDbEUsTUFBTUMsaUJBQWlCQyxjQUFjLElBQUksQ0FBQ3RFLE9BQU87UUFFakQsNERBQTREO1FBQzVELHFFQUFxRTtRQUNyRSxNQUFNdUUsdUJBQXVCLElBQUkxRDtRQUNqQzBELG9CQUFvQixDQUFDdkUsT0FBTyxHQUFHcUU7UUFDL0JFLG9CQUFvQixDQUFDcEUsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTztRQUMzQ29FLG9CQUFvQixDQUFDdEUsU0FBUyxDQUFDTyxhQUFhLEdBQUc2RCxlQUFlbEQsV0FBVztRQUN6RW9ELG9CQUFvQixDQUFDdEUsU0FBUyxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDRCxTQUFTLENBQUNDLE9BQU87UUFDL0RxRSxvQkFBb0IsQ0FBQ3RFLFNBQVMsQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ0YsU0FBUyxDQUFDRSxPQUFPO1FBRS9ELE9BQU9vRTtJQUNUO0FBQ0Y7QUFFQXBGLFVBQVUwQjtBQUVWNEIsT0FBTytCLGdCQUFnQixDQUFDM0QsU0FBUzRELFNBQVMsRUFBRTtJQUMxQ3hDLE1BQU01QztJQUNOOEMsS0FBSzlDO0lBQ0wrQyxRQUFRL0M7SUFDUnFFLElBQUlyRTtJQUNKb0UsWUFBWXBFO0lBQ1pzRSxZQUFZdEU7SUFDWnVFLFNBQVN2RTtJQUNUMkUsT0FBTzNFO0lBQ1AwQyxNQUFNMUM7SUFDTnlFLFVBQVV6RTtJQUNWLENBQUNxRixPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQjVCLE9BQU87UUFDUDZCLGNBQWM7SUFDaEI7QUFDRjtBQUVBbkMsT0FBTytCLGdCQUFnQixDQUFDM0QsVUFBVTtJQUNoQ08sTUFBTS9CO0lBQ042QyxVQUFVN0M7SUFDVnlCLE9BQU96QjtBQUNUO0FBRUEsd0RBQXdEO0FBQ3hELFNBQVNpRixjQUFlTyxRQUFRO0lBQzlCLGlEQUFpRDtJQUVqRCxxRUFBcUU7SUFDckUscUVBQXFFO0lBQ3JFLHFCQUFxQjtJQUNyQixJQUFJQSxTQUFTQyxnQkFBZ0IsRUFBRTtRQUM3QixPQUFPQyxlQUNMVCxjQUFjTyxTQUFTQyxnQkFBZ0IsR0FDdkNELFNBQVM1QyxJQUFJO0lBRWpCO0lBRUEsaUVBQWlFO0lBQ2pFLE1BQU0rQyxjQUFjN0IsYUFBYTtRQUFFLEdBQUcwQixRQUFRO1FBQUU5QyxNQUFNO0lBQUs7SUFFM0Qsd0VBQXdFO0lBQ3hFLHFDQUFxQztJQUNyQyxJQUFJOEMsU0FBUzlDLElBQUksSUFBSSxNQUFNO1FBQ3pCaUQsWUFBWWpELElBQUksR0FBRzdDLFVBQVUyRixTQUFTOUMsSUFBSTtJQUM1QztJQUVBLHlCQUF5QjtJQUN6QixPQUFPaUQ7QUFDVDtBQUVBLFNBQVM3QixhQUFjN0IsSUFBSTtJQUN6QixPQUFPO1FBQ0wyRCxTQUFTO1FBQ1RDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyw0QkFBNEI7UUFDNUJuRCxNQUFNO1FBQ05HLFFBQVE7UUFDUmlELFlBQVk7UUFDWkMsWUFBWTtRQUNaM0IsWUFBWTtRQUNaLEdBQUdyQyxJQUFJO1FBQ1BILGFBQWFHLEtBQUtILFdBQVcsR0FDekIsSUFBSXJDLFlBQVl3QyxLQUFLSCxXQUFXLElBQ2hDLElBQUlyQztRQUNSeUUsU0FBU2pDLEtBQUtpQyxPQUFPLEdBQUc7ZUFBSWpDLEtBQUtpQyxPQUFPO1NBQUMsR0FBRyxFQUFFO0lBQ2hEO0FBQ0Y7QUFFQSxTQUFTckMsaUJBQWtCcUUsTUFBTTtJQUMvQixNQUFNQyxVQUFVN0YsWUFBWTRGO0lBQzVCLE9BQU9wQyxhQUFhO1FBQ2xCbEIsTUFBTTtRQUNORyxRQUFRO1FBQ1J0QixPQUFPMEUsVUFDSEQsU0FDQSxJQUFJRSxNQUFNRixTQUFTRyxPQUFPSCxVQUFVQTtRQUN4Q04sU0FBU00sVUFBVUEsT0FBT0ksSUFBSSxLQUFLO0lBQ3JDO0FBQ0Y7QUFFQSxTQUFTQyxxQkFBc0JmLFFBQVEsRUFBRWdCLEtBQUs7SUFDNUNBLFFBQVE7UUFDTmYsa0JBQWtCRDtRQUNsQixHQUFHZ0IsS0FBSztJQUNWO0lBRUEsT0FBTyxJQUFJQyxNQUFNakIsVUFBVTtRQUN6QmtCLEtBQUtDLE1BQU0sRUFBRUMsQ0FBQztZQUNaLE9BQU9BLEtBQUtKLFFBQVFBLEtBQUssQ0FBQ0ksRUFBRSxHQUFHRCxNQUFNLENBQUNDLEVBQUU7UUFDMUM7UUFDQUMsS0FBS0YsTUFBTSxFQUFFQyxDQUFDLEVBQUVsRCxLQUFLO1lBQ25CdEMsT0FBTyxDQUFFd0YsQ0FBQUEsS0FBS0osS0FBSTtZQUNsQkcsTUFBTSxDQUFDQyxFQUFFLEdBQUdsRDtZQUNaLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQSwyREFBMkQ7QUFDM0QsU0FBU2dDLGVBQWdCRixRQUFRLEVBQUU1QyxJQUFJO0lBQ3JDLHVFQUF1RTtJQUN2RSwrREFBK0Q7SUFDL0QsSUFBSUEsU0FBUyxTQUFTO1FBQ3BCLHlFQUF5RTtRQUN6RSwwRUFBMEU7UUFDMUUsa0RBQWtEO1FBRWxELGtFQUFrRTtRQUNsRSxPQUFPMkQscUJBQXFCZixVQUFVO1lBQ3BDNUMsTUFBTTtZQUNOZCxhQUFhMEQsU0FBUzFELFdBQVc7UUFDbkM7SUFDRixPQUFPLElBQUljLFNBQVMsUUFBUTtRQUMxQix1RUFBdUU7UUFDdkUscUVBQXFFO1FBQ3JFLHVFQUF1RTtRQUN2RSxxREFBcUQ7UUFFckQsd0VBQXdFO1FBQ3hFLE9BQU8yRCxxQkFBcUJmLFVBQVU7WUFDcEM1QyxNQUFNO1lBQ05kLGFBQWEwRCxTQUFTMUQsV0FBVztRQUNuQztJQUNGLE9BQU8sSUFBSWMsU0FBUyxVQUFVO1FBQzVCLG1FQUFtRTtRQUNuRSxvRUFBb0U7UUFDcEUsc0VBQXNFO1FBRXRFLE9BQU8yRCxxQkFBcUJmLFVBQVU7WUFDcEM1QyxNQUFNO1lBQ05zQixTQUFTZCxPQUFPMEQsTUFBTSxDQUFDLEVBQUU7WUFDekIvRCxRQUFRO1lBQ1J1QixZQUFZO1lBQ1o1QixNQUFNO1FBQ1I7SUFDRixPQUFPLElBQUlFLFNBQVMsa0JBQWtCO1FBQ3BDLHlFQUF5RTtRQUN6RSxxRUFBcUU7UUFDckUsb0RBQW9EO1FBRXBELE9BQU8yRCxxQkFBcUJmLFVBQVU7WUFDcEM1QyxNQUFNO1lBQ05HLFFBQVE7WUFDUnVCLFlBQVk7WUFDWnhDLGFBQWEsRUFBRTtZQUNmWSxNQUFNO1FBQ1I7SUFDRixPQUFPO1FBQ0x0QixPQUFPO0lBQ1Q7QUFDRjtBQUVBLDJEQUEyRDtBQUMzRCxTQUFTMkYsNEJBQTZCQyxXQUFXLEVBQUU3RCxNQUFNLElBQUk7SUFDM0Qsc0NBQXNDO0lBQ3RDL0IsT0FBT2xCLFlBQVk4RztJQUVuQixnRUFBZ0U7SUFDaEUsb0NBQW9DO0lBQ3BDLE9BQU83RyxVQUFVNkcsZUFDYm5GLGlCQUFpQnVCLE9BQU9DLE1BQU0sQ0FBQyxJQUFJM0MsYUFBYSw4QkFBOEIsZUFBZTtRQUFFNkMsT0FBT0o7SUFBSSxNQUMxR3RCLGlCQUFpQnVCLE9BQU9DLE1BQU0sQ0FBQyxJQUFJM0MsYUFBYSwyQkFBMkI7UUFBRTZDLE9BQU9KO0lBQUk7QUFDOUY7QUFFQSwyREFBMkQ7QUFDM0QsU0FBU1IsbUJBQW9CNkMsUUFBUSxFQUFFdkQsSUFBSSxFQUFFUyxJQUFJO0lBQy9DLHVFQUF1RTtJQUN2RSx5QkFBeUI7SUFDekIsSUFBSVQsS0FBS2MsTUFBTSxLQUFLLFFBQVNkLENBQUFBLEtBQUtjLE1BQU0sR0FBRyxPQUFPZCxLQUFLYyxNQUFNLEdBQUcsR0FBRSxHQUFJO1FBQ3BFLE1BQU0sSUFBSVUsV0FBVztJQUN2QjtJQUVBLDhFQUE4RTtJQUM5RSw2QkFBNkI7SUFDN0IsSUFBSSxnQkFBZ0J4QixRQUFRQSxLQUFLcUMsVUFBVSxJQUFJLE1BQU07UUFDbkQsb0VBQW9FO1FBQ3BFLHVEQUF1RDtRQUN2RCxJQUFJLENBQUNyRSxvQkFBb0JvRyxPQUFPcEUsS0FBS3FDLFVBQVUsSUFBSTtZQUNqRCxNQUFNLElBQUloQixVQUFVO1FBQ3RCO0lBQ0Y7SUFFQSx5REFBeUQ7SUFDekQsSUFBSSxZQUFZckIsUUFBUUEsS0FBS2MsTUFBTSxJQUFJLE1BQU07UUFDM0N5QyxRQUFRLENBQUM3RSxPQUFPLENBQUNvQyxNQUFNLEdBQUdkLEtBQUtjLE1BQU07SUFDdkM7SUFFQSxxRUFBcUU7SUFDckUsSUFBSSxnQkFBZ0JkLFFBQVFBLEtBQUtxQyxVQUFVLElBQUksTUFBTTtRQUNuRGtCLFFBQVEsQ0FBQzdFLE9BQU8sQ0FBQzJELFVBQVUsR0FBR3JDLEtBQUtxQyxVQUFVO0lBQy9DO0lBRUEsbUZBQW1GO0lBQ25GLElBQUksYUFBYXJDLFFBQVFBLEtBQUtzQyxPQUFPLElBQUksTUFBTTtRQUM3QzdFLEtBQUs4RixRQUFRLENBQUM1RSxTQUFTLEVBQUVxQixLQUFLc0MsT0FBTztJQUN2QztJQUVBLDhCQUE4QjtJQUM5QixJQUFJN0IsTUFBTTtRQUNSLHlFQUF5RTtRQUN6RSxJQUFJakMsZUFBZStDLFFBQVEsQ0FBQ2dDLFNBQVN6QyxNQUFNLEdBQUc7WUFDNUMsTUFBTWhDLE9BQU84RCxNQUFNLENBQUNDLFNBQVMsQ0FBQztnQkFDNUIxQyxRQUFRO2dCQUNSMkMsU0FBUyxrQ0FBa0NTLFNBQVN6QyxNQUFNO1lBQzVEO1FBQ0Y7UUFFQSx5Q0FBeUM7UUFDekN5QyxRQUFRLENBQUM3RSxPQUFPLENBQUMrQixJQUFJLEdBQUdBLEtBQUtBLElBQUk7UUFFakMsNEVBQTRFO1FBQzVFLDBGQUEwRjtRQUMxRixJQUFJQSxLQUFLRSxJQUFJLElBQUksUUFBUSxDQUFDNEMsUUFBUSxDQUFDN0UsT0FBTyxDQUFDbUIsV0FBVyxDQUFDbUYsUUFBUSxDQUFDLGlCQUFpQjtZQUMvRXpCLFFBQVEsQ0FBQzdFLE9BQU8sQ0FBQ21CLFdBQVcsQ0FBQzZCLE1BQU0sQ0FBQyxnQkFBZ0JqQixLQUFLRSxJQUFJO1FBQy9EO0lBQ0Y7QUFDRjtBQUVBN0IsT0FBT3NCLFVBQVUsQ0FBQ2YsY0FBYyxHQUFHUCxPQUFPbUcsa0JBQWtCLENBQzFENUY7QUFHRlAsT0FBT3NCLFVBQVUsQ0FBQ3JCLFFBQVEsR0FBR0QsT0FBT21HLGtCQUFrQixDQUNwRGxHO0FBR0ZELE9BQU9zQixVQUFVLENBQUM4RSxlQUFlLEdBQUdwRyxPQUFPbUcsa0JBQWtCLENBQzNEQztBQUdGLG1FQUFtRTtBQUNuRXBHLE9BQU9zQixVQUFVLENBQUMrRSxzQkFBc0IsR0FBRyxTQUFVQyxDQUFDO0lBQ3BELElBQUksT0FBT0EsTUFBTSxVQUFVO1FBQ3pCLE9BQU90RyxPQUFPc0IsVUFBVSxDQUFDVyxTQUFTLENBQUNxRTtJQUNyQztJQUVBLElBQUlqSCxXQUFXaUgsSUFBSTtRQUNqQixPQUFPdEcsT0FBT3NCLFVBQVUsQ0FBQ2lGLElBQUksQ0FBQ0QsR0FBRztZQUFFRSxRQUFRO1FBQU07SUFDbkQ7SUFFQSxJQUNFbEcsTUFBTW1HLGdCQUFnQixDQUFDSCxNQUN2QmhHLE1BQU1vRyxZQUFZLENBQUNKLE1BQ25CaEcsTUFBTXFHLFVBQVUsQ0FBQ0wsSUFDakI7UUFDQSxPQUFPdEcsT0FBT3NCLFVBQVUsQ0FBQ3NGLFlBQVksQ0FBQ047SUFDeEM7SUFFQSxJQUFJdEgsS0FBSzZILGNBQWMsQ0FBQ1AsSUFBSTtRQUMxQixPQUFPdEcsT0FBT3NCLFVBQVUsQ0FBQ3JCLFFBQVEsQ0FBQ3FHLEdBQUc7WUFBRUUsUUFBUTtRQUFNO0lBQ3ZEO0lBRUEsSUFBSUYsYUFBYUYsaUJBQWlCO1FBQ2hDLE9BQU9wRyxPQUFPc0IsVUFBVSxDQUFDOEUsZUFBZSxDQUFDRTtJQUMzQztJQUVBLE9BQU90RyxPQUFPc0IsVUFBVSxDQUFDd0YsU0FBUyxDQUFDUjtBQUNyQztBQUVBLDBDQUEwQztBQUMxQ3RHLE9BQU9zQixVQUFVLENBQUN3QixRQUFRLEdBQUcsU0FBVXdELENBQUM7SUFDdEMsSUFBSUEsYUFBYS9GLGdCQUFnQjtRQUMvQixPQUFPUCxPQUFPc0IsVUFBVSxDQUFDZixjQUFjLENBQUMrRjtJQUMxQztJQUVBLGtEQUFrRDtJQUNsRCwrQkFBK0I7SUFDL0IsSUFBSUEsR0FBRyxDQUFDaEMsT0FBT3lDLGFBQWEsQ0FBQyxFQUFFO1FBQzdCLE9BQU9UO0lBQ1Q7SUFFQSxPQUFPdEcsT0FBT3NCLFVBQVUsQ0FBQytFLHNCQUFzQixDQUFDQztBQUNsRDtBQUVBdEcsT0FBT3NCLFVBQVUsQ0FBQ0MsWUFBWSxHQUFHdkIsT0FBT2dILG1CQUFtQixDQUFDO0lBQzFEO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV2xILE9BQU9zQixVQUFVLENBQUMsaUJBQWlCO1FBQzlDNkYsY0FBYztJQUNoQjtJQUNBO1FBQ0VGLEtBQUs7UUFDTEMsV0FBV2xILE9BQU9zQixVQUFVLENBQUM4RixVQUFVO1FBQ3ZDRCxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUYsS0FBSztRQUNMQyxXQUFXbEgsT0FBT3NCLFVBQVUsQ0FBQytGLFdBQVc7SUFDMUM7Q0FDRDtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnpHO0lBQ0FpQztJQUNBaUQ7SUFDQXJCO0lBQ0FsRTtJQUNBeUQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvcmVzcG9uc2UuanM/YmFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIZWFkZXJzLCBIZWFkZXJzTGlzdCwgZmlsbCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgZXh0cmFjdEJvZHksIGNsb25lQm9keSwgbWl4aW5Cb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWxcbmNvbnN0IHtcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNCbG9iTGlrZSxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBpc0Vycm9yTGlrZSxcbiAgaXNvbW9ycGhpY0VuY29kZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzLFxuICBudWxsQm9keVN0YXR1cyxcbiAgRE9NRXhjZXB0aW9uXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzLCBrR3VhcmQsIGtSZWFsbSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2dsb2JhbCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4vZGF0YVVSTCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcblxuY29uc3QgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtIHx8IHJlcXVpcmUoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2UtY2xhc3NcbmNsYXNzIFJlc3BvbnNlIHtcbiAgLy8gQ3JlYXRlcyBuZXR3b3JrIGVycm9yIFJlc3BvbnNlLlxuICBzdGF0aWMgZXJyb3IgKCkge1xuICAgIC8vIFRPRE9cbiAgICBjb25zdCByZWxldmFudFJlYWxtID0geyBzZXR0aW5nc09iamVjdDoge30gfVxuXG4gICAgLy8gVGhlIHN0YXRpYyBlcnJvcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYVxuICAgIC8vIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgbmV0d29yayBlcnJvciwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzXG4gICAgLy8gcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBuZXcgUmVzcG9uc2UoKVxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0gPSBtYWtlTmV0d29ya0Vycm9yKClcbiAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrSGVhZGVyc0xpc3RdID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdFxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ2ltbXV0YWJsZSdcbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVzcG9uc2UtanNvblxuICBzdGF0aWMganNvbiAoZGF0YSwgaW5pdCA9IHt9KSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ1Jlc3BvbnNlLmpzb24nIH0pXG5cbiAgICBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KVxuICAgIH1cblxuICAgIC8vIDEuIExldCBieXRlcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2VyaWFsaXplIGEgSmF2YVNjcmlwdCB2YWx1ZSB0byBKU09OIGJ5dGVzIG9uIGRhdGEuXG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JykuZW5jb2RlKFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgKVxuXG4gICAgLy8gMi4gTGV0IGJvZHkgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJ5dGVzLlxuICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcylcblxuICAgIC8vIDMuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyByZXNwb25zZSxcbiAgICAvLyAgICBcInJlc3BvbnNlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZWxldmFudFJlYWxtID0geyBzZXR0aW5nc09iamVjdDoge30gfVxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICByZXNwb25zZU9iamVjdFtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gJ3Jlc3BvbnNlJ1xuICAgIHJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gcmVsZXZhbnRSZWFsbVxuXG4gICAgLy8gNC4gUGVyZm9ybSBpbml0aWFsaXplIGEgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2VPYmplY3QsIGluaXQsIGFuZCAoYm9keSwgXCJhcHBsaWNhdGlvbi9qc29uXCIpLlxuICAgIGluaXRpYWxpemVSZXNwb25zZShyZXNwb25zZU9iamVjdCwgaW5pdCwgeyBib2R5OiBib2R5WzBdLCB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSlcblxuICAgIC8vIDUuIFJldHVybiByZXNwb25zZU9iamVjdC5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSByZWRpcmVjdCBSZXNwb25zZSB0aGF0IHJlZGlyZWN0cyB0byB1cmwgd2l0aCBzdGF0dXMgc3RhdHVzLlxuICBzdGF0aWMgcmVkaXJlY3QgKHVybCwgc3RhdHVzID0gMzAyKSB7XG4gICAgY29uc3QgcmVsZXZhbnRSZWFsbSA9IHsgc2V0dGluZ3NPYmplY3Q6IHt9IH1cblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdSZXNwb25zZS5yZWRpcmVjdCcgfSlcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgc3RhdHVzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oc3RhdHVzKVxuXG4gICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdXJsIHdpdGggY3VycmVudCBzZXR0aW5nc1xuICAgIC8vIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIFRPRE86IGJhc2UtVVJMP1xuICAgIGxldCBwYXJzZWRVUkxcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwsIGdldEdsb2JhbE9yaWdpbigpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJyArIHVybCksIHtcbiAgICAgICAgY2F1c2U6IGVyclxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgICBpZiAoIXJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlICcgKyBzdGF0dXMpXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gYSBuZXcgcmVzcG9uc2UsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IG5ldyBSZXNwb25zZSgpXG4gICAgcmVzcG9uc2VPYmplY3Rba1JlYWxtXSA9IHJlbGV2YW50UmVhbG1cbiAgICByZXNwb25zZU9iamVjdFtrSGVhZGVyc11ba0d1YXJkXSA9ICdpbW11dGFibGUnXG4gICAgcmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tSZWFsbV0gPSByZWxldmFudFJlYWxtXG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gc3RhdHVzLlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uc3RhdHVzID0gc3RhdHVzXG5cbiAgICAvLyA2LiBMZXQgdmFsdWUgYmUgcGFyc2VkVVJMLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgY29uc3QgdmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKFVSTFNlcmlhbGl6ZXIocGFyc2VkVVJMKSlcblxuICAgIC8vIDcuIEFwcGVuZCBgTG9jYXRpb25gL3ZhbHVlIHRvIHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2xvY2F0aW9uJywgdmFsdWUpXG5cbiAgICAvLyA4LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlXG4gIGNvbnN0cnVjdG9yIChib2R5ID0gbnVsbCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGJvZHkgIT09IG51bGwpIHtcbiAgICAgIGJvZHkgPSB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdChib2R5KVxuICAgIH1cblxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcblxuICAgIC8vIFRPRE9cbiAgICB0aGlzW2tSZWFsbV0gPSB7IHNldHRpbmdzT2JqZWN0OiB7fSB9XG5cbiAgICAvLyAxLiBTZXQgdGhpc+KAmXMgcmVzcG9uc2UgdG8gYSBuZXcgcmVzcG9uc2UuXG4gICAgdGhpc1trU3RhdGVdID0gbWFrZVJlc3BvbnNlKHt9KVxuXG4gICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLCB3aG9zZSBoZWFkZXIgbGlzdCBpcyB0aGlz4oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkXG4gICAgLy8gaXMgXCJyZXNwb25zZVwiLlxuICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoKVxuICAgIHRoaXNba0hlYWRlcnNdW2tHdWFyZF0gPSAncmVzcG9uc2UnXG4gICAgdGhpc1trSGVhZGVyc11ba0hlYWRlcnNMaXN0XSA9IHRoaXNba1N0YXRlXS5oZWFkZXJzTGlzdFxuICAgIHRoaXNba0hlYWRlcnNdW2tSZWFsbV0gPSB0aGlzW2tSZWFsbV1cblxuICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgbnVsbC5cbiAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgYm9keVdpdGhUeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBib2R5V2l0aFR5cGUgPSB7IGJvZHk6IGV4dHJhY3RlZEJvZHksIHR5cGUgfVxuICAgIH1cblxuICAgIC8vIDUuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHRoaXMsIGluaXQsIGFuZCBib2R5V2l0aFR5cGUuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHR5cGUsIGUuZy4sIFwiY29yc1wiLlxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgdHlwZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgdHlwZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnR5cGVcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIFVSTCwgaWYgaXQgaGFzIG9uZTsgb3RoZXJ3aXNlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgY29uc3QgdXJsTGlzdCA9IHRoaXNba1N0YXRlXS51cmxMaXN0XG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaWYgdGhpc+KAmXNcbiAgICAvLyByZXNwb25zZeKAmXMgVVJMIGlzIG51bGw7IG90aGVyd2lzZSB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMLFxuICAgIC8vIHNlcmlhbGl6ZWQgd2l0aCBleGNsdWRlIGZyYWdtZW50IHNldCB0byB0cnVlLlxuICAgIGNvbnN0IHVybCA9IHVybExpc3RbdXJsTGlzdC5sZW5ndGggLSAxXSA/PyBudWxsXG5cbiAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih1cmwsIHRydWUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2Ugd2FzIG9idGFpbmVkIHRocm91Z2ggYSByZWRpcmVjdC5cbiAgZ2V0IHJlZGlyZWN0ZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHJlZGlyZWN0ZWQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgVVJMXG4gICAgLy8gbGlzdCBoYXMgbW9yZSB0aGFuIG9uZSBpdGVtOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS51cmxMaXN0Lmxlbmd0aCA+IDFcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgZ2V0IHN0YXR1cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuIG9rIHN0YXR1cy5cbiAgZ2V0IG9rICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBvayBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW5cbiAgICAvLyBvayBzdGF0dXM7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1trU3RhdGVdLnN0YXR1cyA8PSAyOTlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlLlxuICBnZXQgc3RhdHVzVGV4dCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzVGV4dCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzXG4gICAgLy8gbWVzc2FnZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIGhlYWRlcnMgYXMgSGVhZGVycy5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIGhlYWRlcnMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgaGVhZGVycy5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc11cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGxcbiAgfVxuXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXNwb25zZS5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCAodGhpcy5ib2R5ICYmIHRoaXMuYm9keS5sb2NrZWQpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlLmNsb25lJyxcbiAgICAgICAgbWVzc2FnZTogJ0JvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIGNsb25pbmcgdGhpc+KAmXMgcmVzcG9uc2UuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKHRoaXNba1N0YXRlXSlcblxuICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlblxuICAgIC8vIGNsb25lZFJlc3BvbnNlLCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlT2JqZWN0ID0gbmV3IFJlc3BvbnNlKClcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrU3RhdGVdID0gY2xvbmVkUmVzcG9uc2VcbiAgICBjbG9uZWRSZXNwb25zZU9iamVjdFtrUmVhbG1dID0gdGhpc1trUmVhbG1dXG4gICAgY2xvbmVkUmVzcG9uc2VPYmplY3Rba0hlYWRlcnNdW2tIZWFkZXJzTGlzdF0gPSBjbG9uZWRSZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrR3VhcmRdID0gdGhpc1trSGVhZGVyc11ba0d1YXJkXVxuICAgIGNsb25lZFJlc3BvbnNlT2JqZWN0W2tIZWFkZXJzXVtrUmVhbG1dID0gdGhpc1trSGVhZGVyc11ba1JlYWxtXVxuXG4gICAgcmV0dXJuIGNsb25lZFJlc3BvbnNlT2JqZWN0XG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlc3BvbnNlKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgdHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9rOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXNwb25zZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLCB7XG4gIGpzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gIC8vIFRvIGNsb25lIGEgcmVzcG9uc2UgcmVzcG9uc2UsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlLCB0aGVuIHJldHVybiBhIG5ldyBpZGVudGljYWxcbiAgLy8gZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWwgcmVzcG9uc2UgaXMgYSBjbG9uZSBvZiByZXNwb25zZeKAmXNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgY2xvbmVSZXNwb25zZShyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSxcbiAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICApXG4gIH1cblxuICAvLyAyLiBMZXQgbmV3UmVzcG9uc2UgYmUgYSBjb3B5IG9mIHJlc3BvbnNlLCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IC4uLnJlc3BvbnNlLCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IG5ld1Jlc3BvbnNl4oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXNwb25zZeKAmXMgYm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkocmVzcG9uc2UuYm9keSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiBuZXdSZXNwb25zZS5cbiAgcmV0dXJuIG5ld1Jlc3BvbnNlXG59XG5cbmZ1bmN0aW9uIG1ha2VSZXNwb25zZSAoaW5pdCkge1xuICByZXR1cm4ge1xuICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgIHJhbmdlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd1Bhc3NlZDogZmFsc2UsXG4gICAgcmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICBzdGF0dXM6IDIwMCxcbiAgICB0aW1pbmdJbmZvOiBudWxsLFxuICAgIGNhY2hlU3RhdGU6ICcnLFxuICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgIC4uLmluaXQsXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQudXJsTGlzdCA/IFsuLi5pbml0LnVybExpc3RdIDogW11cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTmV0d29ya0Vycm9yIChyZWFzb24pIHtcbiAgY29uc3QgaXNFcnJvciA9IGlzRXJyb3JMaWtlKHJlYXNvbilcbiAgcmV0dXJuIG1ha2VSZXNwb25zZSh7XG4gICAgdHlwZTogJ2Vycm9yJyxcbiAgICBzdGF0dXM6IDAsXG4gICAgZXJyb3I6IGlzRXJyb3JcbiAgICAgID8gcmVhc29uXG4gICAgICA6IG5ldyBFcnJvcihyZWFzb24gPyBTdHJpbmcocmVhc29uKSA6IHJlYXNvbiksXG4gICAgYWJvcnRlZDogcmVhc29uICYmIHJlYXNvbi5uYW1lID09PSAnQWJvcnRFcnJvcidcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzID0gaW5pdC5zdGF0dXNcbiAgfVxuXG4gIC8vIDQuIFNldCByZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGluaXRbXCJzdGF0dXNUZXh0XCJdLlxuICBpZiAoJ3N0YXR1c1RleHQnIGluIGluaXQgJiYgaW5pdC5zdGF0dXNUZXh0ICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIDUuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBmaWxsIHJlc3BvbnNl4oCZcyBoZWFkZXJzIHdpdGggaW5pdFtcImhlYWRlcnNcIl0uXG4gIGlmICgnaGVhZGVycycgaW4gaW5pdCAmJiBpbml0LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgIGZpbGwocmVzcG9uc2Vba0hlYWRlcnNdLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgcmVzcG9uc2Vba1N0YXRlXS5ib2R5ID0gYm9keS5ib2R5XG5cbiAgICAvLyAzLiBJZiBib2R5J3MgdHlwZSBpcyBub24tbnVsbCBhbmQgcmVzcG9uc2UncyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluXG4gICAgLy8gICAgYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIChgQ29udGVudC1UeXBlYCwgYm9keSdzIHR5cGUpIHRvIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QuXG4gICAgaWYgKGJvZHkudHlwZSAhPSBudWxsICYmICFyZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdDb250ZW50LVR5cGUnKSkge1xuICAgICAgcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSlcbiAgICB9XG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0gPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBSZWFkYWJsZVN0cmVhbVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEZvcm1EYXRhXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFVSTFNlYXJjaFBhcmFtc1xuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jdHlwZWRlZmRlZi14bWxodHRwcmVxdWVzdGJvZHlpbml0XG53ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0ID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAoXG4gICAgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSB8fFxuICAgIHR5cGVzLmlzVHlwZWRBcnJheShWKSB8fFxuICAgIHR5cGVzLmlzRGF0YVZpZXcoVilcbiAgKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKVxuICB9XG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMoVilcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoVilcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2JvZHlpbml0XG53ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdCA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmIChWIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0oVilcbiAgfVxuXG4gIC8vIE5vdGU6IHRoZSBzcGVjIGRvZXNuJ3QgaW5jbHVkZSBhc3luYyBpdGVyYWJsZXMsXG4gIC8vIHRoaXMgaXMgYW4gdW5kaWNpIGV4dGVuc2lvbi5cbiAgaWYgKFY/LltTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gVlxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQoVilcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnc3RhdHVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogMjAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzdGF0dXNUZXh0JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZVJlc3BvbnNlLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBSZXNwb25zZSxcbiAgY2xvbmVSZXNwb25zZVxufVxuIl0sIm5hbWVzIjpbIkhlYWRlcnMiLCJIZWFkZXJzTGlzdCIsImZpbGwiLCJyZXF1aXJlIiwiZXh0cmFjdEJvZHkiLCJjbG9uZUJvZHkiLCJtaXhpbkJvZHkiLCJ1dGlsIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsImlzVmFsaWRSZWFzb25QaHJhc2UiLCJpc0NhbmNlbGxlZCIsImlzQWJvcnRlZCIsImlzQmxvYkxpa2UiLCJzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmciLCJpc0Vycm9yTGlrZSIsImlzb21vcnBoaWNFbmNvZGUiLCJyZWRpcmVjdFN0YXR1cyIsIm51bGxCb2R5U3RhdHVzIiwiRE9NRXhjZXB0aW9uIiwia1N0YXRlIiwia0hlYWRlcnMiLCJrR3VhcmQiLCJrUmVhbG0iLCJ3ZWJpZGwiLCJGb3JtRGF0YSIsImdldEdsb2JhbE9yaWdpbiIsIlVSTFNlcmlhbGl6ZXIiLCJrSGVhZGVyc0xpc3QiLCJhc3NlcnQiLCJ0eXBlcyIsIlJlYWRhYmxlU3RyZWFtIiwiZ2xvYmFsVGhpcyIsIlJlc3BvbnNlIiwiZXJyb3IiLCJyZWxldmFudFJlYWxtIiwic2V0dGluZ3NPYmplY3QiLCJyZXNwb25zZU9iamVjdCIsIm1ha2VOZXR3b3JrRXJyb3IiLCJoZWFkZXJzTGlzdCIsImpzb24iLCJkYXRhIiwiaW5pdCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJoZWFkZXIiLCJjb252ZXJ0ZXJzIiwiUmVzcG9uc2VJbml0IiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJvZHkiLCJpbml0aWFsaXplUmVzcG9uc2UiLCJ0eXBlIiwicmVkaXJlY3QiLCJ1cmwiLCJzdGF0dXMiLCJVU1ZTdHJpbmciLCJwYXJzZWRVUkwiLCJVUkwiLCJlcnIiLCJPYmplY3QiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJjYXVzZSIsImluY2x1ZGVzIiwiUmFuZ2VFcnJvciIsInZhbHVlIiwiYXBwZW5kIiwiY29uc3RydWN0b3IiLCJCb2R5SW5pdCIsIm1ha2VSZXNwb25zZSIsImJvZHlXaXRoVHlwZSIsImV4dHJhY3RlZEJvZHkiLCJicmFuZENoZWNrIiwidXJsTGlzdCIsImxlbmd0aCIsInJlZGlyZWN0ZWQiLCJvayIsInN0YXR1c1RleHQiLCJoZWFkZXJzIiwic3RyZWFtIiwiYm9keVVzZWQiLCJpc0Rpc3R1cmJlZCIsImNsb25lIiwibG9ja2VkIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsImNsb25lZFJlc3BvbnNlIiwiY2xvbmVSZXNwb25zZSIsImNsb25lZFJlc3BvbnNlT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY29uZmlndXJhYmxlIiwicmVzcG9uc2UiLCJpbnRlcm5hbFJlc3BvbnNlIiwiZmlsdGVyUmVzcG9uc2UiLCJuZXdSZXNwb25zZSIsImFib3J0ZWQiLCJyYW5nZVJlcXVlc3RlZCIsInRpbWluZ0FsbG93UGFzc2VkIiwicmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMiLCJ0aW1pbmdJbmZvIiwiY2FjaGVTdGF0ZSIsInJlYXNvbiIsImlzRXJyb3IiLCJFcnJvciIsIlN0cmluZyIsIm5hbWUiLCJtYWtlRmlsdGVyZWRSZXNwb25zZSIsInN0YXRlIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwIiwic2V0IiwiZnJlZXplIiwibWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIiwiZmV0Y2hQYXJhbXMiLCJjb250YWlucyIsImludGVyZmFjZUNvbnZlcnRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlhNTEh0dHBSZXF1ZXN0Qm9keUluaXQiLCJWIiwiQmxvYiIsInN0cmljdCIsImlzQW55QXJyYXlCdWZmZXIiLCJpc1R5cGVkQXJyYXkiLCJpc0RhdGFWaWV3IiwiQnVmZmVyU291cmNlIiwiaXNGb3JtRGF0YUxpa2UiLCJET01TdHJpbmciLCJhc3luY0l0ZXJhdG9yIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIkJ5dGVTdHJpbmciLCJIZWFkZXJzSW5pdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/symbols.js":
/*!**************************************************!*\
  !*** ./node_modules/undici/lib/fetch/symbols.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kUrl: Symbol(\"url\"),\n    kHeaders: Symbol(\"headers\"),\n    kSignal: Symbol(\"signal\"),\n    kState: Symbol(\"state\"),\n    kGuard: Symbol(\"guard\"),\n    kRealm: Symbol(\"realm\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxNQUFNQyxPQUFPO0lBQ2JDLFVBQVVELE9BQU87SUFDakJFLFNBQVNGLE9BQU87SUFDaEJHLFFBQVFILE9BQU87SUFDZkksUUFBUUosT0FBTztJQUNmSyxRQUFRTCxPQUFPO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC9zeW1ib2xzLmpzPzU0MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrSGVhZGVyczogU3ltYm9sKCdoZWFkZXJzJyksXG4gIGtTaWduYWw6IFN5bWJvbCgnc2lnbmFsJyksXG4gIGtTdGF0ZTogU3ltYm9sKCdzdGF0ZScpLFxuICBrR3VhcmQ6IFN5bWJvbCgnZ3VhcmQnKSxcbiAga1JlYWxtOiBTeW1ib2woJ3JlYWxtJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia1VybCIsIlN5bWJvbCIsImtIZWFkZXJzIiwia1NpZ25hbCIsImtTdGF0ZSIsImtHdWFyZCIsImtSZWFsbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/util.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/fetch/util.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/fetch/global.js\");\nconst { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { isUint8Array } = __webpack_require__(/*! util/types */ \"util/types\");\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nfunction responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in response’s URL list and null if response’s URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n    // 1. If response’s status is not a redirect status, then return null.\n    if (!redirectStatus.includes(response.status)) {\n        return null;\n    }\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and response’s header list.\n    let location = response.headersList.get(\"location\");\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with response’s URL.\n    if (location !== null && isValidHeaderValue(location)) {\n        location = new URL(location, responseURL(response));\n    }\n    // 4. If location is a URL whose fragment is null, then set location’s\n    // fragment to requestFragment.\n    if (location && !location.hash) {\n        location.hash = requestFragment;\n    }\n    // 5. Return location.\n    return location;\n}\n/** @returns {URL} */ function requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n    // 1. Let url be request’s current URL.\n    const url = requestCurrentURL(request);\n    // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n    // then return blocked.\n    if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {\n        return \"blocked\";\n    }\n    // 3. Return allowed.\n    return \"allowed\";\n}\nfunction isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === \"Error\" || object?.constructor?.name === \"DOMException\";\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff // obs-text\n        )) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isTokenChar(c) {\n    return !(c >= 0x7f || c <= 0x20 || c === \"(\" || c === \")\" || c === \"<\" || c === \">\" || c === \"@\" || c === \",\" || c === \";\" || c === \":\" || c === \"\\\\\" || c === '\"' || c === \"/\" || c === \"[\" || c === \"]\" || c === \"?\" || c === \"=\" || c === \"{\" || c === \"}\");\n}\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken(characters) {\n    if (!characters || typeof characters !== \"string\") {\n        return false;\n    }\n    for(let i = 0; i < characters.length; ++i){\n        const c = characters.charCodeAt(i);\n        if (c > 0x7f || !isTokenChar(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName(potentialValue) {\n    if (potentialValue.length === 0) {\n        return false;\n    }\n    return isValidHTTPToken(potentialValue);\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    if (potentialValue.startsWith(\"\t\") || potentialValue.startsWith(\" \") || potentialValue.endsWith(\"\t\") || potentialValue.endsWith(\" \")) {\n        return false;\n    }\n    if (potentialValue.includes(\"\\x00\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\n\")) {\n        return false;\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates request’s referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n    const { headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get(\"referrer-policy\") ?? \"\").split(\",\");\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = \"\";\n    if (policyHeader.length > 0) {\n        // The right-most policy takes precedence.\n        // The left-most policy is the fallback.\n        for(let i = policyHeader.length; i !== 0; i--){\n            const token = policyHeader[i - 1].trim();\n            if (referrerPolicyTokens.includes(token)) {\n                policy = token;\n                break;\n            }\n        }\n    }\n    // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n    if (policy !== \"\") {\n        request.referrerPolicy = policy;\n    }\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n    // TODO\n    return \"allowed\";\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n    // TODO\n    return \"success\";\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n    // TODO\n    return \"success\";\n}\nfunction appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: r’s url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set header’s value to r’s mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n    httpRequest.headersList.set(\"sec-fetch-mode\", header);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n    let serializedOrigin = request.origin;\n    // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n    if (request.responseTainting === \"cors\" || request.mode === \"websocket\") {\n        if (serializedOrigin) {\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n    } else if (request.method !== \"GET\" && request.method !== \"HEAD\") {\n        // 1. Switch on request’s referrer policy:\n        switch(request.referrerPolicy){\n            case \"no-referrer\":\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case \"no-referrer-when-downgrade\":\n            case \"strict-origin\":\n            case \"strict-origin-when-cross-origin\":\n                // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n                if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            case \"same-origin\":\n                // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n                if (!sameOrigin(request, requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            default:\n        }\n        if (serializedOrigin) {\n            // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n            request.headersList.append(\"origin\", serializedOrigin);\n        }\n    }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    // TODO\n    return performance.now();\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: \"strict-origin-when-cross-origin\"\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    assert(policy);\n    // 2. Let environment be request’s client.\n    let referrerSource = null;\n    // 3. Switch on request’s referrer:\n    if (request.referrer === \"client\") {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === \"null\") {\n            return \"no-referrer\";\n        }\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) {\n        // Let referrerSource be request’s referrer.\n        referrerSource = request.referrer;\n    }\n    // 4. Let request’s referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    const areSameOrigin = sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case \"origin\":\n            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"same-origin\":\n            return areSameOrigin ? referrerOrigin : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case \"strict-origin-when-cross-origin\":\n            {\n                const currentURL = requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of request’s current\n                //    URL are the same, then return referrerURL.\n                if (sameOrigin(referrerURL, currentURL)) {\n                    return referrerURL;\n                }\n                // 2. If referrerURL is a potentially trustworthy URL and request’s\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n                    return \"no-referrer\";\n                }\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case \"strict-origin\":\n        /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */ case \"no-referrer-when-downgrade\":\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ default:\n            return isNonPotentiallyTrustWorthy ? \"no-referrer\" : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    assert(url instanceof URL);\n    // 2. If url’s scheme is a local scheme, then return no referrer.\n    if (url.protocol === \"file:\" || url.protocol === \"about:\" || url.protocol === \"blank:\") {\n        return \"no-referrer\";\n    }\n    // 3. Set url’s username to the empty string.\n    url.username = \"\";\n    // 4. Set url’s password to the empty string.\n    url.password = \"\";\n    // 5. Set url’s fragment to null.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set url’s path to « the empty string ».\n        url.pathname = \"\";\n        // 2. Set url’s query to null.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) {\n        return false;\n    }\n    // If child of about, return true\n    if (url.href === \"about:blank\" || url.href === \"about:srcdoc\") {\n        return true;\n    }\n    // If scheme is data, return true\n    if (url.protocol === \"data:\") return true;\n    // If file, return true\n    if (url.protocol === \"file:\") return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === \"null\") return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === \"https:\" || originAsURL.protocol === \"wss:\") {\n            return true;\n        }\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === \"localhost\" || originAsURL.hostname.includes(\"localhost.\") || originAsURL.hostname.endsWith(\".localhost\")) {\n            return true;\n        }\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if (crypto === undefined) {\n        return true;\n    }\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === \"no metadata\") {\n        return true;\n    }\n    // 3. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) {\n        return true;\n    }\n    // 4. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const list = parsedMetadata.sort((c, d)=>d.algo.localeCompare(c.algo));\n    // get the strongest algorithm\n    const strongest = list[0].algo;\n    // get all entries that use the strongest algorithm; ignore weaker\n    const metadata = list.filter((item)=>item.algo === strongest);\n    // 5. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        let expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        if (expectedValue.endsWith(\"==\")) {\n            expectedValue = expectedValue.slice(0, -2);\n        }\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = crypto.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue.endsWith(\"==\")) {\n            actualValue = actualValue.slice(0, -2);\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (actualValue === expectedValue) {\n            return true;\n        }\n        let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest(\"base64url\");\n        if (actualBase64URL.endsWith(\"==\")) {\n            actualBase64URL = actualBase64URL.slice(0, -2);\n        }\n        if (actualBase64URL === expectedValue) {\n            return true;\n        }\n    }\n    // 6. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    const supportedHashes = crypto.getHashes();\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(\" \")){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined) {\n            continue;\n        }\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo;\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n            result.push(parsedToken.groups);\n        }\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) {\n        return \"no metadata\";\n    }\n    return result;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === \"null\") {\n        return true;\n    }\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n    }\n    // 3. Return false.\n    return false;\n}\nfunction createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction isAborted(fetchParams) {\n    return fetchParams.controller.state === \"aborted\";\n}\nfunction isCancelled(fetchParams) {\n    return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n}\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod(method) {\n    return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) {\n        throw new TypeError(\"Value is not JSON serializable\");\n    }\n    // 3. Assert: result is a string.\n    assert(typeof result === \"string\");\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */ function makeIterator(iterator, name, kind) {\n    const object = {\n        index: 0,\n        kind,\n        target: iterator\n    };\n    const i = {\n        next () {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (Object.getPrototypeOf(this) !== i) {\n                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            }\n            // 6. Let index be object’s index.\n            // 7. Let kind be object’s kind.\n            // 8. Let values be object’s target's value pairs to iterate over.\n            const { index, kind, target } = object;\n            const values = target();\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            // 11. Let pair be the entry in values at index index.\n            const pair = values[index];\n            // 12. Set object’s index to index + 1.\n            object.index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            return iteratorResult(pair, kind);\n        },\n        // The class string of an iterator prototype object for a given interface is the\n        // result of concatenating the identifier of the interface and the string \" Iterator\".\n        [Symbol.toStringTag]: `${name} Iterator`\n    };\n    // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n    Object.setPrototypeOf(i, esIteratorPrototype);\n    // esIteratorPrototype needs to be the prototype of i\n    // which is the prototype of an empty object. Yes, it's confusing.\n    return Object.setPrototypeOf({}, i);\n}\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n    let result;\n    // 1. Let result be a value determined by the value of kind:\n    switch(kind){\n        case \"key\":\n            {\n                // 1. Let idlKey be pair’s key.\n                // 2. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 3. result is key.\n                result = pair[0];\n                break;\n            }\n        case \"value\":\n            {\n                // 1. Let idlValue be pair’s value.\n                // 2. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 3. result is value.\n                result = pair[1];\n                break;\n            }\n        case \"key+value\":\n            {\n                // 1. Let idlKey be pair’s key.\n                // 2. Let idlValue be pair’s value.\n                // 3. Let key be the result of converting idlKey to an\n                //    ECMAScript value.\n                // 4. Let value be the result of converting idlValue to\n                //    an ECMAScript value.\n                // 5. Let array be ! ArrayCreate(2).\n                // 6. Call ! CreateDataProperty(array, \"0\", key).\n                // 7. Call ! CreateDataProperty(array, \"1\", value).\n                // 8. result is array.\n                result = pair;\n                break;\n            }\n    }\n    // 2. Return CreateIterResultObject(result, false).\n    return {\n        value: result,\n        done: false\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for body’s stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        const result = await readAllBytes(reader);\n        successSteps(result);\n    } catch (e) {\n        errorSteps(e);\n    }\n}\n/** @type {ReadableStream} */ let ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n    if (!ReadableStream) {\n        ReadableStream = (__webpack_require__(/*! stream/web */ \"stream/web\").ReadableStream);\n    }\n    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === \"ReadableStream\" && typeof stream.tee === \"function\";\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */ function isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to input’s length and whose code points have the same values\n    //    as the values of input’s bytes, in the same order.\n    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n        return String.fromCharCode(...input);\n    }\n    return input.reduce((previous, current)=>previous + String.fromCharCode(current), \"\");\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function readableStreamClose(controller) {\n    try {\n        controller.close();\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes(\"Controller is already closed\")) {\n            throw err;\n        }\n    }\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    for(let i = 0; i < input.length; i++){\n        assert(input.charCodeAt(i) <= 0xFF);\n    }\n    // 2. Return a byte sequence whose length is equal to input’s code\n    //    point length and whose bytes have the same values as the\n    //    values of input’s code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done, value: chunk } = await reader.read();\n        if (done) {\n            // 1. Call successSteps with bytes.\n            return Buffer.concat(bytes, byteLength);\n        }\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!isUint8Array(chunk)) {\n            throw new TypeError(\"Received non-Uint8Array chunk\");\n        }\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function urlIsLocal(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"about:\" || protocol === \"blob:\" || protocol === \"data:\";\n}\n/**\n * @param {string|URL} url\n */ function urlHasHttpsScheme(url) {\n    if (typeof url === \"string\") {\n        return url.startsWith(\"https:\");\n    }\n    return url.protocol === \"https:\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function urlIsHttpHttpsScheme(url) {\n    assert(\"protocol\" in url) // ensure it's a url object\n    ;\n    const protocol = url.protocol;\n    return protocol === \"http:\" || protocol === \"https:\";\n}\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */ const hasOwn = Object.hasOwn || ((dict, key)=>Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n    isAborted,\n    isCancelled,\n    createDeferredPromise,\n    ReadableStreamFrom,\n    toUSVString,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    coarsenedSharedCurrentTime,\n    determineRequestsReferrer,\n    makePolicyContainer,\n    clonePolicyContainer,\n    appendFetchMetadata,\n    appendRequestOriginHeader,\n    TAOCheck,\n    corsCheck,\n    crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken,\n    requestBadPort,\n    requestCurrentURL,\n    responseURL,\n    responseLocationURL,\n    isBlobLike,\n    isURLPotentiallyTrustworthy,\n    isValidReasonPhrase,\n    sameOrigin,\n    normalizeMethod,\n    serializeJavascriptValueToJSONString,\n    makeIterator,\n    isValidHeaderName,\n    isValidHeaderValue,\n    hasOwn,\n    isErrorLike,\n    fullyReadBody,\n    bytesMatch,\n    isReadableStreamLike,\n    readableStreamClose,\n    isomorphicEncode,\n    isomorphicDecode,\n    urlIsLocal,\n    urlHasHttpsScheme,\n    urlIsHttpHttpsScheme,\n    readAllBytes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxjQUFjLEVBQUVDLFFBQVEsRUFBRUMsZ0JBQWdCQyxvQkFBb0IsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUNuRixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVHLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUNoRSxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVPLFlBQVksRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUVqQyxrRkFBa0Y7QUFDbEYsdUNBQXVDLEdBQ3ZDLElBQUlRO0FBRUosSUFBSTtJQUNGQSxTQUFTUixtQkFBT0EsQ0FBQztBQUNuQixFQUFFLE9BQU0sQ0FFUjtBQUVBLFNBQVNTLFlBQWFDLFFBQVE7SUFDNUIsMkNBQTJDO0lBQzNDLG9FQUFvRTtJQUNwRSxtRUFBbUU7SUFDbkUsTUFBTUMsVUFBVUQsU0FBU0MsT0FBTztJQUNoQyxNQUFNQyxTQUFTRCxRQUFRQyxNQUFNO0lBQzdCLE9BQU9BLFdBQVcsSUFBSSxPQUFPRCxPQUFPLENBQUNDLFNBQVMsRUFBRSxDQUFDQyxRQUFRO0FBQzNEO0FBRUEsK0RBQStEO0FBQy9ELFNBQVNDLG9CQUFxQkosUUFBUSxFQUFFSyxlQUFlO0lBQ3JELHNFQUFzRTtJQUN0RSxJQUFJLENBQUNuQixlQUFlb0IsUUFBUSxDQUFDTixTQUFTTyxNQUFNLEdBQUc7UUFDN0MsT0FBTztJQUNUO0lBRUEsdUVBQXVFO0lBQ3ZFLHlDQUF5QztJQUN6QyxJQUFJQyxXQUFXUixTQUFTUyxXQUFXLENBQUNDLEdBQUcsQ0FBQztJQUV4Qyx1RUFBdUU7SUFDdkUsMkNBQTJDO0lB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SUFDQStGO0lBQ0EvRDtJQUNBa0M7SUFDQTBGO0lBQ0FFO0lBQ0FVO0lBQ0FoSTtJQUNBdEI7SUFDQW9NO0lBQ0EzTDtJQUNBeUo7SUFDQXhFO0lBQ0FxRjtJQUNBVTtJQUNBSTtJQUNBWDtJQUNBaUI7SUFDQXBKO0lBQ0F4QztJQUNBcUs7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZmV0Y2gvdXRpbC5qcz9iM2JjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHJlZGlyZWN0U3RhdHVzLCBiYWRQb3J0cywgcmVmZXJyZXJQb2xpY3k6IHJlZmVycmVyUG9saWN5VG9rZW5zIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgncGVyZl9ob29rcycpXG5jb25zdCB7IGlzQmxvYkxpa2UsIHRvVVNWU3RyaW5nLCBSZWFkYWJsZVN0cmVhbUZyb20gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBpc1VpbnQ4QXJyYXkgfSA9IHJlcXVpcmUoJ3V0aWwvdHlwZXMnKVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2RldGVybWluaW5nLWlmLWNyeXB0by1zdXBwb3J0LWlzLXVuYXZhaWxhYmxlXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl8dW5kZWZpbmVkfSAqL1xubGV0IGNyeXB0b1xuXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxufSBjYXRjaCB7XG5cbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMi4gTGV0IGxvY2F0aW9uIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW5cbiAgLy8gYExvY2F0aW9uYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJylcblxuICAvLyAzLiBJZiBsb2NhdGlvbiBpcyBhIGhlYWRlciB2YWx1ZSwgdGhlbiBzZXQgbG9jYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBwYXJzaW5nIGxvY2F0aW9uIHdpdGggcmVzcG9uc2XigJlzIFVSTC5cbiAgaWYgKGxvY2F0aW9uICE9PSBudWxsICYmIGlzVmFsaWRIZWFkZXJWYWx1ZShsb2NhdGlvbikpIHtcbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzLmluY2x1ZGVzKHVybC5wb3J0KSkge1xuICAgIHJldHVybiAnYmxvY2tlZCdcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbGxvd2VkLlxuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEVycm9yIHx8IChcbiAgICBvYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRXJyb3InIHx8XG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbidcbiAgKVxufVxuXG4vLyBDaGVjayB3aGV0aGVyIHxzdGF0dXNUZXh0fCBpcyBhIEJ5dGVTdHJpbmcgYW5kXG4vLyBtYXRjaGVzIHRoZSBSZWFzb24tUGhyYXNlIHRva2VuIHByb2R1Y3Rpb24uXG4vLyBSRkMgMjYxNjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTZcbi8vIFJGQyA3MjMwOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMFxuLy8gXCJyZWFzb24tcGhyYXNlID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXCJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iLzk0LjAuNDYwNC4xL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZmV0Y2gvcmVzcG9uc2UuY2MjTDExNlxuZnVuY3Rpb24gaXNWYWxpZFJlYXNvblBocmFzZSAoc3RhdHVzVGV4dCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXR1c1RleHQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjID0gc3RhdHVzVGV4dC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgKFxuICAgICAgICAgIGMgPT09IDB4MDkgfHwgLy8gSFRBQlxuICAgICAgICAgIChjID49IDB4MjAgJiYgYyA8PSAweDdlKSB8fCAvLyBTUCAvIFZDSEFSXG4gICAgICAgICAgKGMgPj0gMHg4MCAmJiBjIDw9IDB4ZmYpXG4gICAgICAgICkgLy8gb2JzLXRleHRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1Rva2VuQ2hhciAoYykge1xuICByZXR1cm4gIShcbiAgICBjID49IDB4N2YgfHxcbiAgICBjIDw9IDB4MjAgfHxcbiAgICBjID09PSAnKCcgfHxcbiAgICBjID09PSAnKScgfHxcbiAgICBjID09PSAnPCcgfHxcbiAgICBjID09PSAnPicgfHxcbiAgICBjID09PSAnQCcgfHxcbiAgICBjID09PSAnLCcgfHxcbiAgICBjID09PSAnOycgfHxcbiAgICBjID09PSAnOicgfHxcbiAgICBjID09PSAnXFxcXCcgfHxcbiAgICBjID09PSAnXCInIHx8XG4gICAgYyA9PT0gJy8nIHx8XG4gICAgYyA9PT0gJ1snIHx8XG4gICAgYyA9PT0gJ10nIHx8XG4gICAgYyA9PT0gJz8nIHx8XG4gICAgYyA9PT0gJz0nIHx8XG4gICAgYyA9PT0gJ3snIHx8XG4gICAgYyA9PT0gJ30nXG4gIClcbn1cblxuLy8gU2VlIFJGQyA3MjMwLCBTZWN0aW9uIDMuMi42LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvZDdkYTAyNDBjYWU3NzgyNGQxZWRhMjU3NDVjNDAyMjc1NzQ5OTEzMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9wbGF0Zm9ybS9uZXR3b3JrL2h0dHBfcGFyc2Vycy5jYyNMMzIxXG5mdW5jdGlvbiBpc1ZhbGlkSFRUUFRva2VuIChjaGFyYWN0ZXJzKSB7XG4gIGlmICghY2hhcmFjdGVycyB8fCB0eXBlb2YgY2hhcmFjdGVycyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjID0gY2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGMgPiAweDdmIHx8ICFpc1Rva2VuQ2hhcihjKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvYjNkMzdlNmY5NGY4N2Q1OWU0NDY2MmQ2MDc4ZjZhMTJkZTg0NWQxNy9uZXQvaHR0cC9odHRwX3V0aWwuY2MjTDM0MlxuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIGlmIChwb3RlbnRpYWxWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBpc1ZhbGlkSFRUUFRva2VuKHBvdGVudGlhbFZhbHVlKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgaWYgKFxuICAgIHBvdGVudGlhbFZhbHVlLnN0YXJ0c1dpdGgoJ1xcdCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuc3RhcnRzV2l0aCgnICcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuZW5kc1dpdGgoJ1xcdCcpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuZW5kc1dpdGgoJyAnKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFwwJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxyJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxuJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCAocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICAvLyAgdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAgLy8gIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBhY3R1YWxSZXNwb25zZVxuICAvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIE5vdGU6IEFzIHRoZSByZWZlcnJlci1wb2xpY3kgY2FuIGNvbnRhaW4gbXVsdGlwbGUgcG9saWNpZXNcbiAgLy8gc2VwYXJhdGVkIGJ5IGNvbW1hLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbVxuICAvLyBhbmQgcGljayB0aGUgZmlyc3QgdmFsaWQgb25lLlxuICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZWZlcnJlci1Qb2xpY3kjc3BlY2lmeV9hX2ZhbGxiYWNrX3BvbGljeVxuICBsZXQgcG9saWN5ID0gJydcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgcG9saWN5ID0gdG9rZW5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAyLiBJZiBwb2xpY3kgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byBwb2xpY3kuXG4gIGlmIChwb2xpY3kgIT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHBvbGljeVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjcm9zcy1vcmlnaW4tcmVzb3VyY2UtcG9saWN5LWNoZWNrXG5mdW5jdGlvbiBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnYWxsb3dlZCdcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY29ycy1jaGVja1xuZnVuY3Rpb24gY29yc0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXRhby1jaGVja1xuZnVuY3Rpb24gVEFPQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuZnVuY3Rpb24gYXBwZW5kRmV0Y2hNZXRhZGF0YSAoaHR0cFJlcXVlc3QpIHtcbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1kZXN0LWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtbW9kZS1oZWFkZXJcblxuICAvLyAgMS4gQXNzZXJ0OiBy4oCZcyB1cmwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwuXG4gIC8vICBUT0RPXG5cbiAgLy8gIDIuIExldCBoZWFkZXIgYmUgYSBTdHJ1Y3R1cmVkIEhlYWRlciB3aG9zZSB2YWx1ZSBpcyBhIHRva2VuLlxuICBsZXQgaGVhZGVyID0gbnVsbFxuXG4gIC8vICAzLiBTZXQgaGVhZGVy4oCZcyB2YWx1ZSB0byBy4oCZcyBtb2RlLlxuICBoZWFkZXIgPSBodHRwUmVxdWVzdC5tb2RlXG5cbiAgLy8gIDQuIFNldCBhIHN0cnVjdHVyZWQgZmllbGQgdmFsdWUgYFNlYy1GZXRjaC1Nb2RlYC9oZWFkZXIgaW4gcuKAmXMgaGVhZGVyIGxpc3QuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnc2VjLWZldGNoLW1vZGUnLCBoZWFkZXIpXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1zaXRlLWhlYWRlclxuICAvLyAgVE9ET1xuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtdXNlci1oZWFkZXJcbiAgLy8gIFRPRE9cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2FwcGVuZC1hLXJlcXVlc3Qtb3JpZ2luLWhlYWRlclxuZnVuY3Rpb24gYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgc2VyaWFsaXplZE9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIGJ5dGUtc2VyaWFsaXppbmcgYSByZXF1ZXN0IG9yaWdpbiB3aXRoIHJlcXVlc3QuXG4gIGxldCBzZXJpYWxpemVkT3JpZ2luID0gcmVxdWVzdC5vcmlnaW5cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBvciByZXF1ZXN04oCZcyBtb2RlIGlzIFwid2Vic29ja2V0XCIsIHRoZW4gYXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgaWYgKHNlcmlhbGl6ZWRPcmlnaW4pIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luKVxuICAgIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIGlmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBuZWl0aGVyIGBHRVRgIG5vciBgSEVBRGAsIHRoZW46XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAvLyAxLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5OlxuICAgIHN3aXRjaCAocmVxdWVzdC5yZWZlcnJlclBvbGljeSkge1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXInOlxuICAgICAgICAvLyBTZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZSc6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4sIGl0cyBzY2hlbWUgaXMgXCJodHRwc1wiLCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBub3QgXCJodHRwc1wiLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKHJlcXVlc3Qub3JpZ2luICYmIHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3Qub3JpZ2luKSAmJiAhdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgICAvLyBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbiwgdGhlbiBzZXQgc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0LCByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH1cblxuICAgIGlmIChzZXJpYWxpemVkT3JpZ2luKSB7XG4gICAgICAvLyAyLiBBcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSAoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1hbi1vcGFxdWUtdGltaW5nLWluZm9cbmZ1bmN0aW9uIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8gKHRpbWluZ0luZm8pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lID8/IDAsXG4gICAgcmVkaXJlY3RTdGFydFRpbWU6IDAsXG4gICAgcmVkaXJlY3RFbmRUaW1lOiAwLFxuICAgIHBvc3RSZWRpcmVjdFN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICBmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZTogMCxcbiAgICBlbmRUaW1lOiAwLFxuICAgIGVuY29kZWRCb2R5U2l6ZTogMCxcbiAgICBkZWNvZGVkQm9keVNpemU6IDAsXG4gICAgZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzogbnVsbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3BvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIG1ha2VQb2xpY3lDb250YWluZXIgKCkge1xuICAvLyBOb3RlOiB0aGUgZmV0Y2ggc3BlYyBkb2Vzbid0IG1ha2UgdXNlIG9mIGVtYmVkZGVyIHBvbGljeSBvciBDU1AgbGlzdFxuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbidcbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNjbG9uZS1hLXBvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIGNsb25lUG9saWN5Q29udGFpbmVyIChwb2xpY3lDb250YWluZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZWZlcnJlclBvbGljeTogcG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlclxuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgcG9saWN5IGJlIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kuXG4gIGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3lcblxuICAvLyBOb3RlOiBwb2xpY3kgY2Fubm90IChzaG91bGRuJ3QpIGJlIG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICBhc3NlcnQocG9saWN5KVxuXG4gIC8vIDIuIExldCBlbnZpcm9ubWVudCBiZSByZXF1ZXN04oCZcyBjbGllbnQuXG5cbiAgbGV0IHJlZmVycmVyU291cmNlID0gbnVsbFxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlcjpcbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gTm90ZTogbm9kZSBpc24ndCBhIGJyb3dzZXIgYW5kIGRvZXNuJ3QgaW1wbGVtZW50IGRvY3VtZW50L2lmcmFtZXMsXG4gICAgLy8gc28gd2UgYnlwYXNzIHRoaXMgc3RlcCBhbmQgcmVwbGFjZSBpdCB3aXRoIG91ciBvd24uXG5cbiAgICBjb25zdCBnbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW4oKVxuXG4gICAgaWYgKCFnbG9iYWxPcmlnaW4gfHwgZ2xvYmFsT3JpZ2luLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIG5vdGU6IHdlIG5lZWQgdG8gY2xvbmUgaXQgYXMgaXQncyBtdXRhdGVkXG4gICAgcmVmZXJyZXJTb3VyY2UgPSBuZXcgVVJMKGdsb2JhbE9yaWdpbilcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgLy8gTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgIHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlclxuICB9XG5cbiAgLy8gNC4gTGV0IHJlcXVlc3TigJlzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvclxuICAvLyAgICB1c2UgYXMgYSByZWZlcnJlci5cbiAgbGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSlcblxuICAvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhc1xuICAvLyAgICBhIHJlZmVycmVyLCB3aXRoIHRoZSBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuICBjb25zdCByZWZlcnJlck9yaWdpbiA9IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG5cbiAgLy8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXNcbiAgLy8gICAgZ3JlYXRlciB0aGFuIDQwOTYsIHNldCByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cbiAgaWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuICAgIHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW5cbiAgfVxuXG4gIGNvbnN0IGFyZVNhbWVPcmlnaW4gPSBzYW1lT3JpZ2luKHJlcXVlc3QsIHJlZmVycmVyVVJMKVxuICBjb25zdCBpc05vblBvdGVudGlhbGx5VHJ1c3RXb3J0aHkgPSBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmXG4gICAgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZXF1ZXN0LnVybClcblxuICAvLyA4LiBFeGVjdXRlIHRoZSBzd2l0Y2ggc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG4gIHN3aXRjaCAocG9saWN5KSB7XG4gICAgY2FzZSAnb3JpZ2luJzogcmV0dXJuIHJlZmVycmVyT3JpZ2luICE9IG51bGwgPyByZWZlcnJlck9yaWdpbiA6IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG4gICAgY2FzZSAndW5zYWZlLXVybCc6IHJldHVybiByZWZlcnJlclVSTFxuICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJPcmlnaW4gOiAnbm8tcmVmZXJyZXInXG4gICAgY2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJVUkwgOiByZWZlcnJlck9yaWdpblxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgLy8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN04oCZcyBjdXJyZW50XG4gICAgICAvLyAgICBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuIHJldHVybiByZWZlcnJlclVSTC5cbiAgICAgIGlmIChzYW1lT3JpZ2luKHJlZmVycmVyVVJMLCBjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3TigJlzXG4gICAgICAvLyAgICBjdXJyZW50IFVSTCBpcyBub3QgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vXG4gICAgICAvLyAgICByZWZlcnJlci5cbiAgICAgIGlmIChpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcbiAgICAgICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgICAgIH1cblxuICAgICAgLy8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgfVxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAgICogMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kXG4gICAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgICAqIDIuIFJldHVybiByZWZlcnJlck9yaWdpblxuICAgICAgICAqL1xuICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLyoqXG4gICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAqIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAqL1xuXG4gICAgZGVmYXVsdDogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA/ICduby1yZWZlcnJlcicgOiByZWZlcnJlck9yaWdpblxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvcmlnaW5Pbmx5XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVVJMRm9yUmVmZXJyZXIgKHVybCwgb3JpZ2luT25seSkge1xuICAvLyAxLiBBc3NlcnQ6IHVybCBpcyBhIFVSTC5cbiAgYXNzZXJ0KHVybCBpbnN0YW5jZW9mIFVSTClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZSwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicgfHwgdXJsLnByb3RvY29sID09PSAnYWJvdXQ6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdibGFuazonKSB7XG4gICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgfVxuXG4gIC8vIDMuIFNldCB1cmzigJlzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHVybC51c2VybmFtZSA9ICcnXG5cbiAgLy8gNC4gU2V0IHVybOKAmXMgcGFzc3dvcmQgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnBhc3N3b3JkID0gJydcblxuICAvLyA1LiBTZXQgdXJs4oCZcyBmcmFnbWVudCB0byBudWxsLlxuICB1cmwuaGFzaCA9ICcnXG5cbiAgLy8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKG9yaWdpbk9ubHkpIHtcbiAgICAvLyAxLiBTZXQgdXJs4oCZcyBwYXRoIHRvIMKrIHRoZSBlbXB0eSBzdHJpbmcgwrsuXG4gICAgdXJsLnBhdGhuYW1lID0gJydcblxuICAgIC8vIDIuIFNldCB1cmzigJlzIHF1ZXJ5IHRvIG51bGwuXG4gICAgdXJsLnNlYXJjaCA9ICcnXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdXJsLlxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAodXJsKSB7XG4gIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIElmIGNoaWxkIG9mIGFib3V0LCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLmhyZWYgPT09ICdhYm91dDpibGFuaycgfHwgdXJsLmhyZWYgPT09ICdhYm91dDpzcmNkb2MnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHNjaGVtZSBpcyBkYXRhLCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSByZXR1cm4gdHJ1ZVxuXG4gIC8vIElmIGZpbGUsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwub3JpZ2luKVxuXG4gIGZ1bmN0aW9uIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAob3JpZ2luKSB7XG4gICAgLy8gSWYgb3JpZ2luIGlzIGV4cGxpY2l0bHkgbnVsbCwgcmV0dXJuIGZhbHNlXG4gICAgaWYgKG9yaWdpbiA9PSBudWxsIHx8IG9yaWdpbiA9PT0gJ251bGwnKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IG9yaWdpbkFzVVJMID0gbmV3IFVSTChvcmlnaW4pXG5cbiAgICAvLyBJZiBzZWN1cmUsIHJldHVybiB0cnVlXG4gICAgaWYgKG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBvcmlnaW5Bc1VSTC5wcm90b2NvbCA9PT0gJ3dzczonKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGxvY2FsaG9zdCBvciB2YXJpYW50cywgcmV0dXJuIHRydWVcbiAgICBpZiAoL14xMjcoPzpcXC5bMC05XSspezAsMn1cXC5bMC05XSskfF5cXFsoPzowKjopKj86PzAqMVxcXSQvLnRlc3Qob3JpZ2luQXNVUkwuaG9zdG5hbWUpIHx8XG4gICAgIChvcmlnaW5Bc1VSTC5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgb3JpZ2luQXNVUkwuaG9zdG5hbWUuaW5jbHVkZXMoJ2xvY2FsaG9zdC4nKSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lLmVuZHNXaXRoKCcubG9jYWxob3N0JykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGFueSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNkb2VzLXJlc3BvbnNlLW1hdGNoLW1ldGFkYXRhbGlzdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBieXRlc01hdGNoIChieXRlcywgbWV0YWRhdGFMaXN0KSB7XG4gIC8vIElmIG5vZGUgaXMgbm90IGJ1aWx0IHdpdGggT3BlblNTTCBzdXBwb3J0LCB3ZSBjYW5ub3QgY2hlY2tcbiAgLy8gYSByZXF1ZXN0J3MgaW50ZWdyaXR5LCBzbyBhbGxvdyBpdCBieSBkZWZhdWx0ICh0aGUgc3BlYyB3aWxsXG4gIC8vIGFsbG93IHJlcXVlc3RzIGlmIGFuIGludmFsaWQgaGFzaCBpcyBnaXZlbiwgYXMgcHJlY2VkZW5jZSkuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogb25seSBpZiBub2RlIGlzIGJ1aWx0IHdpdGggLS13aXRob3V0LXNzbCAqL1xuICBpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMS4gTGV0IHBhcnNlZE1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBtZXRhZGF0YUxpc3QuXG4gIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gcGFyc2VNZXRhZGF0YShtZXRhZGF0YUxpc3QpXG5cbiAgLy8gMi4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgbm8gbWV0YWRhdGEsIHJldHVybiB0cnVlLlxuICBpZiAocGFyc2VkTWV0YWRhdGEgPT09ICdubyBtZXRhZGF0YScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgdGhlIGVtcHR5IHNldCwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNC4gTGV0IG1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyB0aGUgc3Ryb25nZXN0XG4gIC8vICAgIG1ldGFkYXRhIGZyb20gcGFyc2VkTWV0YWRhdGEuXG4gIGNvbnN0IGxpc3QgPSBwYXJzZWRNZXRhZGF0YS5zb3J0KChjLCBkKSA9PiBkLmFsZ28ubG9jYWxlQ29tcGFyZShjLmFsZ28pKVxuICAvLyBnZXQgdGhlIHN0cm9uZ2VzdCBhbGdvcml0aG1cbiAgY29uc3Qgc3Ryb25nZXN0ID0gbGlzdFswXS5hbGdvXG4gIC8vIGdldCBhbGwgZW50cmllcyB0aGF0IHVzZSB0aGUgc3Ryb25nZXN0IGFsZ29yaXRobTsgaWdub3JlIHdlYWtlclxuICBjb25zdCBtZXRhZGF0YSA9IGxpc3QuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFsZ28gPT09IHN0cm9uZ2VzdClcblxuICAvLyA1LiBGb3IgZWFjaCBpdGVtIGluIG1ldGFkYXRhOlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAvLyAxLiBMZXQgYWxnb3JpdGhtIGJlIHRoZSBhbGcgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvXG5cbiAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgdmFsIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGxldCBleHBlY3RlZFZhbHVlID0gaXRlbS5oYXNoXG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvY29tbWl0L2U0YzVjYzdhNWU0ODA5MzIyMDUyOGRmZGQxYzQwMTJkYzM4MzdhMGVcbiAgICAvLyBcImJlIGxpYmVyYWwgd2l0aCBwYWRkaW5nXCIuIFRoaXMgaXMgYW5ub3lpbmcsIGFuZCBpdCdzIG5vdCBldmVuIGluIHRoZSBzcGVjLlxuXG4gICAgaWYgKGV4cGVjdGVkVmFsdWUuZW5kc1dpdGgoJz09JykpIHtcbiAgICAgIGV4cGVjdGVkVmFsdWUgPSBleHBlY3RlZFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIC8vIDMuIExldCBhY3R1YWxWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFsZ29yaXRobSB0byBieXRlcy5cbiAgICBsZXQgYWN0dWFsVmFsdWUgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShieXRlcykuZGlnZXN0KCdiYXNlNjQnKVxuXG4gICAgaWYgKGFjdHVhbFZhbHVlLmVuZHNXaXRoKCc9PScpKSB7XG4gICAgICBhY3R1YWxWYWx1ZSA9IGFjdHVhbFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIC8vIDQuIElmIGFjdHVhbFZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgbWF0Y2ggZm9yIGV4cGVjdGVkVmFsdWUsXG4gICAgLy8gICAgcmV0dXJuIHRydWUuXG4gICAgaWYgKGFjdHVhbFZhbHVlID09PSBleHBlY3RlZFZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBhY3R1YWxCYXNlNjRVUkwgPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShieXRlcykuZGlnZXN0KCdiYXNlNjR1cmwnKVxuXG4gICAgaWYgKGFjdHVhbEJhc2U2NFVSTC5lbmRzV2l0aCgnPT0nKSkge1xuICAgICAgYWN0dWFsQmFzZTY0VVJMID0gYWN0dWFsQmFzZTY0VVJMLnNsaWNlKDAsIC0yKVxuICAgIH1cblxuICAgIGlmIChhY3R1YWxCYXNlNjRVUkwgPT09IGV4cGVjdGVkVmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2dyYW1tYXJkZWYtaGFzaC13aXRoLW9wdGlvbnNcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9DU1AyLyNzb3VyY2UtbGlzdC1zeW50YXhcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1MjM0I2FwcGVuZGl4LUIuMVxuY29uc3QgcGFyc2VIYXNoV2l0aE9wdGlvbnMgPSAvKCg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSg/PGhhc2g+W0EtejAtOSsvXXsxfS4qPXswLDJ9KSkoICtbXFx4MjEtXFx4N2VdPyk/L2lcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNwYXJzZS1tZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEgKG1ldGFkYXRhKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHNldC5cbiAgLyoqIEB0eXBlIHt7IGFsZ286IHN0cmluZywgaGFzaDogc3RyaW5nIH1bXX0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICAvLyAyLiBMZXQgZW1wdHkgYmUgZXF1YWwgdG8gdHJ1ZS5cbiAgbGV0IGVtcHR5ID0gdHJ1ZVxuXG4gIGNvbnN0IHN1cHBvcnRlZEhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMoKVxuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIHJldHVybmVkIGJ5IHNwbGl0dGluZyBtZXRhZGF0YSBvbiBzcGFjZXM6XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgbWV0YWRhdGEuc3BsaXQoJyAnKSkge1xuICAgIC8vIDEuIFNldCBlbXB0eSB0byBmYWxzZS5cbiAgICBlbXB0eSA9IGZhbHNlXG5cbiAgICAvLyAyLiBQYXJzZSB0b2tlbiBhcyBhIGhhc2gtd2l0aC1vcHRpb25zLlxuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gcGFyc2VIYXNoV2l0aE9wdGlvbnMuZXhlYyh0b2tlbilcblxuICAgIC8vIDMuIElmIHRva2VuIGRvZXMgbm90IHBhcnNlLCBjb250aW51ZSB0byB0aGUgbmV4dCB0b2tlbi5cbiAgICBpZiAocGFyc2VkVG9rZW4gPT09IG51bGwgfHwgcGFyc2VkVG9rZW4uZ3JvdXBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vdGU6IENocm9taXVtIGJsb2NrcyB0aGUgcmVxdWVzdCBhdCB0aGlzIHBvaW50LCBidXQgRmlyZWZveFxuICAgICAgLy8gZ2l2ZXMgYSB3YXJuaW5nIHRoYXQgYW4gaW52YWxpZCBpbnRlZ3JpdHkgd2FzIGdpdmVuLiBUaGVcbiAgICAgIC8vIGNvcnJlY3QgYmVoYXZpb3IgaXMgdG8gaWdub3JlIHRoZXNlLCBhbmQgc3Vic2VxdWVudGx5IG5vdFxuICAgICAgLy8gY2hlY2sgdGhlIGludGVncml0eSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDQuIExldCBhbGdvcml0aG0gYmUgdGhlIGhhc2gtYWxnbyBjb21wb25lbnQgb2YgdG9rZW4uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ29cblxuICAgIC8vIDUuIElmIGFsZ29yaXRobSBpcyBhIGhhc2ggZnVuY3Rpb24gcmVjb2duaXplZCBieSB0aGUgdXNlclxuICAgIC8vICAgIGFnZW50LCBhZGQgdGhlIHBhcnNlZCB0b2tlbiB0byByZXN1bHQuXG4gICAgaWYgKHN1cHBvcnRlZEhhc2hlcy5pbmNsdWRlcyhhbGdvcml0aG0udG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZFRva2VuLmdyb3VwcylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbm8gbWV0YWRhdGEgaWYgZW1wdHkgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiByZXN1bHQuXG4gIGlmIChlbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnbm8gbWV0YWRhdGEnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtdXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cy8jdXBncmFkZS1yZXF1ZXN0XG5mdW5jdGlvbiB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwgKHJlcXVlc3QpIHtcbiAgLy8gVE9ET1xufVxuXG4vKipcbiAqIEBsaW5rIHtodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNzYW1lLW9yaWdpbn1cbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICovXG5mdW5jdGlvbiBzYW1lT3JpZ2luIChBLCBCKSB7XG4gIC8vIDEuIElmIEEgYW5kIEIgYXJlIHRoZSBzYW1lIG9wYXF1ZSBvcmlnaW4sIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLm9yaWdpbiA9PT0gQi5vcmlnaW4gJiYgQS5vcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiBBIGFuZCBCIGFyZSBib3RoIHR1cGxlIG9yaWdpbnMgYW5kIHRoZWlyIHNjaGVtZXMsXG4gIC8vICAgIGhvc3RzLCBhbmQgcG9ydCBhcmUgaWRlbnRpY2FsLCB0aGVuIHJldHVybiB0cnVlLlxuICBpZiAoQS5wcm90b2NvbCA9PT0gQi5wcm90b2NvbCAmJiBBLmhvc3RuYW1lID09PSBCLmhvc3RuYW1lICYmIEEucG9ydCA9PT0gQi5wb3J0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSAoKSB7XG4gIGxldCByZXNcbiAgbGV0IHJlalxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSlcblxuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXMsIHJlamVjdDogcmVqIH1cbn1cblxuZnVuY3Rpb24gaXNBYm9ydGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZCAobWV0aG9kKSB7XG4gIHJldHVybiAvXihERUxFVEV8R0VUfEhFQUR8T1BUSU9OU3xQT1NUfFBVVCkkL2kudGVzdChtZXRob2QpXG4gICAgPyBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIDogbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0geydrZXknfCd2YWx1ZSd8J2tleSt2YWx1ZSd9IGtpbmRcbiAqL1xuZnVuY3Rpb24gbWFrZUl0ZXJhdG9yIChpdGVyYXRvciwgbmFtZSwga2luZCkge1xuICBjb25zdCBvYmplY3QgPSB7XG4gICAgaW5kZXg6IDAsXG4gICAga2luZCxcbiAgICB0YXJnZXQ6IGl0ZXJhdG9yXG4gIH1cblxuICBjb25zdCBpID0ge1xuICAgIG5leHQgKCkge1xuICAgICAgLy8gMS4gTGV0IGludGVyZmFjZSBiZSB0aGUgaW50ZXJmYWNlIGZvciB3aGljaCB0aGUgaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBleGlzdHMuXG5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG5cbiAgICAgIC8vIDMuIExldCBvYmplY3QgYmUgPyBUb09iamVjdCh0aGlzVmFsdWUpLlxuXG4gICAgICAvLyA0LiBJZiBvYmplY3QgaXMgYSBwbGF0Zm9ybSBvYmplY3QsIHRoZW4gcGVyZm9ybSBhIHNlY3VyaXR5XG4gICAgICAvLyAgICBjaGVjaywgcGFzc2luZzpcblxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgeyBpbmRleCwga2luZCwgdGFyZ2V0IH0gPSBvYmplY3RcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRhcmdldCgpXG5cbiAgICAgIC8vIDkuIExldCBsZW4gYmUgdGhlIGxlbmd0aCBvZiB2YWx1ZXMuXG4gICAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIDEwLiBJZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbGVuLCB0aGVuIHJldHVyblxuICAgICAgLy8gICAgIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKS5cbiAgICAgIGlmIChpbmRleCA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgICB9XG5cbiAgICAgIC8vIDExLiBMZXQgcGFpciBiZSB0aGUgZW50cnkgaW4gdmFsdWVzIGF0IGluZGV4IGluZGV4LlxuICAgICAgY29uc3QgcGFpciA9IHZhbHVlc1tpbmRleF1cblxuICAgICAgLy8gMTIuIFNldCBvYmplY3TigJlzIGluZGV4IHRvIGluZGV4ICsgMS5cbiAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4ICsgMVxuXG4gICAgICAvLyAxMy4gUmV0dXJuIHRoZSBpdGVyYXRvciByZXN1bHQgZm9yIHBhaXIgYW5kIGtpbmQuXG4gICAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQocGFpciwga2luZClcbiAgICB9LFxuICAgIC8vIFRoZSBjbGFzcyBzdHJpbmcgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBmb3IgYSBnaXZlbiBpbnRlcmZhY2UgaXMgdGhlXG4gICAgLy8gcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGludGVyZmFjZSBhbmQgdGhlIHN0cmluZyBcIiBJdGVyYXRvclwiLlxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiBgJHtuYW1lfSBJdGVyYXRvcmBcbiAgfVxuXG4gIC8vIFRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHNsb3Qgb2YgYW4gaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBtdXN0IGJlICVJdGVyYXRvclByb3RvdHlwZSUuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihpLCBlc0l0ZXJhdG9yUHJvdG90eXBlKVxuICAvLyBlc0l0ZXJhdG9yUHJvdG90eXBlIG5lZWRzIHRvIGJlIHRoZSBwcm90b3R5cGUgb2YgaVxuICAvLyB3aGljaCBpcyB0aGUgcHJvdG90eXBlIG9mIGFuIGVtcHR5IG9iamVjdC4gWWVzLCBpdCdzIGNvbmZ1c2luZy5cbiAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZih7fSwgaSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpdGVyYXRvci1yZXN1bHRcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzdWx0IChwYWlyLCBraW5kKSB7XG4gIGxldCByZXN1bHRcblxuICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAna2V5Jzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyAzLiByZXN1bHQgaXMga2V5LlxuICAgICAgcmVzdWx0ID0gcGFpclswXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAndmFsdWUnOiB7XG4gICAgICAvLyAxLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gMy4gcmVzdWx0IGlzIHZhbHVlLlxuICAgICAgcmVzdWx0ID0gcGFpclsxXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAna2V5K3ZhbHVlJzoge1xuICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAvLyAyLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAvLyA0LiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAvLyA2LiBDYWxsICEgQ3JlYXRlRGF0YVByb3BlcnR5KGFycmF5LCBcIjBcIiwga2V5KS5cbiAgICAgIC8vIDcuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMVwiLCB2YWx1ZSkuXG4gICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICByZXN1bHQgPSBwYWlyXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuIFJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlc3VsdCwgZmFsc2UpLlxuICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS1mdWxseS1yZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZ1bGx5UmVhZEJvZHkgKGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gIC8vIDEuIElmIHRhc2tEZXN0aW5hdGlvbiBpcyBudWxsLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG9cbiAgLy8gICAgdGhlIHJlc3VsdCBvZiBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cblxuICAvLyAyLiBMZXQgc3VjY2Vzc1N0ZXBzIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlcyBiZSB0byBxdWV1ZSBhXG4gIC8vICAgIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzLCB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gcHJvY2Vzc0JvZHlcblxuICAvLyAzLiBMZXQgZXJyb3JTdGVwcyBiZSB0byBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5RXJyb3IsXG4gIC8vICAgIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBlcnJvclN0ZXBzID0gcHJvY2Vzc0JvZHlFcnJvclxuXG4gIC8vIDQuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZvciBib2R54oCZcyBzdHJlYW0uXG4gIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzIHdpdGggdGhhdFxuICAvLyAgICBleGNlcHRpb24gYW5kIHJldHVybi5cbiAgbGV0IHJlYWRlclxuXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yU3RlcHMoZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcilcbiAgICBzdWNjZXNzU3RlcHMocmVzdWx0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICB9XG59XG5cbi8qKiBAdHlwZSB7UmVhZGFibGVTdHJlYW19ICovXG5sZXQgUmVhZGFibGVTdHJlYW0gPSBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtXG5cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlIChzdHJlYW0pIHtcbiAgaWYgKCFSZWFkYWJsZVN0cmVhbSkge1xuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtXG4gIH1cblxuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG5jb25zdCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCA9IDY1NTM1XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1kZWNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyW118VWludDhBcnJheX0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0RlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gVG8gaXNvbW9ycGhpYyBkZWNvZGUgYSBieXRlIHNlcXVlbmNlIGlucHV0LCByZXR1cm4gYSBzdHJpbmcgd2hvc2UgY29kZSBwb2ludFxuICAvLyAgICBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGxlbmd0aCBhbmQgd2hvc2UgY29kZSBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXNcbiAgLy8gICAgYXMgdGhlIHZhbHVlcyBvZiBpbnB1dOKAmXMgYnl0ZXMsIGluIHRoZSBzYW1lIG9yZGVyLlxuXG4gIGlmIChpbnB1dC5sZW5ndGggPCBNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmlucHV0KVxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgU3RyaW5nLmZyb21DaGFyQ29kZShjdXJyZW50KSwgJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8VWludDhBcnJheT59IGNvbnRyb2xsZXJcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1DbG9zZSAoY29udHJvbGxlcikge1xuICB0cnkge1xuICAgIGNvbnRyb2xsZXIuY2xvc2UoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUT0RPOiBhZGQgY29tbWVudCBleHBsYWluaW5nIHdoeSB0aGlzIGVycm9yIG9jY3Vycy5cbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdDb250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2lzb21vcnBoaWMtZW5jb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0VuY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gQXNzZXJ0OiBpbnB1dCBjb250YWlucyBubyBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVSswMEZGLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXNzZXJ0KGlucHV0LmNoYXJDb2RlQXQoaSkgPD0gMHhGRilcbiAgfVxuXG4gIC8vIDIuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugd2hvc2UgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBjb2RlXG4gIC8vICAgIHBvaW50IGxlbmd0aCBhbmQgd2hvc2UgYnl0ZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gIC8vICAgIHZhbHVlcyBvZiBpbnB1dOKAmXMgY29kZSBwb2ludHMsIGluIHRoZSBzYW1lIG9yZGVyXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW1kZWZhdWx0cmVhZGVyLXJlYWQtYWxsLWJ5dGVzXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWQtbG9vcFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IHJlYWRlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMgKHJlYWRlcikge1xuICBjb25zdCBieXRlcyA9IFtdXG4gIGxldCBieXRlTGVuZ3RoID0gMFxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyAxLiBDYWxsIHN1Y2Nlc3NTdGVwcyB3aXRoIGJ5dGVzLlxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnl0ZXMsIGJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY2h1bmsgaXMgbm90IGEgVWludDhBcnJheSBvYmplY3QsIGNhbGwgZmFpbHVyZVN0ZXBzXG4gICAgLy8gICAgd2l0aCBhIFR5cGVFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBub24tVWludDhBcnJheSBjaHVuaycpXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIHRoZSBieXRlcyByZXByZXNlbnRlZCBieSBjaHVuayB0byBieXRlcy5cbiAgICBieXRlcy5wdXNoKGNodW5rKVxuICAgIGJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICAvLyAzLiBSZWFkLWxvb3AgZ2l2ZW4gcmVhZGVyLCBieXRlcywgc3VjY2Vzc1N0ZXBzLCBhbmQgZmFpbHVyZVN0ZXBzLlxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaXMtbG9jYWxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNMb2NhbCAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHByb3RvY29sID09PSAnYmxvYjonIHx8IHByb3RvY29sID09PSAnZGF0YTonXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSGFzSHR0cHNTY2hlbWUgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpXG4gIH1cblxuICByZXR1cm4gdXJsLnByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtc2NoZW1lXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKi9cbmZ1bmN0aW9uIHVybElzSHR0cEh0dHBzU2NoZW1lICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOidcbn1cblxuLyoqXG4gKiBGZXRjaCBzdXBwb3J0cyBub2RlID49IDE2LjguMCwgYnV0IE9iamVjdC5oYXNPd24gd2FzIGFkZGVkIGluIHYxNi45LjAuXG4gKi9cbmNvbnN0IGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKChkaWN0LCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaWN0LCBrZXkpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBYm9ydGVkLFxuICBpc0NhbmNlbGxlZCxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHRvVVNWU3RyaW5nLFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgVEFPQ2hlY2ssXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHJlc3BvbnNlVVJMLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICBpc0Jsb2JMaWtlLFxuICBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBtYWtlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGhhc093bixcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGJ5dGVzTWF0Y2gsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICBpc29tb3JwaGljRGVjb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxIYXNIdHRwc1NjaGVtZSxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHJlYWRBbGxCeXRlc1xufVxuIl0sIm5hbWVzIjpbInJlZGlyZWN0U3RhdHVzIiwiYmFkUG9ydHMiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyUG9saWN5VG9rZW5zIiwicmVxdWlyZSIsImdldEdsb2JhbE9yaWdpbiIsInBlcmZvcm1hbmNlIiwiaXNCbG9iTGlrZSIsInRvVVNWU3RyaW5nIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwiYXNzZXJ0IiwiaXNVaW50OEFycmF5IiwiY3J5cHRvIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZSIsInVybExpc3QiLCJsZW5ndGgiLCJ0b1N0cmluZyIsInJlc3BvbnNlTG9jYXRpb25VUkwiLCJyZXF1ZXN0RnJhZ21lbnQiLCJpbmNsdWRlcyIsInN0YXR1cyIsImxvY2F0aW9uIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJVUkwiLCJoYXNoIiwicmVxdWVzdEN1cnJlbnRVUkwiLCJyZXF1ZXN0IiwicmVxdWVzdEJhZFBvcnQiLCJ1cmwiLCJ1cmxJc0h0dHBIdHRwc1NjaGVtZSIsInBvcnQiLCJpc0Vycm9yTGlrZSIsIm9iamVjdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXNWYWxpZFJlYXNvblBocmFzZSIsInN0YXR1c1RleHQiLCJpIiwiYyIsImNoYXJDb2RlQXQiLCJpc1Rva2VuQ2hhciIsImlzVmFsaWRIVFRQVG9rZW4iLCJjaGFyYWN0ZXJzIiwiaXNWYWxpZEhlYWRlck5hbWUiLCJwb3RlbnRpYWxWYWx1ZSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QiLCJhY3R1YWxSZXNwb25zZSIsInBvbGljeUhlYWRlciIsInNwbGl0IiwicG9saWN5IiwidG9rZW4iLCJ0cmltIiwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrIiwiY29yc0NoZWNrIiwiVEFPQ2hlY2siLCJhcHBlbmRGZXRjaE1ldGFkYXRhIiwiaHR0cFJlcXVlc3QiLCJoZWFkZXIiLCJtb2RlIiwic2V0IiwiYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciIsInNlcmlhbGl6ZWRPcmlnaW4iLCJvcmlnaW4iLCJyZXNwb25zZVRhaW50aW5nIiwiYXBwZW5kIiwibWV0aG9kIiwidXJsSGFzSHR0cHNTY2hlbWUiLCJzYW1lT3JpZ2luIiwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUiLCJjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSIsIm5vdyIsImNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8iLCJ0aW1pbmdJbmZvIiwic3RhcnRUaW1lIiwicmVkaXJlY3RTdGFydFRpbWUiLCJyZWRpcmVjdEVuZFRpbWUiLCJwb3N0UmVkaXJlY3RTdGFydFRpbWUiLCJmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWUiLCJmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZSIsImZpbmFsTmV0d29ya1JlcXVlc3RTdGFydFRpbWUiLCJlbmRUaW1lIiwiZW5jb2RlZEJvZHlTaXplIiwiZGVjb2RlZEJvZHlTaXplIiwiZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbyIsIm1ha2VQb2xpY3lDb250YWluZXIiLCJjbG9uZVBvbGljeUNvbnRhaW5lciIsInBvbGljeUNvbnRhaW5lciIsImRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIiLCJyZWZlcnJlclNvdXJjZSIsInJlZmVycmVyIiwiZ2xvYmFsT3JpZ2luIiwicmVmZXJyZXJVUkwiLCJzdHJpcFVSTEZvclJlZmVycmVyIiwicmVmZXJyZXJPcmlnaW4iLCJhcmVTYW1lT3JpZ2luIiwiaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5IiwiaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5IiwiY3VycmVudFVSTCIsIm9yaWdpbk9ubHkiLCJwcm90b2NvbCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsInNlYXJjaCIsImhyZWYiLCJpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkiLCJvcmlnaW5Bc1VSTCIsInRlc3QiLCJob3N0bmFtZSIsImJ5dGVzTWF0Y2giLCJieXRlcyIsIm1ldGFkYXRhTGlzdCIsInVuZGVmaW5lZCIsInBhcnNlZE1ldGFkYXRhIiwicGFyc2VNZXRhZGF0YSIsImxpc3QiLCJzb3J0IiwiZCIsImFsZ28iLCJsb2NhbGVDb21wYXJlIiwic3Ryb25nZXN0IiwibWV0YWRhdGEiLCJmaWx0ZXIiLCJpdGVtIiwiYWxnb3JpdGhtIiwiZXhwZWN0ZWRWYWx1ZSIsInNsaWNlIiwiYWN0dWFsVmFsdWUiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwiYWN0dWFsQmFzZTY0VVJMIiwicGFyc2VIYXNoV2l0aE9wdGlvbnMiLCJyZXN1bHQiLCJlbXB0eSIsInN1cHBvcnRlZEhhc2hlcyIsImdldEhhc2hlcyIsInBhcnNlZFRva2VuIiwiZXhlYyIsImdyb3VwcyIsInRvTG93ZXJDYXNlIiwicHVzaCIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsIkEiLCJCIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaXNBYm9ydGVkIiwiZmV0Y2hQYXJhbXMiLCJjb250cm9sbGVyIiwic3RhdGUiLCJpc0NhbmNlbGxlZCIsIm5vcm1hbGl6ZU1ldGhvZCIsInRvVXBwZXJDYXNlIiwic2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nIiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwiVHlwZUVycm9yIiwiZXNJdGVyYXRvclByb3RvdHlwZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJtYWtlSXRlcmF0b3IiLCJraW5kIiwiaW5kZXgiLCJ0YXJnZXQiLCJuZXh0IiwidmFsdWVzIiwibGVuIiwiZG9uZSIsInBhaXIiLCJpdGVyYXRvclJlc3VsdCIsInRvU3RyaW5nVGFnIiwic2V0UHJvdG90eXBlT2YiLCJmdWxseVJlYWRCb2R5IiwiYm9keSIsInByb2Nlc3NCb2R5IiwicHJvY2Vzc0JvZHlFcnJvciIsInN1Y2Nlc3NTdGVwcyIsImVycm9yU3RlcHMiLCJyZWFkZXIiLCJzdHJlYW0iLCJnZXRSZWFkZXIiLCJlIiwicmVhZEFsbEJ5dGVzIiwiUmVhZGFibGVTdHJlYW0iLCJnbG9iYWxUaGlzIiwiaXNSZWFkYWJsZVN0cmVhbUxpa2UiLCJ0ZWUiLCJNQVhJTVVNX0FSR1VNRU5UX0xFTkdUSCIsImlzb21vcnBoaWNEZWNvZGUiLCJpbnB1dCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJlZHVjZSIsInByZXZpb3VzIiwiY3VycmVudCIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJjbG9zZSIsImVyciIsIm1lc3NhZ2UiLCJpc29tb3JwaGljRW5jb2RlIiwiYnl0ZUxlbmd0aCIsImNodW5rIiwicmVhZCIsIkJ1ZmZlciIsImNvbmNhdCIsInVybElzTG9jYWwiLCJoYXNPd24iLCJkaWN0Iiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fetch/webidl.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fetch/webidl.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { hasOwn, toUSVString } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fetch/util.js\");\n/** @type {import('../../types/webidl').Webidl} */ const webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? \"\" : \" one of\";\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(\", \")}.`;\n    return webidl.errors.exception({\n        header: context.prefix,\n        message\n    });\n};\nwebidl.errors.invalidArgument = function(context) {\n    return webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function(V, I, opts = undefined) {\n    if (opts?.strict !== false && !(V instanceof I)) {\n        throw new TypeError(\"Illegal invocation\");\n    } else {\n        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n    }\n};\nwebidl.argumentLengthCheck = function({ length }, min, ctx) {\n    if (length < min) {\n        throw webidl.errors.exception({\n            message: `${min} argument${min !== 1 ? \"s\" : \"\"} required, ` + `but${length ? \" only\" : \"\"} ${length} found.`,\n            ...ctx\n        });\n    }\n};\nwebidl.illegalConstructor = function() {\n    throw webidl.errors.exception({\n        header: \"TypeError\",\n        message: \"Illegal constructor\"\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function(V) {\n    switch(typeof V){\n        case \"undefined\":\n            return \"Undefined\";\n        case \"boolean\":\n            return \"Boolean\";\n        case \"string\":\n            return \"String\";\n        case \"symbol\":\n            return \"Symbol\";\n        case \"number\":\n            return \"Number\";\n        case \"bigint\":\n            return \"BigInt\";\n        case \"function\":\n        case \"object\":\n            {\n                if (V === null) {\n                    return \"Null\";\n                }\n                return \"Object\";\n            }\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53 − 1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === \"unsigned\") {\n            lowerBound = 0;\n        } else {\n            // 3. Otherwise let lowerBound be −2^53 + 1.\n            lowerBound = Math.pow(-2, 53) + 1;\n        }\n    } else if (signedness === \"unsigned\") {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength − 1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength − 1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength − 1 − 1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is −0, then set x to +0.\n    if (x === 0) {\n        x = 0;\n    }\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts.enforceRange === true) {\n        // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Could not convert ${V} to an integer.`\n            });\n        }\n        // 2. Set x to IntegerPart(x).\n        x = webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n            });\n        }\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than −0.\n        if (Math.floor(x) % 2 === 0) {\n            x = Math.floor(x);\n        } else {\n            x = Math.ceil(x);\n        }\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n    }\n    // 9. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n    //    then return x − 2^bitLength.\n    if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n    }\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1 × r.\n    if (n < 0) {\n        return -1 * r;\n    }\n    // 3. Otherwise, return r.\n    return r;\n};\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function(converter) {\n    return (V)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if (webidl.util.Type(V) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n            });\n        }\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = V?.[Symbol.iterator]?.();\n        const seq = [];\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== \"function\") {\n            throw webidl.errors.exception({\n                header: \"Sequence\",\n                message: \"Object is not an iterator.\"\n            });\n        }\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done, value } = method.next();\n            if (done) {\n                break;\n            }\n            seq.push(converter(value));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if (webidl.util.Type(O) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Record\",\n                message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n            });\n        }\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!types.isProxy(O)) {\n            // Object.keys only returns enumerable properties\n            const keys = Object.keys(O);\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key]);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\nwebidl.interfaceConverter = function(i) {\n    return (V, opts = {})=>{\n        if (opts.strict !== false && !(V instanceof i)) {\n            throw webidl.errors.exception({\n                header: i.name,\n                message: `Expected ${V} to be an instance of ${i.name}.`\n            });\n        }\n        return V;\n    };\n};\nwebidl.dictionaryConverter = function(converters) {\n    return (dictionary)=>{\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === \"Null\" || type === \"Undefined\") {\n            return dict;\n        } else if (type !== \"Object\") {\n            throw webidl.errors.exception({\n                header: \"Dictionary\",\n                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n            });\n        }\n        for (const options of converters){\n            const { key, defaultValue, required, converter } = options;\n            if (required === true) {\n                if (!hasOwn(dictionary, key)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `Missing required key \"${key}\".`\n                    });\n                }\n            }\n            let value = dictionary[key];\n            const hasDefault = hasOwn(options, \"defaultValue\");\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) {\n                value = value ?? defaultValue;\n            }\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value);\n                if (options.allowedValues && !options.allowedValues.includes(value)) {\n                    throw webidl.errors.exception({\n                        header: \"Dictionary\",\n                        message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n                    });\n                }\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\nwebidl.nullableConverter = function(converter) {\n    return (V)=>{\n        if (V === null) {\n            return V;\n        }\n        return converter(V);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function(V, opts = {}) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts.legacyNullToEmptyString) {\n        return \"\";\n    }\n    // 2. Let x be ? ToString(V).\n    if (typeof V === \"symbol\") {\n        throw new TypeError(\"Could not convert argument of type symbol to string.\");\n    }\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function(V) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = webidl.converters.DOMString(V);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        const charCode = x.charCodeAt(index);\n        if (charCode > 255) {\n            throw new TypeError(\"Cannot convert argument to a ByteString because the character at \" + `index ${index} has a value of ${charCode} which is greater than 255.`);\n        }\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\nwebidl.converters.USVString = toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters[\"long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = webidl.util.ConvertToInt(V, 64, \"signed\");\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters[\"unsigned long long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 64, \"unsigned\");\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters[\"unsigned long\"] = function(V) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 32, \"unsigned\");\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters[\"unsigned short\"] = function(V, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 16, \"unsigned\", opts);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${V}`,\n            argument: `${V}`,\n            types: [\n                \"ArrayBuffer\"\n            ]\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal.\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\nwebidl.converters.TypedArray = function(V, T, opts = {}) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to T’s name, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        throw webidl.errors.conversionFailed({\n            prefix: `${T.name}`,\n            argument: `${V}`,\n            types: [\n                T.name\n            ]\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable array buffers are currently a proposal\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\nwebidl.converters.DataView = function(V, opts = {}) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        throw webidl.errors.exception({\n            header: \"DataView\",\n            message: \"Object is not a DataView.\"\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    // Note: resizable ArrayBuffers are currently a proposal\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function(V, opts = {}) {\n    if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, opts);\n    }\n    if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor);\n    }\n    if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, opts);\n    }\n    throw new TypeError(`Could not convert ${V} to a BufferSource.`);\n};\nwebidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(webidl.converters[\"sequence<ByteString>\"]);\nwebidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n    webidl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9mZXRjaC93ZWJpZGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLEtBQUssRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBRXhDLGdEQUFnRCxHQUNoRCxNQUFNRyxTQUFTLENBQUM7QUFDaEJBLE9BQU9DLFVBQVUsR0FBRyxDQUFDO0FBQ3JCRCxPQUFPRSxJQUFJLEdBQUcsQ0FBQztBQUNmRixPQUFPRyxNQUFNLEdBQUcsQ0FBQztBQUVqQkgsT0FBT0csTUFBTSxDQUFDQyxTQUFTLEdBQUcsU0FBVUMsT0FBTztJQUN6QyxPQUFPLElBQUlDLFVBQVUsQ0FBQyxFQUFFRCxRQUFRRSxNQUFNLENBQUMsRUFBRSxFQUFFRixRQUFRQSxPQUFPLENBQUMsQ0FBQztBQUM5RDtBQUVBTCxPQUFPRyxNQUFNLENBQUNLLGdCQUFnQixHQUFHLFNBQVVDLE9BQU87SUFDaEQsTUFBTUMsU0FBU0QsUUFBUWIsS0FBSyxDQUFDZSxNQUFNLEtBQUssSUFBSSxLQUFLO0lBQ2pELE1BQU1OLFVBQ0osQ0FBQyxFQUFFSSxRQUFRRyxRQUFRLENBQUMsMEJBQTBCLENBQUMsR0FDL0MsQ0FBQyxFQUFFRixPQUFPLEVBQUUsRUFBRUQsUUFBUWIsS0FBSyxDQUFDaUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTNDLE9BQU9iLE9BQU9HLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO1FBQzdCRyxRQUFRRSxRQUFRSyxNQUFNO1FBQ3RCVDtJQUNGO0FBQ0Y7QUFFQUwsT0FBT0csTUFBTSxDQUFDWSxlQUFlLEdBQUcsU0FBVU4sT0FBTztJQUMvQyxPQUFPVCxPQUFPRyxNQUFNLENBQUNDLFNBQVMsQ0FBQztRQUM3QkcsUUFBUUUsUUFBUUssTUFBTTtRQUN0QlQsU0FBUyxDQUFDLENBQUMsRUFBRUksUUFBUU8sS0FBSyxDQUFD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LENBQzFFL0QsT0FBT0MsVUFBVSxDQUFDNkYsVUFBVSxFQUM1QjlGLE9BQU9DLFVBQVUsQ0FBQzZGLFVBQVU7QUFHOUJvQixPQUFPQyxPQUFPLEdBQUc7SUFDZm5IO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZldGNoL3dlYmlkbC5qcz8zMzIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IHsgaGFzT3duLCB0b1VTVlN0cmluZyB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYmlkbCcpLldlYmlkbH0gKi9cbmNvbnN0IHdlYmlkbCA9IHt9XG53ZWJpZGwuY29udmVydGVycyA9IHt9XG53ZWJpZGwudXRpbCA9IHt9XG53ZWJpZGwuZXJyb3JzID0ge31cblxud2ViaWRsLmVycm9ycy5leGNlcHRpb24gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgJHttZXNzYWdlLmhlYWRlcn06ICR7bWVzc2FnZS5tZXNzYWdlfWApXG59XG5cbndlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGNvbnN0IHBsdXJhbCA9IGNvbnRleHQudHlwZXMubGVuZ3RoID09PSAxID8gJycgOiAnIG9uZSBvZidcbiAgY29uc3QgbWVzc2FnZSA9XG4gICAgYCR7Y29udGV4dC5hcmd1bWVudH0gY291bGQgbm90IGJlIGNvbnZlcnRlZCB0b2AgK1xuICAgIGAke3BsdXJhbH06ICR7Y29udGV4dC50eXBlcy5qb2luKCcsICcpfS5gXG5cbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2VcbiAgfSlcbn1cblxud2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogY29udGV4dC5wcmVmaXgsXG4gICAgbWVzc2FnZTogYFwiJHtjb250ZXh0LnZhbHVlfVwiIGlzIGFuIGludmFsaWQgJHtjb250ZXh0LnR5cGV9LmBcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpbXBsZW1lbnRzXG53ZWJpZGwuYnJhbmRDaGVjayA9IGZ1bmN0aW9uIChWLCBJLCBvcHRzID0gdW5kZWZpbmVkKSB7XG4gIGlmIChvcHRzPy5zdHJpY3QgIT09IGZhbHNlICYmICEoViBpbnN0YW5jZW9mIEkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gVj8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IEkucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ11cbiAgfVxufVxuXG53ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayA9IGZ1bmN0aW9uICh7IGxlbmd0aCB9LCBtaW4sIGN0eCkge1xuICBpZiAobGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgbWVzc2FnZTogYCR7bWlufSBhcmd1bWVudCR7bWluICE9PSAxID8gJ3MnIDogJyd9IHJlcXVpcmVkLCBgICtcbiAgICAgICAgICAgICAgIGBidXQke2xlbmd0aCA/ICcgb25seScgOiAnJ30gJHtsZW5ndGh9IGZvdW5kLmAsXG4gICAgICAuLi5jdHhcbiAgICB9KVxuICB9XG59XG5cbndlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6ICdUeXBlRXJyb3InLFxuICAgIG1lc3NhZ2U6ICdJbGxlZ2FsIGNvbnN0cnVjdG9yJ1xuICB9KVxufVxuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXG53ZWJpZGwudXRpbC5UeXBlID0gZnVuY3Rpb24gKFYpIHtcbiAgc3dpdGNoICh0eXBlb2YgVikge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiAnVW5kZWZpbmVkJ1xuICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gJ0Jvb2xlYW4nXG4gICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdTdHJpbmcnXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuICdTeW1ib2wnXG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICdOdW1iZXInXG4gICAgY2FzZSAnYmlnaW50JzogcmV0dXJuICdCaWdJbnQnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnTnVsbCdcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdPYmplY3QnXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYWJzdHJhY3Qtb3BkZWYtY29udmVydHRvaW50XG53ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQgPSBmdW5jdGlvbiAoViwgYml0TGVuZ3RoLCBzaWduZWRuZXNzLCBvcHRzID0ge30pIHtcbiAgbGV0IHVwcGVyQm91bmRcbiAgbGV0IGxvd2VyQm91bmRcblxuICAvLyAxLiBJZiBiaXRMZW5ndGggaXMgNjQsIHRoZW46XG4gIGlmIChiaXRMZW5ndGggPT09IDY0KSB7XG4gICAgLy8gMS4gTGV0IHVwcGVyQm91bmQgYmUgMl41MyDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG4gICAgLy8gMi4gSWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW4gbGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgbG93ZXJCb3VuZCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlIGxldCBsb3dlckJvdW5kIGJlIOKIkjJeNTMgKyAxLlxuICAgICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCA1MykgKyAxXG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBsb3dlckJvdW5kID0gMFxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgLTJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgYml0TGVuZ3RoKSAtIDFcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKSAtIDFcbiAgfVxuXG4gIC8vIDQuIExldCB4IGJlID8gVG9OdW1iZXIoVikuXG4gIGxldCB4ID0gTnVtYmVyKFYpXG5cbiAgLy8gNS4gSWYgeCBpcyDiiJIwLCB0aGVuIHNldCB4IHRvICswLlxuICBpZiAoeCA9PT0gMCkge1xuICAgIHggPSAwXG4gIH1cblxuICAvLyA2LiBJZiB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtFbmZvcmNlUmFuZ2VdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKG9wdHMuZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgLy8gMS4gSWYgeCBpcyBOYU4sICviiJ4sIG9yIOKIkuKIniwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke1Z9IHRvIGFuIGludGVnZXIuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAgIC8vIDMuIElmIHggPCBsb3dlckJvdW5kIG9yIHggPiB1cHBlckJvdW5kLCB0aGVuXG4gICAgLy8gICAgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gJHtsb3dlckJvdW5kfS0ke3VwcGVyQm91bmR9LCBnb3QgJHt4fS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA3LiBJZiB4IGlzIG5vdCBOYU4gYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETFxuICAvLyAgICB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0NsYW1wXSBleHRlbmRlZFxuICAvLyAgICBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdHMuY2xhbXAgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXNlcXVlbmNlXG53ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoVikgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1NlcXVlbmNlJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG9mIHR5cGUgJHt3ZWJpZGwudXRpbC5UeXBlKFYpfSBpcyBub3QgYW4gT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IG1ldGhvZCBiZSA/IEdldE1ldGhvZChWLCBAQGl0ZXJhdG9yKS5cbiAgICAvKiogQHR5cGUge0dlbmVyYXRvcn0gKi9cbiAgICBjb25zdCBtZXRob2QgPSBWPy5bU3ltYm9sLml0ZXJhdG9yXT8uKClcbiAgICBjb25zdCBzZXEgPSBbXVxuXG4gICAgLy8gMy4gSWYgbWV0aG9kIGlzIHVuZGVmaW5lZCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgbWV0aG9kID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHR5cGVvZiBtZXRob2QubmV4dCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdTZXF1ZW5jZScsXG4gICAgICAgIG1lc3NhZ2U6ICdPYmplY3QgaXMgbm90IGFuIGl0ZXJhdG9yLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNjcmVhdGUtc2VxdWVuY2UtZnJvbS1pdGVyYWJsZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBtZXRob2QubmV4dCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNlcS5wdXNoKGNvbnZlcnRlcih2YWx1ZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdG8tcmVjb3JkXG53ZWJpZGwucmVjb3JkQ29udmVydGVyID0gZnVuY3Rpb24gKGtleUNvbnZlcnRlciwgdmFsdWVDb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChPKSA9PiB7XG4gICAgLy8gMS4gSWYgVHlwZShPKSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVjb3JkJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG9mIHR5cGUgJHt3ZWJpZGwudXRpbC5UeXBlKE8pfSBpcyBub3QgYW4gT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHJlc3VsdCBiZSBhIG5ldyBlbXB0eSBpbnN0YW5jZSBvZiByZWNvcmQ8SywgVj4uXG4gICAgY29uc3QgcmVzdWx0ID0ge31cblxuICAgIGlmICghdHlwZXMuaXNQcm94eShPKSkge1xuICAgICAgLy8gT2JqZWN0LmtleXMgb25seSByZXR1cm5zIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKE8pXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSlcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIDMuIExldCBrZXlzIGJlID8gTy5bW093blByb3BlcnR5S2V5c11dKCkuXG4gICAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhPKVxuXG4gICAgLy8gNC4gRm9yIGVhY2gga2V5IG9mIGtleXMuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gMS4gTGV0IGRlc2MgYmUgPyBPLltbR2V0T3duUHJvcGVydHldXShrZXkpLlxuICAgICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSlcblxuICAgICAgLy8gMi4gSWYgZGVzYyBpcyBub3QgdW5kZWZpbmVkIGFuZCBkZXNjLltbRW51bWVyYWJsZV1dIGlzIHRydWU6XG4gICAgICBpZiAoZGVzYz8uZW51bWVyYWJsZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZWRLZXkgYmUga2V5IGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBLLlxuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleUNvbnZlcnRlcihrZXkpXG5cbiAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlID8gR2V0KE8sIGtleSkuXG4gICAgICAgIC8vIDMuIExldCB0eXBlZFZhbHVlIGJlIHZhbHVlIGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBWLlxuICAgICAgICBjb25zdCB0eXBlZFZhbHVlID0gdmFsdWVDb252ZXJ0ZXIoT1trZXldKVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxud2ViaWRsLmludGVyZmFjZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiAoViwgb3B0cyA9IHt9KSA9PiB7XG4gICAgaWYgKG9wdHMuc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBpKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IGkubmFtZSxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7Vn0gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJHtpLm5hbWV9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFZcbiAgfVxufVxuXG53ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIHJldHVybiAoZGljdGlvbmFyeSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpXG4gICAgY29uc3QgZGljdCA9IHt9XG5cbiAgICBpZiAodHlwZSA9PT0gJ051bGwnIHx8IHR5cGUgPT09ICdVbmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZGljdFxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnRGljdGlvbmFyeScsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29udmVydGVycykge1xuICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd24oZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0RpY3Rpb25hcnknLFxuICAgICAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQga2V5IFwiJHtrZXl9XCIuYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHZhbHVlID0gZGljdGlvbmFyeVtrZXldXG4gICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0VmFsdWUnKVxuXG4gICAgICAvLyBPbmx5IHVzZSBkZWZhdWx0VmFsdWUgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZFxuICAgICAgLy8gYSBkZWZhdWx0VmFsdWUgb3B0aW9ucyB3YXMgcHJvdmlkZWQuXG4gICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8/IGRlZmF1bHRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBBIGtleSBjYW4gYmUgb3B0aW9uYWwgYW5kIGhhdmUgbm8gZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBkbyBub3QgcGVyZm9ybSBhIGNvbnZlcnNpb24sXG4gICAgICAvLyBhbmQgZG8gbm90IGFzc2lnbiB0aGUga2V5IGEgdmFsdWUuXG4gICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiZcbiAgICAgICAgICAhb3B0aW9ucy5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdEaWN0aW9uYXJ5JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGljdFtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdFxuICB9XG59XG5cbndlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWKSA9PiB7XG4gICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlcihWKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtRE9NU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIC8vIDEuIElmIFYgaXMgbnVsbCBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGVcbiAgLy8gICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBbTGVnYWN5TnVsbFRvRW1wdHlTdHJpbmddXG4gIC8vICAgIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbiByZXR1cm4gdGhlIERPTVN0cmluZyB2YWx1ZVxuICAvLyAgICB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IHN0cmluZy5cbiAgaWYgKFYgPT09IG51bGwgJiYgb3B0cy5sZWdhY3lOdWxsVG9FbXB0eVN0cmluZykge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMi4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgc3ltYm9sIHRvIHN0cmluZy4nKVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSBJREwgRE9NU3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gICAgc2FtZSBzZXF1ZW5jZSBvZiBjb2RlIHVuaXRzIGFzIHRoZSBvbmUgdGhlXG4gIC8vICAgIEVDTUFTY3JpcHQgU3RyaW5nIHZhbHVlIHggcmVwcmVzZW50cy5cbiAgcmV0dXJuIFN0cmluZyhWKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLUJ5dGVTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICAvLyBOb3RlOiBET01TdHJpbmcgY29udmVydGVyIHBlcmZvcm0gPyBUb1N0cmluZyhWKVxuICBjb25zdCB4ID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYpXG5cbiAgLy8gMi4gSWYgdGhlIHZhbHVlIG9mIGFueSBlbGVtZW50IG9mIHggaXMgZ3JlYXRlciB0aGFuXG4gIC8vICAgIDI1NSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSB4LmNoYXJDb2RlQXQoaW5kZXgpXG5cbiAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCB0byBhIEJ5dGVTdHJpbmcgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGF0ICcgK1xuICAgICAgICBgaW5kZXggJHtpbmRleH0gaGFzIGEgdmFsdWUgb2YgJHtjaGFyQ29kZX0gd2hpY2ggaXMgZ3JlYXRlciB0aGFuIDI1NS5gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGFuIElETCBCeXRlU3RyaW5nIHZhbHVlIHdob3NlIGxlbmd0aCBpcyB0aGVcbiAgLy8gICAgbGVuZ3RoIG9mIHgsIGFuZCB3aGVyZSB0aGUgdmFsdWUgb2YgZWFjaCBlbGVtZW50IGlzXG4gIC8vICAgIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IG9mIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtVVNWU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcgPSB0b1VTVlN0cmluZ1xuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWJvb2xlYW5cbndlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSB0aGUgcmVzdWx0IG9mIGNvbXB1dGluZyBUb0Jvb2xlYW4oVikuXG4gIGNvbnN0IHggPSBCb29sZWFuKFYpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgYm9vbGVhbiB2YWx1ZSB0aGF0IGlzIHRoZSBvbmUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIHRydXRoIHZhbHVlIGFzIHRoZSBFQ01BU2NyaXB0IEJvb2xlYW4gdmFsdWUgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1hbnlcbndlYmlkbC5jb252ZXJ0ZXJzLmFueSA9IGZ1bmN0aW9uIChWKSB7XG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJzaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICdzaWduZWQnKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGxvbmcgbG9uZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICd1bnNpZ25lZCcpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgbG9uZyBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDMyLCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDMyLCAndW5zaWduZWQnKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1zaG9ydFxud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10gPSBmdW5jdGlvbiAoViwgb3B0cykge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAxNiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAxNiwgJ3Vuc2lnbmVkJywgb3B0cylcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBzaG9ydCB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2lkbC1BcnJheUJ1ZmZlclxud2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoViwgb3B0cyA9IHt9KSB7XG4gIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFuXG4gIC8vICAgIFtbQXJyYXlCdWZmZXJEYXRhXV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLWFycmF5YnVmZmVyLWluc3RhbmNlc1xuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtc2hhcmVkYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fFxuICAgICF0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6IGAke1Z9YCxcbiAgICAgIGFyZ3VtZW50OiBgJHtWfWAsXG4gICAgICB0eXBlczogWydBcnJheUJ1ZmZlciddXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICAvLyBOb3RlOiByZXNpemFibGUgQXJyYXlCdWZmZXJzIGFyZSBjdXJyZW50bHkgYSBwcm9wb3NhbC5cblxuICAvLyA0LiBSZXR1cm4gdGhlIElETCBBcnJheUJ1ZmZlciB2YWx1ZSB0aGF0IGlzIGFcbiAgLy8gICAgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5UeXBlZEFycmF5ID0gZnVuY3Rpb24gKFYsIFQsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBMZXQgVCBiZSB0aGUgSURMIHR5cGUgViBpcyBiZWluZyBjb252ZXJ0ZWQgdG8uXG5cbiAgLy8gMi4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW1R5cGVkQXJyYXlOYW1lXV0gaW50ZXJuYWwgc2xvdCB3aXRoIGEgdmFsdWVcbiAgLy8gICAgZXF1YWwgdG8gVOKAmXMgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8XG4gICAgIXR5cGVzLmlzVHlwZWRBcnJheShWKSB8fFxuICAgIFYuY29uc3RydWN0b3IubmFtZSAhPT0gVC5uYW1lXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6IGAke1QubmFtZX1gLFxuICAgICAgYXJndW1lbnQ6IGAke1Z9YCxcbiAgICAgIHR5cGVzOiBbVC5uYW1lXVxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChvcHRzLmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgLy8gTm90ZTogcmVzaXphYmxlIGFycmF5IGJ1ZmZlcnMgYXJlIGN1cnJlbnRseSBhIHByb3Bvc2FsXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSBJREwgdmFsdWUgb2YgdHlwZSBUIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3ID0gZnVuY3Rpb24gKFYsIG9wdHMgPSB7fSkge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbRGF0YVZpZXddXSBpbnRlcm5hbCBzbG90LCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHwgIXR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdEYXRhVmlldycsXG4gICAgICBtZXNzYWdlOiAnT2JqZWN0IGlzIG5vdCBhIERhdGFWaWV3LidcbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpcyB0cnVlLFxuICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIE5vdGU6IHJlc2l6YWJsZSBBcnJheUJ1ZmZlcnMgYXJlIGN1cnJlbnRseSBhIHByb3Bvc2FsXG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgRGF0YVZpZXcgdmFsdWUgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNCdWZmZXJTb3VyY2VcbndlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uIChWLCBvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIoViwgb3B0cylcbiAgfVxuXG4gIGlmICh0eXBlcy5pc1R5cGVkQXJyYXkoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheShWLCBWLmNvbnN0cnVjdG9yKVxuICB9XG5cbiAgaWYgKHR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcoViwgb3B0cylcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYENvdWxkIG5vdCBjb252ZXJ0ICR7Vn0gdG8gYSBCdWZmZXJTb3VyY2UuYClcbn1cblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXVxuKVxuXG53ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwucmVjb3JkQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWJpZGxcbn1cbiJdLCJuYW1lcyI6WyJ0eXBlcyIsInJlcXVpcmUiLCJoYXNPd24iLCJ0b1VTVlN0cmluZyIsIndlYmlkbCIsImNvbnZlcnRlcnMiLCJ1dGlsIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwibWVzc2FnZSIsIlR5cGVFcnJvciIsImhlYWRlciIsImNvbnZlcnNpb25GYWlsZWQiLCJjb250ZXh0IiwicGx1cmFsIiwibGVuZ3RoIiwiYXJndW1lbnQiLCJqb2luIiwicHJlZml4IiwiaW52YWxpZEFyZ3VtZW50IiwidmFsdWUiLCJ0eXBlIiwiYnJhbmRDaGVjayIsIlYiLCJJIiwib3B0cyIsInVuZGVmaW5lZCIsInN0cmljdCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwicHJvdG90eXBlIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsIm1pbiIsImN0eCIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIlR5cGUiLCJDb252ZXJ0VG9JbnQiLCJiaXRMZW5ndGgiLCJzaWduZWRuZXNzIiwidXBwZXJCb3VuZCIsImxvd2VyQm91bmQiLCJNYXRoIiwicG93IiwieCIsIk51bWJlciIsImVuZm9yY2VSYW5nZSIsImlzTmFOIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsIkludGVnZXJQYXJ0IiwiY2xhbXAiLCJtYXgiLCJmbG9vciIsImNlaWwiLCJPYmplY3QiLCJpcyIsIm4iLCJyIiwiYWJzIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJtZXRob2QiLCJpdGVyYXRvciIsInNlcSIsIm5leHQiLCJkb25lIiwicHVzaCIsInJlY29yZENvbnZlcnRlciIsImtleUNvbnZlcnRlciIsInZhbHVlQ29udmVydGVyIiwiTyIsInJlc3VsdCIsImlzUHJveHkiLCJrZXlzIiwia2V5IiwidHlwZWRLZXkiLCJ0eXBlZFZhbHVlIiwiUmVmbGVjdCIsIm93bktleXMiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsImkiLCJuYW1lIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImRpY3Rpb25hcnkiLCJkaWN0Iiwib3B0aW9ucyIsImRlZmF1bHRWYWx1ZSIsInJlcXVpcmVkIiwiaGFzRGVmYXVsdCIsImFsbG93ZWRWYWx1ZXMiLCJpbmNsdWRlcyIsIm51bGxhYmxlQ29udmVydGVyIiwiRE9NU3RyaW5nIiwibGVnYWN5TnVsbFRvRW1wdHlTdHJpbmciLCJTdHJpbmciLCJCeXRlU3RyaW5nIiwiaW5kZXgiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJVU1ZTdHJpbmciLCJib29sZWFuIiwiQm9vbGVhbiIsImFueSIsIkFycmF5QnVmZmVyIiwiaXNBbnlBcnJheUJ1ZmZlciIsImFsbG93U2hhcmVkIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsIlR5cGVkQXJyYXkiLCJUIiwiaXNUeXBlZEFycmF5IiwiY29uc3RydWN0b3IiLCJidWZmZXIiLCJEYXRhVmlldyIsImlzRGF0YVZpZXciLCJCdWZmZXJTb3VyY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fetch/webidl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fileapi/encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/encoding.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */ function getEncoding(label) {\n    if (!label) {\n        return \"failure\";\n    }\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    // 2. If label is an ASCII case-insensitive match for any of the\n    //    labels listed in the table below, then return the\n    //    corresponding encoding; otherwise return failure.\n    switch(label.trim().toLowerCase()){\n        case \"unicode-1-1-utf-8\":\n        case \"unicode11utf8\":\n        case \"unicode20utf8\":\n        case \"utf-8\":\n        case \"utf8\":\n        case \"x-unicode20utf8\":\n            return \"UTF-8\";\n        case \"866\":\n        case \"cp866\":\n        case \"csibm866\":\n        case \"ibm866\":\n            return \"IBM866\";\n        case \"csisolatin2\":\n        case \"iso-8859-2\":\n        case \"iso-ir-101\":\n        case \"iso8859-2\":\n        case \"iso88592\":\n        case \"iso_8859-2\":\n        case \"iso_8859-2:1987\":\n        case \"l2\":\n        case \"latin2\":\n            return \"ISO-8859-2\";\n        case \"csisolatin3\":\n        case \"iso-8859-3\":\n        case \"iso-ir-109\":\n        case \"iso8859-3\":\n        case \"iso88593\":\n        case \"iso_8859-3\":\n        case \"iso_8859-3:1988\":\n        case \"l3\":\n        case \"latin3\":\n            return \"ISO-8859-3\";\n        case \"csisolatin4\":\n        case \"iso-8859-4\":\n        case \"iso-ir-110\":\n        case \"iso8859-4\":\n        case \"iso88594\":\n        case \"iso_8859-4\":\n        case \"iso_8859-4:1988\":\n        case \"l4\":\n        case \"latin4\":\n            return \"ISO-8859-4\";\n        case \"csisolatincyrillic\":\n        case \"cyrillic\":\n        case \"iso-8859-5\":\n        case \"iso-ir-144\":\n        case \"iso8859-5\":\n        case \"iso88595\":\n        case \"iso_8859-5\":\n        case \"iso_8859-5:1988\":\n            return \"ISO-8859-5\";\n        case \"arabic\":\n        case \"asmo-708\":\n        case \"csiso88596e\":\n        case \"csiso88596i\":\n        case \"csisolatinarabic\":\n        case \"ecma-114\":\n        case \"iso-8859-6\":\n        case \"iso-8859-6-e\":\n        case \"iso-8859-6-i\":\n        case \"iso-ir-127\":\n        case \"iso8859-6\":\n        case \"iso88596\":\n        case \"iso_8859-6\":\n        case \"iso_8859-6:1987\":\n            return \"ISO-8859-6\";\n        case \"csisolatingreek\":\n        case \"ecma-118\":\n        case \"elot_928\":\n        case \"greek\":\n        case \"greek8\":\n        case \"iso-8859-7\":\n        case \"iso-ir-126\":\n        case \"iso8859-7\":\n        case \"iso88597\":\n        case \"iso_8859-7\":\n        case \"iso_8859-7:1987\":\n        case \"sun_eu_greek\":\n            return \"ISO-8859-7\";\n        case \"csiso88598e\":\n        case \"csisolatinhebrew\":\n        case \"hebrew\":\n        case \"iso-8859-8\":\n        case \"iso-8859-8-e\":\n        case \"iso-ir-138\":\n        case \"iso8859-8\":\n        case \"iso88598\":\n        case \"iso_8859-8\":\n        case \"iso_8859-8:1988\":\n        case \"visual\":\n            return \"ISO-8859-8\";\n        case \"csiso88598i\":\n        case \"iso-8859-8-i\":\n        case \"logical\":\n            return \"ISO-8859-8-I\";\n        case \"csisolatin6\":\n        case \"iso-8859-10\":\n        case \"iso-ir-157\":\n        case \"iso8859-10\":\n        case \"iso885910\":\n        case \"l6\":\n        case \"latin6\":\n            return \"ISO-8859-10\";\n        case \"iso-8859-13\":\n        case \"iso8859-13\":\n        case \"iso885913\":\n            return \"ISO-8859-13\";\n        case \"iso-8859-14\":\n        case \"iso8859-14\":\n        case \"iso885914\":\n            return \"ISO-8859-14\";\n        case \"csisolatin9\":\n        case \"iso-8859-15\":\n        case \"iso8859-15\":\n        case \"iso885915\":\n        case \"iso_8859-15\":\n        case \"l9\":\n            return \"ISO-8859-15\";\n        case \"iso-8859-16\":\n            return \"ISO-8859-16\";\n        case \"cskoi8r\":\n        case \"koi\":\n        case \"koi8\":\n        case \"koi8-r\":\n        case \"koi8_r\":\n            return \"KOI8-R\";\n        case \"koi8-ru\":\n        case \"koi8-u\":\n            return \"KOI8-U\";\n        case \"csmacintosh\":\n        case \"mac\":\n        case \"macintosh\":\n        case \"x-mac-roman\":\n            return \"macintosh\";\n        case \"iso-8859-11\":\n        case \"iso8859-11\":\n        case \"iso885911\":\n        case \"tis-620\":\n        case \"windows-874\":\n            return \"windows-874\";\n        case \"cp1250\":\n        case \"windows-1250\":\n        case \"x-cp1250\":\n            return \"windows-1250\";\n        case \"cp1251\":\n        case \"windows-1251\":\n        case \"x-cp1251\":\n            return \"windows-1251\";\n        case \"ansi_x3.4-1968\":\n        case \"ascii\":\n        case \"cp1252\":\n        case \"cp819\":\n        case \"csisolatin1\":\n        case \"ibm819\":\n        case \"iso-8859-1\":\n        case \"iso-ir-100\":\n        case \"iso8859-1\":\n        case \"iso88591\":\n        case \"iso_8859-1\":\n        case \"iso_8859-1:1987\":\n        case \"l1\":\n        case \"latin1\":\n        case \"us-ascii\":\n        case \"windows-1252\":\n        case \"x-cp1252\":\n            return \"windows-1252\";\n        case \"cp1253\":\n        case \"windows-1253\":\n        case \"x-cp1253\":\n            return \"windows-1253\";\n        case \"cp1254\":\n        case \"csisolatin5\":\n        case \"iso-8859-9\":\n        case \"iso-ir-148\":\n        case \"iso8859-9\":\n        case \"iso88599\":\n        case \"iso_8859-9\":\n        case \"iso_8859-9:1989\":\n        case \"l5\":\n        case \"latin5\":\n        case \"windows-1254\":\n        case \"x-cp1254\":\n            return \"windows-1254\";\n        case \"cp1255\":\n        case \"windows-1255\":\n        case \"x-cp1255\":\n            return \"windows-1255\";\n        case \"cp1256\":\n        case \"windows-1256\":\n        case \"x-cp1256\":\n            return \"windows-1256\";\n        case \"cp1257\":\n        case \"windows-1257\":\n        case \"x-cp1257\":\n            return \"windows-1257\";\n        case \"cp1258\":\n        case \"windows-1258\":\n        case \"x-cp1258\":\n            return \"windows-1258\";\n        case \"x-mac-cyrillic\":\n        case \"x-mac-ukrainian\":\n            return \"x-mac-cyrillic\";\n        case \"chinese\":\n        case \"csgb2312\":\n        case \"csiso58gb231280\":\n        case \"gb2312\":\n        case \"gb_2312\":\n        case \"gb_2312-80\":\n        case \"gbk\":\n        case \"iso-ir-58\":\n        case \"x-gbk\":\n            return \"GBK\";\n        case \"gb18030\":\n            return \"gb18030\";\n        case \"big5\":\n        case \"big5-hkscs\":\n        case \"cn-big5\":\n        case \"csbig5\":\n        case \"x-x-big5\":\n            return \"Big5\";\n        case \"cseucpkdfmtjapanese\":\n        case \"euc-jp\":\n        case \"x-euc-jp\":\n            return \"EUC-JP\";\n        case \"csiso2022jp\":\n        case \"iso-2022-jp\":\n            return \"ISO-2022-JP\";\n        case \"csshiftjis\":\n        case \"ms932\":\n        case \"ms_kanji\":\n        case \"shift-jis\":\n        case \"shift_jis\":\n        case \"sjis\":\n        case \"windows-31j\":\n        case \"x-sjis\":\n            return \"Shift_JIS\";\n        case \"cseuckr\":\n        case \"csksc56011987\":\n        case \"euc-kr\":\n        case \"iso-ir-149\":\n        case \"korean\":\n        case \"ks_c_5601-1987\":\n        case \"ks_c_5601-1989\":\n        case \"ksc5601\":\n        case \"ksc_5601\":\n        case \"windows-949\":\n            return \"EUC-KR\";\n        case \"csiso2022kr\":\n        case \"hz-gb-2312\":\n        case \"iso-2022-cn\":\n        case \"iso-2022-cn-ext\":\n        case \"iso-2022-kr\":\n        case \"replacement\":\n            return \"replacement\";\n        case \"unicodefffe\":\n        case \"utf-16be\":\n            return \"UTF-16BE\";\n        case \"csunicode\":\n        case \"iso-10646-ucs-2\":\n        case \"ucs-2\":\n        case \"unicode\":\n        case \"unicodefeff\":\n        case \"utf-16\":\n        case \"utf-16le\":\n            return \"UTF-16LE\";\n        case \"x-user-defined\":\n            return \"x-user-defined\";\n        default:\n            return \"failure\";\n    }\n}\nmodule.exports = {\n    getEncoding\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0EsWUFBYUMsS0FBSztJQUN6QixJQUFJLENBQUNBLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFFQSxrRUFBa0U7SUFDbEUsZ0VBQWdFO0lBQ2hFLHVEQUF1RDtJQUN2RCx1REFBdUQ7SUFDdkQsT0FBUUEsTUFBTUMsSUFBSSxHQUFHQyxXQUFXO1FBQzlCLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQVMsT0FBTztJQUNsQjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmTDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2VuY29kaW5nLmpzP2Y1OTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbmNvZGluZy1nZXRcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGFiZWxcbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RpbmcgKGxhYmVsKSB7XG4gIGlmICghbGFiZWwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBsYWJlbC5cbiAgLy8gMi4gSWYgbGFiZWwgaXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYW55IG9mIHRoZVxuICAvLyAgICBsYWJlbHMgbGlzdGVkIGluIHRoZSB0YWJsZSBiZWxvdywgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGNvcnJlc3BvbmRpbmcgZW5jb2Rpbmc7IG90aGVyd2lzZSByZXR1cm4gZmFpbHVyZS5cbiAgc3dpdGNoIChsYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3VuaWNvZGUtMS0xLXV0Zi04JzpcbiAgICBjYXNlICd1bmljb2RlMTF1dGY4JzpcbiAgICBjYXNlICd1bmljb2RlMjB1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAneC11bmljb2RlMjB1dGY4JzpcbiAgICAgIHJldHVybiAnVVRGLTgnXG4gICAgY2FzZSAnODY2JzpcbiAgICBjYXNlICdjcDg2Nic6XG4gICAgY2FzZSAnY3NpYm04NjYnOlxuICAgIGNhc2UgJ2libTg2Nic6XG4gICAgICByZXR1cm4gJ0lCTTg2NidcbiAgICBjYXNlICdjc2lzb2xhdGluMic6XG4gICAgY2FzZSAnaXNvLTg4NTktMic6XG4gICAgY2FzZSAnaXNvLWlyLTEwMSc6XG4gICAgY2FzZSAnaXNvODg1OS0yJzpcbiAgICBjYXNlICdpc284ODU5Mic6XG4gICAgY2FzZSAnaXNvXzg4NTktMic6XG4gICAgY2FzZSAnaXNvXzg4NTktMjoxOTg3JzpcbiAgICBjYXNlICdsMic6XG4gICAgY2FzZSAnbGF0aW4yJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMidcbiAgICBjYXNlICdjc2lzb2xhdGluMyc6XG4gICAgY2FzZSAnaXNvLTg4NTktMyc6XG4gICAgY2FzZSAnaXNvLWlyLTEwOSc6XG4gICAgY2FzZSAnaXNvODg1OS0zJzpcbiAgICBjYXNlICdpc284ODU5Myc6XG4gICAgY2FzZSAnaXNvXzg4NTktMyc6XG4gICAgY2FzZSAnaXNvXzg4NTktMzoxOTg4JzpcbiAgICBjYXNlICdsMyc6XG4gICAgY2FzZSAnbGF0aW4zJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMydcbiAgICBjYXNlICdjc2lzb2xhdGluNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNCc6XG4gICAgY2FzZSAnaXNvLWlyLTExMCc6XG4gICAgY2FzZSAnaXNvODg1OS00JzpcbiAgICBjYXNlICdpc284ODU5NCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNDoxOTg4JzpcbiAgICBjYXNlICdsNCc6XG4gICAgY2FzZSAnbGF0aW40JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNCdcbiAgICBjYXNlICdjc2lzb2xhdGluY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2N5cmlsbGljJzpcbiAgICBjYXNlICdpc28tODg1OS01JzpcbiAgICBjYXNlICdpc28taXItMTQ0JzpcbiAgICBjYXNlICdpc284ODU5LTUnOlxuICAgIGNhc2UgJ2lzbzg4NTk1JzpcbiAgICBjYXNlICdpc29fODg1OS01JzpcbiAgICBjYXNlICdpc29fODg1OS01OjE5ODgnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS01J1xuICAgIGNhc2UgJ2FyYWJpYyc6XG4gICAgY2FzZSAnYXNtby03MDgnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZlJzpcbiAgICBjYXNlICdjc2lzbzg4NTk2aSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmFyYWJpYyc6XG4gICAgY2FzZSAnZWNtYS0xMTQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtZSc6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1pJzpcbiAgICBjYXNlICdpc28taXItMTI3JzpcbiAgICBjYXNlICdpc284ODU5LTYnOlxuICAgIGNhc2UgJ2lzbzg4NTk2JzpcbiAgICBjYXNlICdpc29fODg1OS02JzpcbiAgICBjYXNlICdpc29fODg1OS02OjE5ODcnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS02J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5ncmVlayc6XG4gICAgY2FzZSAnZWNtYS0xMTgnOlxuICAgIGNhc2UgJ2Vsb3RfOTI4JzpcbiAgICBjYXNlICdncmVlayc6XG4gICAgY2FzZSAnZ3JlZWs4JzpcbiAgICBjYXNlICdpc28tODg1OS03JzpcbiAgICBjYXNlICdpc28taXItMTI2JzpcbiAgICBjYXNlICdpc284ODU5LTcnOlxuICAgIGNhc2UgJ2lzbzg4NTk3JzpcbiAgICBjYXNlICdpc29fODg1OS03JzpcbiAgICBjYXNlICdpc29fODg1OS03OjE5ODcnOlxuICAgIGNhc2UgJ3N1bl9ldV9ncmVlayc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTcnXG4gICAgY2FzZSAnY3Npc284ODU5OGUnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5oZWJyZXcnOlxuICAgIGNhc2UgJ2hlYnJldyc6XG4gICAgY2FzZSAnaXNvLTg4NTktOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1lJzpcbiAgICBjYXNlICdpc28taXItMTM4JzpcbiAgICBjYXNlICdpc284ODU5LTgnOlxuICAgIGNhc2UgJ2lzbzg4NTk4JzpcbiAgICBjYXNlICdpc29fODg1OS04JzpcbiAgICBjYXNlICdpc29fODg1OS04OjE5ODgnOlxuICAgIGNhc2UgJ3Zpc3VhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgnXG4gICAgY2FzZSAnY3Npc284ODU5OGknOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtaSc6XG4gICAgY2FzZSAnbG9naWNhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgtSSdcbiAgICBjYXNlICdjc2lzb2xhdGluNic6XG4gICAgY2FzZSAnaXNvLTg4NTktMTAnOlxuICAgIGNhc2UgJ2lzby1pci0xNTcnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMCc6XG4gICAgY2FzZSAnbDYnOlxuICAgIGNhc2UgJ2xhdGluNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEwJ1xuICAgIGNhc2UgJ2lzby04ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5MTMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMydcbiAgICBjYXNlICdpc28tODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OTE0JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbjknOlxuICAgIGNhc2UgJ2lzby04ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5MTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE1JzpcbiAgICBjYXNlICdsOSc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE1J1xuICAgIGNhc2UgJ2lzby04ODU5LTE2JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTYnXG4gICAgY2FzZSAnY3Nrb2k4cic6XG4gICAgY2FzZSAna29pJzpcbiAgICBjYXNlICdrb2k4JzpcbiAgICBjYXNlICdrb2k4LXInOlxuICAgIGNhc2UgJ2tvaThfcic6XG4gICAgICByZXR1cm4gJ0tPSTgtUidcbiAgICBjYXNlICdrb2k4LXJ1JzpcbiAgICBjYXNlICdrb2k4LXUnOlxuICAgICAgcmV0dXJuICdLT0k4LVUnXG4gICAgY2FzZSAnY3NtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ21hYyc6XG4gICAgY2FzZSAnbWFjaW50b3NoJzpcbiAgICBjYXNlICd4LW1hYy1yb21hbic6XG4gICAgICByZXR1cm4gJ21hY2ludG9zaCdcbiAgICBjYXNlICdpc28tODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OTExJzpcbiAgICBjYXNlICd0aXMtNjIwJzpcbiAgICBjYXNlICd3aW5kb3dzLTg3NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtODc0J1xuICAgIGNhc2UgJ2NwMTI1MCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUwJzpcbiAgICBjYXNlICd4LWNwMTI1MCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MCdcbiAgICBjYXNlICdjcDEyNTEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MSc6XG4gICAgY2FzZSAneC1jcDEyNTEnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTEnXG4gICAgY2FzZSAnYW5zaV94My40LTE5NjgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdjcDEyNTInOlxuICAgIGNhc2UgJ2NwODE5JzpcbiAgICBjYXNlICdjc2lzb2xhdGluMSc6XG4gICAgY2FzZSAnaWJtODE5JzpcbiAgICBjYXNlICdpc28tODg1OS0xJzpcbiAgICBjYXNlICdpc28taXItMTAwJzpcbiAgICBjYXNlICdpc284ODU5LTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxJzpcbiAgICBjYXNlICdpc29fODg1OS0xJzpcbiAgICBjYXNlICdpc29fODg1OS0xOjE5ODcnOlxuICAgIGNhc2UgJ2wxJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ3VzLWFzY2lpJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTInOlxuICAgIGNhc2UgJ3gtY3AxMjUyJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUyJ1xuICAgIGNhc2UgJ2NwMTI1Myc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUzJzpcbiAgICBjYXNlICd4LWNwMTI1Myc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MydcbiAgICBjYXNlICdjcDEyNTQnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW41JzpcbiAgICBjYXNlICdpc28tODg1OS05JzpcbiAgICBjYXNlICdpc28taXItMTQ4JzpcbiAgICBjYXNlICdpc284ODU5LTknOlxuICAgIGNhc2UgJ2lzbzg4NTk5JzpcbiAgICBjYXNlICdpc29fODg1OS05JzpcbiAgICBjYXNlICdpc29fODg1OS05OjE5ODknOlxuICAgIGNhc2UgJ2w1JzpcbiAgICBjYXNlICdsYXRpbjUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NCc6XG4gICAgY2FzZSAneC1jcDEyNTQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTQnXG4gICAgY2FzZSAnY3AxMjU1JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTUnOlxuICAgIGNhc2UgJ3gtY3AxMjU1JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU1J1xuICAgIGNhc2UgJ2NwMTI1Nic6XG4gICAgY2FzZSAnd2luZG93cy0xMjU2JzpcbiAgICBjYXNlICd4LWNwMTI1Nic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NidcbiAgICBjYXNlICdjcDEyNTcnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nyc6XG4gICAgY2FzZSAneC1jcDEyNTcnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTcnXG4gICAgY2FzZSAnY3AxMjU4JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTgnOlxuICAgIGNhc2UgJ3gtY3AxMjU4JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU4J1xuICAgIGNhc2UgJ3gtbWFjLWN5cmlsbGljJzpcbiAgICBjYXNlICd4LW1hYy11a3JhaW5pYW4nOlxuICAgICAgcmV0dXJuICd4LW1hYy1jeXJpbGxpYydcbiAgICBjYXNlICdjaGluZXNlJzpcbiAgICBjYXNlICdjc2diMjMxMic6XG4gICAgY2FzZSAnY3Npc281OGdiMjMxMjgwJzpcbiAgICBjYXNlICdnYjIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTItODAnOlxuICAgIGNhc2UgJ2diayc6XG4gICAgY2FzZSAnaXNvLWlyLTU4JzpcbiAgICBjYXNlICd4LWdiayc6XG4gICAgICByZXR1cm4gJ0dCSydcbiAgICBjYXNlICdnYjE4MDMwJzpcbiAgICAgIHJldHVybiAnZ2IxODAzMCdcbiAgICBjYXNlICdiaWc1JzpcbiAgICBjYXNlICdiaWc1LWhrc2NzJzpcbiAgICBjYXNlICdjbi1iaWc1JzpcbiAgICBjYXNlICdjc2JpZzUnOlxuICAgIGNhc2UgJ3gteC1iaWc1JzpcbiAgICAgIHJldHVybiAnQmlnNSdcbiAgICBjYXNlICdjc2V1Y3BrZGZtdGphcGFuZXNlJzpcbiAgICBjYXNlICdldWMtanAnOlxuICAgIGNhc2UgJ3gtZXVjLWpwJzpcbiAgICAgIHJldHVybiAnRVVDLUpQJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmpwJzpcbiAgICBjYXNlICdpc28tMjAyMi1qcCc6XG4gICAgICByZXR1cm4gJ0lTTy0yMDIyLUpQJ1xuICAgIGNhc2UgJ2Nzc2hpZnRqaXMnOlxuICAgIGNhc2UgJ21zOTMyJzpcbiAgICBjYXNlICdtc19rYW5qaSc6XG4gICAgY2FzZSAnc2hpZnQtamlzJzpcbiAgICBjYXNlICdzaGlmdF9qaXMnOlxuICAgIGNhc2UgJ3NqaXMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMzFqJzpcbiAgICBjYXNlICd4LXNqaXMnOlxuICAgICAgcmV0dXJuICdTaGlmdF9KSVMnXG4gICAgY2FzZSAnY3NldWNrcic6XG4gICAgY2FzZSAnY3Nrc2M1NjAxMTk4Nyc6XG4gICAgY2FzZSAnZXVjLWtyJzpcbiAgICBjYXNlICdpc28taXItMTQ5JzpcbiAgICBjYXNlICdrb3JlYW4nOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg3JzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4OSc6XG4gICAgY2FzZSAna3NjNTYwMSc6XG4gICAgY2FzZSAna3NjXzU2MDEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtOTQ5JzpcbiAgICAgIHJldHVybiAnRVVDLUtSJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmtyJzpcbiAgICBjYXNlICdoei1nYi0yMzEyJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24tZXh0JzpcbiAgICBjYXNlICdpc28tMjAyMi1rcic6XG4gICAgY2FzZSAncmVwbGFjZW1lbnQnOlxuICAgICAgcmV0dXJuICdyZXBsYWNlbWVudCdcbiAgICBjYXNlICd1bmljb2RlZmZmZSc6XG4gICAgY2FzZSAndXRmLTE2YmUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgICBjYXNlICdjc3VuaWNvZGUnOlxuICAgIGNhc2UgJ2lzby0xMDY0Ni11Y3MtMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgIGNhc2UgJ3VuaWNvZGVmZWZmJzpcbiAgICBjYXNlICd1dGYtMTYnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2TEUnXG4gICAgY2FzZSAneC11c2VyLWRlZmluZWQnOlxuICAgICAgcmV0dXJuICd4LXVzZXItZGVmaW5lZCdcbiAgICBkZWZhdWx0OiByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEVuY29kaW5nXG59XG4iXSwibmFtZXMiOlsiZ2V0RW5jb2RpbmciLCJsYWJlbCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fileapi/encoding.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fileapi/filereader.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/filereader.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/fileapi/util.js\");\nconst { kState, kError, kResult, kEvents, kAborted } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fileapi/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nclass FileReader extends EventTarget {\n    constructor(){\n        super();\n        this[kState] = \"empty\";\n        this[kResult] = null;\n        this[kError] = null;\n        this[kEvents] = {\n            loadend: null,\n            error: null,\n            abort: null,\n            load: null,\n            progress: null,\n            loadstart: null\n        };\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */ readAsArrayBuffer(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsArrayBuffer\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsArrayBuffer(blob) method, when invoked,\n        // must initiate a read operation for blob with ArrayBuffer.\n        readOperation(this, blob, \"ArrayBuffer\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */ readAsBinaryString(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsBinaryString\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsBinaryString(blob) method, when invoked,\n        // must initiate a read operation for blob with BinaryString.\n        readOperation(this, blob, \"BinaryString\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */ readAsText(blob, encoding = undefined) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsText\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        if (encoding !== undefined) {\n            encoding = webidl.converters.DOMString(encoding);\n        }\n        // The readAsText(blob, encoding) method, when invoked,\n        // must initiate a read operation for blob with Text and encoding.\n        readOperation(this, blob, \"Text\", encoding);\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */ readAsDataURL(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"FileReader.readAsDataURL\"\n        });\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsDataURL(blob) method, when invoked, must\n        // initiate a read operation for blob with DataURL.\n        readOperation(this, blob, \"DataURL\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */ abort() {\n        // 1. If this's state is \"empty\" or if this's state is\n        //    \"done\" set this's result to null and terminate\n        //    this algorithm.\n        if (this[kState] === \"empty\" || this[kState] === \"done\") {\n            this[kResult] = null;\n            return;\n        }\n        // 2. If this's state is \"loading\" set this's state to\n        //    \"done\" and set this's result to null.\n        if (this[kState] === \"loading\") {\n            this[kState] = \"done\";\n            this[kResult] = null;\n        }\n        // 3. If there are any tasks from this on the file reading\n        //    task source in an affiliated task queue, then remove\n        //    those tasks from that task queue.\n        this[kAborted] = true;\n        // 4. Terminate the algorithm for the read method being processed.\n        // TODO\n        // 5. Fire a progress event called abort at this.\n        fireAProgressEvent(\"abort\", this);\n        // 6. If this's state is not \"loading\", fire a progress\n        //    event called loadend at this.\n        if (this[kState] !== \"loading\") {\n            fireAProgressEvent(\"loadend\", this);\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */ get readyState() {\n        webidl.brandCheck(this, FileReader);\n        switch(this[kState]){\n            case \"empty\":\n                return this.EMPTY;\n            case \"loading\":\n                return this.LOADING;\n            case \"done\":\n                return this.DONE;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */ get result() {\n        webidl.brandCheck(this, FileReader);\n        // The result attribute’s getter, when invoked, must return\n        // this's result.\n        return this[kResult];\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */ get error() {\n        webidl.brandCheck(this, FileReader);\n        // The error attribute’s getter, when invoked, must return\n        // this's error.\n        return this[kError];\n    }\n    get onloadend() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadend;\n    }\n    set onloadend(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadend) {\n            this.removeEventListener(\"loadend\", this[kEvents].loadend);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadend = fn;\n            this.addEventListener(\"loadend\", fn);\n        } else {\n            this[kEvents].loadend = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].error) {\n            this.removeEventListener(\"error\", this[kEvents].error);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this[kEvents].error = null;\n        }\n    }\n    get onloadstart() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadstart;\n    }\n    set onloadstart(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadstart) {\n            this.removeEventListener(\"loadstart\", this[kEvents].loadstart);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadstart = fn;\n            this.addEventListener(\"loadstart\", fn);\n        } else {\n            this[kEvents].loadstart = null;\n        }\n    }\n    get onprogress() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].progress;\n    }\n    set onprogress(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].progress) {\n            this.removeEventListener(\"progress\", this[kEvents].progress);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].progress = fn;\n            this.addEventListener(\"progress\", fn);\n        } else {\n            this[kEvents].progress = null;\n        }\n    }\n    get onload() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].load;\n    }\n    set onload(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].load) {\n            this.removeEventListener(\"load\", this[kEvents].load);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].load = fn;\n            this.addEventListener(\"load\", fn);\n        } else {\n            this[kEvents].load = null;\n        }\n    }\n    get onabort() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].abort;\n    }\n    set onabort(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].abort) {\n            this.removeEventListener(\"abort\", this[kEvents].abort);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].abort = fn;\n            this.addEventListener(\"abort\", fn);\n        } else {\n            this[kEvents].abort = null;\n        }\n    }\n}\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0;\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1;\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2;\nObject.defineProperties(FileReader.prototype, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors,\n    readAsArrayBuffer: kEnumerableProperty,\n    readAsBinaryString: kEnumerableProperty,\n    readAsText: kEnumerableProperty,\n    readAsDataURL: kEnumerableProperty,\n    abort: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    result: kEnumerableProperty,\n    error: kEnumerableProperty,\n    onloadstart: kEnumerableProperty,\n    onprogress: kEnumerableProperty,\n    onload: kEnumerableProperty,\n    onabort: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onloadend: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"FileReader\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(FileReader, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors\n});\nmodule.exports = {\n    FileReader\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL2ZpbGVyZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLHlCQUF5QixFQUN6QkMsYUFBYSxFQUNiQyxrQkFBa0IsRUFDbkIsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pDLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxNQUFNLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFTyxtQkFBbUIsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNUSxtQkFBbUJDO0lBQ3ZCQyxhQUFlO1FBQ2IsS0FBSztRQUVMLElBQUksQ0FBQ1QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNFLFFBQVEsR0FBRztZQUNkTyxTQUFTO1lBQ1RDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLFVBQVU7WUFDVkMsV0FBVztRQUNiO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDREMsa0JBQW1CQyxJQUFJLEVBQUU7UUFDdkJaLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCRixPQUFPYyxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1lBQUVDLFFBQVE7UUFBK0I7UUFFbEZKLE9BQU9aLE9BQU9pQixVQUFVLENBQUNDLElBQUksQ0FBQ04sTUFBTTtZQUFFTyxRQUFRO1FBQU07UUFFcEQsb0RBQW9EO1FBQ3BELDREQUE0RDtRQUM1RDNCLGNBQWMsSUFBSSxFQUFFb0IsTUFBTTtJQUM1QjtJQUVBOzs7R0FHQyxHQUNEUSxtQkFBb0JSLElBQUksRUFBRTtRQUN4QlosT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEJGLE9BQU9jLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUFnQztRQUVuRkosT0FBT1osT0FBT2lCLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDTixNQUFNO1lBQUVPLFFBQVE7UUFBTTtRQUVwRCxxREFBcUQ7UUFDckQsNkRBQTZEO1FBQzdEM0IsY0FBYyxJQUFJLEVBQUVvQixNQUFNO0lBQzVCO0lBRUE7Ozs7R0FJQyxHQUNEUyxXQUFZVCxJQUFJLEVBQUVVLFdBQVdDLFNBQVMsRUFBRTtRQUN0Q3ZCLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCRixPQUFPYyxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1lBQUVDLFFBQVE7UUFBd0I7UUFFM0VKLE9BQU9aLE9BQU9pQixVQUFVLENBQUNDLElBQUksQ0FBQ04sTUFBTTtZQUFFTyxRQUFRO1FBQU07UUFFcEQsSUFBSUcsYUFBYUMsV0FBVztZQUMxQkQsV0FBV3RCLE9BQU9pQixVQUFVLENBQUNPLFNBQVMsQ0FBQ0Y7UUFDekM7UUFFQSx1REFBdUQ7UUFDdkQsa0VBQWtFO1FBQ2xFOUIsY0FBYyxJQUFJLEVBQUVvQixNQUFNLFFBQVFVO0lBQ3BDO0lBRUE7OztHQUdDLEdBQ0RHLGNBQWViLElBQUksRUFBRTtRQUNuQlosT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEJGLE9BQU9jLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUEyQjtRQUU5RUosT0FBT1osT0FBT2lCLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDTixNQUFNO1lBQUVPLFFBQVE7UUFBTTtRQUVwRCxxREFBcUQ7UUFDckQsbURBQW1EO1FBQ25EM0IsY0FBYyxJQUFJLEVBQUVvQixNQUFNO0lBQzVCO0lBRUE7O0dBRUMsR0FDREwsUUFBUztRQUNQLHNEQUFzRDtRQUN0RCxvREFBb0Q7UUFDcEQscUJBQXFCO1FBQ3JCLElBQUksSUFBSSxDQUFDWixPQUFPLEtBQUssV0FBVyxJQUFJLENBQUNBLE9BQU8sS0FBSyxRQUFRO1lBQ3ZELElBQUksQ0FBQ0UsUUFBUSxHQUFHO1lBQ2hCO1FBQ0Y7UUFFQSxzREFBc0Q7UUFDdEQsMkNBQTJDO1FBQzNDLElBQUksSUFBSSxDQUFDRixPQUFPLEtBQUssV0FBVztZQUM5QixJQUFJLENBQUNBLE9BQU8sR0FBRztZQUNmLElBQUksQ0FBQ0UsUUFBUSxHQUFHO1FBQ2xCO1FBRUEsMERBQTBEO1FBQzFELDBEQUEwRDtRQUMxRCx1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDRSxTQUFTLEdBQUc7UUFFakIsa0VBQWtFO1FBQ2xFLE9BQU87UUFFUCxpREFBaUQ7UUFDakROLG1CQUFtQixTQUFTLElBQUk7UUFFaEMsdURBQXVEO1FBQ3ZELG1DQUFtQztRQUNuQyxJQUFJLElBQUksQ0FBQ0UsT0FBTyxLQUFLLFdBQVc7WUFDOUJGLG1CQUFtQixXQUFXLElBQUk7UUFDcEM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsSUFBSWlDLGFBQWM7UUFDaEIxQixPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFRLElBQUksQ0FBQ1AsT0FBTztZQUNsQixLQUFLO2dCQUFTLE9BQU8sSUFBSSxDQUFDZ0MsS0FBSztZQUMvQixLQUFLO2dCQUFXLE9BQU8sSUFBSSxDQUFDQyxPQUFPO1lBQ25DLEtBQUs7Z0JBQVEsT0FBTyxJQUFJLENBQUNDLElBQUk7UUFDL0I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsSUFBSUMsU0FBVTtRQUNaOUIsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsMkRBQTJEO1FBQzNELGlCQUFpQjtRQUNqQixPQUFPLElBQUksQ0FBQ0wsUUFBUTtJQUN0QjtJQUVBOztHQUVDLEdBQ0QsSUFBSVMsUUFBUztRQUNYTixPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QiwwREFBMEQ7UUFDMUQsZ0JBQWdCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDTixPQUFPO0lBQ3JCO0lBRUEsSUFBSW1DLFlBQWE7UUFDZi9CLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLE9BQU8sSUFBSSxDQUFDSixRQUFRLENBQUNPLE9BQU87SUFDOUI7SUFFQSxJQUFJMEIsVUFBV0MsRUFBRSxFQUFFO1FBQ2pCaEMsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsSUFBSSxJQUFJLENBQUNKLFFBQVEsQ0FBQ08sT0FBTyxFQUFFO1lBQ3pCLElBQUksQ0FBQzRCLG1CQUFtQixDQUFDLFdBQVcsSUFBSSxDQUFDbkMsUUFBUSxDQUFDTyxPQUFPO1FBQzNEO1FBRUEsSUFBSSxPQUFPMkIsT0FBTyxZQUFZO1lBQzVCLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ08sT0FBTyxHQUFHMkI7WUFDeEIsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQyxXQUFXRjtRQUNuQyxPQUFPO1lBQ0wsSUFBSSxDQUFDbEMsUUFBUSxDQUFDTyxPQUFPLEdBQUc7UUFDMUI7SUFDRjtJQUVBLElBQUk4QixVQUFXO1FBQ2JuQyxPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0osUUFBUSxDQUFDUSxLQUFLO0lBQzVCO0lBRUEsSUFBSTZCLFFBQVNILEVBQUUsRUFBRTtRQUNmaEMsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsSUFBSSxJQUFJLENBQUNKLFFBQVEsQ0FBQ1EsS0FBSyxFQUFFO1lBQ3ZCLElBQUksQ0FBQzJCLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDbkMsUUFBUSxDQUFDUSxLQUFLO1FBQ3ZEO1FBRUEsSUFBSSxPQUFPMEIsT0FBTyxZQUFZO1lBQzVCLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ1EsS0FBSyxHQUFHMEI7WUFDdEIsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQyxTQUFTRjtRQUNqQyxPQUFPO1lBQ0wsSUFBSSxDQUFDbEMsUUFBUSxDQUFDUSxLQUFLLEdBQUc7UUFDeEI7SUFDRjtJQUVBLElBQUk4QixjQUFlO1FBQ2pCcEMsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNKLFFBQVEsQ0FBQ1ksU0FBUztJQUNoQztJQUVBLElBQUkwQixZQUFhSixFQUFFLEVBQUU7UUFDbkJoQyxPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixJQUFJLElBQUksQ0FBQ0osUUFBUSxDQUFDWSxTQUFTLEVBQUU7WUFDM0IsSUFBSSxDQUFDdUIsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUNuQyxRQUFRLENBQUNZLFNBQVM7UUFDL0Q7UUFFQSxJQUFJLE9BQU9zQixPQUFPLFlBQVk7WUFDNUIsSUFBSSxDQUFDbEMsUUFBUSxDQUFDWSxTQUFTLEdBQUdzQjtZQUMxQixJQUFJLENBQUNFLGdCQUFnQixDQUFDLGFBQWFGO1FBQ3JDLE9BQU87WUFDTCxJQUFJLENBQUNsQyxRQUFRLENBQUNZLFNBQVMsR0FBRztRQUM1QjtJQUNGO0lBRUEsSUFBSTJCLGFBQWM7UUFDaEJyQyxPQUFPYSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0osUUFBUSxDQUFDVyxRQUFRO0lBQy9CO0lBRUEsSUFBSTRCLFdBQVlMLEVBQUUsRUFBRTtRQUNsQmhDLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLElBQUksSUFBSSxDQUFDSixRQUFRLENBQUNXLFFBQVEsRUFBRTtZQUMxQixJQUFJLENBQUN3QixtQkFBbUIsQ0FBQyxZQUFZLElBQUksQ0FBQ25DLFFBQVEsQ0FBQ1csUUFBUTtRQUM3RDtRQUVBLElBQUksT0FBT3VCLE9BQU8sWUFBWTtZQUM1QixJQUFJLENBQUNsQyxRQUFRLENBQUNXLFFBQVEsR0FBR3VCO1lBQ3pCLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUMsWUFBWUY7UUFDcEMsT0FBTztZQUNMLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ1csUUFBUSxHQUFHO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJNkIsU0FBVTtRQUNadEMsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNKLFFBQVEsQ0FBQ1UsSUFBSTtJQUMzQjtJQUVBLElBQUk4QixPQUFRTixFQUFFLEVBQUU7UUFDZGhDLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLElBQUksSUFBSSxDQUFDSixRQUFRLENBQUNVLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUN5QixtQkFBbUIsQ0FBQyxRQUFRLElBQUksQ0FBQ25DLFFBQVEsQ0FBQ1UsSUFBSTtRQUNyRDtRQUVBLElBQUksT0FBT3dCLE9BQU8sWUFBWTtZQUM1QixJQUFJLENBQUNsQyxRQUFRLENBQUNVLElBQUksR0FBR3dCO1lBQ3JCLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUMsUUFBUUY7UUFDaEMsT0FBTztZQUNMLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ1UsSUFBSSxHQUFHO1FBQ3ZCO0lBQ0Y7SUFFQSxJQUFJK0IsVUFBVztRQUNidkMsT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNKLFFBQVEsQ0FBQ1MsS0FBSztJQUM1QjtJQUVBLElBQUlnQyxRQUFTUCxFQUFFLEVBQUU7UUFDZmhDLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCLElBQUksSUFBSSxDQUFDSixRQUFRLENBQUNTLEtBQUssRUFBRTtZQUN2QixJQUFJLENBQUMwQixtQkFBbUIsQ0FBQyxTQUFTLElBQUksQ0FBQ25DLFFBQVEsQ0FBQ1MsS0FBSztRQUN2RDtRQUVBLElBQUksT0FBT3lCLE9BQU8sWUFBWTtZQUM1QixJQUFJLENBQUNsQyxRQUFRLENBQUNTLEtBQUssR0FBR3lCO1lBQ3RCLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUMsU0FBU0Y7UUFDakMsT0FBTztZQUNMLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQ1MsS0FBSyxHQUFHO1FBQ3hCO0lBQ0Y7QUFDRjtBQUVBLHNEQUFzRDtBQUN0REwsV0FBV3lCLEtBQUssR0FBR3pCLFdBQVdzQyxTQUFTLENBQUNiLEtBQUssR0FBRztBQUNoRCx3REFBd0Q7QUFDeER6QixXQUFXMEIsT0FBTyxHQUFHMUIsV0FBV3NDLFNBQVMsQ0FBQ1osT0FBTyxHQUFHO0FBQ3BELHFEQUFxRDtBQUNyRDFCLFdBQVcyQixJQUFJLEdBQUczQixXQUFXc0MsU0FBUyxDQUFDWCxJQUFJLEdBQUc7QUFFOUNZLE9BQU9DLGdCQUFnQixDQUFDeEMsV0FBV3NDLFNBQVMsRUFBRTtJQUM1Q2IsT0FBT3BDO0lBQ1BxQyxTQUFTckM7SUFDVHNDLE1BQU10QztJQUNOb0IsbUJBQW1CVjtJQUNuQm1CLG9CQUFvQm5CO0lBQ3BCb0IsWUFBWXBCO0lBQ1p3QixlQUFleEI7SUFDZk0sT0FBT047SUFDUHlCLFlBQVl6QjtJQUNaNkIsUUFBUTdCO0lBQ1JLLE9BQU9MO0lBQ1BtQyxhQUFhbkM7SUFDYm9DLFlBQVlwQztJQUNacUMsUUFBUXJDO0lBQ1JzQyxTQUFTdEM7SUFDVGtDLFNBQVNsQztJQUNUOEIsV0FBVzlCO0lBQ1gsQ0FBQzBDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQVAsT0FBT0MsZ0JBQWdCLENBQUN4QyxZQUFZO0lBQ2xDeUIsT0FBT3BDO0lBQ1BxQyxTQUFTckM7SUFDVHNDLE1BQU10QztBQUNSO0FBRUEwRCxPQUFPQyxPQUFPLEdBQUc7SUFDZmhEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvZmlsZXJlYWRlci5qcz83MTNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGtTdGF0ZSxcbiAga0Vycm9yLFxuICBrUmVzdWx0LFxuICBrRXZlbnRzLFxuICBrQWJvcnRlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY2xhc3MgRmlsZVJlYWRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1N0YXRlXSA9ICdlbXB0eSdcbiAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgIHRoaXNba0Vycm9yXSA9IG51bGxcbiAgICB0aGlzW2tFdmVudHNdID0ge1xuICAgICAgbG9hZGVuZDogbnVsbCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgYWJvcnQ6IG51bGwsXG4gICAgICBsb2FkOiBudWxsLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICBsb2Fkc3RhcnQ6IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLXJlYWRBc0FycmF5QnVmZmVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNBcnJheUJ1ZmZlciAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcicgfSlcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0FycmF5QnVmZmVyKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEFycmF5QnVmZmVyLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkQXNCaW5hcnlTdHJpbmdcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0JpbmFyeVN0cmluZyAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRmlsZVJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcnIH0pXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNCaW5hcnlTdHJpbmcoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggQmluYXJ5U3RyaW5nLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0JpbmFyeVN0cmluZycpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzRGF0YVRleHRcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ1xuICAgKi9cbiAgcmVhZEFzVGV4dCAoYmxvYiwgZW5jb2RpbmcgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzVGV4dCcgfSlcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGVuY29kaW5nKVxuICAgIH1cblxuICAgIC8vIFRoZSByZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBUZXh0IGFuZCBlbmNvZGluZy5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdUZXh0JywgZW5jb2RpbmcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLXJlYWRBc0RhdGFVUkxcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0RhdGFVUkwgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ0ZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTCcgfSlcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0RhdGFVUkwoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsIG11c3RcbiAgICAvLyBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggRGF0YVVSTC5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdEYXRhVVJMJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tYWJvcnRcbiAgICovXG4gIGFib3J0ICgpIHtcbiAgICAvLyAxLiBJZiB0aGlzJ3Mgc3RhdGUgaXMgXCJlbXB0eVwiIG9yIGlmIHRoaXMncyBzdGF0ZSBpc1xuICAgIC8vICAgIFwiZG9uZVwiIHNldCB0aGlzJ3MgcmVzdWx0IHRvIG51bGwgYW5kIHRlcm1pbmF0ZVxuICAgIC8vICAgIHRoaXMgYWxnb3JpdGhtLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gPT09ICdlbXB0eScgfHwgdGhpc1trU3RhdGVdID09PSAnZG9uZScpIHtcbiAgICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlzJ3Mgc3RhdGUgaXMgXCJsb2FkaW5nXCIgc2V0IHRoaXMncyBzdGF0ZSB0b1xuICAgIC8vICAgIFwiZG9uZVwiIGFuZCBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gPT09ICdsb2FkaW5nJykge1xuICAgICAgdGhpc1trU3RhdGVdID0gJ2RvbmUnXG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoZXJlIGFyZSBhbnkgdGFza3MgZnJvbSB0aGlzIG9uIHRoZSBmaWxlIHJlYWRpbmdcbiAgICAvLyAgICB0YXNrIHNvdXJjZSBpbiBhbiBhZmZpbGlhdGVkIHRhc2sgcXVldWUsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgdGhvc2UgdGFza3MgZnJvbSB0aGF0IHRhc2sgcXVldWUuXG4gICAgdGhpc1trQWJvcnRlZF0gPSB0cnVlXG5cbiAgICAvLyA0LiBUZXJtaW5hdGUgdGhlIGFsZ29yaXRobSBmb3IgdGhlIHJlYWQgbWV0aG9kIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAvLyBUT0RPXG5cbiAgICAvLyA1LiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGFib3J0IGF0IHRoaXMuXG4gICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdhYm9ydCcsIHRoaXMpXG5cbiAgICAvLyA2LiBJZiB0aGlzJ3Mgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCB0aGlzLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgdGhpcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItcmVhZHlzdGF0ZVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBzd2l0Y2ggKHRoaXNba1N0YXRlXSkge1xuICAgICAgY2FzZSAnZW1wdHknOiByZXR1cm4gdGhpcy5FTVBUWVxuICAgICAgY2FzZSAnbG9hZGluZyc6IHJldHVybiB0aGlzLkxPQURJTkdcbiAgICAgIGNhc2UgJ2RvbmUnOiByZXR1cm4gdGhpcy5ET05FXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlc3VsdFxuICAgKi9cbiAgZ2V0IHJlc3VsdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIC8vIFRoZSByZXN1bHQgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgcmVzdWx0LlxuICAgIHJldHVybiB0aGlzW2tSZXN1bHRdXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZXJyb3JcbiAgICovXG4gIGdldCBlcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIC8vIFRoZSBlcnJvciBhdHRyaWJ1dGXigJlzIGdldHRlciwgd2hlbiBpbnZva2VkLCBtdXN0IHJldHVyblxuICAgIC8vIHRoaXMncyBlcnJvci5cbiAgICByZXR1cm4gdGhpc1trRXJyb3JdXG4gIH1cblxuICBnZXQgb25sb2FkZW5kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZGVuZFxuICB9XG5cbiAgc2V0IG9ubG9hZGVuZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZGVuZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgdGhpc1trRXZlbnRzXS5sb2FkZW5kKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkZW5kID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXNba0V2ZW50c10uZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubG9hZHN0YXJ0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0XG4gIH1cblxuICBzZXQgb25sb2Fkc3RhcnQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRzdGFydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCB0aGlzW2tFdmVudHNdLmxvYWRzdGFydClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRzdGFydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRzdGFydCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25wcm9ncmVzcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLnByb2dyZXNzXG4gIH1cblxuICBzZXQgb25wcm9ncmVzcyAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzW2tFdmVudHNdLnByb2dyZXNzKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2FkXG4gIH1cblxuICBzZXQgb25sb2FkIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2FkKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzW2tFdmVudHNdLmxvYWQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uYWJvcnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5hYm9ydFxuICB9XG5cbiAgc2V0IG9uYWJvcnQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmFib3J0KSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpc1trRXZlbnRzXS5hYm9ydClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmFib3J0ID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVtcHR5XG5GaWxlUmVhZGVyLkVNUFRZID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRU1QVFkgPSAwXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItbG9hZGluZ1xuRmlsZVJlYWRlci5MT0FESU5HID0gRmlsZVJlYWRlci5wcm90b3R5cGUuTE9BRElORyA9IDFcbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1kb25lXG5GaWxlUmVhZGVyLkRPTkUgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5ET05FID0gMlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWxlUmVhZGVyLnByb3RvdHlwZSwge1xuICBFTVBUWTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgTE9BRElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgRE9ORTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZEFzQXJyYXlCdWZmZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0JpbmFyeVN0cmluZzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzRGF0YVVSTDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWJvcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlc3VsdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZHN0YXJ0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbnByb2dyZXNzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uYWJvcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0ZpbGVSZWFkZXInLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlciwge1xuICBFTVBUWTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgTE9BRElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgRE9ORTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yc1xufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZpbGVSZWFkZXJcbn1cbiJdLCJuYW1lcyI6WyJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwicmVhZE9wZXJhdGlvbiIsImZpcmVBUHJvZ3Jlc3NFdmVudCIsInJlcXVpcmUiLCJrU3RhdGUiLCJrRXJyb3IiLCJrUmVzdWx0Iiwia0V2ZW50cyIsImtBYm9ydGVkIiwid2ViaWRsIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIkZpbGVSZWFkZXIiLCJFdmVudFRhcmdldCIsImNvbnN0cnVjdG9yIiwibG9hZGVuZCIsImVycm9yIiwiYWJvcnQiLCJsb2FkIiwicHJvZ3Jlc3MiLCJsb2Fkc3RhcnQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImJsb2IiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJCbG9iIiwic3RyaWN0IiwicmVhZEFzQmluYXJ5U3RyaW5nIiwicmVhZEFzVGV4dCIsImVuY29kaW5nIiwidW5kZWZpbmVkIiwiRE9NU3RyaW5nIiwicmVhZEFzRGF0YVVSTCIsInJlYWR5U3RhdGUiLCJFTVBUWSIsIkxPQURJTkciLCJET05FIiwicmVzdWx0Iiwib25sb2FkZW5kIiwiZm4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uZXJyb3IiLCJvbmxvYWRzdGFydCIsIm9ucHJvZ3Jlc3MiLCJvbmxvYWQiLCJvbmFib3J0IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fileapi/filereader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fileapi/progressevent.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/progressevent.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst kState = Symbol(\"ProgressEvent state\");\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */ class ProgressEvent extends Event {\n    constructor(type, eventInitDict = {}){\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});\n        super(type, eventInitDict);\n        this[kState] = {\n            lengthComputable: eventInitDict.lengthComputable,\n            loaded: eventInitDict.loaded,\n            total: eventInitDict.total\n        };\n    }\n    get lengthComputable() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].lengthComputable;\n    }\n    get loaded() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].loaded;\n    }\n    get total() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].total;\n    }\n}\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n    {\n        key: \"lengthComputable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"loaded\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"total\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n]);\nmodule.exports = {\n    ProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3Byb2dyZXNzZXZlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUzQixNQUFNQyxTQUFTQyxPQUFPO0FBRXRCOztDQUVDLEdBQ0QsTUFBTUMsc0JBQXNCQztJQUMxQkMsWUFBYUMsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUU7UUFDckNELE9BQU9QLE9BQU9TLFVBQVUsQ0FBQ0MsU0FBUyxDQUFDSDtRQUNuQ0MsZ0JBQWdCUixPQUFPUyxVQUFVLENBQUNFLGlCQUFpQixDQUFDSCxpQkFBaUIsQ0FBQztRQUV0RSxLQUFLLENBQUNELE1BQU1DO1FBRVosSUFBSSxDQUFDTixPQUFPLEdBQUc7WUFDYlUsa0JBQWtCSixjQUFjSSxnQkFBZ0I7WUFDaERDLFFBQVFMLGNBQWNLLE1BQU07WUFDNUJDLE9BQU9OLGNBQWNNLEtBQUs7UUFDNUI7SUFDRjtJQUVBLElBQUlGLG1CQUFvQjtRQUN0QlosT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1UsZ0JBQWdCO0lBQ3RDO0lBRUEsSUFBSUMsU0FBVTtRQUNaYixPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDVyxNQUFNO0lBQzVCO0lBRUEsSUFBSUMsUUFBUztRQUNYZCxPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDWSxLQUFLO0lBQzNCO0FBQ0Y7QUFFQWQsT0FBT1MsVUFBVSxDQUFDRSxpQkFBaUIsR0FBR1gsT0FBT2dCLG1CQUFtQixDQUFDO0lBQy9EO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQyxxQkFBcUI7UUFDbERXLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUMscUJBQXFCO1FBQ2xEVyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0NBQ0Q7QUFFREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3Byb2dyZXNzZXZlbnQuanM/MTQ3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5cbmNvbnN0IGtTdGF0ZSA9IFN5bWJvbCgnUHJvZ3Jlc3NFdmVudCBzdGF0ZScpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3Byb2dyZXNzZXZlbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSlcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudEluaXREaWN0Lmxlbmd0aENvbXB1dGFibGUsXG4gICAgICBsb2FkZWQ6IGV2ZW50SW5pdERpY3QubG9hZGVkLFxuICAgICAgdG90YWw6IGV2ZW50SW5pdERpY3QudG90YWxcbiAgICB9XG4gIH1cblxuICBnZXQgbGVuZ3RoQ29tcHV0YWJsZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGVuZ3RoQ29tcHV0YWJsZVxuICB9XG5cbiAgZ2V0IGxvYWRlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubG9hZGVkXG4gIH1cblxuICBnZXQgdG90YWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnRvdGFsXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdsZW5ndGhDb21wdXRhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnbG9hZGVkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3RvdGFsJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQcm9ncmVzc0V2ZW50XG59XG4iXSwibmFtZXMiOlsid2ViaWRsIiwicmVxdWlyZSIsImtTdGF0ZSIsIlN5bWJvbCIsIlByb2dyZXNzRXZlbnQiLCJFdmVudCIsImNvbnN0cnVjdG9yIiwidHlwZSIsImV2ZW50SW5pdERpY3QiLCJjb252ZXJ0ZXJzIiwiRE9NU3RyaW5nIiwiUHJvZ3Jlc3NFdmVudEluaXQiLCJsZW5ndGhDb21wdXRhYmxlIiwibG9hZGVkIiwidG90YWwiLCJicmFuZENoZWNrIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImJvb2xlYW4iLCJkZWZhdWx0VmFsdWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fileapi/progressevent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fileapi/symbols.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/symbols.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kState: Symbol(\"FileReader state\"),\n    kResult: Symbol(\"FileReader result\"),\n    kError: Symbol(\"FileReader error\"),\n    kLastProgressEventFired: Symbol(\"FileReader last progress event fired timestamp\"),\n    kEvents: Symbol(\"FileReader events\"),\n    kAborted: Symbol(\"FileReader aborted\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLFFBQVFDLE9BQU87SUFDZkMsU0FBU0QsT0FBTztJQUNoQkUsUUFBUUYsT0FBTztJQUNmRyx5QkFBeUJILE9BQU87SUFDaENJLFNBQVNKLE9BQU87SUFDaEJLLFVBQVVMLE9BQU87QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvc3ltYm9scy5qcz83MDgxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1N0YXRlOiBTeW1ib2woJ0ZpbGVSZWFkZXIgc3RhdGUnKSxcbiAga1Jlc3VsdDogU3ltYm9sKCdGaWxlUmVhZGVyIHJlc3VsdCcpLFxuICBrRXJyb3I6IFN5bWJvbCgnRmlsZVJlYWRlciBlcnJvcicpLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZDogU3ltYm9sKCdGaWxlUmVhZGVyIGxhc3QgcHJvZ3Jlc3MgZXZlbnQgZmlyZWQgdGltZXN0YW1wJyksXG4gIGtFdmVudHM6IFN5bWJvbCgnRmlsZVJlYWRlciBldmVudHMnKSxcbiAga0Fib3J0ZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBhYm9ydGVkJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia1N0YXRlIiwiU3ltYm9sIiwia1Jlc3VsdCIsImtFcnJvciIsImtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkIiwia0V2ZW50cyIsImtBYm9ydGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fileapi/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/fileapi/util.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/fileapi/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/fileapi/symbols.js\");\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(rsc)/./node_modules/undici/lib/fileapi/progressevent.js\");\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(rsc)/./node_modules/undici/lib/fileapi/encoding.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { btoa } = __webpack_require__(/*! buffer */ \"buffer\");\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function readOperation(fr, blob, type, encodingName) {\n    // 1. If fr’s state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[kState] === \"loading\") {\n        throw new DOMException(\"Invalid state\", \"InvalidStateError\");\n    }\n    // 2. Set fr’s state to \"loading\".\n    fr[kState] = \"loading\";\n    // 3. Set fr’s result to null.\n    fr[kResult] = null;\n    // 4. Set fr’s error to null.\n    fr[kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[kAborted]){\n            // 1. Wait for chunkPromise to be fulfilled or rejected.\n            try {\n                const { done, value } = await chunkPromise;\n                // 2. If chunkPromise is fulfilled, and isFirstChunk is\n                //    true, queue a task to fire a progress event called\n                //    loadstart at fr.\n                if (isFirstChunk && !fr[kAborted]) {\n                    queueMicrotask(()=>{\n                        fireAProgressEvent(\"loadstart\", fr);\n                    });\n                }\n                // 3. Set isFirstChunk to false.\n                isFirstChunk = false;\n                // 4. If chunkPromise is fulfilled with an object whose\n                //    done property is false and whose value property is\n                //    a Uint8Array object, run these steps:\n                if (!done && types.isUint8Array(value)) {\n                    // 1. Let bs be the byte sequence represented by the\n                    //    Uint8Array object.\n                    // 2. Append bs to bytes.\n                    bytes.push(value);\n                    // 3. If roughly 50ms have passed since these steps\n                    //    were last invoked, queue a task to fire a\n                    //    progress event called progress at fr.\n                    if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n                        fr[kLastProgressEventFired] = Date.now();\n                        queueMicrotask(()=>{\n                            fireAProgressEvent(\"progress\", fr);\n                        });\n                    }\n                    // 4. Set chunkPromise to the result of reading a\n                    //    chunk from stream with reader.\n                    chunkPromise = reader.read();\n                } else if (done) {\n                    // 5. Otherwise, if chunkPromise is fulfilled with an\n                    //    object whose done property is true, queue a task\n                    //    to run the following steps and abort this algorithm:\n                    queueMicrotask(()=>{\n                        // 1. Set fr’s state to \"done\".\n                        fr[kState] = \"done\";\n                        // 2. Let result be the result of package data given\n                        //    bytes, type, blob’s type, and encodingName.\n                        try {\n                            const result = packageData(bytes, type, blob.type, encodingName);\n                            // 4. Else:\n                            if (fr[kAborted]) {\n                                return;\n                            }\n                            // 1. Set fr’s result to result.\n                            fr[kResult] = result;\n                            // 2. Fire a progress event called load at the fr.\n                            fireAProgressEvent(\"load\", fr);\n                        } catch (error) {\n                            // 3. If package data threw an exception error:\n                            // 1. Set fr’s error to error.\n                            fr[kError] = error;\n                            // 2. Fire a progress event called error at fr.\n                            fireAProgressEvent(\"error\", fr);\n                        }\n                        // 5. If fr’s state is not \"loading\", fire a progress\n                        //    event called loadend at the fr.\n                        if (fr[kState] !== \"loading\") {\n                            fireAProgressEvent(\"loadend\", fr);\n                        }\n                    });\n                    break;\n                }\n            } catch (error) {\n                if (fr[kAborted]) {\n                    return;\n                }\n                // 6. Otherwise, if chunkPromise is rejected with an\n                //    error error, queue a task to run the following\n                //    steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set fr’s state to \"done\".\n                    fr[kState] = \"done\";\n                    // 2. Set fr’s error to error.\n                    fr[kError] = error;\n                    // 3. Fire a progress event called error at fr.\n                    fireAProgressEvent(\"error\", fr);\n                    // 4. If fr’s state is not \"loading\", fire a progress\n                    //    event called loadend at fr.\n                    if (fr[kState] !== \"loading\") {\n                        fireAProgressEvent(\"loadend\", fr);\n                    }\n                });\n                break;\n            }\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case \"DataURL\":\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = \"data:\";\n                const parsed = parseMIMEType(mimeType || \"application/octet-stream\");\n                if (parsed !== \"failure\") {\n                    dataURL += serializeAMimeType(parsed);\n                }\n                dataURL += \";base64,\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    dataURL += btoa(decoder.write(chunk));\n                }\n                dataURL += btoa(decoder.end());\n                return dataURL;\n            }\n        case \"Text\":\n            {\n                // 1. Let encoding be failure\n                let encoding = \"failure\";\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) {\n                    encoding = getEncoding(encodingName);\n                }\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === \"failure\" && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from type’s parameters[\"charset\"].\n                    if (type !== \"failure\") {\n                        encoding = getEncoding(type.parameters.get(\"charset\"));\n                    }\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === \"failure\") {\n                    encoding = \"UTF-8\";\n                }\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return decode(bytes, encoding);\n            }\n        case \"ArrayBuffer\":\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case \"BinaryString\":\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = \"\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    binaryString += decoder.write(chunk);\n                }\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function decode(ioQueue, encoding) {\n    const bytes = combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === \"UTF-8\" ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encoding’s\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) {\n        return \"UTF-8\";\n    } else if (a === 0xFE && b === 0xFF) {\n        return \"UTF-16BE\";\n    } else if (a === 0xFF && b === 0xFE) {\n        return \"UTF-16LE\";\n    }\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\nmodule.exports = {\n    staticPropertyDescriptors,\n    readOperation,\n    fireAProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9maWxlYXBpL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLFFBQVEsRUFDUkMsdUJBQXVCLEVBQ3hCLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRSxXQUFXLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDaEMsTUFBTSxFQUFFRyxZQUFZLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFFSSxrQkFBa0IsRUFBRUMsYUFBYSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU0sRUFBRU0sS0FBSyxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU0sRUFBRU8sYUFBYSxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRVEsSUFBSSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRXpCLCtCQUErQixHQUMvQixNQUFNUyw0QkFBNEI7SUFDaENDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxjQUFjO0FBQ2hCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsY0FBZUMsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsWUFBWTtJQUNsRCw0REFBNEQ7SUFDNUQsbUJBQW1CO0lBQ25CLElBQUlILEVBQUUsQ0FBQ25CLE9BQU8sS0FBSyxXQUFXO1FBQzVCLE1BQU0sSUFBSVEsYUFBYSxpQkFBaUI7SUFDMUM7SUFFQSxrQ0FBa0M7SUFDbENXLEVBQUUsQ0FBQ25CLE9BQU8sR0FBRztJQUViLDhCQUE4QjtJQUM5Qm1CLEVBQUUsQ0FBQ2pCLFFBQVEsR0FBRztJQUVkLDZCQUE2QjtJQUM3QmlCLEVBQUUsQ0FBQ2xCLE9BQU8sR0FBRztJQUViLDZEQUE2RDtJQUM3RCxnREFBZ0QsR0FD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ZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ZpbGVhcGkvdXRpbC5qcz9mMTFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIGtTdGF0ZSxcbiAga0Vycm9yLFxuICBrUmVzdWx0LFxuICBrQWJvcnRlZCxcbiAga0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBQcm9ncmVzc0V2ZW50IH0gPSByZXF1aXJlKCcuL3Byb2dyZXNzZXZlbnQnKVxuY29uc3QgeyBnZXRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9lbmNvZGluZycpXG5jb25zdCB7IERPTUV4Y2VwdGlvbiB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvY29uc3RhbnRzJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlLCBwYXJzZU1JTUVUeXBlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhVVJMJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgeyBTdHJpbmdEZWNvZGVyIH0gPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpXG5jb25zdCB7IGJ0b2EgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfSAqL1xuY29uc3Qgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZE9wZXJhdGlvblxuICogQHBhcmFtIHtpbXBvcnQoJy4vZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJ9IGZyXG4gKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdOYW1lXG4gKi9cbmZ1bmN0aW9uIHJlYWRPcGVyYXRpb24gKGZyLCBibG9iLCB0eXBlLCBlbmNvZGluZ05hbWUpIHtcbiAgLy8gMS4gSWYgZnLigJlzIHN0YXRlIGlzIFwibG9hZGluZ1wiLCB0aHJvdyBhbiBJbnZhbGlkU3RhdGVFcnJvclxuICAvLyAgICBET01FeGNlcHRpb24uXG4gIGlmIChmcltrU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIHN0YXRlJywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgfVxuXG4gIC8vIDIuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJsb2FkaW5nXCIuXG4gIGZyW2tTdGF0ZV0gPSAnbG9hZGluZydcblxuICAvLyAzLiBTZXQgZnLigJlzIHJlc3VsdCB0byBudWxsLlxuICBmcltrUmVzdWx0XSA9IG51bGxcblxuICAvLyA0LiBTZXQgZnLigJlzIGVycm9yIHRvIG51bGwuXG4gIGZyW2tFcnJvcl0gPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0cmVhbSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZ2V0IHN0cmVhbSBvbiBibG9iLlxuICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtL3dlYicpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICBjb25zdCBzdHJlYW0gPSBibG9iLnN0cmVhbSgpXG5cbiAgLy8gNi4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZnJvbSBzdHJlYW0uXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gIC8vIDcuIExldCBieXRlcyBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXlbXX0gKi9cbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIC8vIDguIExldCBjaHVua1Byb21pc2UgYmUgdGhlIHJlc3VsdCBvZiByZWFkaW5nIGEgY2h1bmsgZnJvbVxuICAvLyAgICBzdHJlYW0gd2l0aCByZWFkZXIuXG4gIGxldCBjaHVua1Byb21pc2UgPSByZWFkZXIucmVhZCgpXG5cbiAgLy8gOS4gTGV0IGlzRmlyc3RDaHVuayBiZSB0cnVlLlxuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZVxuXG4gIC8vIDEwLiBJbiBwYXJhbGxlbCwgd2hpbGUgdHJ1ZTpcbiAgLy8gTm90ZTogXCJJbiBwYXJhbGxlbFwiIGp1c3QgbWVhbnMgbm9uLWJsb2NraW5nXG4gIC8vIE5vdGUgMjogcmVhZE9wZXJhdGlvbiBpdHNlbGYgY2Fubm90IGJlIGFzeW5jIGFzIGRvdWJsZVxuICAvLyByZWFkaW5nIHRoZSBib2R5IHdvdWxkIHRoZW4gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnN0ZWFkXG4gIC8vIG9mIHRocm93aW5nIGFuIGVycm9yLlxuICA7KGFzeW5jICgpID0+IHtcbiAgICB3aGlsZSAoIWZyW2tBYm9ydGVkXSkge1xuICAgICAgLy8gMS4gV2FpdCBmb3IgY2h1bmtQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGNodW5rUHJvbWlzZVxuXG4gICAgICAgIC8vIDIuIElmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCBpc0ZpcnN0Q2h1bmsgaXNcbiAgICAgICAgLy8gICAgdHJ1ZSwgcXVldWUgYSB0YXNrIHRvIGZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWRcbiAgICAgICAgLy8gICAgbG9hZHN0YXJ0IGF0IGZyLlxuICAgICAgICBpZiAoaXNGaXJzdENodW5rICYmICFmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRzdGFydCcsIGZyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBTZXQgaXNGaXJzdENodW5rIHRvIGZhbHNlLlxuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZVxuXG4gICAgICAgIC8vIDQuIElmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhbiBvYmplY3Qgd2hvc2VcbiAgICAgICAgLy8gICAgZG9uZSBwcm9wZXJ0eSBpcyBmYWxzZSBhbmQgd2hvc2UgdmFsdWUgcHJvcGVydHkgaXNcbiAgICAgICAgLy8gICAgYSBVaW50OEFycmF5IG9iamVjdCwgcnVuIHRoZXNlIHN0ZXBzOlxuICAgICAgICBpZiAoIWRvbmUgJiYgdHlwZXMuaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgIC8vIDEuIExldCBicyBiZSB0aGUgYnl0ZSBzZXF1ZW5jZSByZXByZXNlbnRlZCBieSB0aGVcbiAgICAgICAgICAvLyAgICBVaW50OEFycmF5IG9iamVjdC5cblxuICAgICAgICAgIC8vIDIuIEFwcGVuZCBicyB0byBieXRlcy5cbiAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlKVxuXG4gICAgICAgICAgLy8gMy4gSWYgcm91Z2hseSA1MG1zIGhhdmUgcGFzc2VkIHNpbmNlIHRoZXNlIHN0ZXBzXG4gICAgICAgICAgLy8gICAgd2VyZSBsYXN0IGludm9rZWQsIHF1ZXVlIGEgdGFzayB0byBmaXJlIGFcbiAgICAgICAgICAvLyAgICBwcm9ncmVzcyBldmVudCBjYWxsZWQgcHJvZ3Jlc3MgYXQgZnIuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICBEYXRlLm5vdygpIC0gZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID49IDUwXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhZnJba0Fib3J0ZWRdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPSBEYXRlLm5vdygpXG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgncHJvZ3Jlc3MnLCBmcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4gU2V0IGNodW5rUHJvbWlzZSB0byB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgYVxuICAgICAgICAgIC8vICAgIGNodW5rIGZyb20gc3RyZWFtIHdpdGggcmVhZGVyLlxuICAgICAgICAgIGNodW5rUHJvbWlzZSA9IHJlYWRlci5yZWFkKClcbiAgICAgICAgfSBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW5cbiAgICAgICAgICAvLyAgICBvYmplY3Qgd2hvc2UgZG9uZSBwcm9wZXJ0eSBpcyB0cnVlLCBxdWV1ZSBhIHRhc2tcbiAgICAgICAgICAvLyAgICB0byBydW4gdGhlIGZvbGxvd2luZyBzdGVwcyBhbmQgYWJvcnQgdGhpcyBhbGdvcml0aG06XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImRvbmVcIi5cbiAgICAgICAgICAgIGZyW2tTdGF0ZV0gPSAnZG9uZSdcblxuICAgICAgICAgICAgLy8gMi4gTGV0IHJlc3VsdCBiZSB0aGUgcmVzdWx0IG9mIHBhY2thZ2UgZGF0YSBnaXZlblxuICAgICAgICAgICAgLy8gICAgYnl0ZXMsIHR5cGUsIGJsb2LigJlzIHR5cGUsIGFuZCBlbmNvZGluZ05hbWUuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYWNrYWdlRGF0YShieXRlcywgdHlwZSwgYmxvYi50eXBlLCBlbmNvZGluZ05hbWUpXG5cbiAgICAgICAgICAgICAgLy8gNC4gRWxzZTpcblxuICAgICAgICAgICAgICBpZiAoZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHJlc3VsdCB0byByZXN1bHQuXG4gICAgICAgICAgICAgIGZyW2tSZXN1bHRdID0gcmVzdWx0XG5cbiAgICAgICAgICAgICAgLy8gMi4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBsb2FkIGF0IHRoZSBmci5cbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkJywgZnIpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyAzLiBJZiBwYWNrYWdlIGRhdGEgdGhyZXcgYW4gZXhjZXB0aW9uIGVycm9yOlxuXG4gICAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgZXJyb3IgdG8gZXJyb3IuXG4gICAgICAgICAgICAgIGZyW2tFcnJvcl0gPSBlcnJvclxuXG4gICAgICAgICAgICAgIC8vIDIuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgZXJyb3IgYXQgZnIuXG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnZXJyb3InLCBmcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNS4gSWYgZnLigJlzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgICAgICAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCB0aGUgZnIuXG4gICAgICAgICAgICBpZiAoZnJba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIGZyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBPdGhlcndpc2UsIGlmIGNodW5rUHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuXG4gICAgICAgIC8vICAgIGVycm9yIGVycm9yLCBxdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gICAgc3RlcHMgYW5kIGFib3J0IHRoaXMgYWxnb3JpdGhtOlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImRvbmVcIi5cbiAgICAgICAgICBmcltrU3RhdGVdID0gJ2RvbmUnXG5cbiAgICAgICAgICAvLyAyLiBTZXQgZnLigJlzIGVycm9yIHRvIGVycm9yLlxuICAgICAgICAgIGZyW2tFcnJvcl0gPSBlcnJvclxuXG4gICAgICAgICAgLy8gMy4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBlcnJvciBhdCBmci5cbiAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Vycm9yJywgZnIpXG5cbiAgICAgICAgICAvLyA0LiBJZiBmcuKAmXMgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAgICAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCBmci5cbiAgICAgICAgICBpZiAoZnJba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCBmcilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0pKClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNmaXJlLWEtcHJvZ3Jlc3MtZXZlbnRcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJ9IHJlYWRlclxuICovXG5mdW5jdGlvbiBmaXJlQVByb2dyZXNzRXZlbnQgKGUsIHJlYWRlcikge1xuICAvLyBUaGUgcHJvZ3Jlc3MgZXZlbnQgZSBkb2VzIG5vdCBidWJibGUuIGUuYnViYmxlcyBtdXN0IGJlIGZhbHNlXG4gIC8vIFRoZSBwcm9ncmVzcyBldmVudCBlIGlzIE5PVCBjYW5jZWxhYmxlLiBlLmNhbmNlbGFibGUgbXVzdCBiZSBmYWxzZVxuICBjb25zdCBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KGUsIHtcbiAgICBidWJibGVzOiBmYWxzZSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICB9KVxuXG4gIHJlYWRlci5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Jsb2ItcGFja2FnZS1kYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IG1pbWVUeXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nTmFtZVxuICovXG5mdW5jdGlvbiBwYWNrYWdlRGF0YSAoYnl0ZXMsIHR5cGUsIG1pbWVUeXBlLCBlbmNvZGluZ05hbWUpIHtcbiAgLy8gMS4gQSBCbG9iIGhhcyBhbiBhc3NvY2lhdGVkIHBhY2thZ2UgZGF0YSBhbGdvcml0aG0sIGdpdmVuXG4gIC8vICAgIGJ5dGVzLCBhIHR5cGUsIGEgb3B0aW9uYWwgbWltZVR5cGUsIGFuZCBhIG9wdGlvbmFsXG4gIC8vICAgIGVuY29kaW5nTmFtZSwgd2hpY2ggc3dpdGNoZXMgb24gdHlwZSBhbmQgcnVucyB0aGVcbiAgLy8gICAgYXNzb2NpYXRlZCBzdGVwczpcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdEYXRhVVJMJzoge1xuICAgICAgLy8gMS4gUmV0dXJuIGJ5dGVzIGFzIGEgRGF0YVVSTCBbUkZDMjM5N10gc3ViamVjdCB0b1xuICAgICAgLy8gICAgdGhlIGNvbnNpZGVyYXRpb25zIGJlbG93OlxuICAgICAgLy8gICogVXNlIG1pbWVUeXBlIGFzIHBhcnQgb2YgdGhlIERhdGEgVVJMIGlmIGl0IGlzXG4gICAgICAvLyAgICBhdmFpbGFibGUgaW4ga2VlcGluZyB3aXRoIHRoZSBEYXRhIFVSTFxuICAgICAgLy8gICAgc3BlY2lmaWNhdGlvbiBbUkZDMjM5N10uXG4gICAgICAvLyAgKiBJZiBtaW1lVHlwZSBpcyBub3QgYXZhaWxhYmxlIHJldHVybiBhIERhdGEgVVJMXG4gICAgICAvLyAgICB3aXRob3V0IGEgbWVkaWEtdHlwZS4gW1JGQzIzOTddLlxuXG4gICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzIzOTcjc2VjdGlvbi0zXG4gICAgICAvLyBkYXRhdXJsICAgIDo9IFwiZGF0YTpcIiBbIG1lZGlhdHlwZSBdIFsgXCI7YmFzZTY0XCIgXSBcIixcIiBkYXRhXG4gICAgICAvLyBtZWRpYXR5cGUgIDo9IFsgdHlwZSBcIi9cIiBzdWJ0eXBlIF0gKiggXCI7XCIgcGFyYW1ldGVyIClcbiAgICAgIC8vIGRhdGEgICAgICAgOj0gKnVybGNoYXJcbiAgICAgIC8vIHBhcmFtZXRlciAgOj0gYXR0cmlidXRlIFwiPVwiIHZhbHVlXG4gICAgICBsZXQgZGF0YVVSTCA9ICdkYXRhOidcblxuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJylcblxuICAgICAgaWYgKHBhcnNlZCAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIGRhdGFVUkwgKz0gc2VyaWFsaXplQU1pbWVUeXBlKHBhcnNlZClcbiAgICAgIH1cblxuICAgICAgZGF0YVVSTCArPSAnO2Jhc2U2NCwnXG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcignbGF0aW4xJylcblxuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBieXRlcykge1xuICAgICAgICBkYXRhVVJMICs9IGJ0b2EoZGVjb2Rlci53cml0ZShjaHVuaykpXG4gICAgICB9XG5cbiAgICAgIGRhdGFVUkwgKz0gYnRvYShkZWNvZGVyLmVuZCgpKVxuXG4gICAgICByZXR1cm4gZGF0YVVSTFxuICAgIH1cbiAgICBjYXNlICdUZXh0Jzoge1xuICAgICAgLy8gMS4gTGV0IGVuY29kaW5nIGJlIGZhaWx1cmVcbiAgICAgIGxldCBlbmNvZGluZyA9ICdmYWlsdXJlJ1xuXG4gICAgICAvLyAyLiBJZiB0aGUgZW5jb2RpbmdOYW1lIGlzIHByZXNlbnQsIHNldCBlbmNvZGluZyB0byB0aGVcbiAgICAgIC8vICAgIHJlc3VsdCBvZiBnZXR0aW5nIGFuIGVuY29kaW5nIGZyb20gZW5jb2RpbmdOYW1lLlxuICAgICAgaWYgKGVuY29kaW5nTmFtZSkge1xuICAgICAgICBlbmNvZGluZyA9IGdldEVuY29kaW5nKGVuY29kaW5nTmFtZSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgZW5jb2RpbmcgaXMgZmFpbHVyZSwgYW5kIG1pbWVUeXBlIGlzIHByZXNlbnQ6XG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdmYWlsdXJlJyAmJiBtaW1lVHlwZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNlIGEgTUlNRSB0eXBlXG4gICAgICAgIC8vICAgIGdpdmVuIG1pbWVUeXBlLlxuICAgICAgICBjb25zdCB0eXBlID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAgICAgICAvLyAyLiBJZiB0eXBlIGlzIG5vdCBmYWlsdXJlLCBzZXQgZW5jb2RpbmcgdG8gdGhlIHJlc3VsdFxuICAgICAgICAvLyAgICBvZiBnZXR0aW5nIGFuIGVuY29kaW5nIGZyb20gdHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0uXG4gICAgICAgIGlmICh0eXBlICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICBlbmNvZGluZyA9IGdldEVuY29kaW5nKHR5cGUucGFyYW1ldGVycy5nZXQoJ2NoYXJzZXQnKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBJZiBlbmNvZGluZyBpcyBmYWlsdXJlLCB0aGVuIHNldCBlbmNvZGluZyB0byBVVEYtOC5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIGVuY29kaW5nID0gJ1VURi04J1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBEZWNvZGUgYnl0ZXMgdXNpbmcgZmFsbGJhY2sgZW5jb2RpbmcgZW5jb2RpbmcsIGFuZFxuICAgICAgLy8gICAgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICByZXR1cm4gZGVjb2RlKGJ5dGVzLCBlbmNvZGluZylcbiAgICB9XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOiB7XG4gICAgICAvLyBSZXR1cm4gYSBuZXcgQXJyYXlCdWZmZXIgd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgY29uc3Qgc2VxdWVuY2UgPSBjb21iaW5lQnl0ZVNlcXVlbmNlcyhieXRlcylcblxuICAgICAgcmV0dXJuIHNlcXVlbmNlLmJ1ZmZlclxuICAgIH1cbiAgICBjYXNlICdCaW5hcnlTdHJpbmcnOiB7XG4gICAgICAvLyBSZXR1cm4gYnl0ZXMgYXMgYSBiaW5hcnkgc3RyaW5nLCBpbiB3aGljaCBldmVyeSBieXRlXG4gICAgICAvLyAgaXMgcmVwcmVzZW50ZWQgYnkgYSBjb2RlIHVuaXQgb2YgZXF1YWwgdmFsdWUgWzAuLjI1NV0uXG4gICAgICBsZXQgYmluYXJ5U3RyaW5nID0gJydcblxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCdsYXRpbjEnKVxuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ5dGVzKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyArPSBkZWNvZGVyLndyaXRlKGNodW5rKVxuICAgICAgfVxuXG4gICAgICBiaW5hcnlTdHJpbmcgKz0gZGVjb2Rlci5lbmQoKVxuXG4gICAgICByZXR1cm4gYmluYXJ5U3RyaW5nXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jZGVjb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gaW9RdWV1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoaW9RdWV1ZSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgYnl0ZXMgPSBjb21iaW5lQnl0ZVNlcXVlbmNlcyhpb1F1ZXVlKVxuXG4gIC8vIDEuIExldCBCT01FbmNvZGluZyBiZSB0aGUgcmVzdWx0IG9mIEJPTSBzbmlmZmluZyBpb1F1ZXVlLlxuICBjb25zdCBCT01FbmNvZGluZyA9IEJPTVNuaWZmaW5nKGJ5dGVzKVxuXG4gIGxldCBzbGljZSA9IDBcblxuICAvLyAyLiBJZiBCT01FbmNvZGluZyBpcyBub24tbnVsbDpcbiAgaWYgKEJPTUVuY29kaW5nICE9PSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IGVuY29kaW5nIHRvIEJPTUVuY29kaW5nLlxuICAgIGVuY29kaW5nID0gQk9NRW5jb2RpbmdcblxuICAgIC8vIDIuIFJlYWQgdGhyZWUgYnl0ZXMgZnJvbSBpb1F1ZXVlLCBpZiBCT01FbmNvZGluZyBpc1xuICAgIC8vICAgIFVURi04OyBvdGhlcndpc2UgcmVhZCB0d28gYnl0ZXMuXG4gICAgLy8gICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgc2xpY2UgPSBCT01FbmNvZGluZyA9PT0gJ1VURi04JyA/IDMgOiAyXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBlbmNvZGluZ+KAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG5cbiAgY29uc3Qgc2xpY2VkID0gYnl0ZXMuc2xpY2Uoc2xpY2UpXG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpLmRlY29kZShzbGljZWQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jYm9tLXNuaWZmXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlvUXVldWVcbiAqL1xuZnVuY3Rpb24gQk9NU25pZmZpbmcgKGlvUXVldWUpIHtcbiAgLy8gMS4gTGV0IEJPTSBiZSB0aGUgcmVzdWx0IG9mIHBlZWtpbmcgMyBieXRlcyBmcm9tIGlvUXVldWUsXG4gIC8vICAgIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG4gIGNvbnN0IFthLCBiLCBjXSA9IGlvUXVldWVcblxuICAvLyAyLiBGb3IgZWFjaCBvZiB0aGUgcm93cyBpbiB0aGUgdGFibGUgYmVsb3csIHN0YXJ0aW5nIHdpdGhcbiAgLy8gICAgdGhlIGZpcnN0IG9uZSBhbmQgZ29pbmcgZG93biwgaWYgQk9NIHN0YXJ0cyB3aXRoIHRoZVxuICAvLyAgICBieXRlcyBnaXZlbiBpbiB0aGUgZmlyc3QgY29sdW1uLCB0aGVuIHJldHVybiB0aGVcbiAgLy8gICAgZW5jb2RpbmcgZ2l2ZW4gaW4gdGhlIGNlbGwgaW4gdGhlIHNlY29uZCBjb2x1bW4gb2YgdGhhdFxuICAvLyAgICByb3cuIE90aGVyd2lzZSwgcmV0dXJuIG51bGwuXG4gIGlmIChhID09PSAweEVGICYmIGIgPT09IDB4QkIgJiYgYyA9PT0gMHhCRikge1xuICAgIHJldHVybiAnVVRGLTgnXG4gIH0gZWxzZSBpZiAoYSA9PT0gMHhGRSAmJiBiID09PSAweEZGKSB7XG4gICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgfSBlbHNlIGlmIChhID09PSAweEZGICYmIGIgPT09IDB4RkUpIHtcbiAgICByZXR1cm4gJ1VURi0xNkxFJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXlbXX0gc2VxdWVuY2VzXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVCeXRlU2VxdWVuY2VzIChzZXF1ZW5jZXMpIHtcbiAgY29uc3Qgc2l6ZSA9IHNlcXVlbmNlcy5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gYSArIGIuYnl0ZUxlbmd0aFxuICB9LCAwKVxuXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgcmV0dXJuIHNlcXVlbmNlcy5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICBhLnNldChiLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGIuYnl0ZUxlbmd0aFxuICAgIHJldHVybiBhXG4gIH0sIG5ldyBVaW50OEFycmF5KHNpemUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZE9wZXJhdGlvbixcbiAgZmlyZUFQcm9ncmVzc0V2ZW50XG59XG4iXSwibmFtZXMiOlsia1N0YXRlIiwia0Vycm9yIiwia1Jlc3VsdCIsImtBYm9ydGVkIiwia0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQiLCJyZXF1aXJlIiwiUHJvZ3Jlc3NFdmVudCIsImdldEVuY29kaW5nIiwiRE9NRXhjZXB0aW9uIiwic2VyaWFsaXplQU1pbWVUeXBlIiwicGFyc2VNSU1FVHlwZSIsInR5cGVzIiwiU3RyaW5nRGVjb2RlciIsImJ0b2EiLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwicmVhZE9wZXJhdGlvbiIsImZyIiwiYmxvYiIsInR5cGUiLCJlbmNvZGluZ05hbWUiLCJzdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJieXRlcyIsImNodW5rUHJvbWlzZSIsInJlYWQiLCJpc0ZpcnN0Q2h1bmsiLCJkb25lIiwidmFsdWUiLCJxdWV1ZU1pY3JvdGFzayIsImZpcmVBUHJvZ3Jlc3NFdmVudCIsImlzVWludDhBcnJheSIsInB1c2giLCJ1bmRlZmluZWQiLCJEYXRlIiwibm93IiwicmVzdWx0IiwicGFja2FnZURhdGEiLCJlcnJvciIsImUiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsIm1pbWVUeXBlIiwiZGF0YVVSTCIsInBhcnNlZCIsImRlY29kZXIiLCJjaHVuayIsIndyaXRlIiwiZW5kIiwiZW5jb2RpbmciLCJwYXJhbWV0ZXJzIiwiZ2V0IiwiZGVjb2RlIiwic2VxdWVuY2UiLCJjb21iaW5lQnl0ZVNlcXVlbmNlcyIsImJ1ZmZlciIsImJpbmFyeVN0cmluZyIsImlvUXVldWUiLCJCT01FbmNvZGluZyIsIkJPTVNuaWZmaW5nIiwic2xpY2UiLCJzbGljZWQiLCJUZXh0RGVjb2RlciIsImEiLCJiIiwiYyIsInNlcXVlbmNlcyIsInNpemUiLCJyZWR1Y2UiLCJieXRlTGVuZ3RoIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/fileapi/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/agent.js\");\nif (getGlobalDispatcher() === undefined) {\n    setGlobalDispatcher(new Agent());\n}\nfunction setGlobalDispatcher(agent) {\n    if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n    }\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nfunction getGlobalDispatcher() {\n    return globalThis[globalDispatcher];\n}\nmodule.exports = {\n    setGlobalDispatcher,\n    getGlobalDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxtRkFBbUY7QUFDbkYsNERBQTREO0FBQzVELE1BQU1BLG1CQUFtQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ3BDLE1BQU0sRUFBRUMsb0JBQW9CLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDekMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFdEIsSUFBSUUsMEJBQTBCQyxXQUFXO0lBQ3ZDQyxvQkFBb0IsSUFBSUg7QUFDMUI7QUFFQSxTQUFTRyxvQkFBcUJDLEtBQUs7SUFDakMsSUFBSSxDQUFDQSxTQUFTLE9BQU9BLE1BQU1DLFFBQVEsS0FBSyxZQUFZO1FBQ2xELE1BQU0sSUFBSVAscUJBQXFCO0lBQ2pDO0lBQ0FRLE9BQU9DLGNBQWMsQ0FBQ0MsWUFBWWIsa0JBQWtCO1FBQ2xEYyxPQUFPTDtRQUNQTSxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUEsU0FBU1g7SUFDUCxPQUFPTyxVQUFVLENBQUNiLGlCQUFpQjtBQUNyQztBQUVBa0IsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZYO0lBQ0FGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2dsb2JhbC5qcz9kYjhhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXZSBpbmNsdWRlIGEgdmVyc2lvbiBudW1iZXIgZm9yIHRoZSBEaXNwYXRjaGVyIEFQSS4gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLFxuLy8gdGhpcyB2ZXJzaW9uIG51bWJlciBtdXN0IGJlIGluY3JlYXNlZCB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxEaXNwYXRjaGVyID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbERpc3BhdGNoZXIuMScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5cbmlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBBZ2VudCgpKVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyIChhZ2VudCkge1xuICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxEaXNwYXRjaGVyLCB7XG4gICAgdmFsdWU6IGFnZW50LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlciAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICBnZXRHbG9iYWxEaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsRGlzcGF0Y2hlciIsIlN5bWJvbCIsImZvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsIkFnZW50IiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsInVuZGVmaW5lZCIsInNldEdsb2JhbERpc3BhdGNoZXIiLCJhZ2VudCIsImRpc3BhdGNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnbG9iYWxUaGlzIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/DecoratorHandler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/DecoratorHandler.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = class DecoratorHandler {\n    constructor(handler){\n        this.handler = handler;\n    }\n    onConnect(...args) {\n        return this.handler.onConnect(...args);\n    }\n    onError(...args) {\n        return this.handler.onError(...args);\n    }\n    onUpgrade(...args) {\n        return this.handler.onUpgrade(...args);\n    }\n    onHeaders(...args) {\n        return this.handler.onHeaders(...args);\n    }\n    onData(...args) {\n        return this.handler.onData(...args);\n    }\n    onComplete(...args) {\n        return this.handler.onComplete(...args);\n    }\n    onBodySent(...args) {\n        return this.handler.onBodySent(...args);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCQyxZQUFhQyxPQUFPLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0lBRUFDLFVBQVcsR0FBR0MsSUFBSSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNDLFNBQVMsSUFBSUM7SUFDbkM7SUFFQUMsUUFBUyxHQUFHRCxJQUFJLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csT0FBTyxJQUFJRDtJQUNqQztJQUVBRSxVQUFXLEdBQUdGLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSSxTQUFTLElBQUlGO0lBQ25DO0lBRUFHLFVBQVcsR0FBR0gsSUFBSSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNLLFNBQVMsSUFBSUg7SUFDbkM7SUFFQUksT0FBUSxHQUFHSixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDTSxNQUFNLElBQUlKO0lBQ2hDO0lBRUFLLFdBQVksR0FBR0wsSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNPLFVBQVUsSUFBSUw7SUFDcEM7SUFFQU0sV0FBWSxHQUFHTixJQUFJLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1EsVUFBVSxJQUFJTjtJQUNwQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL0RlY29yYXRvckhhbmRsZXIuanM/MTVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBvbkNvbm5lY3QgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQ29ubmVjdCguLi5hcmdzKVxuICB9XG5cbiAgb25FcnJvciAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25FcnJvciguLi5hcmdzKVxuICB9XG5cbiAgb25VcGdyYWRlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoLi4uYXJncylcbiAgfVxuXG4gIG9uSGVhZGVycyAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKC4uLmFyZ3MpXG4gIH1cblxuICBvbkRhdGEgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YSguLi5hcmdzKVxuICB9XG5cbiAgb25Db21wbGV0ZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSguLi5hcmdzKVxuICB9XG5cbiAgb25Cb2R5U2VudCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Cb2R5U2VudCguLi5hcmdzKVxuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkRlY29yYXRvckhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsImhhbmRsZXIiLCJvbkNvbm5lY3QiLCJhcmdzIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm9uSGVhZGVycyIsIm9uRGF0YSIsIm9uQ29tcGxldGUiLCJvbkJvZHlTZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/DecoratorHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/RedirectHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/handler/RedirectHandler.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst EE = __webpack_require__(/*! events */ \"events\");\nconst redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst kBody = Symbol(\"body\");\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nclass RedirectHandler {\n    constructor(dispatch, maxRedirections, opts, handler){\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatch = dispatch;\n        this.location = null;\n        this.abort = null;\n        this.opts = {\n            ...opts,\n            maxRedirections: 0\n        } // opts must be a copy\n        ;\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        if (util.isStream(this.opts.body)) {\n            // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n            // so that it can be dispatched again?\n            // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n            if (util.bodyLength(this.opts.body) === 0) {\n                this.opts.body.on(\"data\", function() {\n                    assert(false);\n                });\n            }\n            if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n                this.opts.body[kBodyUsed] = false;\n                EE.prototype.on.call(this.opts.body, \"data\", function() {\n                    this[kBodyUsed] = true;\n                });\n            }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n            // TODO (fix): We can't access ReadableStream internal state\n            // to determine whether or not it has been disturbed. This is just\n            // a workaround.\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n            // TODO: Should we allow re-using iterable if !this.opts.idempotent\n            // or through some other flag?\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n    }\n    onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, {\n            history: this.history\n        });\n    }\n    onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onError(error) {\n        this.handler.onError(error);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.origin) {\n            this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n            return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path = search ? `${pathname}${search}` : pathname;\n        // Remove headers referring to the original URL.\n        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n        // https://tools.ietf.org/html/rfc7231#section-6.4\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        this.opts.query = null;\n        // https://tools.ietf.org/html/rfc7231#section-6.4.4\n        // In case of HTTP 303, always replace method to be either HEAD or GET\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n            this.opts.method = \"GET\";\n            this.opts.body = null;\n        }\n    }\n    onData(chunk) {\n        if (this.location) {\n        /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */ } else {\n            return this.handler.onData(chunk);\n        }\n    }\n    onComplete(trailers) {\n        if (this.location) {\n            /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */ this.location = null;\n            this.abort = null;\n            this.dispatch(this.opts, this);\n        } else {\n            this.handler.onComplete(trailers);\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n            this.handler.onBodySent(chunk);\n        }\n    }\n}\nfunction parseLocation(statusCode, headers) {\n    if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n    }\n    for(let i = 0; i < headers.length; i += 2){\n        if (headers[i].toString().toLowerCase() === \"location\") {\n            return headers[i + 1];\n        }\n    }\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n    return header.length === 4 && header.toString().toLowerCase() === \"host\" || removeContent && header.toString().toLowerCase().indexOf(\"content-\") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === \"authorization\" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === \"cookie\";\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n    const ret = [];\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n                ret.push(headers[i], headers[i + 1]);\n            }\n        }\n    } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)){\n            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n                ret.push(key, headers[key]);\n            }\n        }\n    } else {\n        assert(headers == null, \"headers must be an object or an array\");\n    }\n    return ret;\n}\nmodule.exports = RedirectHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL1JlZGlyZWN0SGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUcsb0JBQW9CLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDekMsTUFBTUksS0FBS0osbUJBQU9BLENBQUM7QUFFbkIsTUFBTUssMEJBQTBCO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFOUQsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDSixNQUFNLEdBQUdJO1FBQ2QsSUFBSSxDQUFDVCxVQUFVLEdBQUc7SUFDcEI7SUFFQSxPQUFRLENBQUNNLE9BQU9JLGFBQWEsQ0FBQyxHQUFJO1FBQ2hDVCxPQUFPLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUU7UUFDekIsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsT0FBUSxJQUFJLENBQUNLLE1BQU07SUFDckI7QUFDRjtBQUVBLE1BQU1NO0lBQ0pILFlBQWFJLFFBQVEsRUFBRUMsZUFBZSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sQ0FBRTtRQUNyRCxJQUFJRixtQkFBbUIsUUFBUyxFQUFDRyxPQUFPQyxTQUFTLENBQUNKLG9CQUFvQkEsa0JBQWtCLElBQUk7WUFDMUYsTUFBTSxJQUFJWCxxQkFBcUI7UUFDakM7UUFFQUosS0FBS29CLGVBQWUsQ0FBQ0gsU0FBU0QsS0FBS0ssTUFBTSxFQUFFTCxLQUFLTSxPQUFPO1FBRXZELElBQUksQ0FBQ1IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNTLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElB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UmVkaXJlY3RIYW5kbGVyLmpzPzA4NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuXG5jb25zdCByZWRpcmVjdGFibGVTdGF0dXNDb2RlcyA9IFszMDAsIDMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5jb25zdCBrQm9keSA9IFN5bWJvbCgnYm9keScpXG5cbmNsYXNzIEJvZHlBc3luY0l0ZXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKGJvZHkpIHtcbiAgICB0aGlzW2tCb2R5XSA9IGJvZHlcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZVxuICB9XG5cbiAgYXN5bmMgKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgJ2Rpc3R1cmJlZCcpXG4gICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgIHlpZWxkICogdGhpc1trQm9keV1cbiAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcikge1xuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgdXRpbC52YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgb3B0cy5tZXRob2QsIG9wdHMudXBncmFkZSlcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICAgIHRoaXMubG9jYXRpb24gPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9IC8vIG9wdHMgbXVzdCBiZSBhIGNvcHlcbiAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0odGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgICBpZiAodXRpbC5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVxuICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgICBFRS5wcm90b3R5cGUub24uY2FsbCh0aGlzLm9wdHMuYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLm9wdHMuYm9keSAmJlxuICAgICAgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgIHV0aWwuaXNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhbGxvdyByZS11c2luZyBpdGVyYWJsZSBpZiAhdGhpcy5vcHRzLmlkZW1wb3RlbnRcbiAgICAgIC8vIG9yIHRocm91Z2ggc29tZSBvdGhlciBmbGFnP1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuaGFuZGxlci5vbkNvbm5lY3QoYWJvcnQsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5IH0pXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLmhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSlcbiAgICAgID8gbnVsbFxuICAgICAgOiBwYXJzZUxvY2F0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpXG5cbiAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpXG4gICAgfVxuXG4gICAgY29uc3QgeyBvcmlnaW4sIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHV0aWwucGFyc2VVUkwobmV3IFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLm9wdHMub3JpZ2luICYmIG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKSlcbiAgICBjb25zdCBwYXRoID0gc2VhcmNoID8gYCR7cGF0aG5hbWV9JHtzZWFyY2h9YCA6IHBhdGhuYW1lXG5cbiAgICAvLyBSZW1vdmUgaGVhZGVycyByZWZlcnJpbmcgdG8gdGhlIG9yaWdpbmFsIFVSTC5cbiAgICAvLyBCeSBkZWZhdWx0IGl0IGlzIEhvc3Qgb25seSwgdW5sZXNzIGl0J3MgYSAzMDMgKHNlZSBiZWxvdyksIHdoaWNoIHJlbW92ZXMgYWxzbyBhbGwgQ29udGVudC0qIGhlYWRlcnMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcbiAgICB0aGlzLm9wdHMuaGVhZGVycyA9IGNsZWFuUmVxdWVzdEhlYWRlcnModGhpcy5vcHRzLmhlYWRlcnMsIHN0YXR1c0NvZGUgPT09IDMwMywgdGhpcy5vcHRzLm9yaWdpbiAhPT0gb3JpZ2luKVxuICAgIHRoaXMub3B0cy5wYXRoID0gcGF0aFxuICAgIHRoaXMub3B0cy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLm9wdHMubWF4UmVkaXJlY3Rpb25zID0gMFxuICAgIHRoaXMub3B0cy5xdWVyeSA9IG51bGxcblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbiAgICAvLyBJbiBjYXNlIG9mIEhUVFAgMzAzLCBhbHdheXMgcmVwbGFjZSBtZXRob2QgdG8gYmUgZWl0aGVyIEhFQUQgb3IgR0VUXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDMwMyAmJiB0aGlzLm9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMub3B0cy5tZXRob2QgPSAnR0VUJ1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgYm9kaWVzLlxuXG4gICAgICAgIFJlZGlyZWN0aW9uIGlzIHVzZWQgdG8gc2VydmUgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBmcm9tIGFub3RoZXIgVVJMLCBzbyBpdCBpcyBhc3N1bWVzIHRoYXRcbiAgICAgICAgbm8gYm9keSBpcyBnZW5lcmF0ZWQgKGFuZCB0aHVzIGNhbiBiZSBpZ25vcmVkKS4gRXZlbiB0aG91Z2ggZ2VuZXJhdGluZyBhIGJvZHkgaXMgbm90IHByb2hpYml0ZWQuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDEsIDMwMiwgMzAzLCAzMDcgYW5kIDMwOCAodGhlIGxhdHRlciBmcm9tIFJGQyA3MjM4KSwgdGhlIHNwZWNzIG1lbnRpb24gdGhhdCB0aGUgYm9keSB1c3VhbGx5XG4gICAgICAgICh3aGljaCBtZWFucyBpdCdzIG9wdGlvbmFsIGFuZCBub3QgbWFuZGF0ZWQpIGNvbnRhaW4ganVzdCBhbiBoeXBlcmxpbmsgdG8gdGhlIHZhbHVlIG9mXG4gICAgICAgIHRoZSBMb2NhdGlvbiByZXNwb25zZSBoZWFkZXIsIHNvIHRoZSBib2R5IGNhbiBiZSBpZ25vcmVkIHNhZmVseS5cblxuICAgICAgICBGb3Igc3RhdHVzIDMwMCwgd2hpY2ggaXMgXCJNdWx0aXBsZSBDaG9pY2VzXCIsIHRoZSBzcGVjIG1lbnRpb25zIGJvdGggZ2VuZXJhdGluZyBhIExvY2F0aW9uXG4gICAgICAgIHJlc3BvbnNlIGhlYWRlciBBTkQgYSByZXNwb25zZSBib2R5IHdpdGggdGhlIG90aGVyIHBvc3NpYmxlIGxvY2F0aW9uIHRvIGZvbGxvdy5cbiAgICAgICAgU2luY2UgdGhlIHNwZWMgZXhwbGljaXRpbHkgY2hvb3NlcyBub3QgdG8gc3BlY2lmeSBhIGZvcm1hdCBmb3Igc3VjaCBib2R5IGFuZCBsZWF2ZSBpdCB0b1xuICAgICAgICBzZXJ2ZXJzIGFuZCBicm93c2VycyBpbXBsZW1lbnRvcnMsIHdlIGlnbm9yZSB0aGUgYm9keSBhcyB0aGVyZSBpcyBubyBzcGVjaWZpZWQgd2F5IHRvIGV2ZW50dWFsbHkgcGFyc2UgaXQuXG4gICAgICAqL1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuaylcbiAgICB9XG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgdHJhaWxlcnMgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIGluIGNhc2Ugb2YgcmVkaXJlY3Rpb25zXG4gICAgICAgIGFuZCBuZWl0aGVyIGFyZSB1c2VmdWwgaWYgcHJlc2VudC5cblxuICAgICAgICBTZWUgY29tbWVudCBvbiBvbkRhdGEgbWV0aG9kIGFib3ZlIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9ucy5cbiAgICAgICovXG5cbiAgICAgIHRoaXMubG9jYXRpb24gPSBudWxsXG4gICAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgICB0aGlzLmRpc3BhdGNoKHRoaXMub3B0cywgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uQm9keVNlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KGNodW5rKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2F0aW9uIChzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gIGlmIChyZWRpcmVjdGFibGVTdGF0dXNDb2Rlcy5pbmRleE9mKHN0YXR1c0NvZGUpID09PSAtMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoaGVhZGVyc1tpXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhdGlvbicpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW2kgKyAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVIZWFkZXIgKGhlYWRlciwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICByZXR1cm4gKFxuICAgIChoZWFkZXIubGVuZ3RoID09PSA0ICYmIGhlYWRlci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdob3N0JykgfHxcbiAgICAocmVtb3ZlQ29udGVudCAmJiBoZWFkZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2NvbnRlbnQtJykgPT09IDApIHx8XG4gICAgKHVua25vd25PcmlnaW4gJiYgaGVhZGVyLmxlbmd0aCA9PT0gMTMgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2F1dGhvcml6YXRpb24nKSB8fFxuICAgICh1bmtub3duT3JpZ2luICYmIGhlYWRlci5sZW5ndGggPT09IDYgJiYgaGVhZGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2Nvb2tpZScpXG4gIClcbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcbmZ1bmN0aW9uIGNsZWFuUmVxdWVzdEhlYWRlcnMgKGhlYWRlcnMsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgY29uc3QgcmV0ID0gW11cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmICghc2hvdWxkUmVtb3ZlSGVhZGVyKGhlYWRlcnNbaV0sIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgIHJldC5wdXNoKGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihrZXksIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgIHJldC5wdXNoKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoaGVhZGVycyA9PSBudWxsLCAnaGVhZGVycyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheScpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZGlyZWN0SGFuZGxlclxuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwia0JvZHlVc2VkIiwiYXNzZXJ0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJFRSIsInJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzIiwia0JvZHkiLCJTeW1ib2wiLCJCb2R5QXN5bmNJdGVyYWJsZSIsImNvbnN0cnVjdG9yIiwiYm9keSIsImFzeW5jSXRlcmF0b3IiLCJSZWRpcmVjdEhhbmRsZXIiLCJkaXNwYXRjaCIsIm1heFJlZGlyZWN0aW9ucyIsIm9wdHMiLCJoYW5kbGVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwidmFsaWRhdGVIYW5kbGVyIiwibWV0aG9kIiwidXBncmFkZSIsImxvY2F0aW9uIiwiYWJvcnQiLCJoaXN0b3J5IiwiaXNTdHJlYW0iLCJib2R5TGVuZ3RoIiwib24iLCJyZWFkYWJsZURpZFJlYWQiLCJwcm90b3R5cGUiLCJjYWxsIiwicGlwZVRvIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0l0ZXJhYmxlIiwib25Db25uZWN0Iiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJzb2NrZXQiLCJvbkVycm9yIiwiZXJyb3IiLCJvbkhlYWRlcnMiLCJyZXN1bWUiLCJzdGF0dXNUZXh0IiwibGVuZ3RoIiwiaXNEaXN0dXJiZWQiLCJwYXJzZUxvY2F0aW9uIiwib3JpZ2luIiwicHVzaCIsIlVSTCIsInBhdGgiLCJwYXRobmFtZSIsInNlYXJjaCIsInBhcnNlVVJMIiwiY2xlYW5SZXF1ZXN0SGVhZGVycyIsInF1ZXJ5Iiwib25EYXRhIiwiY2h1bmsiLCJvbkNvbXBsZXRlIiwidHJhaWxlcnMiLCJvbkJvZHlTZW50IiwiaW5kZXhPZiIsImkiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwic2hvdWxkUmVtb3ZlSGVhZGVyIiwiaGVhZGVyIiwicmVtb3ZlQ29udGVudCIsInVua25vd25PcmlnaW4iLCJyZXQiLCJBcnJheSIsImlzQXJyYXkiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/RedirectHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/redirectInterceptor.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirectInterceptor.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/RedirectHandler */ \"(rsc)/./node_modules/undici/lib/handler/RedirectHandler.js\");\nfunction createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { maxRedirections = defaultMaxRedirections } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            opts = {\n                ...opts,\n                maxRedirections: 0\n            } // Stop sub dispatcher from also redirecting.\n            ;\n            return dispatch(opts, redirectHandler);\n        };\n    };\n}\nmodule.exports = createRedirectInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUVoQyxTQUFTQywwQkFBMkIsRUFBRUMsaUJBQWlCQyxzQkFBc0IsRUFBRTtJQUM3RSxPQUFPLENBQUNDO1FBQ04sT0FBTyxTQUFTQyxVQUFXQyxJQUFJLEVBQUVDLE9BQU87WUFDdEMsTUFBTSxFQUFFTCxrQkFBa0JDLHNCQUFzQixFQUFFLEdBQUdHO1lBRXJELElBQUksQ0FBQ0osaUJBQWlCO2dCQUNwQixPQUFPRSxTQUFTRSxNQUFNQztZQUN4QjtZQUVBLE1BQU1DLGtCQUFrQixJQUFJVCxnQkFBZ0JLLFVBQVVGLGlCQUFpQkksTUFBTUM7WUFDN0VELE9BQU87Z0JBQUUsR0FBR0EsSUFBSTtnQkFBRUosaUJBQWlCO1lBQUUsRUFBRSw2Q0FBNkM7O1lBQ3BGLE9BQU9FLFNBQVNFLE1BQU1FO1FBQ3hCO0lBQ0Y7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdEludGVyY2VwdG9yLmpzP2I4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvUmVkaXJlY3RIYW5kbGVyJylcblxuZnVuY3Rpb24gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciAoeyBtYXhSZWRpcmVjdGlvbnM6IGRlZmF1bHRNYXhSZWRpcmVjdGlvbnMgfSkge1xuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0gPSBvcHRzXG5cbiAgICAgIGlmICghbWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICBvcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBTdG9wIHN1YiBkaXNwYXRjaGVyIGZyb20gYWxzbyByZWRpcmVjdGluZy5cbiAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCByZWRpcmVjdEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbIlJlZGlyZWN0SGFuZGxlciIsInJlcXVpcmUiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwibWF4UmVkaXJlY3Rpb25zIiwiZGVmYXVsdE1heFJlZGlyZWN0aW9ucyIsImRpc3BhdGNoIiwiSW50ZXJjZXB0Iiwib3B0cyIsImhhbmRsZXIiLCJyZWRpcmVjdEhhbmRsZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/redirectInterceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function(ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function(TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function(FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function(LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function(METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */ METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */ METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */ METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */ METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */ METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */ METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */ METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */ METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */ METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */ METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */ METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS[\"M-SEARCH\"],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key)=>{\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function(FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor(let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++){\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9\n};\nexports.HEX_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 0XA,\n    B: 0XB,\n    C: 0XC,\n    D: 0XD,\n    E: 0XE,\n    F: 0XF,\n    a: 0xa,\n    b: 0xb,\n    c: 0xc,\n    d: 0xd,\n    e: 0xe,\n    f: 0xf\n};\nexports.NUM = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\"\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = [\n    \"-\",\n    \"_\",\n    \".\",\n    \"!\",\n    \"~\",\n    \"*\",\n    \"'\",\n    \"(\",\n    \")\"\n];\nexports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\n    \"%\",\n    \";\",\n    \":\",\n    \"&\",\n    \"=\",\n    \"+\",\n    \"$\",\n    \",\"\n]);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    \"!\",\n    '\"',\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"@\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\n    \"\t\",\n    \"\\f\"\n]);\n// All characters with 0x80 bit set to 1\nfor(let i = 0x80; i <= 0xff; i++){\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat([\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\"\n]);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */ exports.STRICT_TOKEN = [\n    \"!\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"*\",\n    \"+\",\n    \"-\",\n    \".\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"|\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([\n    \" \"\n]);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */ exports.HEADER_CHARS = [\n    \"\t\"\n];\nfor(let i = 32; i <= 255; i++){\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c)=>c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function(HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    \"connection\": HEADER_STATE.CONNECTION,\n    \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n    \"proxy-connection\": HEADER_STATE.CONNECTION,\n    \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n    \"upgrade\": HEADER_STATE.UPGRADE\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSw4QkFBOEIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0Esb0JBQW9CLEdBQUdBLFdBQVcsR0FBR0EsZ0JBQWdCLEdBQUdBLHVCQUF1QixHQUFHQSxzQkFBc0IsR0FBR0EsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsV0FBVyxHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esb0JBQW9CLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxZQUFZLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3ZrQixNQUFNK0IsVUFBVUMsbUJBQU9BLENBQUMsZ0VBQVM7QUFDakMsWUFBWTtBQUNaLElBQUlGO0FBQ0gsVUFBVUEsS0FBSztJQUNaQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ3pCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQzdCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLEdBQUc7SUFDaERBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUN4Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGtCQUFrQixHQUFHLEVBQUUsR0FBRztJQUN0Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsdUJBQXVCLEdBQUcsR0FBRyxHQUFHO0lBQzVDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyx5QkFBeUIsR0FBRyxHQUFHLEdBQUc7SUFDOUNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHFCQUFxQixHQUFHLEdBQUcsR0FBRztJQUMxQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxHQUFHO0lBQ3RDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLEdBQUc7SUFDekNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLDRCQUE0QixHQUFHLEdBQUcsR0FBRztJQUNqREEsS0FBSyxDQUFDQSxLQUFLLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxHQUFHO0lBQ3hDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxHQUFHLEdBQUc7SUFDM0NBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLHNCQUFzQixHQUFHLEdBQUcsR0FBRztJQUMzQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0lBQ3ZDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLEdBQUc7SUFDekNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDOUJBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsR0FBRztJQUN0Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQ2hDLEdBQUdBLFFBQVE5QixRQUFROEIsS0FBSyxJQUFLOUIsQ0FBQUEsYUFBYSxHQUFHLENBQUM7QUFDOUMsSUFBSTZCO0FBQ0gsVUFBVUEsSUFBSTtJQUNYQSxJQUFJLENBQUNBLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3pCQSxJQUFJLENBQUNBLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVCQSxJQUFJLENBQUNBLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0FBQ2pDLEdBQUdBLE9BQU83QixRQUFRNkIsSUFBSSxJQUFLN0IsQ0FBQUEsWUFBWSxHQUFHLENBQUM7QUFDM0MsSUFBSTRCO0FBQ0gsVUFBVUEsS0FBSztJQUNaQSxLQUFLLENBQUNBLEtBQUssQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN2Q0EsS0FBSyxDQUFDQSxLQUFLLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQ3pDQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlCQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHO0lBQy9CQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLEdBQUc7SUFDdENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDaENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUc7SUFDakMsbUJBQW1CO0lBQ25CQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLEdBQUc7QUFDOUMsR0FBR0EsUUFBUTVCLFFBQVE0QixLQUFLLElBQUs1QixDQUFBQSxhQUFhLEdBQUcsQ0FBQztBQUM5QyxJQUFJMkI7QUFDSCxVQUFVQSxhQUFhO0lBQ3BCQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxhQUFhLENBQUNBLGFBQWEsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDckRBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDckQsR0FBR0EsZ0JBQWdCM0IsUUFBUTJCLGFBQWEsSUFBSzNCLENBQUFBLHFCQUFxQixHQUFHLENBQUM7QUFDdEUsSUFBSTBCO0FBQ0gsVUFBVUEsT0FBTztJQUNkQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQzlCQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQy9CQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQzlCLGdCQUFnQixHQUNoQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNoQyxVQUFVLEdBQ1ZBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDL0JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDL0JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7SUFDckNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDaENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUc7SUFDL0IsY0FBYyxHQUNkQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxhQUFhLEdBQUcsR0FBRyxHQUFHO0lBQ3RDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQ3BDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0lBQ2pDLFFBQVEsR0FDUkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUN2QyxZQUFZLEdBQ1pBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFFBQVEsR0FBRyxHQUFHLEdBQUc7SUFDakMsVUFBVSxHQUNWQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxhQUFhLEdBQUcsR0FBRyxHQUFHO0lBQ3RDLDhCQUE4QixHQUM5QkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztJQUNoQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRztJQUNsQyxXQUFXLEdBQ1hBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbEMsMEJBQTBCLEdBQzFCQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUFHO0lBQy9CLGlCQUFpQixHQUNqQkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztJQUNoQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNwQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ3pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDekNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDcENBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUc7SUFDbEMsUUFBUSxHQUNSQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO0FBQ3JDLEdBQUdBLFVBQVUxQixRQUFRMEIsT0FBTyxJQUFLMUIsQ0FBQUEsZUFBZSxHQUFHLENBQUM7QUFDcERBLG9CQUFvQixHQUFHO0lBQ25CMEIsUUFBUU8sTUFBTTtJQUNkUCxRQUFRUSxHQUFHO0lBQ1hSLFFBQVFTLElBQUk7SUFDWlQsUUFBUVUsSUFBSTtJQUNaVixRQUFRVyxHQUFHO0lBQ1hYLFFBQVFZLE9BQU87SUFDZlosUUFBUWEsT0FBTztJQUNmYixRQUFRYyxLQUFLO0lBQ2JkLFFBQVFlLElBQUk7SUFDWmYsUUFBUWdCLElBQUk7SUFDWmhCLFFBQVFpQixLQUFLO0lBQ2JqQixRQUFRa0IsSUFBSTtJQUNabEIsUUFBUW1CLFFBQVE7SUFDaEJuQixRQUFRb0IsU0FBUztJQUNqQnBCLFFBQVFxQixNQUFNO0lBQ2RyQixRQUFRc0IsTUFBTTtJQUNkdEIsUUFBUXVCLElBQUk7SUFDWnZCLFFBQVF3QixNQUFNO0lBQ2R4QixRQUFReUIsTUFBTTtJQUNkekIsUUFBUTBCLEdBQUc7SUFDWDFCLFFBQVEyQixNQUFNO0lBQ2QzQixRQUFRNEIsVUFBVTtJQUNsQjVCLFFBQVE2QixRQUFRO0lBQ2hCN0IsUUFBUThCLEtBQUs7SUFDYjlCLE9BQU8sQ0FBQyxXQUFXO0lBQ25CQSxRQUFRK0IsTUFBTTtJQUNkL0IsUUFBUWdDLFNBQVM7SUFDakJoQyxRQUFRaUMsV0FBVztJQUNuQmpDLFFBQVFrQyxLQUFLO0lBQ2JsQyxRQUFRbUMsS0FBSztJQUNibkMsUUFBUW9DLFVBQVU7SUFDbEJwQyxRQUFRcUMsSUFBSTtJQUNackMsUUFBUXNDLE1BQU07SUFDZHRDLFFBQVF1QyxHQUFHO0lBQ1gsK0NBQStDO0lBQy9DdkMsUUFBUXdDLE1BQU07Q0FDakI7QUFDRGxFLG1CQUFtQixHQUFHO0lBQ2xCMEIsUUFBUXdDLE1BQU07Q0FDakI7QUFDRGxFLG9CQUFvQixHQUFHO0lBQ25CMEIsUUFBUWEsT0FBTztJQUNmYixRQUFReUMsUUFBUTtJQUNoQnpDLFFBQVEwQyxRQUFRO0lBQ2hCMUMsUUFBUTJDLEtBQUs7SUFDYjNDLFFBQVE0QyxJQUFJO0lBQ1o1QyxRQUFRNkMsS0FBSztJQUNiN0MsUUFBUThDLFFBQVE7SUFDaEI5QyxRQUFRK0MsYUFBYTtJQUNyQi9DLFFBQVFnRCxhQUFhO0lBQ3JCaEQsUUFBUWlELFFBQVE7SUFDaEJqRCxRQUFRa0QsTUFBTTtJQUNkbEQsUUFBUW1ELEtBQUs7SUFDYixjQUFjO0lBQ2RuRCxRQUFRUSxHQUFHO0lBQ1hSLFFBQVFVLElBQUk7Q0FDZjtBQUNEcEMsa0JBQWtCLEdBQUcrQixRQUFRK0MsU0FBUyxDQUFDcEQ7QUFDdkMxQixvQkFBb0IsR0FBRyxDQUFDO0FBQ3hCRixPQUFPaUYsSUFBSSxDQUFDL0UsUUFBUXNCLFVBQVUsRUFBRTBELE9BQU8sQ0FBQyxDQUFDQztJQUNyQyxJQUFJLEtBQUtDLElBQUksQ0FBQ0QsTUFBTTtRQUNoQmpGLFFBQVFxQixZQUFZLENBQUM0RCxJQUFJLEdBQUdqRixRQUFRc0IsVUFBVSxDQUFDMkQsSUFBSTtJQUN2RDtBQUNKO0FBQ0EsSUFBSTdEO0FBQ0gsVUFBVUEsTUFBTTtJQUNiQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQzdCQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ3JDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQ25DLEdBQUdBLFNBQVNwQixRQUFRb0IsTUFBTSxJQUFLcEIsQ0FBQUEsY0FBYyxHQUFHLENBQUM7QUFDakRBLGFBQWEsR0FBRyxFQUFFO0FBQ2xCLElBQUssSUFBSW1GLElBQUksSUFBSUMsVUFBVSxDQUFDLElBQUlELEtBQUssSUFBSUMsVUFBVSxDQUFDLElBQUlELElBQUs7SUFDekQsYUFBYTtJQUNibkYsUUFBUW1CLEtBQUssQ0FBQ2tFLElBQUksQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDSjtJQUN2QyxhQUFhO0lBQ2JuRixRQUFRbUIsS0FBSyxDQUFDa0UsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNKLElBQUk7QUFDL0M7QUFDQW5GLGVBQWUsR0FBRztJQUNkLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQzNCLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0FBQy9CO0FBQ0FBLGVBQWUsR0FBRztJQUNkLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQzNCLEdBQUc7SUFBRyxHQUFHO0lBQUcsR0FBRztJQUFHLEdBQUc7SUFBRyxHQUFHO0lBQzNCd0YsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFDM0NDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0lBQUtDLEdBQUc7SUFBS0MsR0FBRztJQUFLQyxHQUFHO0FBQy9DO0FBQ0FuRyxXQUFXLEdBQUc7SUFDVjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztDQUNoRDtBQUNEQSxnQkFBZ0IsR0FBR0EsUUFBUW1CLEtBQUssQ0FBQ2lGLE1BQU0sQ0FBQ3BHLFFBQVFnQixHQUFHO0FBQ25EaEIsWUFBWSxHQUFHO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUFLO0NBQUk7QUFDN0RBLHNCQUFzQixHQUFHQSxRQUFRZSxRQUFRLENBQ3BDcUYsTUFBTSxDQUFDcEcsUUFBUWMsSUFBSSxFQUNuQnNGLE1BQU0sQ0FBQztJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUNwRCx5QkFBeUI7QUFDekJwRyx1QkFBdUIsR0FBRztJQUN0QjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFDekI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNuQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFNO0lBQUs7SUFBSztJQUMxQjtJQUNBO0lBQUs7SUFBSztJQUFLO0NBQ2xCLENBQUNvRyxNQUFNLENBQUNwRyxRQUFRZSxRQUFRO0FBQ3pCZixnQkFBZ0IsR0FBR0EsUUFBUVksZUFBZSxDQUNyQ3dGLE1BQU0sQ0FBQztJQUFDO0lBQU07Q0FBSztBQUN4Qix3Q0FBd0M7QUFDeEMsSUFBSyxJQUFJakIsSUFBSSxNQUFNQSxLQUFLLE1BQU1BLElBQUs7SUFDL0JuRixRQUFRVyxRQUFRLENBQUMwRSxJQUFJLENBQUNGO0FBQzFCO0FBQ0FuRixXQUFXLEdBQUdBLFFBQVFnQixHQUFHLENBQUNvRixNQUFNLENBQUM7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUM3Rjs7Ozs7O0NBTUMsR0FDRHBHLG9CQUFvQixHQUFHO0lBQ25CO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUN6QjtJQUFLO0lBQUs7SUFBSztJQUNmO0lBQUs7SUFBSztJQUNWO0lBQUs7Q0FDUixDQUFDb0csTUFBTSxDQUFDcEcsUUFBUWUsUUFBUTtBQUN6QmYsYUFBYSxHQUFHQSxRQUFRUyxZQUFZLENBQUMyRixNQUFNLENBQUM7SUFBQztDQUFJO0FBQ2pEOzs7Q0FHQyxHQUNEcEcsb0JBQW9CLEdBQUc7SUFBQztDQUFLO0FBQzdCLElBQUssSUFBSW1GLElBQUksSUFBSUEsS0FBSyxLQUFLQSxJQUFLO0lBQzVCLElBQUlBLE1BQU0sS0FBSztRQUNYbkYsUUFBUU8sWUFBWSxDQUFDOEUsSUFBSSxDQUFDRjtJQUM5QjtBQUNKO0FBQ0EsYUFBYTtBQUNibkYsOEJBQThCLEdBQUdBLFFBQVFPLFlBQVksQ0FBQzhGLE1BQU0sQ0FBQyxDQUFDTCxJQUFNQSxNQUFNO0FBQzFFaEcsYUFBYSxHQUFHQSxRQUFRa0IsT0FBTztBQUMvQmxCLGFBQWEsR0FBR0EsUUFBUUssS0FBSztBQUM3QixJQUFJRjtBQUNILFVBQVVBLFlBQVk7SUFDbkJBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDL0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ3REQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzVDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLEdBQUc7SUFDMURBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQ3ZEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLEdBQUc7QUFDbEUsR0FBR0EsZUFBZUgsUUFBUUcsWUFBWSxJQUFLSCxDQUFBQSxvQkFBb0IsR0FBRyxDQUFDO0FBQ25FQSx1QkFBdUIsR0FBRztJQUN0QixjQUFjRyxhQUFhbUcsVUFBVTtJQUNyQyxrQkFBa0JuRyxhQUFhb0csY0FBYztJQUM3QyxvQkFBb0JwRyxhQUFhbUcsVUFBVTtJQUMzQyxxQkFBcUJuRyxhQUFhcUcsaUJBQWlCO0lBQ25ELFdBQVdyRyxhQUFhc0csT0FBTztBQUNuQyxHQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qcz9lZDkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SID0gZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBleHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IGV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLk1BUksgPSBleHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5OVU0gPSBleHBvcnRzLkhFWF9NQVAgPSBleHBvcnRzLk5VTV9NQVAgPSBleHBvcnRzLkFMUEhBID0gZXhwb3J0cy5GSU5JU0ggPSBleHBvcnRzLkhfTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EU19SVFNQID0gZXhwb3J0cy5NRVRIT0RTX0lDRSA9IGV4cG9ydHMuTUVUSE9EU19IVFRQID0gZXhwb3J0cy5NRVRIT0RTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5GTEFHUyA9IGV4cG9ydHMuVFlQRSA9IGV4cG9ydHMuRVJST1IgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBDIGhlYWRlcnNcbnZhciBFUlJPUjtcbihmdW5jdGlvbiAoRVJST1IpIHtcbiAgICBFUlJPUltFUlJPUltcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlRFUk5BTFwiXSA9IDFdID0gXCJJTlRFUk5BTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiU1RSSUNUXCJdID0gMl0gPSBcIlNUUklDVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiTEZfRVhQRUNURURcIl0gPSAzXSA9IFwiTEZfRVhQRUNURURcIjtcbiAgICBFUlJPUltFUlJPUltcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIl0gPSA0XSA9IFwiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0xPU0VEX0NPTk5FQ1RJT05cIl0gPSA1XSA9IFwiQ0xPU0VEX0NPTk5FQ1RJT05cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfTUVUSE9EXCJdID0gNl0gPSBcIklOVkFMSURfTUVUSE9EXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1VSTFwiXSA9IDddID0gXCJJTlZBTElEX1VSTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9DT05TVEFOVFwiXSA9IDhdID0gXCJJTlZBTElEX0NPTlNUQU5UXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1ZFUlNJT05cIl0gPSA5XSA9IFwiSU5WQUxJRF9WRVJTSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0hFQURFUl9UT0tFTlwiXSA9IDEwXSA9IFwiSU5WQUxJRF9IRUFERVJfVE9LRU5cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIl0gPSAxMV0gPSBcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ0hVTktfU0laRVwiXSA9IDEyXSA9IFwiSU5WQUxJRF9DSFVOS19TSVpFXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1NUQVRVU1wiXSA9IDEzXSA9IFwiSU5WQUxJRF9TVEFUVVNcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfRU9GX1NUQVRFXCJdID0gMTRdID0gXCJJTlZBTElEX0VPRl9TVEFURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDE1XSA9IFwiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9CRUdJTlwiXSA9IDE2XSA9IFwiQ0JfTUVTU0FHRV9CRUdJTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfSEVBREVSU19DT01QTEVURVwiXSA9IDE3XSA9IFwiQ0JfSEVBREVSU19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9DT01QTEVURVwiXSA9IDE4XSA9IFwiQ0JfTUVTU0FHRV9DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfQ0hVTktfSEVBREVSXCJdID0gMTldID0gXCJDQl9DSFVOS19IRUFERVJcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0NPTVBMRVRFXCJdID0gMjBdID0gXCJDQl9DSFVOS19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEXCJdID0gMjFdID0gXCJQQVVTRURcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9VUEdSQURFXCJdID0gMjJdID0gXCJQQVVTRURfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEX0gyX1VQR1JBREVcIl0gPSAyM10gPSBcIlBBVVNFRF9IMl9VUEdSQURFXCI7XG4gICAgRVJST1JbRVJST1JbXCJVU0VSXCJdID0gMjRdID0gXCJVU0VSXCI7XG59KShFUlJPUiA9IGV4cG9ydHMuRVJST1IgfHwgKGV4cG9ydHMuRVJST1IgPSB7fSkpO1xudmFyIFRZUEU7XG4oZnVuY3Rpb24gKFRZUEUpIHtcbiAgICBUWVBFW1RZUEVbXCJCT1RIXCJdID0gMF0gPSBcIkJPVEhcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVFVRVNUXCJdID0gMV0gPSBcIlJFUVVFU1RcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVNQT05TRVwiXSA9IDJdID0gXCJSRVNQT05TRVwiO1xufSkoVFlQRSA9IGV4cG9ydHMuVFlQRSB8fCAoZXhwb3J0cy5UWVBFID0ge30pKTtcbnZhciBGTEFHUztcbihmdW5jdGlvbiAoRkxBR1MpIHtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiXSA9IDFdID0gXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSAyXSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gNF0gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ0hVTktFRFwiXSA9IDhdID0gXCJDSFVOS0VEXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJVUEdSQURFXCJdID0gMTZdID0gXCJVUEdSQURFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05URU5UX0xFTkdUSFwiXSA9IDMyXSA9IFwiQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlNLSVBCT0RZXCJdID0gNjRdID0gXCJTS0lQQk9EWVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVFJBSUxJTkdcIl0gPSAxMjhdID0gXCJUUkFJTElOR1wiO1xuICAgIC8vIDEgPDwgOCBpcyB1bnVzZWRcbiAgICBGTEFHU1tGTEFHU1tcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gNTEyXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbn0pKEZMQUdTID0gZXhwb3J0cy5GTEFHUyB8fCAoZXhwb3J0cy5GTEFHUyA9IHt9KSk7XG52YXIgTEVOSUVOVF9GTEFHUztcbihmdW5jdGlvbiAoTEVOSUVOVF9GTEFHUykge1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkhFQURFUlNcIl0gPSAxXSA9IFwiSEVBREVSU1wiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkNIVU5LRURfTEVOR1RIXCJdID0gMl0gPSBcIkNIVU5LRURfTEVOR1RIXCI7XG4gICAgTEVOSUVOVF9GTEFHU1tMRU5JRU5UX0ZMQUdTW1wiS0VFUF9BTElWRVwiXSA9IDRdID0gXCJLRUVQX0FMSVZFXCI7XG59KShMRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTIHx8IChleHBvcnRzLkxFTklFTlRfRkxBR1MgPSB7fSkpO1xudmFyIE1FVEhPRFM7XG4oZnVuY3Rpb24gKE1FVEhPRFMpIHtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJERUxFVEVcIl0gPSAwXSA9IFwiREVMRVRFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiR0VUXCJdID0gMV0gPSBcIkdFVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkhFQURcIl0gPSAyXSA9IFwiSEVBRFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBPU1RcIl0gPSAzXSA9IFwiUE9TVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBVVFwiXSA9IDRdID0gXCJQVVRcIjtcbiAgICAvKiBwYXRob2xvZ2ljYWwgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT05ORUNUXCJdID0gNV0gPSBcIkNPTk5FQ1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJPUFRJT05TXCJdID0gNl0gPSBcIk9QVElPTlNcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJUUkFDRVwiXSA9IDddID0gXCJUUkFDRVwiO1xuICAgIC8qIFdlYkRBViAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNPUFlcIl0gPSA4XSA9IFwiQ09QWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkxPQ0tcIl0gPSA5XSA9IFwiTE9DS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQ09MXCJdID0gMTBdID0gXCJNS0NPTFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1PVkVcIl0gPSAxMV0gPSBcIk1PVkVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QRklORFwiXSA9IDEyXSA9IFwiUFJPUEZJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QUEFUQ0hcIl0gPSAxM10gPSBcIlBST1BQQVRDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFQVJDSFwiXSA9IDE0XSA9IFwiU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MT0NLXCJdID0gMTVdID0gXCJVTkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJCSU5EXCJdID0gMTZdID0gXCJCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVCSU5EXCJdID0gMTddID0gXCJSRUJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTkJJTkRcIl0gPSAxOF0gPSBcIlVOQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFDTFwiXSA9IDE5XSA9IFwiQUNMXCI7XG4gICAgLyogc3VidmVyc2lvbiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFUE9SVFwiXSA9IDIwXSA9IFwiUkVQT1JUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtBQ1RJVklUWVwiXSA9IDIxXSA9IFwiTUtBQ1RJVklUWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNIRUNLT1VUXCJdID0gMjJdID0gXCJDSEVDS09VVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1FUkdFXCJdID0gMjNdID0gXCJNRVJHRVwiO1xuICAgIC8qIHVwbnAgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNLVNFQVJDSFwiXSA9IDI0XSA9IFwiTS1TRUFSQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJOT1RJRllcIl0gPSAyNV0gPSBcIk5PVElGWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNVQlNDUklCRVwiXSA9IDI2XSA9IFwiU1VCU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5TVUJTQ1JJQkVcIl0gPSAyN10gPSBcIlVOU1VCU0NSSUJFXCI7XG4gICAgLyogUkZDLTU3ODkgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVRDSFwiXSA9IDI4XSA9IFwiUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVJHRVwiXSA9IDI5XSA9IFwiUFVSR0VcIjtcbiAgICAvKiBDYWxEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NBTEVOREFSXCJdID0gMzBdID0gXCJNS0NBTEVOREFSXCI7XG4gICAgLyogUkZDLTIwNjgsIHNlY3Rpb24gMTkuNi4xLjIgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMSU5LXCJdID0gMzFdID0gXCJMSU5LXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MSU5LXCJdID0gMzJdID0gXCJVTkxJTktcIjtcbiAgICAvKiBpY2VjYXN0ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU09VUkNFXCJdID0gMzNdID0gXCJTT1VSQ0VcIjtcbiAgICAvKiBSRkMtNzU0MCwgc2VjdGlvbiAxMS42ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJJXCJdID0gMzRdID0gXCJQUklcIjtcbiAgICAvKiBSRkMtMjMyNiBSVFNQICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVTQ1JJQkVcIl0gPSAzNV0gPSBcIkRFU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQU5OT1VOQ0VcIl0gPSAzNl0gPSBcIkFOTk9VTkNFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUVVBcIl0gPSAzN10gPSBcIlNFVFVQXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUExBWVwiXSA9IDM4XSA9IFwiUExBWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBBVVNFXCJdID0gMzldID0gXCJQQVVTRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlRFQVJET1dOXCJdID0gNDBdID0gXCJURUFSRE9XTlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVF9QQVJBTUVURVJcIl0gPSA0MV0gPSBcIkdFVF9QQVJBTUVURVJcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRVRfUEFSQU1FVEVSXCJdID0gNDJdID0gXCJTRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVESVJFQ1RcIl0gPSA0M10gPSBcIlJFRElSRUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVDT1JEXCJdID0gNDRdID0gXCJSRUNPUkRcIjtcbiAgICAvKiBSQU9QICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiRkxVU0hcIl0gPSA0NV0gPSBcIkZMVVNIXCI7XG59KShNRVRIT0RTID0gZXhwb3J0cy5NRVRIT0RTIHx8IChleHBvcnRzLk1FVEhPRFMgPSB7fSkpO1xuZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBbXG4gICAgTUVUSE9EUy5ERUxFVEUsXG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5IRUFELFxuICAgIE1FVEhPRFMuUE9TVCxcbiAgICBNRVRIT0RTLlBVVCxcbiAgICBNRVRIT0RTLkNPTk5FQ1QsXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuVFJBQ0UsXG4gICAgTUVUSE9EUy5DT1BZLFxuICAgIE1FVEhPRFMuTE9DSyxcbiAgICBNRVRIT0RTLk1LQ09MLFxuICAgIE1FVEhPRFMuTU9WRSxcbiAgICBNRVRIT0RTLlBST1BGSU5ELFxuICAgIE1FVEhPRFMuUFJPUFBBVENILFxuICAgIE1FVEhPRFMuU0VBUkNILFxuICAgIE1FVEhPRFMuVU5MT0NLLFxuICAgIE1FVEhPRFMuQklORCxcbiAgICBNRVRIT0RTLlJFQklORCxcbiAgICBNRVRIT0RTLlVOQklORCxcbiAgICBNRVRIT0RTLkFDTCxcbiAgICBNRVRIT0RTLlJFUE9SVCxcbiAgICBNRVRIT0RTLk1LQUNUSVZJVFksXG4gICAgTUVUSE9EUy5DSEVDS09VVCxcbiAgICBNRVRIT0RTLk1FUkdFLFxuICAgIE1FVEhPRFNbJ00tU0VBUkNIJ10sXG4gICAgTUVUSE9EUy5OT1RJRlksXG4gICAgTUVUSE9EUy5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5VTlNVQlNDUklCRSxcbiAgICBNRVRIT0RTLlBBVENILFxuICAgIE1FVEhPRFMuUFVSR0UsXG4gICAgTUVUSE9EUy5NS0NBTEVOREFSLFxuICAgIE1FVEhPRFMuTElOSyxcbiAgICBNRVRIT0RTLlVOTElOSyxcbiAgICBNRVRIT0RTLlBSSSxcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBzaG91bGQgd2UgYWxsb3cgaXQgd2l0aCBIVFRQP1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19JQ0UgPSBbXG4gICAgTUVUSE9EUy5TT1VSQ0UsXG5dO1xuZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBbXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuREVTQ1JJQkUsXG4gICAgTUVUSE9EUy5BTk5PVU5DRSxcbiAgICBNRVRIT0RTLlNFVFVQLFxuICAgIE1FVEhPRFMuUExBWSxcbiAgICBNRVRIT0RTLlBBVVNFLFxuICAgIE1FVEhPRFMuVEVBUkRPV04sXG4gICAgTUVUSE9EUy5HRVRfUEFSQU1FVEVSLFxuICAgIE1FVEhPRFMuU0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlJFRElSRUNULFxuICAgIE1FVEhPRFMuUkVDT1JELFxuICAgIE1FVEhPRFMuRkxVU0gsXG4gICAgLy8gRm9yIEFpclBsYXlcbiAgICBNRVRIT0RTLkdFVCxcbiAgICBNRVRIT0RTLlBPU1QsXG5dO1xuZXhwb3J0cy5NRVRIT0RfTUFQID0gdXRpbHNfMS5lbnVtVG9NYXAoTUVUSE9EUyk7XG5leHBvcnRzLkhfTUVUSE9EX01BUCA9IHt9O1xuT2JqZWN0LmtleXMoZXhwb3J0cy5NRVRIT0RfTUFQKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoL15ILy50ZXN0KGtleSkpIHtcbiAgICAgICAgZXhwb3J0cy5IX01FVEhPRF9NQVBba2V5XSA9IGV4cG9ydHMuTUVUSE9EX01BUFtrZXldO1xuICAgIH1cbn0pO1xudmFyIEZJTklTSDtcbihmdW5jdGlvbiAoRklOSVNIKSB7XG4gICAgRklOSVNIW0ZJTklTSFtcIlNBRkVcIl0gPSAwXSA9IFwiU0FGRVwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFX1dJVEhfQ0JcIl0gPSAxXSA9IFwiU0FGRV9XSVRIX0NCXCI7XG4gICAgRklOSVNIW0ZJTklTSFtcIlVOU0FGRVwiXSA9IDJdID0gXCJVTlNBRkVcIjtcbn0pKEZJTklTSCA9IGV4cG9ydHMuRklOSVNIIHx8IChleHBvcnRzLkZJTklTSCA9IHt9KSk7XG5leHBvcnRzLkFMUEhBID0gW107XG5mb3IgKGxldCBpID0gJ0EnLmNoYXJDb2RlQXQoMCk7IGkgPD0gJ1onLmNoYXJDb2RlQXQoMCk7IGkrKykge1xuICAgIC8vIFVwcGVyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG4gICAgLy8gTG93ZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAweDIwKSk7XG59XG5leHBvcnRzLk5VTV9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxufTtcbmV4cG9ydHMuSEVYX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG4gICAgQTogMFhBLCBCOiAwWEIsIEM6IDBYQywgRDogMFhELCBFOiAwWEUsIEY6IDBYRixcbiAgICBhOiAweGEsIGI6IDB4YiwgYzogMHhjLCBkOiAweGQsIGU6IDB4ZSwgZjogMHhmLFxufTtcbmV4cG9ydHMuTlVNID0gW1xuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcbl07XG5leHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5BTFBIQS5jb25jYXQoZXhwb3J0cy5OVU0pO1xuZXhwb3J0cy5NQVJLID0gWyctJywgJ18nLCAnLicsICchJywgJ34nLCAnKicsICdcXCcnLCAnKCcsICcpJ107XG5leHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5BTFBIQU5VTVxuICAgIC5jb25jYXQoZXhwb3J0cy5NQVJLKVxuICAgIC5jb25jYXQoWyclJywgJzsnLCAnOicsICcmJywgJz0nLCAnKycsICckJywgJywnXSk7XG4vLyBUT0RPKGluZHV0bnkpOiB1c2UgUkZDXG5leHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IFtcbiAgICAnIScsICdcIicsICckJywgJyUnLCAnJicsICdcXCcnLFxuICAgICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLFxuICAgICc6JywgJzsnLCAnPCcsICc9JywgJz4nLFxuICAgICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXycsXG4gICAgJ2AnLFxuICAgICd7JywgJ3wnLCAnfScsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSXG4gICAgLmNvbmNhdChbJ1xcdCcsICdcXGYnXSk7XG4vLyBBbGwgY2hhcmFjdGVycyB3aXRoIDB4ODAgYml0IHNldCB0byAxXG5mb3IgKGxldCBpID0gMHg4MDsgaSA8PSAweGZmOyBpKyspIHtcbiAgICBleHBvcnRzLlVSTF9DSEFSLnB1c2goaSk7XG59XG5leHBvcnRzLkhFWCA9IGV4cG9ydHMuTlVNLmNvbmNhdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJ10pO1xuLyogVG9rZW5zIGFzIGRlZmluZWQgYnkgcmZjIDI2MTYuIEFsc28gbG93ZXJjYXNlcyB0aGVtLlxuICogICAgICAgIHRva2VuICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiAqICAgICBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKi9cbmV4cG9ydHMuU1RSSUNUX1RPS0VOID0gW1xuICAgICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKicsICcrJywgJy0nLCAnLicsXG4gICAgJ14nLCAnXycsICdgJyxcbiAgICAnfCcsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOLmNvbmNhdChbJyAnXSk7XG4vKlxuICogVmVyaWZ5IHRoYXQgYSBjaGFyIGlzIGEgdmFsaWQgdmlzaWJsZSAocHJpbnRhYmxlKSBVUy1BU0NJSVxuICogY2hhcmFjdGVyIG9yICV4ODAtRkZcbiAqL1xuZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBbJ1xcdCddO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDEyNykge1xuICAgICAgICBleHBvcnRzLkhFQURFUl9DSEFSUy5wdXNoKGkpO1xuICAgIH1cbn1cbi8vICcsJyA9IFxceDQ0XG5leHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUy5maWx0ZXIoKGMpID0+IGMgIT09IDQ0KTtcbmV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLk5VTV9NQVA7XG5leHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUjtcbnZhciBIRUFERVJfU1RBVEU7XG4oZnVuY3Rpb24gKEhFQURFUl9TVEFURSkge1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJHRU5FUkFMXCJdID0gMF0gPSBcIkdFTkVSQUxcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTlwiXSA9IDFdID0gXCJDT05ORUNUSU9OXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTlRFTlRfTEVOR1RIXCJdID0gMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gM10gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlVQR1JBREVcIl0gPSA0XSA9IFwiVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSA1XSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSA2XSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX1VQR1JBREVcIl0gPSA3XSA9IFwiQ09OTkVDVElPTl9VUEdSQURFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIl0gPSA4XSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwiO1xufSkoSEVBREVSX1NUQVRFID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgfHwgKGV4cG9ydHMuSEVBREVSX1NUQVRFID0ge30pKTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0ge1xuICAgICdjb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJzogSEVBREVSX1NUQVRFLkNPTlRFTlRfTEVOR1RILFxuICAgICdwcm94eS1jb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogSEVBREVSX1NUQVRFLlRSQU5TRkVSX0VOQ09ESU5HLFxuICAgICd1cGdyYWRlJzogSEVBREVSX1NUQVRFLlVQR1JBREUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNQRUNJQUxfSEVBREVSUyIsIkhFQURFUl9TVEFURSIsIk1JTk9SIiwiTUFKT1IiLCJDT05ORUNUSU9OX1RPS0VOX0NIQVJTIiwiSEVBREVSX0NIQVJTIiwiVE9LRU4iLCJTVFJJQ1RfVE9LRU4iLCJIRVgiLCJVUkxfQ0hBUiIsIlNUUklDVF9VUkxfQ0hBUiIsIlVTRVJJTkZPX0NIQVJTIiwiTUFSSyIsIkFMUEhBTlVNIiwiTlVNIiwiSEVYX01BUCIsIk5VTV9NQVAiLCJBTFBIQSIsIkZJTklTSCIsIkhfTUVUSE9EX01BUCIsIk1FVEhPRF9NQVAiLCJNRVRIT0RTX1JUU1AiLCJNRVRIT0RTX0lDRSIsIk1FVEhPRFNfSFRUUCIsIk1FVEhPRFMiLCJMRU5JRU5UX0ZMQUdTIiwiRkxBR1MiLCJUWVBFIiwiRVJST1IiLCJ1dGlsc18xIiwicmVxdWlyZSIsIkRFTEVURSIsIkdFVCIsIkhFQUQiLCJQT1NUIiwiUFVUIiwiQ09OTkVDVCIsIk9QVElPTlMiLCJUUkFDRSIsIkNPUFkiLCJMT0NLIiwiTUtDT0wiLCJNT1ZFIiwiUFJPUEZJTkQiLCJQUk9QUEFUQ0giLCJTRUFSQ0giLCJVTkxPQ0siLCJCSU5EIiwiUkVCSU5EIiwiVU5CSU5EIiwiQUNMIiwiUkVQT1JUIiwiTUtBQ1RJVklUWSIsIkNIRUNLT1VUIiwiTUVSR0UiLCJOT1RJRlkiLCJTVUJTQ1JJQkUiLCJVTlNVQlNDUklCRSIsIlBBVENIIiwiUFVSR0UiLCJNS0NBTEVOREFSIiwiTElOSyIsIlVOTElOSyIsIlBSSSIsIlNPVVJDRSIsIkRFU0NSSUJFIiwiQU5OT1VOQ0UiLCJTRVRVUCIsIlBMQVkiLCJQQVVTRSIsIlRFQVJET1dOIiwiR0VUX1BBUkFNRVRFUiIsIlNFVF9QQVJBTUVURVIiLCJSRURJUkVDVCIsIlJFQ09SRCIsIkZMVVNIIiwiZW51bVRvTWFwIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ0ZXN0IiwiaSIsImNoYXJDb2RlQXQiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiY29uY2F0IiwiZmlsdGVyIiwiQ09OTkVDVElPTiIsIkNPTlRFTlRfTEVOR1RIIiwiVFJBTlNGRVJfRU5DT0RJTkciLCJVUEdSQURFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHAtd2FzbS5qcz85MThjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gJ0FHRnpiUUVBQUFBQk1BaGdBWDhCZjJBRGYzOS9BWDlnQkg5L2YzOEJmMkFBQUdBRGYzOS9BR0FCZndCZ0FuOS9BR0FHZjM5L2YzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUNBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBMFpGQXdNRUFBQUZBQUFBQUFBQUJRRUZBQVVGQlFBQUJnQUFBQUFHQmdZR0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFBQUJBUWNBQUFVRkF3QUJCQVVCY0FFU0VnVURBUUFDQmdnQmZ3RkJnTlFFQ3dmUkJTSUdiV1Z0YjNKNUFnQUxYMmx1YVhScFlXeHBlbVVBQ1JsZlgybHVaR2x5WldOMFgyWjFibU4wYVc5dVgzUmhZbXhsQVFBTGJHeG9kSFJ3WDJsdWFYUUFDaGhzYkdoMGRIQmZjMmh2ZFd4a1gydGxaWEJmWVd4cGRtVUFRUXhzYkdoMGRIQmZZV3hzYjJNQURBWnRZV3hzYjJNQVJndHNiR2gwZEhCZlpuSmxaUUFOQkdaeVpXVUFTQTlzYkdoMGRIQmZaMlYwWDNSNWNHVUFEaFZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV0ZxYjNJQUR4VnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXbHViM0lBRUJGc2JHaDBkSEJmWjJWMFgyMWxkR2h2WkFBUkZteHNhSFIwY0Y5blpYUmZjM1JoZEhWelgyTnZaR1VBRWhKc2JHaDBkSEJmWjJWMFgzVndaM0poWkdVQUV3eHNiR2gwZEhCZmNtVnpaWFFBRkE1c2JHaDBkSEJmWlhobFkzVjBaUUFWRkd4c2FIUjBjRjl6WlhSMGFXNW5jMTlwYm1sMEFCWU5iR3hvZEhSd1gyWnBibWx6YUFBWERHeHNhSFIwY0Y5d1lYVnpaUUFZRFd4c2FIUjBjRjl5WlhOMWJXVUFHUnRzYkdoMGRIQmZjbVZ6ZFcxbFgyRm1kR1Z5WDNWd1ozSmhaR1VBR2hCc2JHaDBkSEJmWjJWMFgyVnljbTV2QUJzWGJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5eVpXRnpiMjRBSEJkc2JHaDBkSEJmYzJWMFgyVnljbTl5WDNKbFlYTnZiZ0FkRkd4c2FIUjBjRjluWlhSZlpYSnliM0pmY0c5ekFCNFJiR3hvZEhSd1gyVnljbTV2WDI1aGJXVUFIeEpzYkdoMGRIQmZiV1YwYUc5a1gyNWhiV1VBSUJKc2JHaDBkSEJmYzNSaGRIVnpYMjVoYldVQUlScHNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZhR1ZoWkdWeWN3QWlJV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlqYUhWdWEyVmtYMnhsYm1kMGFBQWpIV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlyWldWd1gyRnNhWFpsQUNRa2JHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgzUnlZVzV6Wm1WeVgyVnVZMjlrYVc1bkFDVVliR3hvZEhSd1gyMWxjM05oWjJWZmJtVmxaSE5mWlc5bUFEOEpGd0VBUVFFTEVRRUNBd1FGQ3dZSE5UazNNUzh0SnlzcENzTGdBa1VDQUFzSUFCQ0lnSUNBQUFzWkFDQUFFTUtBZ0lBQUdpQUFJQUkyQWpnZ0FDQUJPZ0FvQ3h3QUlBQWdBQzhCTWlBQUxRQXVJQUFRd1lDQWdBQVFnSUNBZ0FBTEtnRUJmMEhBQUJER2dJQ0FBQ0lCRU1LQWdJQUFHaUFCUVlDSWdJQUFOZ0k0SUFFZ0FEb0FLQ0FCQ3dvQUlBQVF5SUNBZ0FBTEJ3QWdBQzBBS0FzSEFDQUFMUUFxQ3djQUlBQXRBQ3NMQndBZ0FDMEFLUXNIQUNBQUx3RXlDd2NBSUFBdEFDNExSUUVFZnlBQUtBSVlJUUVnQUMwQUxTRUNJQUF0QUNnaEF5QUFLQUk0SVFRZ0FCRENnSUNBQUJvZ0FDQUVOZ0k0SUFBZ0F6b0FLQ0FBSUFJNkFDMGdBQ0FCTmdJWUN4RUFJQUFnQVNBQklBSnFFTU9BZ0lBQUN4QUFJQUJCQUVIY0FCRE1nSUNBQUJvTFp3RUJmMEVBSVFFQ1FDQUFLQUlNRFFBQ1FBSkFBa0FDUUNBQUxRQXZEZ01CQUFNQ0N5QUFLQUk0SWdGRkRRQWdBU2dDTENJQlJRMEFJQUFnQVJHQWdJQ0FBQUFpQVEwREMwRUFEd3NReW9DQWdBQUFDeUFBUWNPV2dJQUFOZ0lRUVE0aEFRc2dBUXNlQUFKQUlBQW9BZ3dOQUNBQVFkR2JnSUFBTmdJUUlBQkJGVFlDREFzTEZnQUNRQ0FBS0FJTVFSVkhEUUFnQUVFQU5nSU1Dd3NXQUFKQUlBQW9BZ3hCRmtjTkFDQUFRUUEyQWd3TEN3Y0FJQUFvQWd3TEJ3QWdBQ2dDRUFzSkFDQUFJQUUyQWhBTEJ3QWdBQ2dDRkFzaUFBSkFJQUJCSkVrTkFCREtnSUNBQUFBTElBQkJBblJCb0xPQWdBQnFLQUlBQ3lJQUFrQWdBRUV1U1EwQUVNcUFnSUFBQUFzZ0FFRUNkRUd3dElDQUFHb29BZ0FMN2dzQkFYOUI2NmlBZ0FBaEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCbkg5cUR2UURZMklBQVdGaFlXRmhZUUlEQkFWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhCZ2NJQ1FvTERBME9EMkZoWVdGaEVHRmhZV0ZoWVdGaFlXRmhFV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZUklURkJVV0Z4Z1pHaHRoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoSEIwZUh5QWhJaU1rSlNZbktDa3FLeXd0TGk4d01USXpORFUyWVRjNE9UcGhZV0ZoWVdGaFlUdGhZV0U4WVdGaFlUMCtQMkZoWVdGaFlXRmhRR0ZoUVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UyRmhZV0ZoWVdGaFZGVldWMWhaV2x0aFhGMWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZlWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWDJCaEMwSGhwNENBQUE4TFFhU2hnSUFBRHd0Qnk2eUFnQUFQQzBIK3NZQ0FBQThMUWNDa2dJQUFEd3RCcTZTQWdBQVBDMEdOcUlDQUFBOExRZUttZ0lBQUR3dEJnTENBZ0FBUEMwRzVyNENBQUE4TFFkZWtnSUFBRHd0Qjc1K0FnQUFQQzBIaG40Q0FBQThMUWZxZmdJQUFEd3RCOHFDQWdBQVBDMEdvcjRDQUFBOExRYTZ5Z0lBQUR3dEJpTENBZ0FBUEMwSHNwNENBQUE4TFFZS2lnSUFBRHd0QmpwMkFnQUFQQzBIUXJvQ0FBQThMUWNxamdJQUFEd3RCeGJLQWdBQVBDMEhmbklDQUFBOExRZEtjZ0lBQUR3dEJ4S0NBZ0FBUEMwSFhvSUNBQUE4TFFhS2ZnSUFBRHd0QjdhNkFnQUFQQzBHcnNJQ0FBQThMUWRTbGdJQUFEd3RCeks2QWdBQVBDMEg2cm9DQUFBOExRZnlyZ0lBQUR3dEIwckNBZ0FBUEMwSHhuWUNBQUE4TFFidWdnSUFBRHd0Qjk2dUFnQUFQQzBHUXNZQ0FBQThMUWRleGdJQUFEd3RCb3EyQWdBQVBDMEhVcDRDQUFBOExRZUNyZ0lBQUR3dEJuNnlBZ0FBUEMwSHJzWUNBQUE4TFFkV2ZnSUFBRHd0QnlyR0FnQUFQQzBIZXBZQ0FBQThMUWRTZWdJQUFEd3RCOUp5QWdBQVBDMEduc29DQUFBOExRYkdkZ0lBQUR3dEJvSjJBZ0FBUEMwRzVzWUNBQUE4TFFieXdnSUFBRHd0QmtxR0FnQUFQQzBHenBvQ0FBQThMUWVtc2dJQUFEd3RCcko2QWdBQVBDMEhVcTRDQUFBOExRZmVtZ0lBQUR3dEJnS2FBZ0FBUEMwR3dvWUNBQUE4TFFmNmVnSUFBRHd0QmphT0FnQUFQQzBHSnJZQ0FBQThMUWZlaWdJQUFEd3RCb0xHQWdBQVBDMEd1bjRDQUFBOExRY2FsZ0lBQUR3dEI2SjZBZ0FBUEMwR1Rvb0NBQUE4TFFjS3ZnSUFBRHd0Qnc1MkFnQUFQQzBHTHJJQ0FBQThMUWVHZGdJQUFEd3RCamErQWdBQVBDMEhxb1lDQUFBOExRYlN0Z0lBQUR3dEIwcStBZ0FBUEMwSGZzb0NBQUE4TFFkS3lnSUFBRHd0QjhMQ0FnQUFQQzBHcG9vQ0FBQThMUWZtamdJQUFEd3RCbVo2QWdBQVBDMEcxcklDQUFBOExRWnV3Z0lBQUR3dEJrcktBZ0FBUEMwRzJxNENBQUE4TFFjS2lnSUFBRHd0QitMS0FnQUFQQzBHZXBZQ0FBQThMUWRDaWdJQUFEd3RCdXA2QWdBQVBDMEdCbm9DQUFBOExFTXFBZ0lBQUFBdEIxcUdBZ0FBaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BZ0FpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDQkNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRY2FSZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJd0lnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnZ2lCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVIMmlvQ0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NOQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlNSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3WnFBZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWpnaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxTUUVDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0VDSUVSUTBBSUFBZ0FTQUNJQUZySUFRUmdZQ0FnQUFBSWdOQmYwY05BQ0FBUVpXUWdJQUFOZ0lRUVJnaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSThJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaFFpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFR3FtNENBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDUUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJWUlnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCN1pPQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NKQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlzSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWlnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaUlDQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1VDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSWNJZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQndwbUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9Ba2dpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDSUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWlNVZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FKTUlnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FsUWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NXQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0RkFRRi9Ba0FDUUNBQUx3RXdRUlJ4UVJSSERRQkJBU0VESUFBdEFDaEJBVVlOQVNBQUx3RXlRZVVBUmlFRERBRUxJQUF0QUNsQkJVWWhBd3NnQUNBRE9nQXVRUUFML2dFQkEzOUJBU0VEQWtBZ0FDOEJNQ0lFUVFoeERRQWdBQ2tESUVJQVVpRURDd0pBQWtBZ0FDMEFMa1VOQUVFQklRVWdBQzBBS1VFRlJnMEJRUUVoQlNBRVFjQUFjVVVnQTNGQkFVY05BUXRCQUNFRklBUkJ3QUJ4RFFCQkFpRUZJQVJCLy84RGNTSURRUWh4RFFBQ1FDQURRWUFFY1VVTkFBSkFJQUF0QUNoQkFVY05BQ0FBTFFBdFFRcHhEUUJCQlE4TFFRUVBDd0pBSUFOQklIRU5BQUpBSUFBdEFDaEJBVVlOQUNBQUx3RXlRZi8vQTNFaUFFR2NmMnBCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQVFRUWhCU0FFUVNoeFJRMENJQU5CaUFSeFFZQUVSZzBDQzBFQUR3dEJBRUVESUFBcEF5QlFHeUVGQ3lBRkMySUJBbjlCQUNFQkFrQWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lDUVp4L2FrSGtBRWtOQUNBQ1Fjd0JSZzBBSUFKQnNBSkdEUUFnQUM4Qk1DSUFRY0FBY1EwQVFRRWhBU0FBUVlnRWNVR0FCRVlOQUNBQVFTaHhSU0VCQ3lBQkM2Y0JBUU4vQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFFRUFJUU1nQUM4Qk1DSUVRUUp4UlEwQkRBSUxRUUFoQXlBQUx3RXdJZ1JCQVhGRkRRRUxRUUVoQXlBQUxRQW9RUUZHRFFBZ0FDOEJNa0gvL3dOeElnVkJuSDlxUWVRQVNRMEFJQVZCekFGR0RRQWdCVUd3QWtZTkFDQUVRY0FBY1EwQVFRQWhBeUFFUVlnRWNVR0FCRVlOQUNBRVFTaHhRUUJISVFNTElBQkJBRHNCTUNBQVFRQTZBQzhnQXd1WkFRRUNmd0pBQWtBQ1FDQUFMUUFxUlEwQUlBQXRBQ3RGRFFCQkFDRUJJQUF2QVRBaUFrRUNjVVVOQVF3Q0MwRUFJUUVnQUM4Qk1DSUNRUUZ4UlEwQkMwRUJJUUVnQUMwQUtFRUJSZzBBSUFBdkFUSkIvLzhEY1NJQVFaeC9ha0hrQUVrTkFDQUFRY3dCUmcwQUlBQkJzQUpHRFFBZ0FrSEFBSEVOQUVFQUlRRWdBa0dJQkhGQmdBUkdEUUFnQWtFb2NVRUFSeUVCQ3lBQkMxa0FJQUJCR0dwQ0FEY0RBQ0FBUWdBM0F3QWdBRUU0YWtJQU53TUFJQUJCTUdwQ0FEY0RBQ0FBUVNocVFnQTNBd0FnQUVFZ2FrSUFOd01BSUFCQkVHcENBRGNEQUNBQVFRaHFRZ0EzQXdBZ0FFSGRBVFlDSEVFQUMzc0JBWDhDUUNBQUtBSU1JZ01OQUFKQUlBQW9BZ1JGRFFBZ0FDQUJOZ0lFQ3dKQUlBQWdBU0FDRU1TQWdJQUFJZ01OQUNBQUtBSU1Ed3NnQUNBRE5nSWNRUUFoQXlBQUtBSUVJZ0ZGRFFBZ0FDQUJJQUlnQUNnQ0NCR0JnSUNBQUFBaUFVVU5BQ0FBSUFJMkFoUWdBQ0FCTmdJTUlBRWhBd3NnQXd2azh3RUREbjhEZmdSL0k0Q0FnSUFBUVJCcklnTWtnSUNBZ0FBZ0FTRUVJQUVoQlNBQklRWWdBU0VISUFFaENDQUJJUWtnQVNFS0lBRWhDeUFCSVF3Z0FTRU5JQUVoRGlBQklROENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBQ2dDSENJUVFYOXFEdDBCMmdFQjJRRUNBd1FGQmdjSUNRb0xEQTBPMkFFUEVOY0JFUkxXQVJNVUZSWVhHQmthRytBQjN3RWNIUjdWQVI4Z0lTSWpKQ1hVQVNZbktDa3FLeXpUQWRJQkxTN1JBZEFCTHpBeE1qTTBOVFkzT0RrNk96dzlQajlBUVVKRFJFVkcyd0ZIU0VsS3p3SE9BVXZOQVV6TUFVMU9UMUJSVWxOVVZWWlhXRmxhVzF4ZFhsOWdZV0pqWkdWbVoyaHBhbXRzYlc1dmNIRnljM1IxZG5kNGVYcDdmSDErZjRBQmdRR0NBWU1CaEFHRkFZWUJod0dJQVlrQmlnR0xBWXdCalFHT0FZOEJrQUdSQVpJQmt3R1VBWlVCbGdHWEFaZ0JtUUdhQVpzQm5BR2RBWjRCbndHZ0FhRUJvZ0dqQWFRQnBRR21BYWNCcUFHcEFhb0Jxd0dzQWEwQnJnR3ZBYkFCc1FHeUFiTUJ0QUcxQWJZQnR3SExBY29CdUFISkFia0J5QUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSEdBUURjQVF0QkFDRVFETVlCQzBFT0lSQU14UUVMUVEwaEVBekVBUXRCRHlFUURNTUJDMEVRSVJBTXdnRUxRUk1oRUF6QkFRdEJGQ0VRRE1BQkMwRVZJUkFNdndFTFFSWWhFQXkrQVF0QkZ5RVFETDBCQzBFWUlSQU12QUVMUVJraEVBeTdBUXRCR2lFUURMb0JDMEViSVJBTXVRRUxRUndoRUF5NEFRdEJDQ0VRRExjQkMwRWRJUkFNdGdFTFFTQWhFQXkxQVF0Qkh5RVFETFFCQzBFSElSQU1zd0VMUVNFaEVBeXlBUXRCSWlFUURMRUJDMEVlSVJBTXNBRUxRU01oRUF5dkFRdEJFaUVRREs0QkMwRVJJUkFNclFFTFFTUWhFQXlzQVF0QkpTRVFES3NCQzBFbUlSQU1xZ0VMUVNjaEVBeXBBUXRCd3dFaEVBeW9BUXRCS1NFUURLY0JDMEVySVJBTXBnRUxRU3doRUF5bEFRdEJMU0VRREtRQkMwRXVJUkFNb3dFTFFTOGhFQXlpQVF0QnhBRWhFQXloQVF0Qk1DRVFES0FCQzBFMElSQU1ud0VMUVF3aEVBeWVBUXRCTVNFUURKMEJDMEV5SVJBTW5BRUxRVE1oRUF5YkFRdEJPU0VRREpvQkMwRTFJUkFNbVFFTFFjVUJJUkFNbUFFTFFRc2hFQXlYQVF0Qk9pRVFESllCQzBFMklSQU1sUUVMUVFvaEVBeVVBUXRCTnlFUURKTUJDMEU0SVJBTWtnRUxRVHdoRUF5UkFRdEJPeUVRREpBQkMwRTlJUkFNandFTFFRa2hFQXlPQVF0QktDRVFESTBCQzBFK0lSQU1qQUVMUVQ4aEVBeUxBUXRCd0FBaEVBeUtBUXRCd1FBaEVBeUpBUXRCd2dBaEVBeUlBUXRCd3dBaEVBeUhBUXRCeEFBaEVBeUdBUXRCeFFBaEVBeUZBUXRCeGdBaEVBeUVBUXRCS2lFUURJTUJDMEhIQUNFUURJSUJDMEhJQUNFUURJRUJDMEhKQUNFUURJQUJDMEhLQUNFUURIOExRY3NBSVJBTWZndEJ6UUFoRUF4OUMwSE1BQ0VRREh3TFFjNEFJUkFNZXd0Qnp3QWhFQXg2QzBIUUFDRVFESGtMUWRFQUlSQU1lQXRCMGdBaEVBeDNDMEhUQUNFUURIWUxRZFFBSVJBTWRRdEIxZ0FoRUF4MEMwSFZBQ0VRREhNTFFRWWhFQXh5QzBIWEFDRVFESEVMUVFVaEVBeHdDMEhZQUNFUURHOExRUVFoRUF4dUMwSFpBQ0VRREcwTFFkb0FJUkFNYkF0QjJ3QWhFQXhyQzBIY0FDRVFER29MUVFNaEVBeHBDMEhkQUNFUURHZ0xRZDRBSVJBTVp3dEIzd0FoRUF4bUMwSGhBQ0VRREdVTFFlQUFJUkFNWkF0QjRnQWhFQXhqQzBIakFDRVFER0lMUVFJaEVBeGhDMEhrQUNFUURHQUxRZVVBSVJBTVh3dEI1Z0FoRUF4ZUMwSG5BQ0VRREYwTFFlZ0FJUkFNWEF0QjZRQWhFQXhiQzBIcUFDRVFERm9MUWVzQUlSQU1XUXRCN0FBaEVBeFlDMEh0QUNFUURGY0xRZTRBSVJBTVZndEI3d0FoRUF4VkMwSHdBQ0VRREZRTFFmRUFJUkFNVXd0QjhnQWhFQXhTQzBIekFDRVFERkVMUWZRQUlSQU1VQXRCOVFBaEVBeFBDMEgyQUNFUURFNExRZmNBSVJBTVRRdEIrQUFoRUF4TUMwSDVBQ0VRREVzTFFmb0FJUkFNU2d0Qit3QWhFQXhKQzBIOEFDRVFERWdMUWYwQUlSQU1Sd3RCL2dBaEVBeEdDMEgvQUNFUURFVUxRWUFCSVJBTVJBdEJnUUVoRUF4REMwR0NBU0VRREVJTFFZTUJJUkFNUVF0QmhBRWhFQXhBQzBHRkFTRVFERDhMUVlZQklSQU1QZ3RCaHdFaEVBdzlDMEdJQVNFUUREd0xRWWtCSVJBTU93dEJpZ0VoRUF3NkMwR0xBU0VRRERrTFFZd0JJUkFNT0F0QmpRRWhFQXczQzBHT0FTRVFERFlMUVk4QklSQU1OUXRCa0FFaEVBdzBDMEdSQVNFUURETUxRWklCSVJBTU1ndEJrd0VoRUF3eEMwR1VBU0VRRERBTFFaVUJJUkFNTHd0QmxnRWhFQXd1QzBHWEFTRVFEQzBMUVpnQklSQU1MQXRCbVFFaEVBd3JDMEdhQVNFUURDb0xRWnNCSVJBTUtRdEJuQUVoRUF3b0MwR2RBU0VRRENjTFFaNEJJUkFNSmd0Qm53RWhFQXdsQzBHZ0FTRVFEQ1FMUWFFQklSQU1Jd3RCb2dFaEVBd2lDMEdqQVNFUURDRUxRYVFCSVJBTUlBdEJwUUVoRUF3ZkMwR21BU0VRREI0TFFhY0JJUkFNSFF0QnFBRWhFQXdjQzBHcEFTRVFEQnNMUWFvQklSQU1HZ3RCcXdFaEVBd1pDMEdzQVNFUURCZ0xRYTBCSVJBTUZ3dEJyZ0VoRUF3V0MwRUJJUkFNRlF0QnJ3RWhFQXdVQzBHd0FTRVFEQk1MUWJFQklSQU1FZ3RCc3dFaEVBd1JDMEd5QVNFUURCQUxRYlFCSVJBTUR3dEJ0UUVoRUF3T0MwRzJBU0VRREEwTFFiY0JJUkFNREF0QnVBRWhFQXdMQzBHNUFTRVFEQW9MUWJvQklSQU1DUXRCdXdFaEVBd0lDMEhHQVNFUURBY0xRYndCSVJBTUJndEJ2UUVoRUF3RkMwRytBU0VRREFRTFFiOEJJUkFNQXd0QndBRWhFQXdDQzBIQ0FTRVFEQUVMUWNFQklSQUxBMEFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBUURzY0JBQUVDQXdRRkJnY0lDUW9MREEwT0R4QVJFaE1VRlJZWEdCa2FHeHdlSHlBaEl5VW9QMEJCUkVWR1IwaEpTa3RNVFU5UVVWSlQzZ05YV1Z0Y1hXQmlaV1puYUdscWEyeHRiM0J4Y25OMGRYWjNlSGw2ZTN4OWZvQUJnZ0dGQVlZQmh3R0pBWXNCakFHTkFZNEJqd0dRQVpFQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnVBRzVBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJ4d0hJQWNrQnlnSExBY3dCelFIT0FjOEIwQUhSQWRJQjB3SFVBZFVCMWdIWEFkZ0IyUUhhQWRzQjNBSGRBZDRCNEFIaEFlSUI0d0hrQWVVQjVnSG5BZWdCNlFIcUFlc0I3QUh0QWU0Qjd3SHdBZkVCOGdIekFaa0NwQUt3QXY0Qy9nSUxJQUVpQkNBQ1J3M3pBVUhkQVNFUURQOERDeUFCSWhBZ0FrY04zUUZCd3dFaEVBeitBd3NnQVNJQklBSkhEWkFCUWZjQUlSQU0vUU1MSUFFaUFTQUNSdzJHQVVIdkFDRVFEUHdEQ3lBQklnRWdBa2NOZjBIcUFDRVFEUHNEQ3lBQklnRWdBa2NOZTBIb0FDRVFEUG9EQ3lBQklnRWdBa2NOZUVIbUFDRVFEUGtEQ3lBQklnRWdBa2NOR2tFWUlSQU0rQU1MSUFFaUFTQUNSdzBVUVJJaEVBejNBd3NnQVNJQklBSkhEVmxCeFFBaEVBejJBd3NnQVNJQklBSkhEVXBCUHlFUURQVURDeUFCSWdFZ0FrY05TRUU4SVJBTTlBTUxJQUVpQVNBQ1J3MUJRVEVoRUF6ekF3c2dBQzBBTGtFQlJnM3JBd3lIQWdzZ0FDQUJJZ0VnQWhEQWdJQ0FBRUVCUnczbUFTQUFRZ0EzQXlBTTV3RUxJQUFnQVNJQklBSVF0SUNBZ0FBaUVBM25BU0FCSVFFTTlRSUxBa0FnQVNJQklBSkhEUUJCQmlFUURQQURDeUFBSUFGQkFXb2lBU0FDRUx1QWdJQUFJaEFONkFFZ0FTRUJEREVMSUFCQ0FEY0RJRUVTSVJBTTFRTUxJQUVpRUNBQ1J3MHJRUjBoRUF6dEF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRkJFQ0VRRE5RREMwRUhJUkFNN0FNTElBQkNBQ0FBS1FNZ0loRWdBaUFCSWhCcnJTSVNmU0lUSUJNZ0VWWWJOd01nSUJFZ0VsWWlGRVVONVFGQkNDRVFET3NEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVVSVJBTTBnTUxRUWtoRUF6cUF3c2dBU0VCSUFBcEF5QlFEZVFCSUFFaEFRenlBZ3NDUUNBQklnRWdBa2NOQUVFTElSQU02UU1MSUFBZ0FVRUJhaUlCSUFJUXRvQ0FnQUFpRUEzbEFTQUJJUUVNOGdJTElBQWdBU0lCSUFJUXVJQ0FnQUFpRUEzbEFTQUJJUUVNOGdJTElBQWdBU0lCSUFJUXVJQ0FnQUFpRUEzbUFTQUJJUUVNRFFzZ0FDQUJJZ0VnQWhDNmdJQ0FBQ0lRRGVjQklBRWhBUXp3QWdzQ1FDQUJJZ0VnQWtjTkFFRVBJUkFNNVFNTElBRXRBQUFpRUVFN1JnMElJQkJCRFVjTjZBRWdBVUVCYWlFQkRPOENDeUFBSUFFaUFTQUNFTHFBZ0lBQUloQU42QUVnQVNFQkRQSUNDd05BQWtBZ0FTMEFBRUh3dFlDQUFHb3RBQUFpRUVFQlJnMEFJQkJCQWtjTjZ3RWdBQ2dDQkNFUUlBQkJBRFlDQkNBQUlCQWdBVUVCYWlJQkVMbUFnSUFBSWhBTjZnRWdBU0VCRFBRQ0N5QUJRUUZxSWdFZ0FrY05BQXRCRWlFUURPSURDeUFBSUFFaUFTQUNFTHFBZ0lBQUloQU42UUVnQVNFQkRBb0xJQUVpQVNBQ1J3MEdRUnNoRUF6Z0F3c0NRQ0FCSWdFZ0FrY05BRUVXSVJBTTRBTUxJQUJCaW9DQWdBQTJBZ2dnQUNBQk5nSUVJQUFnQVNBQ0VMaUFnSUFBSWhBTjZnRWdBU0VCUVNBaEVBekdBd3NDUUNBQklnRWdBa1lOQUFOQUFrQWdBUzBBQUVId3Q0Q0FBR290QUFBaUVFRUNSZzBBQWtBZ0VFRi9hZzRFNVFIc0FRRHJBZXdCQ3lBQlFRRnFJUUZCQ0NFUURNZ0RDeUFCUVFGcUlnRWdBa2NOQUF0QkZTRVFETjhEQzBFVklSQU0zZ01MQTBBQ1FDQUJMUUFBUWZDNWdJQUFhaTBBQUNJUVFRSkdEUUFnRUVGL2FnNEUzZ0hzQWVBQjZ3SHNBUXNnQVVFQmFpSUJJQUpIRFFBTFFSZ2hFQXpkQXdzQ1FDQUJJZ0VnQWtZTkFDQUFRWXVBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCQnlFUURNUURDMEVaSVJBTTNBTUxJQUZCQVdvaEFRd0NDd0pBSUFFaUZDQUNSdzBBUVJvaEVBemJBd3NnRkNFQkFrQWdGQzBBQUVGemFnNFUzUUx1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0lBN2dJTFFRQWhFQ0FBUVFBMkFod2dBRUd2aTRDQUFEWUNFQ0FBUVFJMkFnd2dBQ0FVUVFGcU5nSVVETm9EQ3dKQUlBRXRBQUFpRUVFN1JnMEFJQkJCRFVjTjZBRWdBVUVCYWlFQkRPVUNDeUFCUVFGcUlRRUxRU0loRUF5L0F3c0NRQ0FCSWhBZ0FrY05BRUVjSVJBTTJBTUxRZ0FoRVNBUUlRRWdFQzBBQUVGUWFnNDM1d0htQVFFQ0F3UUZCZ2NJQUFBQUFBQUFBQWtLQ3d3TkRnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUR4QVJFaE1VQUF0QkhpRVFETDBEQzBJQ0lSRU01UUVMUWdNaEVRemtBUXRDQkNFUkRPTUJDMElGSVJFTTRnRUxRZ1loRVF6aEFRdENCeUVSRE9BQkMwSUlJUkVNM3dFTFFna2hFUXplQVF0Q0NpRVJETjBCQzBJTElSRU0zQUVMUWd3aEVRemJBUXRDRFNFUkROb0JDMElPSVJFTTJRRUxRZzhoRVF6WUFRdENDaUVSRE5jQkMwSUxJUkVNMWdFTFFnd2hFUXpWQVF0Q0RTRVJETlFCQzBJT0lSRU0wd0VMUWc4aEVRelNBUXRDQUNFUkFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FRTFFBQVFWQnFEamZsQWVRQkFBRUNBd1FGQmdmbUFlWUI1Z0htQWVZQjVnSG1BUWdKQ2dzTURlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdFT0R4QVJFaFBtQVF0Q0FpRVJET1FCQzBJRElSRU00d0VMUWdRaEVRemlBUXRDQlNFUkRPRUJDMElHSVJFTTRBRUxRZ2NoRVF6ZkFRdENDQ0VSRE40QkMwSUpJUkVNM1FFTFFnb2hFUXpjQVF0Q0N5RVJETnNCQzBJTUlSRU0yZ0VMUWcwaEVRelpBUXRDRGlFUkROZ0JDMElQSVJFTTF3RUxRZ29oRVF6V0FRdENDeUVSRE5VQkMwSU1JUkVNMUFFTFFnMGhFUXpUQVF0Q0RpRVJETklCQzBJUElSRU0wUUVMSUFCQ0FDQUFLUU1nSWhFZ0FpQUJJaEJyclNJU2ZTSVRJQk1nRVZZYk53TWdJQkVnRWxZaUZFVU4wZ0ZCSHlFUURNQURDd0pBSUFFaUFTQUNSZzBBSUFCQmlZQ0FnQUEyQWdnZ0FDQUJOZ0lFSUFFaEFVRWtJUkFNcHdNTFFTQWhFQXkvQXdzZ0FDQUJJaEFnQWhDK2dJQ0FBRUYvYWc0RnRnRUF4UUlCMFFIU0FRdEJFU0VRREtRREN5QUFRUUU2QUM4Z0VDRUJETHNEQ3lBQklnRWdBa2NOMGdGQkpDRVFETHNEQ3lBQklnMGdBa2NOSGtIR0FDRVFETG9EQ3lBQUlBRWlBU0FDRUxLQWdJQUFJaEFOMUFFZ0FTRUJETFVCQ3lBQkloQWdBa2NOSmtIUUFDRVFETGdEQ3dKQUlBRWlBU0FDUncwQVFTZ2hFQXk0QXdzZ0FFRUFOZ0lFSUFCQmpJQ0FnQUEyQWdnZ0FDQUJJQUVRc1lDQWdBQWlFQTNUQVNBQklRRU0yQUVMQWtBZ0FTSVFJQUpIRFFCQktTRVFETGNEQ3lBUUxRQUFJZ0ZCSUVZTkZDQUJRUWxIRGRNQklCQkJBV29oQVF3VkN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFRd1hDMEVxSVJBTXRRTUxBa0FnQVNJUUlBSkhEUUJCS3lFUURMVURDd0pBSUJBdEFBQWlBVUVKUmcwQUlBRkJJRWNOMVFFTElBQXRBQ3hCQ0VZTjB3RWdFQ0VCREpFREN3SkFJQUVpQVNBQ1J3MEFRU3doRUF5MEF3c2dBUzBBQUVFS1J3M1ZBU0FCUVFGcUlRRU15UUlMSUFFaURpQUNSdzNWQVVFdklSQU1zZ01MQTBBQ1FDQUJMUUFBSWhCQklFWU5BQUpBSUJCQmRtb09CQURjQWR3QkFOb0JDeUFCSVFFTTRBRUxJQUZCQVdvaUFTQUNSdzBBQzBFeElSQU1zUU1MUVRJaEVDQUJJaFFnQWtZTnNBTWdBaUFVYXlBQUtBSUFJZ0ZxSVJVZ0ZDQUJhMEVEYWlFV0FrQURRQ0FVTFFBQUloZEJJSElnRnlBWFFiOS9ha0gvQVhGQkdra2JRZjhCY1NBQlFmQzdnSUFBYWkwQUFFY05BUUpBSUFGQkEwY05BRUVHSVFFTWxnTUxJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBVk5nSUFETEVEQ3lBQVFRQTJBZ0FnRkNFQkROa0JDMEV6SVJBZ0FTSVVJQUpHRGE4RElBSWdGR3NnQUNnQ0FDSUJhaUVWSUJRZ0FXdEJDR29oRmdKQUEwQWdGQzBBQUNJWFFTQnlJQmNnRjBHL2YycEIvd0Z4UVJwSkcwSC9BWEVnQVVIMHU0Q0FBR290QUFCSERRRUNRQ0FCUVFoSERRQkJCU0VCREpVREN5QUJRUUZxSVFFZ0ZFRUJhaUlVSUFKSERRQUxJQUFnRlRZQ0FBeXdBd3NnQUVFQU5nSUFJQlFoQVF6WUFRdEJOQ0VRSUFFaUZDQUNSZzJ1QXlBQ0lCUnJJQUFvQWdBaUFXb2hGU0FVSUFGclFRVnFJUllDUUFOQUlCUXRBQUFpRjBFZ2NpQVhJQmRCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUncwQkFrQWdBVUVGUncwQVFRY2hBUXlVQXdzZ0FVRUJhaUVCSUJSQkFXb2lGQ0FDUncwQUN5QUFJQlUyQWdBTXJ3TUxJQUJCQURZQ0FDQVVJUUVNMXdFTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTDZBZ0FCcUxRQUFJaEJCQVVZTkFDQVFRUUpHRFFvZ0FTRUJETjBCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJNQ0VRREs0REMwRXdJUkFNclFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQWlFRUVnUmcwQUlCQkJkbW9PQk5rQjJnSGFBZGtCMmdFTElBRkJBV29pQVNBQ1J3MEFDMEU0SVJBTXJRTUxRVGdoRUF5c0F3c0RRQUpBSUFFdEFBQWlFRUVnUmcwQUlCQkJDVWNOQXdzZ0FVRUJhaUlCSUFKSERRQUxRVHdoRUF5ckF3c0RRQUpBSUFFdEFBQWlFRUVnUmcwQUFrQUNRQ0FRUVhacURnVGFBUUVCMmdFQUN5QVFRU3hHRGRzQkN5QUJJUUVNQkFzZ0FVRUJhaUlCSUFKSERRQUxRVDhoRUF5cUF3c2dBU0VCRE5zQkMwSEFBQ0VRSUFFaUZDQUNSZzJvQXlBQ0lCUnJJQUFvQWdBaUFXb2hGaUFVSUFGclFRWnFJUmNDUUFOQUlCUXRBQUJCSUhJZ0FVR0F3SUNBQUdvdEFBQkhEUUVnQVVFR1JnMk9BeUFCUVFGcUlRRWdGRUVCYWlJVUlBSkhEUUFMSUFBZ0ZqWUNBQXlwQXdzZ0FFRUFOZ0lBSUJRaEFRdEJOaUVRREk0REN3SkFJQUVpRHlBQ1J3MEFRY0VBSVJBTXB3TUxJQUJCaklDQWdBQTJBZ2dnQUNBUE5nSUVJQThoQVNBQUxRQXNRWDlxRGdUTkFkVUIxd0haQVljREN5QUJRUUZxSVFFTXpBRUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ2NpQVFJQkJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJaEJCQ1VZTkFDQVFRU0JHRFFBQ1FBSkFBa0FDUUNBUVFaMS9hZzRUQUFNREF3TURBd01CQXdNREF3TURBd01EQWdNTElBRkJBV29oQVVFeElSQU1rUU1MSUFGQkFXb2hBVUV5SVJBTWtBTUxJQUZCQVdvaEFVRXpJUkFNandNTElBRWhBUXpRQVFzZ0FVRUJhaUlCSUFKSERRQUxRVFVoRUF5bEF3dEJOU0VRREtRREN3SkFJQUVpQVNBQ1JnMEFBMEFDUUNBQkxRQUFRWUM4Z0lBQWFpMEFBRUVCUmcwQUlBRWhBUXpUQVFzZ0FVRUJhaUlCSUFKSERRQUxRVDBoRUF5a0F3dEJQU0VRREtNREN5QUFJQUVpQVNBQ0VMQ0FnSUFBSWhBTjFnRWdBU0VCREFFTElCQkJBV29oQVF0QlBDRVFESWNEQ3dKQUlBRWlBU0FDUncwQVFjSUFJUkFNb0FNTEFrQURRQUpBSUFFdEFBQkJkMm9PR0FBQy9nTCtBb1FEL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDQVA0Q0N5QUJRUUZxSWdFZ0FrY05BQXRCd2dBaEVBeWdBd3NnQVVFQmFpRUJJQUF0QUMxQkFYRkZEYjBCSUFFaEFRdEJMQ0VRRElVREN5QUJJZ0VnQWtjTjB3RkJ4QUFoRUF5ZEF3c0RRQUpBSUFFdEFBQkJrTUNBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETGNDQ3lBQlFRRnFJZ0VnQWtjTkFBdEJ4UUFoRUF5Y0F3c2dEUzBBQUNJUVFTQkdEYk1CSUJCQk9rY05nUU1nQUNnQ0JDRUJJQUJCQURZQ0JDQUFJQUVnRFJDdmdJQ0FBQ0lCRGRBQklBMUJBV29oQVF5ekFndEJ4d0FoRUNBQklnMGdBa1lObWdNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUZhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdRd29DQUFHb3RBQUJIRFlBRElBRkJCVVlOOUFJZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1nTUxRY2dBSVJBZ0FTSU5JQUpHRFprRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJDV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCbHNLQWdBQnFMUUFBUnczL0FnSkFJQUZCQ1VjTkFFRUNJUUVNOVFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKa0RDd0pBSUFFaURTQUNSdzBBUWNrQUlSQU1tUU1MQWtBQ1FDQU5MUUFBSWdGQklISWdBU0FCUWI5L2FrSC9BWEZCR2trYlFmOEJjVUdTZjJvT0J3Q0FBNEFEZ0FPQUE0QURBWUFEQ3lBTlFRRnFJUUZCUGlFUURJQURDeUFOUVFGcUlRRkJQeUVRRFA4Q0MwSEtBQ0VRSUFFaURTQUNSZzJYQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRRnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYURDZ0lBQWFpMEFBRWNOL1FJZ0FVRUJSZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5WEF3dEJ5d0FoRUNBQklnMGdBa1lObGdNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRU9haUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdpd29DQUFHb3RBQUJIRGZ3Q0lBRkJEa1lOOEFJZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxnTUxRY3dBSVJBZ0FTSU5JQUpHRFpVRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJEMm9oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCd01LQWdBQnFMUUFBUnczN0FnSkFJQUZCRDBjTkFFRURJUUVNOFFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKVURDMEhOQUNFUUlBRWlEU0FDUmcyVUF5QUNJQTFySUFBb0FnQWlBV29oRmlBTklBRnJRUVZxSVJjRFFDQU5MUUFBSWhSQklISWdGQ0FVUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWREQ2dJQUFhaTBBQUVjTitnSUNRQ0FCUVFWSERRQkJCQ0VCRFBBQ0N5QUJRUUZxSVFFZ0RVRUJhaUlOSUFKSERRQUxJQUFnRmpZQ0FBeVVBd3NDUUNBQklnMGdBa2NOQUVIT0FDRVFESlFEQ3dKQUFrQUNRQUpBSUEwdEFBQWlBVUVnY2lBQklBRkJ2MzlxUWY4QmNVRWFTUnRCL3dGeFFaMS9hZzRUQVAwQy9RTDlBdjBDL1FMOUF2MEMvUUw5QXYwQy9RTDlBZ0g5QXYwQy9RSUNBLzBDQ3lBTlFRRnFJUUZCd1FBaEVBejlBZ3NnRFVFQmFpRUJRY0lBSVJBTS9BSUxJQTFCQVdvaEFVSERBQ0VRRFBzQ0N5QU5RUUZxSVFGQnhBQWhFQXo2QWdzQ1FDQUJJZ0VnQWtZTkFDQUFRWTJBZ0lBQU5nSUlJQUFnQVRZQ0JDQUJJUUZCeFFBaEVBejZBZ3RCendBaEVBeVNBd3NnRUNFQkFrQUNRQ0FRTFFBQVFYWnFEZ1FCcUFLb0FnQ29BZ3NnRUVFQmFpRUJDMEVuSVJBTStBSUxBa0FnQVNJQklBSkhEUUJCMFFBaEVBeVJBd3NDUUNBQkxRQUFRU0JHRFFBZ0FTRUJESTBCQ3lBQlFRRnFJUUVnQUMwQUxVRUJjVVVOeHdFZ0FTRUJESXdCQ3lBQkloY2dBa2NOeUFGQjBnQWhFQXlQQXd0QjB3QWhFQ0FCSWhRZ0FrWU5qZ01nQWlBVWF5QUFLQUlBSWdGcUlSWWdGQ0FCYTBFQmFpRVhBMEFnRkMwQUFDQUJRZGJDZ0lBQWFpMEFBRWNOekFFZ0FVRUJSZzNIQVNBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGallDQUF5T0F3c0NRQ0FCSWdFZ0FrY05BRUhWQUNFUURJNERDeUFCTFFBQVFRcEhEY3dCSUFGQkFXb2hBUXpIQVFzQ1FDQUJJZ0VnQWtjTkFFSFdBQ0VRREkwREN3SkFBa0FnQVMwQUFFRjJhZzRFQU0wQnpRRUJ6UUVMSUFGQkFXb2hBUXpIQVFzZ0FVRUJhaUVCUWNvQUlSQU04d0lMSUFBZ0FTSUJJQUlRcm9DQWdBQWlFQTNMQVNBQklRRkJ6UUFoRUF6eUFnc2dBQzBBS1VFaVJnMkZBd3ltQWdzQ1FDQUJJZ0VnQWtjTkFFSGJBQ0VRRElvREMwRUFJUlJCQVNFWFFRRWhGa0VBSVJBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUZRYWc0SzFBSFRBUUFCQWdNRUJRWUkxUUVMUVFJaEVBd0dDMEVESVJBTUJRdEJCQ0VRREFRTFFRVWhFQXdEQzBFR0lSQU1BZ3RCQnlFUURBRUxRUWdoRUF0QkFDRVhRUUFoRmtFQUlSUU16QUVMUVFraEVFRUJJUlJCQUNFWFFRQWhGZ3pMQVFzQ1FDQUJJZ0VnQWtjTkFFSGRBQ0VRRElrREN5QUJMUUFBUVM1SERjd0JJQUZCQVdvaEFReW1BZ3NnQVNJQklBSkhEY3dCUWQ4QUlSQU1od01MQWtBZ0FTSUJJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRZEFBSVJBTTdnSUxRZUFBSVJBTWhnTUxRZUVBSVJBZ0FTSUJJQUpHRFlVRElBSWdBV3NnQUNnQ0FDSVVhaUVXSUFFZ0ZHdEJBMm9oRndOQUlBRXRBQUFnRkVIaXdvQ0FBR290QUFCSERjMEJJQlJCQTBZTnpBRWdGRUVCYWlFVUlBRkJBV29pQVNBQ1J3MEFDeUFBSUJZMkFnQU1oUU1MUWVJQUlSQWdBU0lCSUFKR0RZUURJQUlnQVdzZ0FDZ0NBQ0lVYWlFV0lBRWdGR3RCQW1vaEZ3TkFJQUV0QUFBZ0ZFSG13b0NBQUdvdEFBQkhEY3dCSUJSQkFrWU56Z0VnRkVFQmFpRVVJQUZCQVdvaUFTQUNSdzBBQ3lBQUlCWTJBZ0FNaEFNTFFlTUFJUkFnQVNJQklBSkdEWU1ESUFJZ0FXc2dBQ2dDQUNJVWFpRVdJQUVnRkd0QkEyb2hGd05BSUFFdEFBQWdGRUhwd29DQUFHb3RBQUJIRGNzQklCUkJBMFlOemdFZ0ZFRUJhaUVVSUFGQkFXb2lBU0FDUncwQUN5QUFJQlkyQWdBTWd3TUxBa0FnQVNJQklBSkhEUUJCNVFBaEVBeURBd3NnQUNBQlFRRnFJZ0VnQWhDb2dJQ0FBQ0lRRGMwQklBRWhBVUhXQUNFUURPa0NDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBSWhCQklFWU5BQUpBQWtBQ1FDQVFRYmgvYWc0TEFBSFBBYzhCendIUEFjOEJ6d0hQQWM4QkFzOEJDeUFCUVFGcUlRRkIwZ0FoRUF6dEFnc2dBVUVCYWlFQlFkTUFJUkFNN0FJTElBRkJBV29oQVVIVUFDRVFET3NDQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1QUFoRUF5Q0F3dEI1QUFoRUF5QkF3c0RRQUpBSUFFdEFBQkI4TUtBZ0FCcUxRQUFJaEJCQVVZTkFDQVFRWDVxRGdQUEFkQUIwUUhTQVFzZ0FVRUJhaUlCSUFKSERRQUxRZVlBSVJBTWdBTUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJEQU1MUWVjQUlSQU0vd0lMQTBBQ1FDQUJMUUFBUWZERWdJQUFhaTBBQUNJUVFRRkdEUUFDUUNBUVFYNXFEZ1RTQWRNQjFBRUExUUVMSUFFaEFVSFhBQ0VRRE9jQ0N5QUJRUUZxSWdFZ0FrY05BQXRCNkFBaEVBeitBZ3NDUUNBQklnRWdBa2NOQUVIcEFDRVFEUDRDQ3dKQUlBRXRBQUFpRUVGMmFnNGF1Z0hWQWRVQnZBSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSEtBZFVCMVFFQTB3RUxJQUZCQVdvaEFRdEJCaUVRRE9NQ0N3TkFBa0FnQVMwQUFFSHd4b0NBQUdvdEFBQkJBVVlOQUNBQklRRU1uZ0lMSUFGQkFXb2lBU0FDUncwQUMwSHFBQ0VRRFBzQ0N3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFRd0RDMEhyQUNFUURQb0NDd0pBSUFFaUFTQUNSdzBBUWV3QUlSQU0rZ0lMSUFGQkFXb2hBUXdCQ3dKQUlBRWlBU0FDUncwQVFlMEFJUkFNK1FJTElBRkJBV29oQVF0QkJDRVFETjRDQ3dKQUlBRWlGQ0FDUncwQVFlNEFJUkFNOXdJTElCUWhBUUpBQWtBQ1FDQVVMUUFBUWZESWdJQUFhaTBBQUVGL2FnNEgxQUhWQWRZQkFKd0NBUUxYQVFzZ0ZFRUJhaUVCREFvTElCUkJBV29oQVF6TkFRdEJBQ0VRSUFCQkFEWUNIQ0FBUVp1U2dJQUFOZ0lRSUFCQkJ6WUNEQ0FBSUJSQkFXbzJBaFFNOWdJTEFrQURRQUpBSUFFdEFBQkI4TWlBZ0FCcUxRQUFJaEJCQkVZTkFBSkFBa0FnRUVGL2FnNEgwZ0hUQWRRQjJRRUFCQUhaQVFzZ0FTRUJRZG9BSVJBTTRBSUxJQUZCQVdvaEFVSGNBQ0VRRE44Q0N5QUJRUUZxSWdFZ0FrY05BQXRCN3dBaEVBejJBZ3NnQVVFQmFpRUJETXNCQ3dKQUlBRWlGQ0FDUncwQVFmQUFJUkFNOVFJTElCUXRBQUJCTDBjTjFBRWdGRUVCYWlFQkRBWUxBa0FnQVNJVUlBSkhEUUJCOFFBaEVBejBBZ3NDUUNBVUxRQUFJZ0ZCTDBjTkFDQVVRUUZxSVFGQjNRQWhFQXpiQWdzZ0FVRjJhaUlFUVJaTERkTUJRUUVnQkhSQmlZQ0FBbkZGRGRNQkRNb0NDd0pBSUFFaUFTQUNSZzBBSUFGQkFXb2hBVUhlQUNFUUROb0NDMEh5QUNFUURQSUNDd0pBSUFFaUZDQUNSdzBBUWZRQUlSQU04Z0lMSUJRaEFRSkFJQlF0QUFCQjhNeUFnQUJxTFFBQVFYOXFEZ1BKQXBRQ0FOUUJDMEhoQUNFUUROZ0NDd0pBSUFFaUZDQUNSZzBBQTBBQ1FDQVVMUUFBUWZES2dJQUFhaTBBQUNJQlFRTkdEUUFDUUNBQlFYOXFEZ0xMQWdEVkFRc2dGQ0VCUWQ4QUlSQU0yZ0lMSUJSQkFXb2lGQ0FDUncwQUMwSHpBQ0VRRFBFQ0MwSHpBQ0VRRFBBQ0N3SkFJQUVpQVNBQ1JnMEFJQUJCajRDQWdBQTJBZ2dnQUNBQk5nSUVJQUVoQVVIZ0FDRVFETmNDQzBIMUFDRVFETzhDQ3dKQUlBRWlBU0FDUncwQVFmWUFJUkFNN3dJTElBQkJqNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBUXRCQXlFUUROUUNDd05BSUFFdEFBQkJJRWNOd3dJZ0FVRUJhaUlCSUFKSERRQUxRZmNBSVJBTTdBSUxBa0FnQVNJQklBSkhEUUJCK0FBaEVBenNBZ3NnQVMwQUFFRWdSdzNPQVNBQlFRRnFJUUVNN3dFTElBQWdBU0lCSUFJUXJJQ0FnQUFpRUEzT0FTQUJJUUVNamdJTEFrQWdBU0lFSUFKSERRQkIrZ0FoRUF6cUFnc2dCQzBBQUVITUFFY04wUUVnQkVFQmFpRUJRUk1oRUF6UEFRc0NRQ0FCSWdRZ0FrY05BRUg3QUNFUURPa0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFWcUlSQURRQ0FFTFFBQUlBRkI4TTZBZ0FCcUxRQUFSdzNRQVNBQlFRVkdEYzRCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWZzQUlSQU02QUlMQWtBZ0FTSUVJQUpIRFFCQi9BQWhFQXpvQWdzQ1FBSkFJQVF0QUFCQnZYOXFEZ3dBMFFIUkFkRUIwUUhSQWRFQjBRSFJBZEVCMFFFQjBRRUxJQVJCQVdvaEFVSG1BQ0VRRE04Q0N5QUVRUUZxSVFGQjV3QWhFQXpPQWdzQ1FDQUJJZ1FnQWtjTkFFSDlBQ0VRRE9jQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEYzhCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUg5QUNFUURPY0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSQWhFQXpNQVFzQ1FDQUJJZ1FnQWtjTkFFSCtBQ0VRRE9ZQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSDJ6b0NBQUdvdEFBQkhEYzRCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUgrQUNFUURPWUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSWWhFQXpMQVFzQ1FDQUJJZ1FnQWtjTkFFSC9BQ0VRRE9VQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVSDh6b0NBQUdvdEFBQkhEYzBCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUgvQUNFUURPVUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRVWhFQXpLQVFzQ1FDQUJJZ1FnQWtjTkFFR0FBU0VRRE9RQ0N5QUVMUUFBUWRrQVJ3M0xBU0FFUVFGcUlRRkJDQ0VRRE1rQkN3SkFJQUVpQkNBQ1J3MEFRWUVCSVJBTTR3SUxBa0FDUUNBRUxRQUFRYkovYWc0REFNd0JBY3dCQ3lBRVFRRnFJUUZCNndBaEVBektBZ3NnQkVFQmFpRUJRZXdBSVJBTXlRSUxBa0FnQVNJRUlBSkhEUUJCZ2dFaEVBemlBZ3NDUUFKQUlBUXRBQUJCdUg5cURnZ0F5d0hMQWNzQnl3SExBY3NCQWNzQkN5QUVRUUZxSVFGQjZnQWhFQXpKQWdzZ0JFRUJhaUVCUWUwQUlSQU15QUlMQWtBZ0FTSUVJQUpIRFFCQmd3RWhFQXpoQWdzZ0FpQUVheUFBS0FJQUlnRnFJUkFnQkNBQmEwRUNhaUVVQWtBRFFDQUVMUUFBSUFGQmdNK0FnQUJxTFFBQVJ3M0pBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJBMkFnQkJnd0VoRUF6aEFndEJBQ0VRSUFCQkFEWUNBQ0FVUVFGcUlRRU14Z0VMQWtBZ0FTSUVJQUpIRFFCQmhBRWhFQXpnQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQmc4K0FnQUJxTFFBQVJ3M0lBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJoQUVoRUF6Z0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFaklSQU14UUVMQWtBZ0FTSUVJQUpIRFFCQmhRRWhFQXpmQWdzQ1FBSkFJQVF0QUFCQnRIOXFEZ2dBeUFISUFjZ0J5QUhJQWNnQkFjZ0JDeUFFUVFGcUlRRkI3d0FoRUF6R0Fnc2dCRUVCYWlFQlFmQUFJUkFNeFFJTEFrQWdBU0lFSUFKSERRQkJoZ0VoRUF6ZUFnc2dCQzBBQUVIRkFFY054UUVnQkVFQmFpRUJESU1DQ3dKQUlBRWlCQ0FDUncwQVFZY0JJUkFNM1FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFZalBnSUFBYWkwQUFFY054UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWWNCSVJBTTNRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkxTRVFETUlCQ3dKQUlBRWlCQ0FDUncwQVFZZ0JJUkFNM0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJDR29oRUFKQUEwQWdCQzBBQUNBQlFkRFBnSUFBYWkwQUFFY054QUVnQVVFSVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWWdCSVJBTTNBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQktTRVFETUVCQ3dKQUlBRWlBU0FDUncwQVFZa0JJUkFNMndJTFFRRWhFQ0FCTFFBQVFkOEFSdzNBQVNBQlFRRnFJUUVNZ1FJTEFrQWdBU0lFSUFKSERRQkJpZ0VoRUF6YUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUEwQWdCQzBBQUNBQlFZelBnSUFBYWkwQUFFY053UUVnQVVFQlJnMnZBaUFCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdLQVNFUUROa0NDd0pBSUFFaUJDQUNSdzBBUVlzQklSQU0yUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVk3UGdJQUFhaTBBQUVjTndRRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZc0JJUkFNMlFJTElBQkJBRFlDQUNBUVFRRnFJUUZCQWlFUURMNEJDd0pBSUFFaUJDQUNSdzBBUVl3QklSQU0yQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZEUGdJQUFhaTBBQUVjTndBRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZd0JJUkFNMkFJTElBQkJBRFlDQUNBUVFRRnFJUUZCSHlFUURMMEJDd0pBSUFFaUJDQUNSdzBBUVkwQklSQU0xd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTnZ3RWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZMEJJUkFNMXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQ1NFUURMd0JDd0pBSUFFaUJDQUNSdzBBUVk0QklSQU0xZ0lMQWtBQ1FDQUVMUUFBUWJkL2FnNEhBTDhCdndHL0FiOEJ2d0VCdndFTElBUkJBV29oQVVINEFDRVFETDBDQ3lBRVFRRnFJUUZCK1FBaEVBeThBZ3NDUUNBQklnUWdBa2NOQUVHUEFTRVFETlVDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHUno0Q0FBR290QUFCSERiMEJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1BBU0VRRE5VQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJnaEVBeTZBUXNDUUNBQklnUWdBa2NOQUVHUUFTRVFETlFDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVHWHo0Q0FBR290QUFCSERid0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1FBU0VRRE5RQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJjaEVBeTVBUXNDUUNBQklnUWdBa2NOQUVHUkFTRVFETk1DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRWnFJUkFDUUFOQUlBUXRBQUFnQVVHYXo0Q0FBR290QUFCSERic0JJQUZCQmtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1JBU0VRRE5NQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJVaEVBeTRBUXNDUUNBQklnUWdBa2NOQUVHU0FTRVFETklDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHaHo0Q0FBR290QUFCSERib0JJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1NBU0VRRE5JQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVI0aEVBeTNBUXNDUUNBQklnUWdBa2NOQUVHVEFTRVFETkVDQ3lBRUxRQUFRY3dBUncyNEFTQUVRUUZxSVFGQkNpRVFETFlCQ3dKQUlBUWdBa2NOQUVHVUFTRVFETkFDQ3dKQUFrQWdCQzBBQUVHL2Yyb09Ed0M1QWJrQnVRRzVBYmtCdVFHNUFia0J1UUc1QWJrQnVRRzVBUUc1QVFzZ0JFRUJhaUVCUWY0QUlSQU10d0lMSUFSQkFXb2hBVUgvQUNFUURMWUNDd0pBSUFRZ0FrY05BRUdWQVNFUURNOENDd0pBQWtBZ0JDMEFBRUcvZjJvT0F3QzRBUUc0QVFzZ0JFRUJhaUVCUWYwQUlSQU10Z0lMSUFSQkFXb2hCRUdBQVNFUURMVUNDd0pBSUFRZ0FrY05BRUdXQVNFUURNNENDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUduejRDQUFHb3RBQUJIRGJZQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHV0FTRVFETTRDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUXNoRUF5ekFRc0NRQ0FFSUFKSERRQkJsd0VoRUF6TkFnc0NRQUpBQWtBQ1FDQUVMUUFBUVZOcURpTUF1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBUUc0QWJnQnVBRzRBYmdCQXJnQnVBRzRBUU80QVFzZ0JFRUJhaUVCUWZzQUlSQU10Z0lMSUFSQkFXb2hBVUg4QUNFUURMVUNDeUFFUVFGcUlRUkJnUUVoRUF5MEFnc2dCRUVCYWlFRVFZSUJJUkFNc3dJTEFrQWdCQ0FDUncwQVFaZ0JJUkFNekFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCR29oRUFKQUEwQWdCQzBBQUNBQlFhblBnSUFBYWkwQUFFY050QUVnQVVFRVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWmdCSVJBTXpBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkdTRVFETEVCQ3dKQUlBUWdBa2NOQUVHWkFTRVFETXNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRVnFJUkFDUUFOQUlBUXRBQUFnQVVHdXo0Q0FBR290QUFCSERiTUJJQUZCQlVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR1pBU0VRRE1zQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVFZaEVBeXdBUXNDUUNBRUlBSkhEUUJCbWdFaEVBektBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdE0rQWdBQnFMUUFBUncyeUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm1nRWhFQXpLQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVjSVJBTXJ3RUxBa0FnQkNBQ1J3MEFRWnNCSVJBTXlRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYmJQZ0lBQWFpMEFBRWNOc1FFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpzQklSQU15UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJKeUVRREs0QkN3SkFJQVFnQWtjTkFFR2NBU0VRRE1nQ0N3SkFBa0FnQkMwQUFFR3NmMm9PQWdBQnNRRUxJQVJCQVdvaEJFR0dBU0VRREs4Q0N5QUVRUUZxSVFSQmh3RWhFQXl1QWdzQ1FDQUVJQUpIRFFCQm5RRWhFQXpIQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQnVNK0FnQUJxTFFBQVJ3MnZBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJuUUVoRUF6SEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFbUlSQU1yQUVMQWtBZ0JDQUNSdzBBUVo0QklSQU14Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWJyUGdJQUFhaTBBQUVjTnJnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaNEJJUkFNeGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQXlFUURLc0JDd0pBSUFRZ0FrY05BRUdmQVNFUURNVUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRGEwQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHZkFTRVFETVVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUXdoRUF5cUFRc0NRQ0FFSUFKSERRQkJvQUVoRUF6RUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVEYWlFUUFrQURRQ0FFTFFBQUlBRkJ2TStBZ0FCcUxRQUFSdzJzQVNBQlFRTkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCb0FFaEVBekVBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRU5JUkFNcVFFTEFrQWdCQ0FDUncwQVFhRUJJUkFNd3dJTEFrQUNRQ0FFTFFBQVFicC9hZzRMQUt3QnJBR3NBYXdCckFHc0Fhd0JyQUdzQVFHc0FRc2dCRUVCYWlFRVFZc0JJUkFNcWdJTElBUkJBV29oQkVHTUFTRVFES2tDQ3dKQUlBUWdBa2NOQUVHaUFTRVFETUlDQ3lBRUxRQUFRZEFBUncycEFTQUVRUUZxSVFRTTZRRUxBa0FnQkNBQ1J3MEFRYU1CSVJBTXdRSUxBa0FDUUNBRUxRQUFRYmQvYWc0SEFhb0JxZ0dxQWFvQnFnRUFxZ0VMSUFSQkFXb2hCRUdPQVNFUURLZ0NDeUFFUVFGcUlRRkJJaUVRREtZQkN3SkFJQVFnQWtjTkFFR2tBU0VRRE1BQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBQ1FBTkFJQVF0QUFBZ0FVSEF6NENBQUdvdEFBQkhEYWdCSUFGQkFVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdrQVNFUURNQUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFSMGhFQXlsQVFzQ1FDQUVJQUpIRFFCQnBRRWhFQXkvQWdzQ1FBSkFJQVF0QUFCQnJuOXFEZ01BcUFFQnFBRUxJQVJCQVdvaEJFR1FBU0VRREtZQ0N5QUVRUUZxSVFGQkJDRVFES1FCQ3dKQUlBUWdBa2NOQUVHbUFTRVFETDRDQ3dKQUFrQUNRQUpBQWtBZ0JDMEFBRUcvZjJvT0ZRQ3FBYW9CcWdHcUFhb0JxZ0dxQWFvQnFnR3FBUUdxQWFvQkFxb0JxZ0VEcWdHcUFRU3FBUXNnQkVFQmFpRUVRWWdCSVJBTXFBSUxJQVJCQVdvaEJFR0pBU0VRREtjQ0N5QUVRUUZxSVFSQmlnRWhFQXltQWdzZ0JFRUJhaUVFUVk4QklSQU1wUUlMSUFSQkFXb2hCRUdSQVNFUURLUUNDd0pBSUFRZ0FrY05BRUduQVNFUURMMENDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUh0ejRDQUFHb3RBQUJIRGFVQklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHbkFTRVFETDBDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUkVoRUF5aUFRc0NRQ0FFSUFKSERRQkJxQUVoRUF5OEFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkJ3cytBZ0FCcUxRQUFSdzJrQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcUFFaEVBeThBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXNJUkFNb1FFTEFrQWdCQ0FDUncwQVFha0JJUkFNdXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCR29oRUFKQUEwQWdCQzBBQUNBQlFjWFBnSUFBYWkwQUFFY05vd0VnQVVFRVJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYWtCSVJBTXV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkt5RVFES0FCQ3dKQUlBUWdBa2NOQUVHcUFTRVFETG9DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRSnFJUkFDUUFOQUlBUXRBQUFnQVVIS3o0Q0FBR290QUFCSERhSUJJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR3FBU0VRRExvQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVJRaEVBeWZBUXNDUUNBRUlBSkhEUUJCcXdFaEVBeTVBZ3NDUUFKQUFrQUNRQ0FFTFFBQVFiNS9hZzRQQUFFQ3BBR2tBYVFCcEFHa0FhUUJwQUdrQWFRQnBBR2tBUU9rQVFzZ0JFRUJhaUVFUVpNQklSQU1vZ0lMSUFSQkFXb2hCRUdVQVNFUURLRUNDeUFFUVFGcUlRUkJsUUVoRUF5Z0Fnc2dCRUVCYWlFRVFaWUJJUkFNbndJTEFrQWdCQ0FDUncwQVFhd0JJUkFNdUFJTElBUXRBQUJCeFFCSERaOEJJQVJCQVdvaEJBemdBUXNDUUNBRUlBSkhEUUJCclFFaEVBeTNBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCemMrQWdBQnFMUUFBUncyZkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnJRRWhFQXkzQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVPSVJBTW5BRUxBa0FnQkNBQ1J3MEFRYTRCSVJBTXRnSUxJQVF0QUFCQjBBQkhEWjBCSUFSQkFXb2hBVUVsSVJBTW13RUxBa0FnQkNBQ1J3MEFRYThCSVJBTXRRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQ0dvaEVBSkFBMEFnQkMwQUFDQUJRZERQZ0lBQWFpMEFBRWNOblFFZ0FVRUlSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWE4QklSQU10UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJLaUVRREpvQkN3SkFJQVFnQWtjTkFFR3dBU0VRRExRQ0N3SkFBa0FnQkMwQUFFR3JmMm9PQ3dDZEFaMEJuUUdkQVowQm5RR2RBWjBCblFFQm5RRUxJQVJCQVdvaEJFR2FBU0VRREpzQ0N5QUVRUUZxSVFSQm13RWhFQXlhQWdzQ1FDQUVJQUpIRFFCQnNRRWhFQXl6QWdzQ1FBSkFJQVF0QUFCQnYzOXFEaFFBbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCQVp3QkN5QUVRUUZxSVFSQm1RRWhFQXlhQWdzZ0JFRUJhaUVFUVp3QklSQU1tUUlMQWtBZ0JDQUNSdzBBUWJJQklSQU1zZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkEyb2hFQUpBQTBBZ0JDMEFBQ0FCUWRuUGdJQUFhaTBBQUVjTm1nRWdBVUVEUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFiSUJJUkFNc2dJTElBQkJBRFlDQUNBUVFRRnFJUUZCSVNFUURKY0JDd0pBSUFRZ0FrY05BRUd6QVNFUURMRUNDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFacUlSQUNRQU5BSUFRdEFBQWdBVUhkejRDQUFHb3RBQUJIRFprQklBRkJCa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHekFTRVFETEVDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUm9oRUF5V0FRc0NRQ0FFSUFKSERRQkJ0QUVoRUF5d0Fnc0NRQUpBQWtBZ0JDMEFBRUc3ZjJvT0VRQ2FBWm9CbWdHYUFab0JtZ0dhQVpvQm1nRUJtZ0dhQVpvQm1nR2FBUUthQVFzZ0JFRUJhaUVFUVowQklSQU1tQUlMSUFSQkFXb2hCRUdlQVNFUURKY0NDeUFFUVFGcUlRUkJud0VoRUF5V0Fnc0NRQ0FFSUFKSERRQkJ0UUVoRUF5dkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVGYWlFUUFrQURRQ0FFTFFBQUlBRkI1TStBZ0FCcUxRQUFSdzJYQVNBQlFRVkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdFFFaEVBeXZBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW9JUkFNbEFFTEFrQWdCQ0FDUncwQVFiWUJJUkFNcmdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlclBnSUFBYWkwQUFFY05sZ0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYllCSVJBTXJnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJ5RVFESk1CQ3dKQUlBUWdBa2NOQUVHM0FTRVFESzBDQ3dKQUFrQWdCQzBBQUVHN2Yyb09EZ0NXQVpZQmxnR1dBWllCbGdHV0FaWUJsZ0dXQVpZQmxnRUJsZ0VMSUFSQkFXb2hCRUdoQVNFUURKUUNDeUFFUVFGcUlRUkJvZ0VoRUF5VEFnc0NRQ0FFSUFKSERRQkJ1QUVoRUF5c0Fnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVDYWlFUUFrQURRQ0FFTFFBQUlBRkI3YytBZ0FCcUxRQUFSdzJVQVNBQlFRSkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCdUFFaEVBeXNBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRVNJUkFNa1FFTEFrQWdCQ0FDUncwQVFia0JJUkFNcXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFmRFBnSUFBYWkwQUFFY05rd0VnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYmtCSVJBTXF3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQklDRVFESkFCQ3dKQUlBUWdBa2NOQUVHNkFTRVFES29DQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVIeXo0Q0FBR290QUFCSERaSUJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFRzZBU0VRREtvQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVE4aEVBeVBBUXNDUUNBRUlBSkhEUUJCdXdFaEVBeXBBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0FrZ0dTQVpJQmtnR1NBUUdTQVFzZ0JFRUJhaUVFUWFVQklSQU1rQUlMSUFSQkFXb2hCRUdtQVNFUURJOENDd0pBSUFRZ0FrY05BRUc4QVNFUURLZ0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFkcUlSQUNRQU5BSUFRdEFBQWdBVUgwejRDQUFHb3RBQUJIRFpBQklBRkJCMFlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHOEFTRVFES2dDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUnNoRUF5TkFRc0NRQ0FFSUFKSERRQkJ2UUVoRUF5bkFnc0NRQUpBQWtBZ0JDMEFBRUcrZjJvT0VnQ1JBWkVCa1FHUkFaRUJrUUdSQVpFQmtRRUJrUUdSQVpFQmtRR1JBWkVCQXBFQkN5QUVRUUZxSVFSQnBBRWhFQXlQQWdzZ0JFRUJhaUVFUWFjQklSQU1qZ0lMSUFSQkFXb2hCRUdvQVNFUURJMENDd0pBSUFRZ0FrY05BRUcrQVNFUURLWUNDeUFFTFFBQVFjNEFSdzJOQVNBRVFRRnFJUVFNendFTEFrQWdCQ0FDUncwQVFiOEJJUkFNcFFJTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQkMwQUFFRy9mMm9PRlFBQkFnT2NBUVFGQnB3Qm5BR2NBUWNJQ1FvTG5BRU1EUTRQbkFFTElBUkJBV29oQVVIb0FDRVFESm9DQ3lBRVFRRnFJUUZCNlFBaEVBeVpBZ3NnQkVFQmFpRUJRZTRBSVJBTW1BSUxJQVJCQVdvaEFVSHlBQ0VRREpjQ0N5QUVRUUZxSVFGQjh3QWhFQXlXQWdzZ0JFRUJhaUVCUWZZQUlSQU1sUUlMSUFSQkFXb2hBVUgzQUNFUURKUUNDeUFFUVFGcUlRRkIrZ0FoRUF5VEFnc2dCRUVCYWlFRVFZTUJJUkFNa2dJTElBUkJBV29oQkVHRUFTRVFESkVDQ3lBRVFRRnFJUVJCaFFFaEVBeVFBZ3NnQkVFQmFpRUVRWklCSVJBTWp3SUxJQVJCQVdvaEJFR1lBU0VRREk0Q0N5QUVRUUZxSVFSQm9BRWhFQXlOQWdzZ0JFRUJhaUVFUWFNQklSQU1qQUlMSUFSQkFXb2hCRUdxQVNFUURJc0NDd0pBSUFRZ0FrWU5BQ0FBUVpDQWdJQUFOZ0lJSUFBZ0JEWUNCRUdyQVNFUURJc0NDMEhBQVNFUURLTUNDeUFBSUFVZ0FoQ3FnSUNBQUNJQkRZc0JJQVVoQVF4Y0N3SkFJQVlnQWtZTkFDQUdRUUZxSVFVTWpRRUxRY0lCSVJBTW9RSUxBMEFDUUNBUUxRQUFRWFpxRGdTTUFRQUFqd0VBQ3lBUVFRRnFJaEFnQWtjTkFBdEJ3d0VoRUF5Z0Fnc0NRQ0FISUFKR0RRQWdBRUdSZ0lDQUFEWUNDQ0FBSUFjMkFnUWdCeUVCUVFFaEVBeUhBZ3RCeEFFaEVBeWZBZ3NDUUNBSElBSkhEUUJCeFFFaEVBeWZBZ3NDUUFKQUlBY3RBQUJCZG1vT0JBSE9BYzRCQU00QkN5QUhRUUZxSVFZTWpRRUxJQWRCQVdvaEJReUpBUXNDUUNBSElBSkhEUUJCeGdFaEVBeWVBZ3NDUUFKQUlBY3RBQUJCZG1vT0Z3R1BBWThCQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVFDUEFRc2dCMEVCYWlFSEMwR3dBU0VRRElRQ0N3SkFJQWdnQWtjTkFFSElBU0VRREowQ0N5QUlMUUFBUVNCSERZMEJJQUJCQURzQk1pQUlRUUZxSVFGQnN3RWhFQXlEQWdzZ0FTRVhBa0FEUUNBWElnY2dBa1lOQVNBSExRQUFRVkJxUWY4QmNTSVFRUXBQRGN3QkFrQWdBQzhCTWlJVVFaa3pTdzBBSUFBZ0ZFRUtiQ0lVT3dFeUlCQkIvLzhEY3lBVVFmNy9BM0ZKRFFBZ0IwRUJhaUVYSUFBZ0ZDQVFhaUlRT3dFeUlCQkIvLzhEY1VIb0Iwa05BUXNMUVFBaEVDQUFRUUEyQWh3Z0FFSEJpWUNBQURZQ0VDQUFRUTAyQWd3Z0FDQUhRUUZxTmdJVURKd0NDMEhIQVNFUURKc0NDeUFBSUFnZ0FoQ3VnSUNBQUNJUVJRM0tBU0FRUVJWSERZd0JJQUJCeUFFMkFod2dBQ0FJTmdJVUlBQkJ5WmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXlhQWdzQ1FDQUpJQUpIRFFCQnpBRWhFQXlhQWd0QkFDRVVRUUVoRjBFQklSWkJBQ0VRQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFrdEFBQkJVR29PQ3BZQmxRRUFBUUlEQkFVR0NKY0JDMEVDSVJBTUJndEJBeUVRREFVTFFRUWhFQXdFQzBFRklSQU1Bd3RCQmlFUURBSUxRUWNoRUF3QkMwRUlJUkFMUVFBaEYwRUFJUlpCQUNFVURJNEJDMEVKSVJCQkFTRVVRUUFoRjBFQUlSWU1qUUVMQWtBZ0NpQUNSdzBBUWM0QklSQU1tUUlMSUFvdEFBQkJMa2NOamdFZ0NrRUJhaUVKRE1vQkN5QUxJQUpIRFk0QlFkQUJJUkFNbHdJTEFrQWdDeUFDUmcwQUlBQkJqb0NBZ0FBMkFnZ2dBQ0FMTmdJRVFiY0JJUkFNL2dFTFFkRUJJUkFNbGdJTEFrQWdCQ0FDUncwQVFkSUJJUkFNbGdJTElBSWdCR3NnQUNnQ0FDSVFhaUVVSUFRZ0VHdEJCR29oQ3dOQUlBUXRBQUFnRUVIOHo0Q0FBR290QUFCSERZNEJJQkJCQkVZTjZRRWdFRUVCYWlFUUlBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkIwZ0VoRUF5VkFnc2dBQ0FNSUFJUXJJQ0FnQUFpQVEyTkFTQU1JUUVNdUFFTEFrQWdCQ0FDUncwQVFkUUJJUkFNbEFJTElBSWdCR3NnQUNnQ0FDSVFhaUVVSUFRZ0VHdEJBV29oREFOQUlBUXRBQUFnRUVHQjBJQ0FBR290QUFCSERZOEJJQkJCQVVZTmpnRWdFRUVCYWlFUUlBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkIxQUVoRUF5VEFnc0NRQ0FFSUFKSERRQkIxZ0VoRUF5VEFnc2dBaUFFYXlBQUtBSUFJaEJxSVJRZ0JDQVFhMEVDYWlFTEEwQWdCQzBBQUNBUVFZUFFnSUFBYWkwQUFFY05qZ0VnRUVFQ1JnMlFBU0FRUVFGcUlSQWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUhXQVNFUURKSUNDd0pBSUFRZ0FrY05BRUhYQVNFUURKSUNDd0pBQWtBZ0JDMEFBRUc3ZjJvT0VBQ1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJBWThCQ3lBRVFRRnFJUVJCdXdFaEVBejVBUXNnQkVFQmFpRUVRYndCSVJBTStBRUxBa0FnQkNBQ1J3MEFRZGdCSVJBTWtRSUxJQVF0QUFCQnlBQkhEWXdCSUFSQkFXb2hCQXpFQVFzQ1FDQUVJQUpHRFFBZ0FFR1FnSUNBQURZQ0NDQUFJQVEyQWdSQnZnRWhFQXozQVF0QjJRRWhFQXlQQWdzQ1FDQUVJQUpIRFFCQjJnRWhFQXlQQWdzZ0JDMEFBRUhJQUVZTnd3RWdBRUVCT2dBb0RMa0JDeUFBUVFJNkFDOGdBQ0FFSUFJUXBvQ0FnQUFpRUEyTkFVSENBU0VRRFBRQkN5QUFMUUFvUVg5cURnSzNBYmtCdUFFTEEwQUNRQ0FFTFFBQVFYWnFEZ1FBamdHT0FRQ09BUXNnQkVFQmFpSUVJQUpIRFFBTFFkMEJJUkFNaXdJTElBQkJBRG9BTHlBQUxRQXRRUVJ4UlEyRUFnc2dBRUVBT2dBdklBQkJBVG9BTkNBQklRRU1qQUVMSUJCQkZVWU4yZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYWVPZ0lBQU5nSVFJQUJCRWpZQ0RFRUFJUkFNaUFJTEFrQWdBQ0FRSUFJUXRJQ0FnQUFpQkEwQUlCQWhBUXlCQWdzQ1FDQUVRUlZIRFFBZ0FFRUROZ0ljSUFBZ0VEWUNGQ0FBUWJDWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTWlBSUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR25qb0NBQURZQ0VDQUFRUkkyQWd4QkFDRVFESWNDQ3lBUVFSVkdEZFlCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUhhallDQUFEWUNFQ0FBUVJRMkFneEJBQ0VRRElZQ0N5QUFLQUlFSVJjZ0FFRUFOZ0lFSUJBZ0VhZHFJaFloQVNBQUlCY2dFQ0FXSUJRYkloQVF0WUNBZ0FBaUZFVU5qUUVnQUVFSE5nSWNJQUFnRURZQ0ZDQUFJQlEyQWd4QkFDRVFESVVDQ3lBQUlBQXZBVEJCZ0FGeU93RXdJQUVoQVF0QktpRVFET29CQ3lBUVFSVkdEZEVCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdEaklDQUFEWUNFQ0FBUVJNMkFneEJBQ0VRRElJQ0N5QVFRUlZHRGM4QklBQkJBRFlDSENBQUlBRTJBaFFnQUVHYWo0Q0FBRFlDRUNBQVFTSTJBZ3hCQUNFUURJRUNDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXQ0Q0FnQUFpRUEwQUlBRkJBV29oQVF5TkFRc2dBRUVNTmdJY0lBQWdFRFlDRENBQUlBRkJBV28yQWhSQkFDRVFESUFDQ3lBUVFSVkdEY3dCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdhajRDQUFEWUNFQ0FBUVNJMkFneEJBQ0VRRFA4QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRdDRDQWdBQWlFQTBBSUFGQkFXb2hBUXlNQVFzZ0FFRU5OZ0ljSUFBZ0VEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQNEJDeUFRUVJWR0Rja0JJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUDBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF1WUNBZ0FBaUVBMEFJQUZCQVdvaEFReUxBUXNnQUVFT05nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFB3QkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQndKV0FnQUEyQWhBZ0FFRUNOZ0lNUVFBaEVBejdBUXNnRUVFVlJnM0ZBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4b3lBZ0FBMkFoQWdBRUVqTmdJTVFRQWhFQXo2QVFzZ0FFRVFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRFBrQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdVlDQWdBQWlCQTBBSUFGQkFXb2hBUXp4QVFzZ0FFRVJOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQZ0JDeUFRUVJWR0RjRUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUGNCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF1WUNBZ0FBaUVBMEFJQUZCQVdvaEFReUlBUXNnQUVFVE5nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBZQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdVlDQWdBQWlCQTBBSUFGQkFXb2hBUXp0QVFzZ0FFRVVOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQVUJDeUFRUVJWR0RiMEJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR2FqNENBQURZQ0VDQUFRU0kyQWd4QkFDRVFEUFFCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVF0NENBZ0FBaUVBMEFJQUZCQVdvaEFReUdBUXNnQUVFV05nSWNJQUFnRURZQ0RDQUFJQUZCQVdvMkFoUkJBQ0VRRFBNQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRdDRDQWdBQWlCQTBBSUFGQkFXb2hBUXpwQVFzZ0FFRVhOZ0ljSUFBZ0JEWUNEQ0FBSUFGQkFXbzJBaFJCQUNFUURQSUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ6Wk9BZ0FBMkFoQWdBRUVNTmdJTVFRQWhFQXp4QVF0Q0FTRVJDeUFRUVFGcUlRRUNRQ0FBS1FNZ0loSkMvLy8vLy8vLy8vOFBWZzBBSUFBZ0VrSUVoaUFSaERjRElDQUJJUUVNaEFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHdGlZQ0FBRFlDRUNBQVFRdzJBZ3hCQUNFUURPOEJDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJ6Wk9BZ0FBMkFoQWdBRUVNTmdJTVFRQWhFQXp1QVFzZ0FDZ0NCQ0VYSUFCQkFEWUNCQ0FRSUJHbmFpSVdJUUVnQUNBWElCQWdGaUFVR3lJUUVMV0FnSUFBSWhSRkRYTWdBRUVGTmdJY0lBQWdFRFlDRkNBQUlCUTJBZ3hCQUNFUURPMEJDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJxcHlBZ0FBMkFoQWdBRUVQTmdJTVFRQWhFQXpzQVFzZ0FDQVFJQUlRdElDQWdBQWlBUTBCSUJBaEFRdEJEaUVRRE5FQkN3SkFJQUZCRlVjTkFDQUFRUUkyQWh3Z0FDQVFOZ0lVSUFCQnNKaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenFBUXNnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRYWVPZ0lBQU5nSVFJQUJCRWpZQ0RFRUFJUkFNNlFFTElBRkJBV29oRUFKQUlBQXZBVEFpQVVHQUFYRkZEUUFDUUNBQUlCQWdBaEM3Z0lDQUFDSUJEUUFnRUNFQkRIQUxJQUZCRlVjTnVnRWdBRUVGTmdJY0lBQWdFRFlDRkNBQVFmbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU02UUVMQWtBZ0FVR2dCSEZCb0FSSERRQWdBQzBBTFVFQ2NRMEFJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR1drNENBQURZQ0VDQUFRUVEyQWd4QkFDRVFET2tCQ3lBQUlCQWdBaEM5Z0lDQUFCb2dFQ0VCQWtBQ1FBSkFBa0FDUUNBQUlCQWdBaEN6Z0lDQUFBNFdBZ0VBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQXdRTElBQkJBVG9BTGdzZ0FDQUFMd0V3UWNBQWNqc0JNQ0FRSVFFTFFTWWhFQXpSQVFzZ0FFRWpOZ0ljSUFBZ0VEWUNGQ0FBUWFXV2dJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTTZRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSFZpNENBQURZQ0VDQUFRUkUyQWd4QkFDRVFET2dCQ3lBQUxRQXRRUUZ4UlEwQlFjTUJJUkFNemdFTEFrQWdEU0FDUmcwQUEwQUNRQ0FOTFFBQVFTQkdEUUFnRFNFQkRNUUJDeUFOUVFGcUlnMGdBa2NOQUF0QkpTRVFET2NCQzBFbElSQU01Z0VMSUFBb0FnUWhCQ0FBUVFBMkFnUWdBQ0FFSUEwUXI0Q0FnQUFpQkVVTnJRRWdBRUVtTmdJY0lBQWdCRFlDRENBQUlBMUJBV28yQWhSQkFDRVFET1VCQ3lBUVFSVkdEYXNCSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUg5allDQUFEWUNFQ0FBUVIwMkFneEJBQ0VRRE9RQkN5QUFRU2MyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTTR3RUxJQkFoQVVFQklSUUNRQUpBQWtBQ1FBSkFBa0FDUUNBQUxRQXNRWDVxRGdjR0JRVURBUUlBQlFzZ0FDQUFMd0V3UVFoeU93RXdEQU1MUVFJaEZBd0JDMEVFSVJRTElBQkJBVG9BTENBQUlBQXZBVEFnRkhJN0FUQUxJQkFoQVF0Qkt5RVFETW9CQ3lBQVFRQTJBaHdnQUNBUU5nSVVJQUJCcTVLQWdBQTJBaEFnQUVFTE5nSU1RUUFoRUF6aUFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFlR1BnSUFBTmdJUUlBQkJDallDREVFQUlSQU00UUVMSUFCQkFEb0FMQ0FRSVFFTXZRRUxJQkFoQVVFQklSUUNRQUpBQWtBQ1FBSkFJQUF0QUN4QmUyb09CQU1CQWdBRkN5QUFJQUF2QVRCQkNISTdBVEFNQXd0QkFpRVVEQUVMUVFRaEZBc2dBRUVCT2dBc0lBQWdBQzhCTUNBVWNqc0JNQXNnRUNFQkMwRXBJUkFNeFFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVId2xJQ0FBRFlDRUNBQVFRTTJBZ3hCQUNFUUROMEJDd0pBSUE0dEFBQkJEVWNOQUNBQUtBSUVJUUVnQUVFQU5nSUVBa0FnQUNBQklBNFFzWUNBZ0FBaUFRMEFJQTVCQVdvaEFReDFDeUFBUVN3MkFod2dBQ0FCTmdJTUlBQWdEa0VCYWpZQ0ZFRUFJUkFNM1FFTElBQXRBQzFCQVhGRkRRRkJ4QUVoRUF6REFRc0NRQ0FPSUFKSERRQkJMU0VRRE53QkN3SkFBa0FEUUFKQUlBNHRBQUJCZG1vT0JBSUFBQU1BQ3lBT1FRRnFJZzRnQWtjTkFBdEJMU0VRRE4wQkN5QUFLQUlFSVFFZ0FFRUFOZ0lFQWtBZ0FDQUJJQTRRc1lDQWdBQWlBUTBBSUE0aEFReDBDeUFBUVN3MkFod2dBQ0FPTmdJVUlBQWdBVFlDREVFQUlSQU0zQUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRITUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpiQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0RoQ3hnSUNBQUNJRURhQUJJQTRoQVF6T0FRc2dFRUVzUncwQklBRkJBV29oRUVFQklRRUNRQUpBQWtBQ1FBSkFJQUF0QUN4QmUyb09CQU1CQWdRQUN5QVFJUUVNQkF0QkFpRUJEQUVMUVFRaEFRc2dBRUVCT2dBc0lBQWdBQzhCTUNBQmNqc0JNQ0FRSVFFTUFRc2dBQ0FBTHdFd1FRaHlPd0V3SUJBaEFRdEJPU0VRREw4QkN5QUFRUUE2QUN3Z0FTRUJDMEUwSVJBTXZRRUxJQUFnQUM4Qk1FRWdjanNCTUNBQklRRU1BZ3NnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVMR0FnSUFBSWdRTkFDQUJJUUVNeHdFTElBQkJOellDSENBQUlBRTJBaFFnQUNBRU5nSU1RUUFoRUF6VUFRc2dBRUVJT2dBc0lBRWhBUXRCTUNFUURMa0JDd0pBSUFBdEFDaEJBVVlOQUNBQklRRU1CQXNnQUMwQUxVRUljVVVOa3dFZ0FTRUJEQU1MSUFBdEFEQkJJSEVObEFGQnhRRWhFQXkzQVFzQ1FDQVBJQUpHRFFBQ1FBTkFBa0FnRHkwQUFFRlFhaUlCUWY4QmNVRUtTUTBBSUE4aEFVRTFJUkFNdWdFTElBQXBBeUFpRVVLWnMrYk1tYlBtekJsV0RRRWdBQ0FSUWdwK0loRTNBeUFnRVNBQnJVTC9BWU1pRWtKL2hWWU5BU0FBSUJFZ0VudzNBeUFnRDBFQmFpSVBJQUpIRFFBTFFUa2hFQXpSQVFzZ0FDZ0NCQ0VDSUFCQkFEWUNCQ0FBSUFJZ0QwRUJhaUlFRUxHQWdJQUFJZ0lObFFFZ0JDRUJETU1CQzBFNUlSQU16d0VMQWtBZ0FDOEJNQ0lCUVFoeFJRMEFJQUF0QUNoQkFVY05BQ0FBTFFBdFFRaHhSUTJRQVFzZ0FDQUJRZmY3QTNGQmdBUnlPd0V3SUE4aEFRdEJOeUVRRExRQkN5QUFJQUF2QVRCQkVISTdBVEFNcXdFTElCQkJGVVlOaXdFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDT2dJQUFOZ0lRSUFCQkhEWUNERUVBSVJBTXl3RUxJQUJCd3dBMkFod2dBQ0FCTmdJTUlBQWdEVUVCYWpZQ0ZFRUFJUkFNeWdFTEFrQWdBUzBBQUVFNlJ3MEFJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDdmdJQ0FBQ0lRRFFBZ0FVRUJhaUVCREdNTElBQkJ3d0EyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU15Z0VMSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUd4a1lDQUFEWUNFQ0FBUVFvMkFneEJBQ0VRRE1rQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQm9KbUFnQUEyQWhBZ0FFRWVOZ0lNUVFBaEVBeklBUXNnQUVFQU5nSUFDeUFBUVlBU093RXFJQUFnRjBFQmFpSUJJQUlRcUlDQWdBQWlFQTBCSUFFaEFRdEJ4d0FoRUF5c0FRc2dFRUVWUncyREFTQUFRZEVBTmdJY0lBQWdBVFlDRkNBQVFlT1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU14QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREY0TElBQkIwZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXd3RUxJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFSEJxSUNBQURZQ0VDQUFRUWMyQWd3Z0FFRUFOZ0lBUVFBaEVBekNBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWFFzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6QkFRdEJBQ0VRSUFCQkFEWUNIQ0FBSUFFMkFoUWdBRUdBa1lDQUFEWUNFQ0FBUVFrMkFnd013QUVMSUJCQkZVWU5mU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsSTJBZ0FBMkFoQWdBRUVoTmdJTVFRQWhFQXkvQVF0QkFTRVdRUUFoRjBFQUlSUkJBU0VRQ3lBQUlCQTZBQ3NnQVVFQmFpRUJBa0FDUUNBQUxRQXRRUkJ4RFFBQ1FBSkFBa0FnQUMwQUtnNERBUUFDQkFzZ0ZrVU5Bd3dDQ3lBVURRRU1BZ3NnRjBVTkFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsyQWdJQUFJaEFOQUNBQklRRU1YQXNnQUVIWUFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXkrQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQUpBSUFBZ0JDQUJFSzJBZ0lBQUlnUU5BQ0FCSVFFTXJRRUxJQUJCMlFBMkFod2dBQ0FCTmdJVUlBQWdCRFlDREVFQUlSQU12UUVMSUFBb0FnUWhCQ0FBUVFBMkFnUUNRQ0FBSUFRZ0FSQ3RnSUNBQUNJRURRQWdBU0VCREtzQkN5QUFRZG9BTmdJY0lBQWdBVFlDRkNBQUlBUTJBZ3hCQUNFUURMd0JDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXJZQ0FnQUFpQkEwQUlBRWhBUXlwQVFzZ0FFSGNBRFlDSENBQUlBRTJBaFFnQUNBRU5nSU1RUUFoRUF5N0FRc0NRQ0FCTFFBQVFWQnFJaEJCL3dGeFFRcFBEUUFnQUNBUU9nQXFJQUZCQVdvaEFVSFBBQ0VRREtJQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFQWtBZ0FDQUVJQUVRcllDQWdBQWlCQTBBSUFFaEFReW5BUXNnQUVIZUFEWUNIQ0FBSUFFMkFoUWdBQ0FFTmdJTVFRQWhFQXk2QVFzZ0FFRUFOZ0lBSUJkQkFXb2hBUUpBSUFBdEFDbEJJMDhOQUNBQklRRU1XUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZE9KZ0lBQU5nSVFJQUJCQ0RZQ0RFRUFJUkFNdVFFTElBQkJBRFlDQUF0QkFDRVFJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1FzNENBQURZQ0VDQUFRUWcyQWd3TXR3RUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwUVNGSERRQWdBU0VCREZZTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHYmlvQ0FBRFlDRUNBQVFRZzJBZ3hCQUNFUURMWUJDeUFBUVFBMkFnQWdGMEVCYWlFQkFrQWdBQzBBS1NJUVFWMXFRUXRQRFFBZ0FTRUJERlVMQWtBZ0VFRUdTdzBBUVFFZ0VIUkJ5Z0J4UlEwQUlBRWhBUXhWQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmZUpnSUFBTmdJUUlBQkJDRFlDREF5MUFRc2dFRUVWUmcxeElBQkJBRFlDSENBQUlBRTJBaFFnQUVHNWpZQ0FBRFlDRUNBQVFSbzJBZ3hCQUNFUURMUUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhVQ3lBQVFlVUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExNQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReE5DeUFBUWRJQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETElCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZE1BTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURMRUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhSQ3lBQVFlVUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRExBQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQnhvcUFnQUEyQWhBZ0FFRUhOZ0lNUVFBaEVBeXZBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNU1FzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5dUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1TUXNnQUVIVEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXl0QVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVRRc2dBRUhsQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeXNBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHlJZ0lBQU5nSVFJQUJCQnpZQ0RFRUFJUkFNcXdFTElCQkJQMGNOQVNBQlFRRnFJUUVMUVFVaEVBeVFBUXRCQUNFUUlBQkJBRFlDSENBQUlBRTJBaFFnQUVIOWtvQ0FBRFlDRUNBQVFRYzJBZ3dNcUFFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFSUxJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1wd0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREVJTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXBnRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERVlMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNcFFFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdGQkNuZ0lDQUFDSUJEUUFnRkNFQkREOExJQUJCMGdBMkFod2dBQ0FVTmdJVUlBQWdBVFlDREVFQUlSQU1wQUVMSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0ZCQ25nSUNBQUNJQkRRQWdGQ0VCREQ4TElBQkIwd0EyQWh3Z0FDQVVOZ0lVSUFBZ0FUWUNERUVBSVJBTW93RUxJQUFvQWdRaEFTQUFRUUEyQWdRQ1FDQUFJQUVnRkJDbmdJQ0FBQ0lCRFFBZ0ZDRUJERU1MSUFCQjVRQTJBaHdnQUNBVU5nSVVJQUFnQVRZQ0RFRUFJUkFNb2dFTElBQkJBRFlDSENBQUlCUTJBaFFnQUVIRGo0Q0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLRUJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ3NCtBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlnQVF0QkFDRVFJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFR01uSUNBQURZQ0VDQUFRUWMyQWd3TW53RUxJQUJCQURZQ0hDQUFJQlEyQWhRZ0FFR01uSUNBQURZQ0VDQUFRUWMyQWd4QkFDRVFESjRCQ3lBQVFRQTJBaHdnQUNBVU5nSVVJQUJCL3BHQWdBQTJBaEFnQUVFSE5nSU1RUUFoRUF5ZEFRc2dBRUVBTmdJY0lBQWdBVFlDRkNBQVFZNmJnSUFBTmdJUUlBQkJCallDREVFQUlSQU1uQUVMSUJCQkZVWU5WeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ6STZBZ0FBMkFoQWdBRUVnTmdJTVFRQWhFQXliQVFzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVrSVJBTElBQWdFRG9BS1NBQUtBSUVJUkFnQUVFQU5nSUVJQUFnRUNBQkVLdUFnSUFBSWhBTlZDQUJJUUVNUGdzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFmR2JnSUFBTmdJUUlBQkJCallDREF5WEFRc2dBVUVWUmcxUUlBQkJBRFlDSENBQUlBVTJBaFFnQUVId2pJQ0FBRFlDRUNBQVFSczJBZ3hCQUNFUURKWUJDeUFBS0FJRUlRVWdBRUVBTmdJRUlBQWdCU0FRRUttQWdJQUFJZ1VOQVNBUVFRRnFJUVVMUWEwQklSQU1ld3NnQUVIQkFUWUNIQ0FBSUFVMkFnd2dBQ0FRUVFGcU5nSVVRUUFoRUF5VEFRc2dBQ2dDQkNFR0lBQkJBRFlDQkNBQUlBWWdFQkNwZ0lDQUFDSUdEUUVnRUVFQmFpRUdDMEd1QVNFUURIZ0xJQUJCd2dFMkFod2dBQ0FHTmdJTUlBQWdFRUVCYWpZQ0ZFRUFJUkFNa0FFTElBQkJBRFlDSENBQUlBYzJBaFFnQUVHWGk0Q0FBRFlDRUNBQVFRMDJBZ3hCQUNFUURJOEJDeUFBUVFBMkFod2dBQ0FJTmdJVUlBQkI0NUNBZ0FBMkFoQWdBRUVKTmdJTVFRQWhFQXlPQVFzZ0FFRUFOZ0ljSUFBZ0NEWUNGQ0FBUVpTTmdJQUFOZ0lRSUFCQklUWUNERUVBSVJBTWpRRUxRUUVoRmtFQUlSZEJBQ0VVUVFFaEVBc2dBQ0FRT2dBcklBbEJBV29oQ0FKQUFrQWdBQzBBTFVFUWNRMEFBa0FDUUFKQUlBQXRBQ29PQXdFQUFnUUxJQlpGRFFNTUFnc2dGQTBCREFJTElCZEZEUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFnUXJZQ0FnQUFpRUVVTlBTQUFRY2tCTmdJY0lBQWdDRFlDRkNBQUlCQTJBZ3hCQUNFUURJd0JDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FJRUsyQWdJQUFJZ1JGRFhZZ0FFSEtBVFlDSENBQUlBZzJBaFFnQUNBRU5nSU1RUUFoRUF5TEFRc2dBQ2dDQkNFRUlBQkJBRFlDQkNBQUlBUWdDUkN0Z0lDQUFDSUVSUTEwSUFCQnl3RTJBaHdnQUNBSk5nSVVJQUFnQkRZQ0RFRUFJUkFNaWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FnQUNBRUlBb1FyWUNBZ0FBaUJFVU5jaUFBUWMwQk5nSWNJQUFnQ2pZQ0ZDQUFJQVEyQWd4QkFDRVFESWtCQ3dKQUlBc3RBQUJCVUdvaUVFSC9BWEZCQ2s4TkFDQUFJQkE2QUNvZ0MwRUJhaUVLUWJZQklSQU1jQXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnQ3hDdGdJQ0FBQ0lFUlExd0lBQkJ6d0UyQWh3Z0FDQUxOZ0lVSUFBZ0JEWUNERUVBSVJBTWlBRUxJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFR1FzNENBQURZQ0VDQUFRUWcyQWd3Z0FFRUFOZ0lBUVFBaEVBeUhBUXNnQVVFVlJnMC9JQUJCQURZQ0hDQUFJQXcyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESVlCQ3lBQVFZRUVPd0VvSUFBb0FnUWhFQ0FBUWdBM0F3QWdBQ0FRSUF4QkFXb2lEQkNyZ0lDQUFDSVFSUTA0SUFCQjB3RTJBaHdnQUNBTU5nSVVJQUFnRURZQ0RFRUFJUkFNaFFFTElBQkJBRFlDQUF0QkFDRVFJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFSFltNENBQURZQ0VDQUFRUWcyQWd3TWd3RUxJQUFvQWdRaEVDQUFRZ0EzQXdBZ0FDQVFJQXRCQVdvaUN4Q3JnSUNBQUNJUURRRkJ4Z0VoRUF4cEN5QUFRUUk2QUNnTVZRc2dBRUhWQVRZQ0hDQUFJQXMyQWhRZ0FDQVFOZ0lNUVFBaEVBeUFBUXNnRUVFVlJnMDNJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFR2tqSUNBQURZQ0VDQUFRUkEyQWd4QkFDRVFESDhMSUFBdEFEUkJBVWNOTkNBQUlBUWdBaEM4Z0lDQUFDSVFSUTAwSUJCQkZVY05OU0FBUWR3Qk5nSWNJQUFnQkRZQ0ZDQUFRZFdXZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNZmd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU1mUXRCQUNFUURHTUxRUUloRUF4aUMwRU5JUkFNWVF0QkR5RVFER0FMUVNVaEVBeGZDMEVUSVJBTVhndEJGU0VRREYwTFFSWWhFQXhjQzBFWElSQU1Xd3RCR0NFUURGb0xRUmtoRUF4WkMwRWFJUkFNV0F0Qkd5RVFERmNMUVJ3aEVBeFdDMEVkSVJBTVZRdEJIeUVRREZRTFFTRWhFQXhUQzBFaklSQU1VZ3RCeGdBaEVBeFJDMEV1SVJBTVVBdEJMeUVRREU4TFFUc2hFQXhPQzBFOUlSQU1UUXRCeUFBaEVBeE1DMEhKQUNFUURFc0xRY3NBSVJBTVNndEJ6QUFoRUF4SkMwSE9BQ0VRREVnTFFkRUFJUkFNUnd0QjFRQWhFQXhHQzBIWUFDRVFERVVMUWRrQUlSQU1SQXRCMndBaEVBeERDMEhrQUNFUURFSUxRZVVBSVJBTVFRdEI4UUFoRUF4QUMwSDBBQ0VRREQ4TFFZMEJJUkFNUGd0Qmx3RWhFQXc5QzBHcEFTRVFERHdMUWF3QklSQU1Pd3RCd0FFaEVBdzZDMEc1QVNFUUREa0xRYThCSVJBTU9BdEJzUUVoRUF3M0MwR3lBU0VRRERZTFFiUUJJUkFNTlF0QnRRRWhFQXcwQzBHNkFTRVFERE1MUWIwQklSQU1NZ3RCdndFaEVBd3hDMEhCQVNFUUREQUxJQUJCQURZQ0hDQUFJQVEyQWhRZ0FFSHBpNENBQURZQ0VDQUFRUjgyQWd4QkFDRVFERWdMSUFCQjJ3RTJBaHdnQUNBRU5nSVVJQUJCK3BhQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF4SEN5QUFRZmdBTmdJY0lBQWdERFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1SZ3NnQUVIUkFEWUNIQ0FBSUFVMkFoUWdBRUd3bDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVVTElBQkIrUUEyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTVJBc2dBRUg0QURZQ0hDQUFJQUUyQWhRZ0FFSEttSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERU1MSUFCQjVBQTJBaHdnQUNBQk5nSVVJQUJCNDVlQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF4Q0N5QUFRZGNBTmdJY0lBQWdBVFlDRkNBQVFjbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1RUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYm1OZ0lBQU5nSVFJQUJCR2pZQ0RFRUFJUkFNUUFzZ0FFSENBRFlDSENBQUlBRTJBaFFnQUVIam1JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUUREOExJQUJCQURZQ0JDQUFJQThnRHhDeGdJQ0FBQ0lFUlEwQklBQkJPallDSENBQUlBUTJBZ3dnQUNBUFFRRnFOZ0lVUVFBaEVBdytDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkVVTkFDQUFRVHMyQWh3Z0FDQUVOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1QZ3NnQVVFQmFpRUJEQzBMSUE5QkFXb2hBUXd0Q3lBQVFRQTJBaHdnQUNBUE5nSVVJQUJCNUpLQWdBQTJBaEFnQUVFRU5nSU1RUUFoRUF3N0N5QUFRVFkyQWh3Z0FDQUVOZ0lVSUFBZ0FqWUNERUVBSVJBTU9nc2dBRUV1TmdJY0lBQWdEallDRkNBQUlBUTJBZ3hCQUNFUUREa0xJQUJCMEFBMkFod2dBQ0FCTmdJVUlBQkJrWmlBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXc0Q3lBTlFRRnFJUUVNTEFzZ0FFRVZOZ0ljSUFBZ0FUWUNGQ0FBUVlLWmdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU5nc2dBRUViTmdJY0lBQWdBVFlDRkNBQVFaR1hnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1OUXNnQUVFUE5nSWNJQUFnQVRZQ0ZDQUFRWkdYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTkFzZ0FFRUxOZ0ljSUFBZ0FUWUNGQ0FBUVpHWGdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU13c2dBRUVhTmdJY0lBQWdBVFlDRkNBQVFZS1pnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1NZ3NnQUVFTE5nSWNJQUFnQVRZQ0ZDQUFRWUtaZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNTVFzZ0FFRUtOZ0ljSUFBZ0FUWUNGQ0FBUWVTV2dJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTU1Bc2dBRUVlTmdJY0lBQWdBVFlDRkNBQVFmbVhnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Md3NnQUVFQU5nSWNJQUFnRURZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNTGdzZ0FFRUVOZ0ljSUFBZ0FUWUNGQ0FBUWJDWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTUxRc2dBRUVBTmdJQUlBdEJBV29oQ3d0QnVBRWhFQXdTQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRZlVBSVJBTUVRc2dBU0VCQWtBZ0FDMEFLVUVGUncwQVFlTUFJUkFNRVF0QjRnQWhFQXdRQzBFQUlSQWdBRUVBTmdJY0lBQkI1SkdBZ0FBMkFoQWdBRUVITmdJTUlBQWdGRUVCYWpZQ0ZBd29DeUFBUVFBMkFnQWdGMEVCYWlFQlFjQUFJUkFNRGd0QkFTRUJDeUFBSUFFNkFDd2dBRUVBTmdJQUlCZEJBV29oQVF0QktDRVFEQXNMSUFFaEFRdEJPQ0VRREFrTEFrQWdBU0lQSUFKR0RRQURRQUpBSUE4dEFBQkJnTDZBZ0FCcUxRQUFJZ0ZCQVVZTkFDQUJRUUpIRFFNZ0QwRUJhaUVCREFRTElBOUJBV29pRHlBQ1J3MEFDMEUrSVJBTUlndEJQaUVRRENFTElBQkJBRG9BTENBUElRRU1BUXRCQ3lFUURBWUxRVG9oRUF3RkN5QUJRUUZxSVFGQkxTRVFEQVFMSUFBZ0FUb0FMQ0FBUVFBMkFnQWdGa0VCYWlFQlFRd2hFQXdEQ3lBQVFRQTJBZ0FnRjBFQmFpRUJRUW9oRUF3Q0N5QUFRUUEyQWdBTElBQkJBRG9BTENBTklRRkJDU0VRREFBTEMwRUFJUkFnQUVFQU5nSWNJQUFnQ3pZQ0ZDQUFRYzJRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1hDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0NqWUNGQ0FBUWVtS2dJQUFOZ0lRSUFCQkNUWUNEQXdXQzBFQUlSQWdBRUVBTmdJY0lBQWdDVFlDRkNBQVFiZVFnSUFBTmdJUUlBQkJDVFlDREF3VkMwRUFJUkFnQUVFQU5nSWNJQUFnQ0RZQ0ZDQUFRWnlSZ0lBQU5nSVFJQUJCQ1RZQ0RBd1VDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWMyUWdJQUFOZ0lRSUFCQkNUWUNEQXdUQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFlbUtnSUFBTmdJUUlBQkJDVFlDREF3U0MwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYmVRZ0lBQU5nSVFJQUJCQ1RZQ0RBd1JDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp5UmdJQUFOZ0lRSUFCQkNUWUNEQXdRQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaZVZnSUFBTmdJUUlBQkJEellDREF3UEMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWmVWZ0lBQU5nSVFJQUJCRHpZQ0RBd09DMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWNDU2dJQUFOZ0lRSUFCQkN6WUNEQXdOQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaV0pnSUFBTmdJUUlBQkJDellDREF3TUMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZUdQZ0lBQU5nSVFJQUJCQ2pZQ0RBd0xDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZ1UGdJQUFOZ0lRSUFCQkNqWUNEQXdLQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFmR1pnSUFBTmdJUUlBQkJBallDREF3SkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRY1NVZ0lBQU5nSVFJQUJCQWpZQ0RBd0lDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZLVmdJQUFOZ0lRSUFCQkFqWUNEQXdIQ3lBQVFRSTJBaHdnQUNBQk5nSVVJQUJCbkpxQWdBQTJBaEFnQUVFV05nSU1RUUFoRUF3R0MwRUJJUkFNQlF0QjFBQWhFQ0FCSWdRZ0FrWU5CQ0FEUVFocUlBQWdCQ0FDUWRqQ2dJQUFRUW9ReFlDQWdBQWdBeWdDRENFRUlBTW9BZ2dPQXdFRUFnQUxFTXFBZ0lBQUFBc2dBRUVBTmdJY0lBQkJ0WnFBZ0FBMkFoQWdBRUVYTmdJTUlBQWdCRUVCYWpZQ0ZFRUFJUkFNQWdzZ0FFRUFOZ0ljSUFBZ0JEWUNGQ0FBUWNxYWdJQUFOZ0lRSUFCQkNUWUNERUVBSVJBTUFRc0NRQ0FCSWdRZ0FrY05BRUVpSVJBTUFRc2dBRUdKZ0lDQUFEWUNDQ0FBSUFRMkFnUkJJU0VRQ3lBRFFSQnFKSUNBZ0lBQUlCQUxyd0VCQW44Z0FTZ0NBQ0VHQWtBQ1FDQUNJQU5HRFFBZ0JDQUdhaUVFSUFZZ0Eyb2dBbXNoQnlBQ0lBWkJmM01nQldvaUJtb2hCUU5BQWtBZ0FpMEFBQ0FFTFFBQVJnMEFRUUloQkF3REN3SkFJQVlOQUVFQUlRUWdCU0VDREFNTElBWkJmMm9oQmlBRVFRRnFJUVFnQWtFQmFpSUNJQU5IRFFBTElBY2hCaUFESVFJTElBQkJBVFlDQUNBQklBWTJBZ0FnQUNBQ05nSUVEd3NnQVVFQU5nSUFJQUFnQkRZQ0FDQUFJQUkyQWdRTENnQWdBQkRIZ0lDQUFBdnlOZ0VMZnlPQWdJQ0FBRUVRYXlJQkpJQ0FnSUFBQWtCQkFDZ0NvTkNBZ0FBTkFFRUFFTXVBZ0lBQVFZRFVoSUFBYXlJQ1Fka0FTUTBBUVFBaEF3SkFRUUFvQXVEVGdJQUFJZ1FOQUVFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVJYWtGd2NVSFlxdFdxQlhNaUJEWUM0Tk9BZ0FCQkFFRUFOZ0wwMDRDQUFFRUFRUUEyQXNUVGdJQUFDMEVBSUFJMkFzelRnSUFBUVFCQmdOU0VnQUEyQXNqVGdJQUFRUUJCZ05TRWdBQTJBcGpRZ0lBQVFRQWdCRFlDck5DQWdBQkJBRUYvTmdLbzBJQ0FBQU5BSUFOQnhOQ0FnQUJxSUFOQnVOQ0FnQUJxSWdRMkFnQWdCQ0FEUWJEUWdJQUFhaUlGTmdJQUlBTkJ2TkNBZ0FCcUlBVTJBZ0FnQTBITTBJQ0FBR29nQTBIQTBJQ0FBR29pQlRZQ0FDQUZJQVEyQWdBZ0EwSFUwSUNBQUdvZ0EwSEkwSUNBQUdvaUJEWUNBQ0FFSUFVMkFnQWdBMEhRMElDQUFHb2dCRFlDQUNBRFFTQnFJZ05CZ0FKSERRQUxRWURVaElBQVFYaEJnTlNFZ0FCclFROXhRUUJCZ05TRWdBQkJDR3BCRDNFYklnTnFJZ1JCQkdvZ0FrRklhaUlGSUFOcklnTkJBWEkyQWdCQkFFRUFLQUx3MDRDQUFEWUNwTkNBZ0FCQkFDQUROZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFRWURVaElBQUlBVnFRVGcyQWdRTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjdBRkxEUUFDUUVFQUtBS0kwSUNBQUNJR1FSQWdBRUVUYWtGd2NTQUFRUXRKR3lJQ1FRTjJJZ1IySWdOQkEzRkZEUUFDUUFKQUlBTkJBWEVnQkhKQkFYTWlCVUVEZENJRVFiRFFnSUFBYWlJRElBUkJ1TkNBZ0FCcUtBSUFJZ1FvQWdnaUFrY05BRUVBSUFaQmZpQUZkM0UyQW9qUWdJQUFEQUVMSUFNZ0FqWUNDQ0FDSUFNMkFnd0xJQVJCQ0dvaEF5QUVJQVZCQTNRaUJVRURjallDQkNBRUlBVnFJZ1FnQkNnQ0JFRUJjallDQkF3TUN5QUNRUUFvQXBEUWdJQUFJZ2RORFFFQ1FDQURSUTBBQWtBQ1FDQURJQVIwUVFJZ0JIUWlBMEVBSUFOcmNuRWlBMEVBSUFOcmNVRi9haUlESUFOQkRIWkJFSEVpQTNZaUJFRUZka0VJY1NJRklBTnlJQVFnQlhZaUEwRUNka0VFY1NJRWNpQURJQVIySWdOQkFYWkJBbkVpQkhJZ0F5QUVkaUlEUVFGMlFRRnhJZ1J5SUFNZ0JIWnFJZ1JCQTNRaUEwR3cwSUNBQUdvaUJTQURRYmpRZ0lBQWFpZ0NBQ0lES0FJSUlnQkhEUUJCQUNBR1FYNGdCSGR4SWdZMkFvalFnSUFBREFFTElBVWdBRFlDQ0NBQUlBVTJBZ3dMSUFNZ0FrRURjallDQkNBRElBUkJBM1FpQkdvZ0JDQUNheUlGTmdJQUlBTWdBbW9pQUNBRlFRRnlOZ0lFQWtBZ0IwVU5BQ0FIUVhoeFFiRFFnSUFBYWlFQ1FRQW9BcHpRZ0lBQUlRUUNRQUpBSUFaQkFTQUhRUU4yZENJSWNRMEFRUUFnQmlBSWNqWUNpTkNBZ0FBZ0FpRUlEQUVMSUFJb0FnZ2hDQXNnQ0NBRU5nSU1JQUlnQkRZQ0NDQUVJQUkyQWd3Z0JDQUlOZ0lJQ3lBRFFRaHFJUU5CQUNBQU5nS2MwSUNBQUVFQUlBVTJBcERRZ0lBQURBd0xRUUFvQW96UWdJQUFJZ2xGRFFFZ0NVRUFJQWxyY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQkVFRmRrRUljU0lGSUFOeUlBUWdCWFlpQTBFQ2RrRUVjU0lFY2lBRElBUjJJZ05CQVhaQkFuRWlCSElnQXlBRWRpSURRUUYyUVFGeElnUnlJQU1nQkhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0lBS0FJRVFYaHhJQUpySVFRZ0FDRUZBa0FEUUFKQUlBVW9BaEFpQXcwQUlBVkJGR29vQWdBaUEwVU5BZ3NnQXlnQ0JFRjRjU0FDYXlJRklBUWdCU0FFU1NJRkd5RUVJQU1nQUNBRkd5RUFJQU1oQlF3QUN3c2dBQ2dDR0NFS0FrQWdBQ2dDRENJSUlBQkdEUUFnQUNnQ0NDSURRUUFvQXBqUWdJQUFTUm9nQ0NBRE5nSUlJQU1nQ0RZQ0RBd0xDd0pBSUFCQkZHb2lCU2dDQUNJRERRQWdBQ2dDRUNJRFJRMERJQUJCRUdvaEJRc0RRQ0FGSVFzZ0F5SUlRUlJxSWdVb0FnQWlBdzBBSUFoQkVHb2hCU0FJS0FJUUlnTU5BQXNnQzBFQU5nSUFEQW9MUVg4aEFpQUFRYjkvU3cwQUlBQkJFMm9pQTBGd2NTRUNRUUFvQW96UWdJQUFJZ2RGRFFCQkFDRUxBa0FnQWtHQUFra05BRUVmSVFzZ0FrSC8vLzhIU3cwQUlBTkJDSFlpQXlBRFFZRCtQMnBCRUhaQkNIRWlBM1FpQkNBRVFZRGdIMnBCRUhaQkJIRWlCSFFpQlNBRlFZQ0FEMnBCRUhaQkFuRWlCWFJCRDNZZ0F5QUVjaUFGY21zaUEwRUJkQ0FDSUFOQkZXcDJRUUZ4Y2tFY2FpRUxDMEVBSUFKcklRUUNRQUpBQWtBQ1FDQUxRUUowUWJqU2dJQUFhaWdDQUNJRkRRQkJBQ0VEUVFBaENBd0JDMEVBSVFNZ0FrRUFRUmtnQzBFQmRtc2dDMEVmUmh0MElRQkJBQ0VJQTBBQ1FDQUZLQUlFUVhoeElBSnJJZ1lnQkU4TkFDQUdJUVFnQlNFSUlBWU5BRUVBSVFRZ0JTRUlJQVVoQXd3REN5QURJQVZCRkdvb0FnQWlCaUFHSUFVZ0FFRWRka0VFY1dwQkVHb29BZ0FpQlVZYklBTWdCaHNoQXlBQVFRRjBJUUFnQlEwQUN3c0NRQ0FESUFoeURRQkJBQ0VJUVFJZ0MzUWlBMEVBSUFOcmNpQUhjU0lEUlEwRElBTkJBQ0FEYTNGQmYyb2lBeUFEUVF4MlFSQnhJZ04ySWdWQkJYWkJDSEVpQUNBRGNpQUZJQUIySWdOQkFuWkJCSEVpQlhJZ0F5QUZkaUlEUVFGMlFRSnhJZ1Z5SUFNZ0JYWWlBMEVCZGtFQmNTSUZjaUFESUFWMmFrRUNkRUc0MG9DQUFHb29BZ0FoQXdzZ0EwVU5BUXNEUUNBREtBSUVRWGh4SUFKcklnWWdCRWtoQUFKQUlBTW9BaEFpQlEwQUlBTkJGR29vQWdBaEJRc2dCaUFFSUFBYklRUWdBeUFJSUFBYklRZ2dCU0VESUFVTkFBc0xJQWhGRFFBZ0JFRUFLQUtRMElDQUFDQUNhMDhOQUNBSUtBSVlJUXNDUUNBSUtBSU1JZ0FnQ0VZTkFDQUlLQUlJSWdOQkFDZ0NtTkNBZ0FCSkdpQUFJQU0yQWdnZ0F5QUFOZ0lNREFrTEFrQWdDRUVVYWlJRktBSUFJZ01OQUNBSUtBSVFJZ05GRFFNZ0NFRVFhaUVGQ3dOQUlBVWhCaUFESWdCQkZHb2lCU2dDQUNJRERRQWdBRUVRYWlFRklBQW9BaEFpQXcwQUN5QUdRUUEyQWdBTUNBc0NRRUVBS0FLUTBJQ0FBQ0lESUFKSkRRQkJBQ2dDbk5DQWdBQWhCQUpBQWtBZ0F5QUNheUlGUVJCSkRRQWdCQ0FDYWlJQUlBVkJBWEkyQWdSQkFDQUZOZ0tRMElDQUFFRUFJQUEyQXB6UWdJQUFJQVFnQTJvZ0JUWUNBQ0FFSUFKQkEzSTJBZ1FNQVFzZ0JDQURRUU55TmdJRUlBUWdBMm9pQXlBREtBSUVRUUZ5TmdJRVFRQkJBRFlDbk5DQWdBQkJBRUVBTmdLUTBJQ0FBQXNnQkVFSWFpRUREQW9MQWtCQkFDZ0NsTkNBZ0FBaUFDQUNUUTBBUVFBb0FxRFFnSUFBSWdNZ0Ftb2lCQ0FBSUFKcklnVkJBWEkyQWdSQkFDQUZOZ0tVMElDQUFFRUFJQVEyQXFEUWdJQUFJQU1nQWtFRGNqWUNCQ0FEUVFocUlRTU1DZ3NDUUFKQVFRQW9BdURUZ0lBQVJRMEFRUUFvQXVqVGdJQUFJUVFNQVF0QkFFSi9Od0xzMDRDQUFFRUFRb0NBaElDQWdNQUFOd0xrMDRDQUFFRUFJQUZCREdwQmNIRkIyS3JWcWdWek5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQkJnSUFFSVFRTFFRQWhBd0pBSUFRZ0FrSEhBR29pQjJvaUJrRUFJQVJySWd0eElnZ2dBa3NOQUVFQVFUQTJBdmpUZ0lBQURBb0xBa0JCQUNnQ3dOT0FnQUFpQTBVTkFBSkFRUUFvQXJqVGdJQUFJZ1FnQ0dvaUJTQUVUUTBBSUFVZ0EwME5BUXRCQUNFRFFRQkJNRFlDK05PQWdBQU1DZ3RCQUMwQXhOT0FnQUJCQkhFTkJBSkFBa0FDUUVFQUtBS2cwSUNBQUNJRVJRMEFRY2pUZ0lBQUlRTURRQUpBSUFNb0FnQWlCU0FFU3cwQUlBVWdBeWdDQkdvZ0JFc05Bd3NnQXlnQ0NDSUREUUFMQzBFQUVNdUFnSUFBSWdCQmYwWU5CU0FJSVFZQ1FFRUFLQUxrMDRDQUFDSURRWDlxSWdRZ0FIRkZEUUFnQ0NBQWF5QUVJQUJxUVFBZ0EydHhhaUVHQ3lBR0lBSk5EUVVnQmtIKy8vLy9CMHNOQlFKQVFRQW9Bc0RUZ0lBQUlnTkZEUUJCQUNnQ3VOT0FnQUFpQkNBR2FpSUZJQVJORFFZZ0JTQURTdzBHQ3lBR0VNdUFnSUFBSWdNZ0FFY05BUXdIQ3lBR0lBQnJJQXR4SWdaQi92Ly8vd2RMRFFRZ0JoRExnSUNBQUNJQUlBTW9BZ0FnQXlnQ0JHcEdEUU1nQUNFREN3SkFJQU5CZjBZTkFDQUNRY2dBYWlBR1RRMEFBa0FnQnlBR2EwRUFLQUxvMDRDQUFDSUVha0VBSUFScmNTSUVRZjcvLy84SFRRMEFJQU1oQUF3SEN3SkFJQVFReTRDQWdBQkJmMFlOQUNBRUlBWnFJUVlnQXlFQURBY0xRUUFnQm1zUXk0Q0FnQUFhREFRTElBTWhBQ0FEUVg5SERRVU1Bd3RCQUNFSURBY0xRUUFoQUF3RkN5QUFRWDlIRFFJTFFRQkJBQ2dDeE5PQWdBQkJCSEkyQXNUVGdJQUFDeUFJUWY3Ly8vOEhTdzBCSUFnUXk0Q0FnQUFoQUVFQUVNdUFnSUFBSVFNZ0FFRi9SZzBCSUFOQmYwWU5BU0FBSUFOUERRRWdBeUFBYXlJR0lBSkJPR3BORFFFTFFRQkJBQ2dDdU5PQWdBQWdCbW9pQXpZQ3VOT0FnQUFDUUNBRFFRQW9BcnpUZ0lBQVRRMEFRUUFnQXpZQ3ZOT0FnQUFMQWtBQ1FBSkFBa0JCQUNnQ29OQ0FnQUFpQkVVTkFFSEkwNENBQUNFREEwQWdBQ0FES0FJQUlnVWdBeWdDQkNJSWFrWU5BaUFES0FJSUlnTU5BQXdEQ3dzQ1FBSkFRUUFvQXBqUWdJQUFJZ05GRFFBZ0FDQURUdzBCQzBFQUlBQTJBcGpRZ0lBQUMwRUFJUU5CQUNBR05nTE0wNENBQUVFQUlBQTJBc2pUZ0lBQVFRQkJmellDcU5DQWdBQkJBRUVBS0FMZzA0Q0FBRFlDck5DQWdBQkJBRUVBTmdMVTA0Q0FBQU5BSUFOQnhOQ0FnQUJxSUFOQnVOQ0FnQUJxSWdRMkFnQWdCQ0FEUWJEUWdJQUFhaUlGTmdJQUlBTkJ2TkNBZ0FCcUlBVTJBZ0FnQTBITTBJQ0FBR29nQTBIQTBJQ0FBR29pQlRZQ0FDQUZJQVEyQWdBZ0EwSFUwSUNBQUdvZ0EwSEkwSUNBQUdvaUJEWUNBQ0FFSUFVMkFnQWdBMEhRMElDQUFHb2dCRFlDQUNBRFFTQnFJZ05CZ0FKSERRQUxJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViSWdOcUlnUWdCa0ZJYWlJRklBTnJJZ05CQVhJMkFnUkJBRUVBS0FMdzA0Q0FBRFlDcE5DQWdBQkJBQ0FETmdLVTBJQ0FBRUVBSUFRMkFxRFFnSUFBSUFBZ0JXcEJPRFlDQkF3Q0N5QURMUUFNUVFoeERRQWdCQ0FGU1EwQUlBUWdBRThOQUNBRVFYZ2dCR3RCRDNGQkFDQUVRUWhxUVE5eEd5SUZhaUlBUVFBb0FwVFFnSUFBSUFacUlnc2dCV3NpQlVFQmNqWUNCQ0FESUFnZ0JtbzJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRk5nS1UwSUNBQUVFQUlBQTJBcURRZ0lBQUlBUWdDMnBCT0RZQ0JBd0JDd0pBSUFCQkFDZ0NtTkNBZ0FBaUNFOE5BRUVBSUFBMkFwalFnSUFBSUFBaENBc2dBQ0FHYWlFRlFjalRnSUFBSVFNQ1FBSkFBa0FDUUFKQUFrQUNRQU5BSUFNb0FnQWdCVVlOQVNBREtBSUlJZ01OQUF3Q0N3c2dBeTBBREVFSWNVVU5BUXRCeU5PQWdBQWhBd05BQWtBZ0F5Z0NBQ0lGSUFSTERRQWdCU0FES0FJRWFpSUZJQVJMRFFNTElBTW9BZ2doQXd3QUN3c2dBeUFBTmdJQUlBTWdBeWdDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZCQUNBQVFRaHFRUTl4RzJvaUN5QUNRUU55TmdJRUlBVkJlQ0FGYTBFUGNVRUFJQVZCQ0dwQkQzRWJhaUlHSUFzZ0Ftb2lBbXNoQXdKQUlBWWdCRWNOQUVFQUlBSTJBcURRZ0lBQVFRQkJBQ2dDbE5DQWdBQWdBMm9pQXpZQ2xOQ0FnQUFnQWlBRFFRRnlOZ0lFREFNTEFrQWdCa0VBS0FLYzBJQ0FBRWNOQUVFQUlBSTJBcHpRZ0lBQVFRQkJBQ2dDa05DQWdBQWdBMm9pQXpZQ2tOQ0FnQUFnQWlBRFFRRnlOZ0lFSUFJZ0Eyb2dBellDQUF3REN3SkFJQVlvQWdRaUJFRURjVUVCUncwQUlBUkJlSEVoQndKQUFrQWdCRUgvQVVzTkFDQUdLQUlJSWdVZ0JFRURkaUlJUVFOMFFiRFFnSUFBYWlJQVJob0NRQ0FHS0FJTUlnUWdCVWNOQUVFQVFRQW9Bb2pRZ0lBQVFYNGdDSGR4TmdLSTBJQ0FBQXdDQ3lBRUlBQkdHaUFFSUFVMkFnZ2dCU0FFTmdJTURBRUxJQVlvQWhnaENRSkFBa0FnQmlnQ0RDSUFJQVpHRFFBZ0JpZ0NDQ0lFSUFoSkdpQUFJQVEyQWdnZ0JDQUFOZ0lNREFFTEFrQWdCa0VVYWlJRUtBSUFJZ1VOQUNBR1FSQnFJZ1FvQWdBaUJRMEFRUUFoQUF3QkN3TkFJQVFoQ0NBRklnQkJGR29pQkNnQ0FDSUZEUUFnQUVFUWFpRUVJQUFvQWhBaUJRMEFDeUFJUVFBMkFnQUxJQWxGRFFBQ1FBSkFJQVlnQmlnQ0hDSUZRUUowUWJqU2dJQUFhaUlFS0FJQVJ3MEFJQVFnQURZQ0FDQUFEUUZCQUVFQUtBS00wSUNBQUVGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ1VFUVFSUWdDU2dDRUNBR1JodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSk5nSVlBa0FnQmlnQ0VDSUVSUTBBSUFBZ0JEWUNFQ0FFSUFBMkFoZ0xJQVlvQWhRaUJFVU5BQ0FBUVJScUlBUTJBZ0FnQkNBQU5nSVlDeUFISUFOcUlRTWdCaUFIYWlJR0tBSUVJUVFMSUFZZ0JFRitjVFlDQkNBQ0lBTnFJQU0yQWdBZ0FpQURRUUZ5TmdJRUFrQWdBMEgvQVVzTkFDQURRWGh4UWJEUWdJQUFhaUVFQWtBQ1FFRUFLQUtJMElDQUFDSUZRUUVnQTBFRGRuUWlBM0VOQUVFQUlBVWdBM0kyQW9qUWdJQUFJQVFoQXd3QkN5QUVLQUlJSVFNTElBTWdBallDRENBRUlBSTJBZ2dnQWlBRU5nSU1JQUlnQXpZQ0NBd0RDMEVmSVFRQ1FDQURRZi8vL3dkTERRQWdBMEVJZGlJRUlBUkJnUDQvYWtFUWRrRUljU0lFZENJRklBVkJnT0FmYWtFUWRrRUVjU0lGZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQUVJQVZ5SUFCeWF5SUVRUUYwSUFNZ0JFRVZhblpCQVhGeVFSeHFJUVFMSUFJZ0JEWUNIQ0FDUWdBM0FoQWdCRUVDZEVHNDBvQ0FBR29oQlFKQVFRQW9Bb3pRZ0lBQUlnQkJBU0FFZENJSWNRMEFJQVVnQWpZQ0FFRUFJQUFnQ0hJMkFvelFnSUFBSUFJZ0JUWUNHQ0FDSUFJMkFnZ2dBaUFDTmdJTURBTUxJQU5CQUVFWklBUkJBWFpySUFSQkgwWWJkQ0VFSUFVb0FnQWhBQU5BSUFBaUJTZ0NCRUY0Y1NBRFJnMENJQVJCSFhZaEFDQUVRUUYwSVFRZ0JTQUFRUVJ4YWtFUWFpSUlLQUlBSWdBTkFBc2dDQ0FDTmdJQUlBSWdCVFlDR0NBQ0lBSTJBZ3dnQWlBQ05nSUlEQUlMSUFCQmVDQUFhMEVQY1VFQUlBQkJDR3BCRDNFYklnTnFJZ3NnQmtGSWFpSUlJQU5ySWdOQkFYSTJBZ1FnQUNBSWFrRTROZ0lFSUFRZ0JVRTNJQVZyUVE5eFFRQWdCVUZKYWtFUGNSdHFRVUZxSWdnZ0NDQUVRUkJxU1JzaUNFRWpOZ0lFUVFCQkFDZ0M4Tk9BZ0FBMkFxVFFnSUFBUVFBZ0F6WUNsTkNBZ0FCQkFDQUxOZ0tnMElDQUFDQUlRUkJxUVFBcEF0RFRnSUFBTndJQUlBaEJBQ2tDeU5PQWdBQTNBZ2hCQUNBSVFRaHFOZ0xRMDRDQUFFRUFJQVkyQXN6VGdJQUFRUUFnQURZQ3lOT0FnQUJCQUVFQU5nTFUwNENBQUNBSVFTUnFJUU1EUUNBRFFRYzJBZ0FnQTBFRWFpSURJQVZKRFFBTElBZ2dCRVlOQXlBSUlBZ29BZ1JCZm5FMkFnUWdDQ0FJSUFScklnQTJBZ0FnQkNBQVFRRnlOZ0lFQWtBZ0FFSC9BVXNOQUNBQVFYaHhRYkRRZ0lBQWFpRURBa0FDUUVFQUtBS0kwSUNBQUNJRlFRRWdBRUVEZG5RaUFIRU5BRUVBSUFVZ0FISTJBb2pRZ0lBQUlBTWhCUXdCQ3lBREtBSUlJUVVMSUFVZ0JEWUNEQ0FESUFRMkFnZ2dCQ0FETmdJTUlBUWdCVFlDQ0F3RUMwRWZJUU1DUUNBQVFmLy8vd2RMRFFBZ0FFRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lGSUFWQmdPQWZha0VRZGtFRWNTSUZkQ0lJSUFoQmdJQVBha0VRZGtFQ2NTSUlkRUVQZGlBRElBVnlJQWh5YXlJRFFRRjBJQUFnQTBFVmFuWkJBWEZ5UVJ4cUlRTUxJQVFnQXpZQ0hDQUVRZ0EzQWhBZ0EwRUNkRUc0MG9DQUFHb2hCUUpBUVFBb0FvelFnSUFBSWdoQkFTQURkQ0lHY1EwQUlBVWdCRFlDQUVFQUlBZ2dCbkkyQW96UWdJQUFJQVFnQlRZQ0dDQUVJQVEyQWdnZ0JDQUVOZ0lNREFRTElBQkJBRUVaSUFOQkFYWnJJQU5CSDBZYmRDRURJQVVvQWdBaENBTkFJQWdpQlNnQ0JFRjRjU0FBUmcwRElBTkJIWFloQ0NBRFFRRjBJUU1nQlNBSVFRUnhha0VRYWlJR0tBSUFJZ2dOQUFzZ0JpQUVOZ0lBSUFRZ0JUWUNHQ0FFSUFRMkFnd2dCQ0FFTmdJSURBTUxJQVVvQWdnaUF5QUNOZ0lNSUFVZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFGTmdJTUlBSWdBellDQ0FzZ0MwRUlhaUVEREFVTElBVW9BZ2dpQXlBRU5nSU1JQVVnQkRZQ0NDQUVRUUEyQWhnZ0JDQUZOZ0lNSUFRZ0F6WUNDQXRCQUNnQ2xOQ0FnQUFpQXlBQ1RRMEFRUUFvQXFEUWdJQUFJZ1FnQW1vaUJTQURJQUpySWdOQkFYSTJBZ1JCQUNBRE5nS1UwSUNBQUVFQUlBVTJBcURRZ0lBQUlBUWdBa0VEY2pZQ0JDQUVRUWhxSVFNTUF3dEJBQ0VEUVFCQk1EWUMrTk9BZ0FBTUFnc0NRQ0FMUlEwQUFrQUNRQ0FJSUFnb0Fod2lCVUVDZEVHNDBvQ0FBR29pQXlnQ0FFY05BQ0FESUFBMkFnQWdBQTBCUVFBZ0IwRitJQVYzY1NJSE5nS00wSUNBQUF3Q0N5QUxRUkJCRkNBTEtBSVFJQWhHRzJvZ0FEWUNBQ0FBUlEwQkN5QUFJQXMyQWhnQ1FDQUlLQUlRSWdORkRRQWdBQ0FETmdJUUlBTWdBRFlDR0FzZ0NFRVVhaWdDQUNJRFJRMEFJQUJCRkdvZ0F6WUNBQ0FESUFBMkFoZ0xBa0FDUUNBRVFROUxEUUFnQ0NBRUlBSnFJZ05CQTNJMkFnUWdDQ0FEYWlJRElBTW9BZ1JCQVhJMkFnUU1BUXNnQ0NBQ2FpSUFJQVJCQVhJMkFnUWdDQ0FDUVFOeU5nSUVJQUFnQkdvZ0JEWUNBQUpBSUFSQi93RkxEUUFnQkVGNGNVR3cwSUNBQUdvaEF3SkFBa0JCQUNnQ2lOQ0FnQUFpQlVFQklBUkJBM1owSWdSeERRQkJBQ0FGSUFSeU5nS0kwSUNBQUNBRElRUU1BUXNnQXlnQ0NDRUVDeUFFSUFBMkFnd2dBeUFBTmdJSUlBQWdBellDRENBQUlBUTJBZ2dNQVF0Qkh5RURBa0FnQkVILy8vOEhTdzBBSUFSQkNIWWlBeUFEUVlEK1AycEJFSFpCQ0hFaUEzUWlCU0FGUVlEZ0gycEJFSFpCQkhFaUJYUWlBaUFDUVlDQUQycEJFSFpCQW5FaUFuUkJEM1lnQXlBRmNpQUNjbXNpQTBFQmRDQUVJQU5CRldwMlFRRnhja0VjYWlFREN5QUFJQU0yQWh3Z0FFSUFOd0lRSUFOQkFuUkJ1TktBZ0FCcUlRVUNRQ0FIUVFFZ0EzUWlBbkVOQUNBRklBQTJBZ0JCQUNBSElBSnlOZ0tNMElDQUFDQUFJQVUyQWhnZ0FDQUFOZ0lJSUFBZ0FEWUNEQXdCQ3lBRVFRQkJHU0FEUVFGMmF5QURRUjlHRzNRaEF5QUZLQUlBSVFJQ1FBTkFJQUlpQlNnQ0JFRjRjU0FFUmcwQklBTkJIWFloQWlBRFFRRjBJUU1nQlNBQ1FRUnhha0VRYWlJR0tBSUFJZ0lOQUFzZ0JpQUFOZ0lBSUFBZ0JUWUNHQ0FBSUFBMkFnd2dBQ0FBTmdJSURBRUxJQVVvQWdnaUF5QUFOZ0lNSUFVZ0FEWUNDQ0FBUVFBMkFoZ2dBQ0FGTmdJTUlBQWdBellDQ0FzZ0NFRUlhaUVEREFFTEFrQWdDa1VOQUFKQUFrQWdBQ0FBS0FJY0lnVkJBblJCdU5LQWdBQnFJZ01vQWdCSERRQWdBeUFJTmdJQUlBZ05BVUVBSUFsQmZpQUZkM0UyQW96UWdJQUFEQUlMSUFwQkVFRVVJQW9vQWhBZ0FFWWJhaUFJTmdJQUlBaEZEUUVMSUFnZ0NqWUNHQUpBSUFBb0FoQWlBMFVOQUNBSUlBTTJBaEFnQXlBSU5nSVlDeUFBUVJScUtBSUFJZ05GRFFBZ0NFRVVhaUFETmdJQUlBTWdDRFlDR0FzQ1FBSkFJQVJCRDBzTkFDQUFJQVFnQW1vaUEwRURjallDQkNBQUlBTnFJZ01nQXlnQ0JFRUJjallDQkF3QkN5QUFJQUpxSWdVZ0JFRUJjallDQkNBQUlBSkJBM0kyQWdRZ0JTQUVhaUFFTmdJQUFrQWdCMFVOQUNBSFFYaHhRYkRRZ0lBQWFpRUNRUUFvQXB6UWdJQUFJUU1DUUFKQVFRRWdCMEVEZG5RaUNDQUdjUTBBUVFBZ0NDQUdjallDaU5DQWdBQWdBaUVJREFFTElBSW9BZ2doQ0FzZ0NDQUROZ0lNSUFJZ0F6WUNDQ0FESUFJMkFnd2dBeUFJTmdJSUMwRUFJQVUyQXB6UWdJQUFRUUFnQkRZQ2tOQ0FnQUFMSUFCQkNHb2hBd3NnQVVFUWFpU0FnSUNBQUNBREN3b0FJQUFReVlDQWdBQUw0ZzBCQjM4Q1FDQUFSUTBBSUFCQmVHb2lBU0FBUVh4cUtBSUFJZ0pCZUhFaUFHb2hBd0pBSUFKQkFYRU5BQ0FDUVFOeFJRMEJJQUVnQVNnQ0FDSUNheUlCUVFBb0FwalFnSUFBSWdSSkRRRWdBaUFBYWlFQUFrQWdBVUVBS0FLYzBJQ0FBRVlOQUFKQUlBSkIvd0ZMRFFBZ0FTZ0NDQ0lFSUFKQkEzWWlCVUVEZEVHdzBJQ0FBR29pQmtZYUFrQWdBU2dDRENJQ0lBUkhEUUJCQUVFQUtBS0kwSUNBQUVGK0lBVjNjVFlDaU5DQWdBQU1Bd3NnQWlBR1Job2dBaUFFTmdJSUlBUWdBallDREF3Q0N5QUJLQUlZSVFjQ1FBSkFJQUVvQWd3aUJpQUJSZzBBSUFFb0FnZ2lBaUFFU1JvZ0JpQUNOZ0lJSUFJZ0JqWUNEQXdCQ3dKQUlBRkJGR29pQWlnQ0FDSUVEUUFnQVVFUWFpSUNLQUlBSWdRTkFFRUFJUVlNQVFzRFFDQUNJUVVnQkNJR1FSUnFJZ0lvQWdBaUJBMEFJQVpCRUdvaEFpQUdLQUlRSWdRTkFBc2dCVUVBTmdJQUN5QUhSUTBCQWtBQ1FDQUJJQUVvQWh3aUJFRUNkRUc0MG9DQUFHb2lBaWdDQUVjTkFDQUNJQVkyQWdBZ0JnMEJRUUJCQUNnQ2pOQ0FnQUJCZmlBRWQzRTJBb3pRZ0lBQURBTUxJQWRCRUVFVUlBY29BaEFnQVVZYmFpQUdOZ0lBSUFaRkRRSUxJQVlnQnpZQ0dBSkFJQUVvQWhBaUFrVU5BQ0FHSUFJMkFoQWdBaUFHTmdJWUN5QUJLQUlVSWdKRkRRRWdCa0VVYWlBQ05nSUFJQUlnQmpZQ0dBd0JDeUFES0FJRUlnSkJBM0ZCQTBjTkFDQURJQUpCZm5FMkFnUkJBQ0FBTmdLUTBJQ0FBQ0FCSUFCcUlBQTJBZ0FnQVNBQVFRRnlOZ0lFRHdzZ0FTQURUdzBBSUFNb0FnUWlBa0VCY1VVTkFBSkFBa0FnQWtFQ2NRMEFBa0FnQTBFQUtBS2cwSUNBQUVjTkFFRUFJQUUyQXFEUWdJQUFRUUJCQUNnQ2xOQ0FnQUFnQUdvaUFEWUNsTkNBZ0FBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbk5DQWdBQkhEUU5CQUVFQU5nS1EwSUNBQUVFQVFRQTJBcHpRZ0lBQUR3c0NRQ0FEUVFBb0FwelFnSUFBUncwQVFRQWdBVFlDbk5DQWdBQkJBRUVBS0FLUTBJQ0FBQ0FBYWlJQU5nS1EwSUNBQUNBQklBQkJBWEkyQWdRZ0FTQUFhaUFBTmdJQUR3c2dBa0Y0Y1NBQWFpRUFBa0FDUUNBQ1FmOEJTdzBBSUFNb0FnZ2lCQ0FDUVFOMklnVkJBM1JCc05DQWdBQnFJZ1pHR2dKQUlBTW9BZ3dpQWlBRVJ3MEFRUUJCQUNnQ2lOQ0FnQUJCZmlBRmQzRTJBb2pRZ0lBQURBSUxJQUlnQmtZYUlBSWdCRFlDQ0NBRUlBSTJBZ3dNQVFzZ0F5Z0NHQ0VIQWtBQ1FDQURLQUlNSWdZZ0EwWU5BQ0FES0FJSUlnSkJBQ2dDbU5DQWdBQkpHaUFHSUFJMkFnZ2dBaUFHTmdJTURBRUxBa0FnQTBFVWFpSUNLQUlBSWdRTkFDQURRUkJxSWdJb0FnQWlCQTBBUVFBaEJnd0JDd05BSUFJaEJTQUVJZ1pCRkdvaUFpZ0NBQ0lFRFFBZ0JrRVFhaUVDSUFZb0FoQWlCQTBBQ3lBRlFRQTJBZ0FMSUFkRkRRQUNRQUpBSUFNZ0F5Z0NIQ0lFUVFKMFFialNnSUFBYWlJQ0tBSUFSdzBBSUFJZ0JqWUNBQ0FHRFFGQkFFRUFLQUtNMElDQUFFRitJQVIzY1RZQ2pOQ0FnQUFNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFZMkFnQWdCa1VOQVFzZ0JpQUhOZ0lZQWtBZ0F5Z0NFQ0lDUlEwQUlBWWdBallDRUNBQ0lBWTJBaGdMSUFNb0FoUWlBa1VOQUNBR1FSUnFJQUkyQWdBZ0FpQUdOZ0lZQ3lBQklBQnFJQUEyQWdBZ0FTQUFRUUZ5TmdJRUlBRkJBQ2dDbk5DQWdBQkhEUUZCQUNBQU5nS1EwSUNBQUE4TElBTWdBa0YrY1RZQ0JDQUJJQUJxSUFBMkFnQWdBU0FBUVFGeU5nSUVDd0pBSUFCQi93RkxEUUFnQUVGNGNVR3cwSUNBQUdvaEFnSkFBa0JCQUNnQ2lOQ0FnQUFpQkVFQklBQkJBM1owSWdCeERRQkJBQ0FFSUFCeU5nS0kwSUNBQUNBQ0lRQU1BUXNnQWlnQ0NDRUFDeUFBSUFFMkFnd2dBaUFCTmdJSUlBRWdBallDRENBQklBQTJBZ2dQQzBFZklRSUNRQ0FBUWYvLy93ZExEUUFnQUVFSWRpSUNJQUpCZ1A0L2FrRVFka0VJY1NJQ2RDSUVJQVJCZ09BZmFrRVFka0VFY1NJRWRDSUdJQVpCZ0lBUGFrRVFka0VDY1NJR2RFRVBkaUFDSUFSeUlBWnlheUlDUVFGMElBQWdBa0VWYW5aQkFYRnlRUnhxSVFJTElBRWdBallDSENBQlFnQTNBaEFnQWtFQ2RFRzQwb0NBQUdvaEJBSkFBa0JCQUNnQ2pOQ0FnQUFpQmtFQklBSjBJZ054RFFBZ0JDQUJOZ0lBUVFBZ0JpQURjallDak5DQWdBQWdBU0FFTmdJWUlBRWdBVFlDQ0NBQklBRTJBZ3dNQVFzZ0FFRUFRUmtnQWtFQmRtc2dBa0VmUmh0MElRSWdCQ2dDQUNFR0FrQURRQ0FHSWdRb0FnUkJlSEVnQUVZTkFTQUNRUjEySVFZZ0FrRUJkQ0VDSUFRZ0JrRUVjV3BCRUdvaUF5Z0NBQ0lHRFFBTElBTWdBVFlDQUNBQklBUTJBaGdnQVNBQk5nSU1JQUVnQVRZQ0NBd0JDeUFFS0FJSUlnQWdBVFlDRENBRUlBRTJBZ2dnQVVFQU5nSVlJQUVnQkRZQ0RDQUJJQUEyQWdnTFFRQkJBQ2dDcU5DQWdBQkJmMm9pQVVGL0lBRWJOZ0tvMElDQUFBc0xCQUFBQUF0T0FBSkFJQUFOQUQ4QVFSQjBEd3NDUUNBQVFmLy9BM0VOQUNBQVFYOU1EUUFDUUNBQVFSQjJRQUFpQUVGL1J3MEFRUUJCTURZQytOT0FnQUJCZnc4TElBQkJFSFFQQ3hES2dJQ0FBQUFMOGdJQ0EzOEJmZ0pBSUFKRkRRQWdBQ0FCT2dBQUlBSWdBR29pQTBGL2FpQUJPZ0FBSUFKQkEwa05BQ0FBSUFFNkFBSWdBQ0FCT2dBQklBTkJmV29nQVRvQUFDQURRWDVxSUFFNkFBQWdBa0VIU1EwQUlBQWdBVG9BQXlBRFFYeHFJQUU2QUFBZ0FrRUpTUTBBSUFCQkFDQUFhMEVEY1NJRWFpSURJQUZCL3dGeFFZR0NoQWhzSWdFMkFnQWdBeUFDSUFSclFYeHhJZ1JxSWdKQmZHb2dBVFlDQUNBRVFRbEpEUUFnQXlBQk5nSUlJQU1nQVRZQ0JDQUNRWGhxSUFFMkFnQWdBa0YwYWlBQk5nSUFJQVJCR1VrTkFDQURJQUUyQWhnZ0F5QUJOZ0lVSUFNZ0FUWUNFQ0FESUFFMkFnd2dBa0Z3YWlBQk5nSUFJQUpCYkdvZ0FUWUNBQ0FDUVdocUlBRTJBZ0FnQWtGa2FpQUJOZ0lBSUFRZ0EwRUVjVUVZY2lJRmF5SUNRU0JKRFFBZ0FhMUNnWUNBZ0JCK0lRWWdBeUFGYWlFQkEwQWdBU0FHTndNWUlBRWdCamNERUNBQklBWTNBd2dnQVNBR053TUFJQUZCSUdvaEFTQUNRV0JxSWdKQkgwc05BQXNMSUFBTEM0NUlBUUJCZ0FnTGhrZ0JBQUFBQWdBQUFBTUFBQUFBQUFBQUFBQUFBQVFBQUFBRkFBQUFBQUFBQUFBQUFBQUdBQUFBQndBQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnY1hWbGNua0FVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWliMlI1QUVOdmJuUmxiblF0VEdWdVozUm9JRzkyWlhKbWJHOTNBRU5vZFc1cklITnBlbVVnYjNabGNtWnNiM2NBVW1WemNHOXVjMlVnYjNabGNtWnNiM2NBU1c1MllXeHBaQ0J0WlhSb2IyUWdabTl5SUVoVVZGQXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0J0WlhSb2IyUWdabTl5SUZKVVUxQXZlQzU0SUhKbGNYVmxjM1FBUlhod1pXTjBaV1FnVTA5VlVrTkZJRzFsZEdodlpDQm1iM0lnU1VORkwzZ3VlQ0J5WlhGMVpYTjBBRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnWm5KaFoyMWxiblFnYzNSaGNuUUFSWGh3WldOMFpXUWdaRzkwQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYzNSaGRIVnpBRWx1ZG1Gc2FXUWdjbVZ6Y0c5dWMyVWdjM1JoZEhWekFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTUFWWE5sY2lCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmNtVnpaWFJnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlvWldGa1pYSmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMkpsWjJsdVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgzWmhiSFZsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmMzUmhkSFZ6WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzVnliRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYM1poYkhWbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsZEdodlpGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMmhsWVdSbGNsOW1hV1ZzWkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhObGNuWmxjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjJZV3gxWlNCamFHRnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlHWnBaV3hrSUdOb1lYSUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOTJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXbHViM0lnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRzFoYW05eUlIWmxjbk5wYjI0QVJYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQkRVa3hHSUdGbWRHVnlJSFpsY25OcGIyNEFTVzUyWVd4cFpDQklWRlJRSUhabGNuTnBiMjRBU1c1MllXeHBaQ0JvWldGa1pYSWdkRzlyWlc0QVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MWNtd0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSnpJR2x1SUhWeWJBQlZibVY0Y0dWamRHVmtJSE4wWVhKMElHTm9ZWElnYVc0Z2RYSnNBRVJ2ZFdKc1pTQkFJR2x1SUhWeWJBQkZiWEIwZVNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCRGIyNTBaVzUwTFV4bGJtZDBhQUJFZFhCc2FXTmhkR1VnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J3WVhSb0FFTnZiblJsYm5RdFRHVnVaM1JvSUdOaGJpZDBJR0psSUhCeVpYTmxiblFnZDJsMGFDQlVjbUZ1YzJabGNpMUZibU52WkdsdVp3QkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QnphWHBsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmYUdWaFpHVnlYM1poYkhWbEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nZG1Gc2RXVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQk1SaUJoWm5SbGNpQm9aV0ZrWlhJZ2RtRnNkV1VBU1c1MllXeHBaQ0JnVkhKaGJuTm1aWEl0Ulc1amIyUnBibWRnSUdobFlXUmxjaUIyWVd4MVpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJSEYxYjNSbElIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1ZrSUhaaGJIVmxBRkJoZFhObFpDQmllU0J2Ymw5b1pXRmtaWEp6WDJOdmJYQnNaWFJsQUVsdWRtRnNhV1FnUlU5R0lITjBZWFJsQUc5dVgzSmxjMlYwSUhCaGRYTmxBRzl1WDJOb2RXNXJYMmhsWVdSbGNpQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgySmxaMmx1SUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpTQndZWFZ6WlFCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MWNteGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDNaaGJIVmxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WlNCd1lYVnpaUUJWYm1WNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlITjBZWEowSUd4cGJtVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUc1aGJXVUFVR0YxYzJVZ2IyNGdRMDlPVGtWRFZDOVZjR2R5WVdSbEFGQmhkWE5sSUc5dUlGQlNTUzlWY0dkeVlXUmxBRVY0Y0dWamRHVmtJRWhVVkZBdk1pQkRiMjV1WldOMGFXOXVJRkJ5WldaaFkyVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOXRaWFJvYjJRQVJYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdiV1YwYUc5a0FGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmFHVmhaR1Z5WDJacFpXeGtBRkJoZFhObFpBQkpiblpoYkdsa0lIZHZjbVFnWlc1amIzVnVkR1Z5WldRQVNXNTJZV3hwWkNCdFpYUm9iMlFnWlc1amIzVnVkR1Z5WldRQVZXNWxlSEJsWTNSbFpDQmphR0Z5SUdsdUlIVnliQ0J6WTJobGJXRUFVbVZ4ZFdWemRDQm9ZWE1nYVc1MllXeHBaQ0JnVkhKaGJuTm1aWEl0Ulc1amIyUnBibWRnQUZOWFNWUkRTRjlRVWs5WVdRQlZVMFZmVUZKUFdGa0FUVXRCUTFSSlZrbFVXUUJWVGxCU1QwTkZVMU5CUWt4RlgwVk9WRWxVV1FCRFQxQlpBRTFQVmtWRVgxQkZVazFCVGtWT1ZFeFpBRlJQVDE5RlFWSk1XUUJPVDFSSlJsa0FSa0ZKVEVWRVgwUkZVRVZPUkVWT1Exa0FRa0ZFWDBkQlZFVlhRVmtBVUV4QldRQlFWVlFBUTBoRlEwdFBWVlFBUjBGVVJWZEJXVjlVU1UxRlQxVlVBRkpGVVZWRlUxUmZWRWxOUlU5VlZBQk9SVlJYVDFKTFgwTlBUazVGUTFSZlZFbE5SVTlWVkFCRFQwNU9SVU5VU1U5T1gxUkpUVVZQVlZRQVRFOUhTVTVmVkVsTlJVOVZWQUJPUlZSWFQxSkxYMUpGUVVSZlZFbE5SVTlWVkFCUVQxTlVBRTFKVTBSSlVrVkRWRVZFWDFKRlVWVkZVMVFBUTB4SlJVNVVYME5NVDFORlJGOVNSVkZWUlZOVUFFTk1TVVZPVkY5RFRFOVRSVVJmVEU5QlJGOUNRVXhCVGtORlJGOVNSVkZWUlZOVUFFSkJSRjlTUlZGVlJWTlVBRWhVVkZCZlVrVlJWVVZUVkY5VFJVNVVYMVJQWDBoVVZGQlRYMUJQVWxRQVVrVlFUMUpVQUVsTlgwRmZWRVZCVUU5VUFGSkZVMFZVWDBOUFRsUkZUbFFBVGs5ZlEwOU9WRVZPVkFCUVFWSlVTVUZNWDBOUFRsUkZUbFFBU0ZCRlgwbE9Wa0ZNU1VSZlEwOU9VMVJCVGxRQVNGQkZYME5DWDFKRlUwVlVBRWRGVkFCSVVFVmZVMVJTU1VOVUFFTlBUa1pNU1VOVUFGUkZUVkJQVWtGU1dWOVNSVVJKVWtWRFZBQlFSVkpOUVU1RlRsUmZVa1ZFU1ZKRlExUUFRMDlPVGtWRFZBQk5WVXhVU1Y5VFZFRlVWVk1BU0ZCRlgwbE9Wa0ZNU1VSZlUxUkJWRlZUQUZSUFQxOU5RVTVaWDFKRlVWVkZVMVJUQUVWQlVreFpYMGhKVGxSVEFGVk9RVlpCU1V4QlFreEZYMFpQVWw5TVJVZEJURjlTUlVGVFQwNVRBRTlRVkVsUFRsTUFVMWRKVkVOSVNVNUhYMUJTVDFSUFEwOU1Vd0JXUVZKSlFVNVVYMEZNVTA5ZlRrVkhUMVJKUVZSRlV3Qk5WVXhVU1ZCTVJWOURTRTlKUTBWVEFFbE9WRVZTVGtGTVgxTkZVbFpGVWw5RlVsSlBVZ0JYUlVKZlUwVlNWa1ZTWDFWT1MwNVBWMDVmUlZKU1QxSUFVa0ZKVEVkVlRsOUZVbEpQVWdCSlJFVk9WRWxVV1Y5UVVrOVdTVVJGVWw5QlZWUklSVTVVU1VOQlZFbFBUbDlGVWxKUFVnQlRVMHhmUTBWU1ZFbEdTVU5CVkVWZlJWSlNUMUlBU1U1V1FVeEpSRjlZWDBaUFVsZEJVa1JGUkY5R1QxSUFVMFZVWDFCQlVrRk5SVlJGVWdCSFJWUmZVRUZTUVUxRlZFVlNBRWhRUlY5VlUwVlNBRk5GUlY5UFZFaEZVZ0JJVUVWZlEwSmZRMGhWVGt0ZlNFVkJSRVZTQUUxTFEwRk1SVTVFUVZJQVUwVlVWVkFBVjBWQ1gxTkZVbFpGVWw5SlUxOUVUMWRPQUZSRlFWSkVUMWRPQUVoUVJWOURURTlUUlVSZlEwOU9Ua1ZEVkVsUFRnQklSVlZTU1ZOVVNVTmZSVmhRU1ZKQlZFbFBUZ0JFU1ZORFQwNU9SVU5VUlVSZlQxQkZVa0ZVU1U5T0FFNVBUbDlCVlZSSVQxSkpWRUZVU1ZaRlgwbE9SazlTVFVGVVNVOU9BRWhRUlY5SlRsWkJURWxFWDFaRlVsTkpUMDRBU0ZCRlgwTkNYMDFGVTFOQlIwVmZRa1ZIU1U0QVUwbFVSVjlKVTE5R1VrOWFSVTRBU0ZCRlgwbE9Wa0ZNU1VSZlNFVkJSRVZTWDFSUFMwVk9BRWxPVmtGTVNVUmZWRTlMUlU0QVJrOVNRa2xFUkVWT0FFVk9TRUZPUTBWZldVOVZVbDlEUVV4TkFFaFFSVjlKVGxaQlRFbEVYMVZTVEFCQ1RFOURTMFZFWDBKWlgxQkJVa1ZPVkVGTVgwTlBUbFJTVDB3QVRVdERUMHdBUVVOTUFFaFFSVjlKVGxSRlVrNUJUQUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRlgxVk9UMFpHU1VOSlFVd0FTRkJGWDA5TEFGVk9URWxPU3dCVlRreFBRMHNBVUZKSkFGSkZWRkpaWDFkSlZFZ0FTRkJGWDBsT1ZrRk1TVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FTRkJGWDFWT1JWaFFSVU5VUlVSZlEwOU9WRVZPVkY5TVJVNUhWRWdBUmt4VlUwZ0FVRkpQVUZCQlZFTklBRTB0VTBWQlVrTklBRlZTU1Y5VVQwOWZURTlPUndCUVVrOURSVk5UU1U1SEFFMUpVME5GVEV4QlRrVlBWVk5mVUVWU1UwbFRWRVZPVkY5WFFWSk9TVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZWMEZTVGtsT1J3QklVRVZmU1U1V1FVeEpSRjlVVWtGT1UwWkZVbDlGVGtOUFJFbE9Sd0JGZUhCbFkzUmxaQ0JEVWt4R0FFaFFSVjlKVGxaQlRFbEVYME5JVlU1TFgxTkpXa1VBVFU5V1JRQkRUMDVVU1U1VlJRQklVRVZmUTBKZlUxUkJWRlZUWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOVdSVkpUU1U5T1gwTlBUVkJNUlZSRkFFaFFSVjlEUWw5VlVreGZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZWa0ZNVlVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYMFZZVkVWT1UwbFBUbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDA1QlRVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwMUZVMU5CUjBWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlZFaFBSRjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1gwWkpSVXhFWDBOUFRWQk1SVlJGQUVSRlRFVlVSUUJJVUVWZlNVNVdRVXhKUkY5RlQwWmZVMVJCVkVVQVNVNVdRVXhKUkY5VFUweGZRMFZTVkVsR1NVTkJWRVVBVUVGVlUwVUFUazlmVWtWVFVFOU9VMFVBVlU1VFZWQlFUMUpVUlVSZlRVVkVTVUZmVkZsUVJRQkhUMDVGQUU1UFZGOUJRME5GVUZSQlFreEZBRk5GVWxaSlEwVmZWVTVCVmtGSlRFRkNURVVBVWtGT1IwVmZUazlVWDFOQlZFbFRSa2xCUWt4RkFFOVNTVWRKVGw5SlUxOVZUbEpGUVVOSVFVSk1SUUJTUlZOUVQwNVRSVjlKVTE5VFZFRk1SUUJRVlZKSFJRQk5SVkpIUlFCU1JWRlZSVk5VWDBoRlFVUkZVbDlHU1VWTVJGTmZWRTlQWDB4QlVrZEZBRkpGVVZWRlUxUmZTRVZCUkVWU1gxUlBUMTlNUVZKSFJRQlFRVmxNVDBGRVgxUlBUMTlNUVZKSFJRQkpUbE5WUmtaSlEwbEZUbFJmVTFSUFVrRkhSUUJJVUVWZlVFRlZVMFZFWDFWUVIxSkJSRVVBU0ZCRlgxQkJWVk5GUkY5SU1sOVZVRWRTUVVSRkFGTlBWVkpEUlFCQlRrNVBWVTVEUlFCVVVrRkRSUUJJVUVWZlZVNUZXRkJGUTFSRlJGOVRVRUZEUlFCRVJWTkRVa2xDUlFCVlRsTlZRbE5EVWtsQ1JRQlNSVU5QVWtRQVNGQkZYMGxPVmtGTVNVUmZUVVZVU0U5RUFFNVBWRjlHVDFWT1JBQlFVazlRUmtsT1JBQlZUa0pKVGtRQVVrVkNTVTVFQUZWT1FWVlVTRTlTU1ZwRlJBQk5SVlJJVDBSZlRrOVVYMEZNVEU5WFJVUUFTRlJVVUY5V1JWSlRTVTlPWDA1UFZGOVRWVkJRVDFKVVJVUUFRVXhTUlVGRVdWOVNSVkJQVWxSRlJBQkJRME5GVUZSRlJBQk9UMVJmU1UxUVRFVk5SVTVVUlVRQVRFOVBVRjlFUlZSRlExUkZSQUJJVUVWZlExSmZSVmhRUlVOVVJVUUFTRkJGWDB4R1gwVllVRVZEVkVWRUFFTlNSVUZVUlVRQVNVMWZWVk5GUkFCSVVFVmZVRUZWVTBWRUFGUkpUVVZQVlZSZlQwTkRWVkpGUkFCUVFWbE5SVTVVWDFKRlVWVkpVa1ZFQUZCU1JVTlBUa1JKVkVsUFRsOVNSVkZWU1ZKRlJBQlFVazlZV1Y5QlZWUklSVTVVU1VOQlZFbFBUbDlTUlZGVlNWSkZSQUJPUlZSWFQxSkxYMEZWVkVoRlRsUkpRMEZVU1U5T1gxSkZVVlZKVWtWRUFFeEZUa2RVU0Y5U1JWRlZTVkpGUkFCVFUweGZRMFZTVkVsR1NVTkJWRVZmVWtWUlZVbFNSVVFBVlZCSFVrRkVSVjlTUlZGVlNWSkZSQUJRUVVkRlgwVllVRWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMFpCU1V4RlJBQkZXRkJGUTFSQlZFbFBUbDlHUVVsTVJVUUFVa1ZXUVV4SlJFRlVTVTlPWDBaQlNVeEZSQUJUVTB4ZlNFRk9SRk5JUVV0RlgwWkJTVXhGUkFCTVQwTkxSVVFBVkZKQlRsTkdUMUpOUVZSSlQwNWZRVkJRVEVsRlJBQk9UMVJmVFU5RVNVWkpSVVFBVGs5VVgwVllWRVZPUkVWRUFFSkJUa1JYU1VSVVNGOU1TVTFKVkY5RldFTkZSVVJGUkFCVFNWUkZYMGxUWDA5V1JWSk1UMEZFUlVRQVNFVkJSQUJGZUhCbFkzUmxaQ0JJVkZSUUx3QUFYaE1BQUNZVEFBQXdFQUFBOEJjQUFKMFRBQUFWRWdBQU9SY0FBUEFTQUFBS0VBQUFkUklBQUswU0FBQ0NFd0FBVHhRQUFIOFFBQUNnRlFBQUl4UUFBSWtTQUFDTEZBQUFUUlVBQU5RUkFBRFBGQUFBRUJnQUFNa1dBQURjRmdBQXdSRUFBT0FYQUFDN0ZBQUFkQlFBQUh3VkFBRGxGQUFBQ0JjQUFCOFFBQUJsRlFBQW94UUFBQ2dWQUFBQ0ZRQUFtUlVBQUN3UUFBQ0xHUUFBVHc4QUFOUU9BQUJxRUFBQXpoQUFBQUlYQUFDSkRnQUFiaE1BQUJ3VEFBQm1GQUFBVmhjQUFNRVRBQURORXdBQWJCTUFBR2dYQUFCbUZ3QUFYeGNBQUNJVEFBRE9Ed0FBYVE0QUFOZ09BQUJqRmdBQXl4TUFBS29PQUFBb0Z3QUFKaGNBQU1VVEFBQmRGZ0FBNkJFQUFHY1RBQUJsRXdBQThoWUFBSE1UQUFBZEZ3QUErUllBQVBNUkFBRFBEZ0FBemhVQUFBd1NBQUN6RVFBQXBSRUFBR0VRQUFBeUZ3QUF1eE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJREFnSUNBZ0lBQUFJQ0FBSUNBQUlDQWdJQ0FnSUNBZ0lBQkFBQUFBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBQUFDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdBQ0FBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBQUlDQWdJQ0FBQUNBZ0FDQWdBQ0FnSUNBZ0lDQWdJQ0FBTUFCQUFBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ0FDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWJHOXpaV1ZsY0MxaGJHbDJaUUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCWTJoMWJtdGxaQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQUFBRUJBQUVCQUFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQUFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBQUFBQUFBQUFBQUFBQUFBQUFBQnlZVzV6Wm1WeUxXVnVZMjlrYVc1bmNHZHlZV1JsRFFvTkNnMEtVMDBOQ2cwS1ZGUlFMME5GTDFSVFVDOEFBQUFBQUFBQUFBQUFBQUFCQWdBQkF3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFRSUFBUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQVFFRkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQUFRQUFBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUlBQUFBQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQk9UMVZPUTBWRlEwdFBWVlJPUlVOVVJWUkZRMUpKUWtWTVZWTklSVlJGUVVSVFJVRlNRMGhTUjBWRFZFbFdTVlJaVEVWT1JFRlNWa1ZQVkVsR1dWQlVTVTlPVTBOSVUwVkJXVk5VUVZSRFNFZEZUMUpFU1ZKRlExUlBVbFJTUTBoUVFWSkJUVVZVUlZKVlVrTkZRbE5EVWtsQ1JVRlNSRTlYVGtGRFJVbE9SRTVMUTB0VlFsTkRVa2xDUlVoVVZGQXZRVVJVVUM4PSdcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC13YXNtLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module) => {

eval("module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzP2M3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFCTUFoZ0FYOEJmMkFEZjM5L0FYOWdCSDkvZjM4QmYyQUFBR0FEZjM5L0FHQUJmd0JnQW45L0FHQUdmMzkvZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBQ0EyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUEwWkZBd01FQUFBRkFBQUFBQUFBQlFFRkFBVUZCUUFBQmdBQUFBQUdCZ1lHQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFBQkFRY0FBQVVGQXdBQkJBVUJjQUVTRWdVREFRQUNCZ2dCZndGQmdOUUVDd2ZSQlNJR2JXVnRiM0o1QWdBTFgybHVhWFJwWVd4cGVtVUFDUmxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFMYkd4b2RIUndYMmx1YVhRQUNoaHNiR2gwZEhCZmMyaHZkV3hrWDJ0bFpYQmZZV3hwZG1VQVFReHNiR2gwZEhCZllXeHNiMk1BREFadFlXeHNiMk1BUmd0c2JHaDBkSEJmWm5KbFpRQU5CR1p5WldVQVNBOXNiR2gwZEhCZloyVjBYM1I1Y0dVQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXRnFiM0lBRHhWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldsdWIzSUFFQkZzYkdoMGRIQmZaMlYwWDIxbGRHaHZaQUFSRm14c2FIUjBjRjluWlhSZmMzUmhkSFZ6WDJOdlpHVUFFaEpzYkdoMGRIQmZaMlYwWDNWd1ozSmhaR1VBRXd4c2JHaDBkSEJmY21WelpYUUFGQTVzYkdoMGRIQmZaWGhsWTNWMFpRQVZGR3hzYUhSMGNGOXpaWFIwYVc1bmMxOXBibWwwQUJZTmJHeG9kSFJ3WDJacGJtbHphQUFYREd4c2FIUjBjRjl3WVhWelpRQVlEV3hzYUhSMGNGOXlaWE4xYldVQUdSdHNiR2gwZEhCZmNtVnpkVzFsWDJGbWRHVnlYM1Z3WjNKaFpHVUFHaEJzYkdoMGRIQmZaMlYwWDJWeWNtNXZBQnNYYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl5WldGemIyNEFIQmRzYkdoMGRIQmZjMlYwWDJWeWNtOXlYM0psWVhOdmJnQWRGR3hzYUhSMGNGOW5aWFJmWlhKeWIzSmZjRzl6QUI0UmJHeG9kSFJ3WDJWeWNtNXZYMjVoYldVQUh4SnNiR2gwZEhCZmJXVjBhRzlrWDI1aGJXVUFJQkpzYkdoMGRIQmZjM1JoZEhWelgyNWhiV1VBSVJwc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmFHVmhaR1Z5Y3dBaUlXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOWphSFZ1YTJWa1gyeGxibWQwYUFBakhXeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXJaV1Z3WDJGc2FYWmxBQ1FrYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNSeVlXNXpabVZ5WDJWdVkyOWthVzVuQUNVWWJHeG9kSFJ3WDIxbGMzTmhaMlZmYm1WbFpITmZaVzltQUQ4SkZ3RUFRUUVMRVFFQ0F3UUZDd1lITlRrM01TOHRKeXNwQ3JMZ0FrVUNBQXNJQUJDSWdJQ0FBQXNaQUNBQUVNS0FnSUFBR2lBQUlBSTJBamdnQUNBQk9nQW9DeHdBSUFBZ0FDOEJNaUFBTFFBdUlBQVF3WUNBZ0FBUWdJQ0FnQUFMS2dFQmYwSEFBQkRHZ0lDQUFDSUJFTUtBZ0lBQUdpQUJRWUNJZ0lBQU5nSTRJQUVnQURvQUtDQUJDd29BSUFBUXlJQ0FnQUFMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFJRRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJEQ2dJQ0FBQm9nQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk2QUMwZ0FDQUJOZ0lZQ3hFQUlBQWdBU0FCSUFKcUVNT0FnSUFBQ3hBQUlBQkJBRUhjQUJETWdJQ0FBQm9MWndFQmYwRUFJUUVDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBdkRnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkdBZ0lDQUFBQWlBUTBEQzBFQUR3c1F5b0NBZ0FBQUN5QUFRY09XZ0lBQU5nSVFRUTRoQVFzZ0FRc2VBQUpBSUFBb0Fnd05BQ0FBUWRHYmdJQUFOZ0lRSUFCQkZUWUNEQXNMRmdBQ1FDQUFLQUlNUVJWSERRQWdBRUVBTmdJTUN3c1dBQUpBSUFBb0FneEJGa2NOQUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNpQUFKQUlBQkJKRWtOQUJES2dJQ0FBQUFMSUFCQkFuUkJvTE9BZ0FCcUtBSUFDeUlBQWtBZ0FFRXVTUTBBRU1xQWdJQUFBQXNnQUVFQ2RFR3d0SUNBQUdvb0FnQUw3Z3NCQVg5QjY2aUFnQUFoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkJuSDlxRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaHA0Q0FBQThMUWFTaGdJQUFEd3RCeTZ5QWdBQVBDMEgrc1lDQUFBOExRY0NrZ0lBQUR3dEJxNlNBZ0FBUEMwR05xSUNBQUE4TFFlS21nSUFBRHd0QmdMQ0FnQUFQQzBHNXI0Q0FBQThMUWRla2dJQUFEd3RCNzUrQWdBQVBDMEhobjRDQUFBOExRZnFmZ0lBQUR3dEI4cUNBZ0FBUEMwR29yNENBQUE4TFFhNnlnSUFBRHd0QmlMQ0FnQUFQQzBIc3A0Q0FBQThMUVlLaWdJQUFEd3RCanAyQWdBQVBDMEhRcm9DQUFBOExRY3FqZ0lBQUR3dEJ4YktBZ0FBUEMwSGZuSUNBQUE4TFFkS2NnSUFBRHd0QnhLQ0FnQUFQQzBIWG9JQ0FBQThMUWFLZmdJQUFEd3RCN2E2QWdBQVBDMEdyc0lDQUFBOExRZFNsZ0lBQUR3dEJ6SzZBZ0FBUEMwSDZyb0NBQUE4TFFmeXJnSUFBRHd0QjByQ0FnQUFQQzBIeG5ZQ0FBQThMUWJ1Z2dJQUFEd3RCOTZ1QWdBQVBDMEdRc1lDQUFBOExRZGV4Z0lBQUR3dEJvcTJBZ0FBUEMwSFVwNENBQUE4TFFlQ3JnSUFBRHd0Qm42eUFnQUFQQzBIcnNZQ0FBQThMUWRXZmdJQUFEd3RCeXJHQWdBQVBDMEhlcFlDQUFBOExRZFNlZ0lBQUR3dEI5SnlBZ0FBUEMwR25zb0NBQUE4TFFiR2RnSUFBRHd0Qm9KMkFnQUFQQzBHNXNZQ0FBQThMUWJ5d2dJQUFEd3RCa3FHQWdBQVBDMEd6cG9DQUFBOExRZW1zZ0lBQUR3dEJySjZBZ0FBUEMwSFVxNENBQUE4TFFmZW1nSUFBRHd0QmdLYUFnQUFQQzBHd29ZQ0FBQThMUWY2ZWdJQUFEd3RCamFPQWdBQVBDMEdKcllDQUFBOExRZmVpZ0lBQUR3dEJvTEdBZ0FBUEMwR3VuNENBQUE4TFFjYWxnSUFBRHd0QjZKNkFnQUFQQzBHVG9vQ0FBQThMUWNLdmdJQUFEd3RCdzUyQWdBQVBDMEdMcklDQUFBOExRZUdkZ0lBQUR3dEJqYStBZ0FBUEMwSHFvWUNBQUE4TFFiU3RnSUFBRHd0QjBxK0FnQUFQQzBIZnNvQ0FBQThMUWRLeWdJQUFEd3RCOExDQWdBQVBDMEdwb29DQUFBOExRZm1qZ0lBQUR3dEJtWjZBZ0FBUEMwRzFySUNBQUE4TFFadXdnSUFBRHd0QmtyS0FnQUFQQzBHMnE0Q0FBQThMUWNLaWdJQUFEd3RCK0xLQWdBQVBDMEdlcFlDQUFBOExRZENpZ0lBQUR3dEJ1cDZBZ0FBUEMwR0Jub0NBQUE4TEVNcUFnSUFBQUF0QjFxR0FnQUFoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FnQWlCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NCQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFjYVJnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUl3SWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREMwa0JBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWdnaUJFVU5BQ0FBSUFFZ0FpQUJheUFFRVlHQWdJQUFBQ0lEUVg5SERRQWdBRUgyaW9DQUFEWUNFRUVZSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ05DSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RKQVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSU1JZ1JGRFFBZ0FDQUJJQUlnQVdzZ0JCR0JnSUNBQUFBaUEwRi9SdzBBSUFCQjdacUFnQUEyQWhCQkdDRURDeUFEQ3k0QkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BamdpQkVVTkFDQUFJQVFSZ0lDQWdBQUFJUU1MSUFNTFNRRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDRUNJRVJRMEFJQUFnQVNBQ0lBRnJJQVFSZ1lDQWdBQUFJZ05CZjBjTkFDQUFRWldRZ0lBQU5nSVFRUmdoQXdzZ0F3c3VBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJOElnUkZEUUFnQUNBRUVZQ0FnSUFBQUNFREN5QURDMGtCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FoUWlCRVVOQUNBQUlBRWdBaUFCYXlBRUVZR0FnSUFBQUNJRFFYOUhEUUFnQUVHcW00Q0FBRFlDRUVFWUlRTUxJQU1MTGdFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NRQ0lFUlEwQUlBQWdCQkdBZ0lDQUFBQWhBd3NnQXd0SkFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUlZSWdSRkRRQWdBQ0FCSUFJZ0FXc2dCQkdCZ0lDQUFBQWlBMEYvUncwQUlBQkI3Wk9BZ0FBMkFoQkJHQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWtRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ0pDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3N1QVFKL1FRQWhBd0pBSUFBb0FqZ2lCRVVOQUNBRUtBSXNJZ1JGRFFBZ0FDQUVFWUNBZ0lBQUFDRURDeUFEQzBrQkFuOUJBQ0VEQWtBZ0FDZ0NPQ0lFUlEwQUlBUW9BaWdpQkVVTkFDQUFJQUVnQWlBQmF5QUVFWUdBZ0lBQUFDSURRWDlIRFFBZ0FFSDJpSUNBQURZQ0VFRVlJUU1MSUFNTExnRUNmMEVBSVFNQ1FDQUFLQUk0SWdSRkRRQWdCQ2dDVUNJRVJRMEFJQUFnQkJHQWdJQ0FBQUFoQXdzZ0F3dEpBUUovUVFBaEF3SkFJQUFvQWpnaUJFVU5BQ0FFS0FJY0lnUkZEUUFnQUNBQklBSWdBV3NnQkJHQmdJQ0FBQUFpQTBGL1J3MEFJQUJCd3BtQWdBQTJBaEJCR0NFREN5QURDeTRCQW45QkFDRURBa0FnQUNnQ09DSUVSUTBBSUFRb0FrZ2lCRVVOQUNBQUlBUVJnSUNBZ0FBQUlRTUxJQU1MU1FFQ2YwRUFJUU1DUUNBQUtBSTRJZ1JGRFFBZ0JDZ0NJQ0lFUlEwQUlBQWdBU0FDSUFGcklBUVJnWUNBZ0FBQUlnTkJmMGNOQUNBQVFaU1VnSUFBTmdJUVFSZ2hBd3NnQXdzdUFRSi9RUUFoQXdKQUlBQW9BamdpQkVVTkFDQUVLQUpNSWdSRkRRQWdBQ0FFRVlDQWdJQUFBQ0VEQ3lBREN5NEJBbjlCQUNFREFrQWdBQ2dDT0NJRVJRMEFJQVFvQWxRaUJFVU5BQ0FBSUFRUmdJQ0FnQUFBSVFNTElBTUxMZ0VDZjBFQUlRTUNRQ0FBS0FJNElnUkZEUUFnQkNnQ1dDSUVSUTBBSUFBZ0JCR0FnSUNBQUFBaEF3c2dBd3RGQVFGL0FrQUNRQ0FBTHdFd1FSUnhRUlJIRFFCQkFTRURJQUF0QUNoQkFVWU5BU0FBTHdFeVFlVUFSaUVEREFFTElBQXRBQ2xCQlVZaEF3c2dBQ0FET2dBdVFRQUwvZ0VCQTM5QkFTRURBa0FnQUM4Qk1DSUVRUWh4RFFBZ0FDa0RJRUlBVWlFREN3SkFBa0FnQUMwQUxrVU5BRUVCSVFVZ0FDMEFLVUVGUmcwQlFRRWhCU0FFUWNBQWNVVWdBM0ZCQVVjTkFRdEJBQ0VGSUFSQndBQnhEUUJCQWlFRklBUkIvLzhEY1NJRFFRaHhEUUFDUUNBRFFZQUVjVVVOQUFKQUlBQXRBQ2hCQVVjTkFDQUFMUUF0UVFweERRQkJCUThMUVFRUEN3SkFJQU5CSUhFTkFBSkFJQUF0QUNoQkFVWU5BQ0FBTHdFeVFmLy9BM0VpQUVHY2YycEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBUVFRaEJTQUVRU2h4UlEwQ0lBTkJpQVJ4UVlBRVJnMENDMEVBRHd0QkFFRURJQUFwQXlCUUd5RUZDeUFGQzJJQkFuOUJBQ0VCQWtBZ0FDMEFLRUVCUmcwQUlBQXZBVEpCLy84RGNTSUNRWngvYWtIa0FFa05BQ0FDUWN3QlJnMEFJQUpCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFTQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUJDeUFCQzZjQkFRTi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUVFQUlRTWdBQzhCTUNJRVFRSnhSUTBCREFJTFFRQWhBeUFBTHdFd0lnUkJBWEZGRFFFTFFRRWhBeUFBTFFBb1FRRkdEUUFnQUM4Qk1rSC8vd054SWdWQm5IOXFRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRVFjQUFjUTBBUVFBaEF5QUVRWWdFY1VHQUJFWU5BQ0FFUVNoeFFRQkhJUU1MSUFCQkFEc0JNQ0FBUVFBNkFDOGdBd3VaQVFFQ2Z3SkFBa0FDUUNBQUxRQXFSUTBBSUFBdEFDdEZEUUJCQUNFQklBQXZBVEFpQWtFQ2NVVU5BUXdDQzBFQUlRRWdBQzhCTUNJQ1FRRnhSUTBCQzBFQklRRWdBQzBBS0VFQlJnMEFJQUF2QVRKQi8vOERjU0lBUVp4L2FrSGtBRWtOQUNBQVFjd0JSZzBBSUFCQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFFZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUJDeUFCQzBrQkFYc2dBRUVRYXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNJQi9Rc0RBQ0FBSUFIOUN3TUFJQUJCTUdvZ0FmMExBd0FnQUVFZ2FpQUIvUXNEQUNBQVFkMEJOZ0ljUVFBTGV3RUJmd0pBSUFBb0Fnd2lBdzBBQWtBZ0FDZ0NCRVVOQUNBQUlBRTJBZ1FMQWtBZ0FDQUJJQUlReElDQWdBQWlBdzBBSUFBb0Fnd1BDeUFBSUFNMkFoeEJBQ0VESUFBb0FnUWlBVVVOQUNBQUlBRWdBaUFBS0FJSUVZR0FnSUFBQUNJQlJRMEFJQUFnQWpZQ0ZDQUFJQUUyQWd3Z0FTRURDeUFEQytUekFRTU9md04rQkg4amdJQ0FnQUJCRUdzaUF5U0FnSUNBQUNBQklRUWdBU0VGSUFFaEJpQUJJUWNnQVNFSUlBRWhDU0FCSVFvZ0FTRUxJQUVoRENBQklRMGdBU0VPSUFFaER3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFLQUljSWhCQmYyb08zUUhhQVFIWkFRSURCQVVHQndnSkNnc01EUTdZQVE4UTF3RVJFdFlCRXhRVkZoY1lHUm9iNEFIZkFSd2RIdFVCSHlBaElpTWtKZFFCSmljb0tTb3JMTk1CMGdFdEx0RUIwQUV2TURFeU16UTFOamM0T1RvN1BEMCtQMEJCUWtORVJVYmJBVWRJU1VyUEFjNEJTODBCVE13QlRVNVBVRkZTVTFSVlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0Fjc0J5Z0c0QWNrQnVRSElBYm9CdXdHOEFiMEJ2Z0cvQWNBQndRSENBY01CeEFIRkFjWUJBTndCQzBFQUlSQU14Z0VMUVE0aEVBekZBUXRCRFNFUURNUUJDMEVQSVJBTXd3RUxRUkFoRUF6Q0FRdEJFeUVRRE1FQkMwRVVJUkFNd0FFTFFSVWhFQXkvQVF0QkZpRVFETDRCQzBFWElSQU12UUVMUVJnaEVBeThBUXRCR1NFUURMc0JDMEVhSVJBTXVnRUxRUnNoRUF5NUFRdEJIQ0VRRExnQkMwRUlJUkFNdHdFTFFSMGhFQXkyQVF0QklDRVFETFVCQzBFZklSQU10QUVMUVFjaEVBeXpBUXRCSVNFUURMSUJDMEVpSVJBTXNRRUxRUjRoRUF5d0FRdEJJeUVRREs4QkMwRVNJUkFNcmdFTFFSRWhFQXl0QVF0QkpDRVFES3dCQzBFbElSQU1xd0VMUVNZaEVBeXFBUXRCSnlFUURLa0JDMEhEQVNFUURLZ0JDMEVwSVJBTXB3RUxRU3NoRUF5bUFRdEJMQ0VRREtVQkMwRXRJUkFNcEFFTFFTNGhFQXlqQVF0Qkx5RVFES0lCQzBIRUFTRVFES0VCQzBFd0lSQU1vQUVMUVRRaEVBeWZBUXRCRENFUURKNEJDMEV4SVJBTW5RRUxRVEloRUF5Y0FRdEJNeUVRREpzQkMwRTVJUkFNbWdFTFFUVWhFQXlaQVF0QnhRRWhFQXlZQVF0QkN5RVFESmNCQzBFNklSQU1sZ0VMUVRZaEVBeVZBUXRCQ2lFUURKUUJDMEUzSVJBTWt3RUxRVGdoRUF5U0FRdEJQQ0VRREpFQkMwRTdJUkFNa0FFTFFUMGhFQXlQQVF0QkNTRVFESTRCQzBFb0lSQU1qUUVMUVQ0aEVBeU1BUXRCUHlFUURJc0JDMEhBQUNFUURJb0JDMEhCQUNFUURJa0JDMEhDQUNFUURJZ0JDMEhEQUNFUURJY0JDMEhFQUNFUURJWUJDMEhGQUNFUURJVUJDMEhHQUNFUURJUUJDMEVxSVJBTWd3RUxRY2NBSVJBTWdnRUxRY2dBSVJBTWdRRUxRY2tBSVJBTWdBRUxRY29BSVJBTWZ3dEJ5d0FoRUF4K0MwSE5BQ0VRREgwTFFjd0FJUkFNZkF0QnpnQWhFQXg3QzBIUEFDRVFESG9MUWRBQUlSQU1lUXRCMFFBaEVBeDRDMEhTQUNFUURIY0xRZE1BSVJBTWRndEIxQUFoRUF4MUMwSFdBQ0VRREhRTFFkVUFJUkFNY3d0QkJpRVFESElMUWRjQUlSQU1jUXRCQlNFUURIQUxRZGdBSVJBTWJ3dEJCQ0VRREc0TFFka0FJUkFNYlF0QjJnQWhFQXhzQzBIYkFDRVFER3NMUWR3QUlSQU1hZ3RCQXlFUURHa0xRZDBBSVJBTWFBdEIzZ0FoRUF4bkMwSGZBQ0VRREdZTFFlRUFJUkFNWlF0QjRBQWhFQXhrQzBIaUFDRVFER01MUWVNQUlSQU1ZZ3RCQWlFUURHRUxRZVFBSVJBTVlBdEI1UUFoRUF4ZkMwSG1BQ0VRREY0TFFlY0FJUkFNWFF0QjZBQWhFQXhjQzBIcEFDRVFERnNMUWVvQUlSQU1XZ3RCNndBaEVBeFpDMEhzQUNFUURGZ0xRZTBBSVJBTVZ3dEI3Z0FoRUF4V0MwSHZBQ0VRREZVTFFmQUFJUkFNVkF0QjhRQWhFQXhUQzBIeUFDRVFERklMUWZNQUlSQU1VUXRCOUFBaEVBeFFDMEgxQUNFUURFOExRZllBSVJBTVRndEI5d0FoRUF4TkMwSDRBQ0VRREV3TFFma0FJUkFNU3d0QitnQWhFQXhLQzBIN0FDRVFERWtMUWZ3QUlSQU1TQXRCL1FBaEVBeEhDMEgrQUNFUURFWUxRZjhBSVJBTVJRdEJnQUVoRUF4RUMwR0JBU0VRREVNTFFZSUJJUkFNUWd0Qmd3RWhFQXhCQzBHRUFTRVFERUFMUVlVQklSQU1Qd3RCaGdFaEVBdytDMEdIQVNFUUREMExRWWdCSVJBTVBBdEJpUUVoRUF3N0MwR0tBU0VRRERvTFFZc0JJUkFNT1F0QmpBRWhFQXc0QzBHTkFTRVFERGNMUVk0QklSQU1OZ3RCandFaEVBdzFDMEdRQVNFUUREUUxRWkVCSVJBTU13dEJrZ0VoRUF3eUMwR1RBU0VRRERFTFFaUUJJUkFNTUF0QmxRRWhFQXd2QzBHV0FTRVFEQzRMUVpjQklSQU1MUXRCbUFFaEVBd3NDMEdaQVNFUURDc0xRWm9CSVJBTUtndEJtd0VoRUF3cEMwR2NBU0VRRENnTFFaMEJJUkFNSnd0Qm5nRWhFQXdtQzBHZkFTRVFEQ1VMUWFBQklSQU1KQXRCb1FFaEVBd2pDMEdpQVNFUURDSUxRYU1CSVJBTUlRdEJwQUVoRUF3Z0MwR2xBU0VRREI4TFFhWUJJUkFNSGd0QnB3RWhFQXdkQzBHb0FTRVFEQndMUWFrQklSQU1Hd3RCcWdFaEVBd2FDMEdyQVNFUURCa0xRYXdCSVJBTUdBdEJyUUVoRUF3WEMwR3VBU0VRREJZTFFRRWhFQXdWQzBHdkFTRVFEQlFMUWJBQklSQU1Fd3RCc1FFaEVBd1NDMEd6QVNFUURCRUxRYklCSVJBTUVBdEJ0QUVoRUF3UEMwRzFBU0VRREE0TFFiWUJJUkFNRFF0QnR3RWhFQXdNQzBHNEFTRVFEQXNMUWJrQklSQU1DZ3RCdWdFaEVBd0pDMEc3QVNFUURBZ0xRY1lCSVJBTUJ3dEJ2QUVoRUF3R0MwRzlBU0VRREFVTFFiNEJJUkFNQkF0QnZ3RWhFQXdEQzBIQUFTRVFEQUlMUWNJQklSQU1BUXRCd1FFaEVBc0RRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUJBT3h3RUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjRmSUNFakpTZy9RRUZFUlVaSFNFbEtTMHhOVDFCUlVsUGVBMWRaVzF4ZFlHSmxabWRvYVdwcmJHMXZjSEZ5YzNSMWRuZDRlWHA3ZkgxK2dBR0NBWVVCaGdHSEFZa0Jpd0dNQVkwQmpnR1BBWkFCa1FHVUFaVUJsZ0dYQVpnQm1RR2FBWnNCbkFHZEFaNEJud0dnQWFFQm9nR2pBYVFCcFFHbUFhY0JxQUdwQWFvQnF3R3NBYTBCcmdHdkFiQUJzUUd5QWJNQnRBRzFBYllCdHdHNEFia0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnSEhBY2dCeVFIS0Fjc0J6QUhOQWM0Qnp3SFFBZEVCMGdIVEFkUUIxUUhXQWRjQjJBSFpBZG9CMndIY0FkMEIzZ0hnQWVFQjRnSGpBZVFCNVFIbUFlY0I2QUhwQWVvQjZ3SHNBZTBCN2dIdkFmQUI4UUh5QWZNQm1RS2tBckFDL2dMK0Fnc2dBU0lFSUFKSERmTUJRZDBCSVJBTS93TUxJQUVpRUNBQ1J3M2RBVUhEQVNFUURQNERDeUFCSWdFZ0FrY05rQUZCOXdBaEVBejlBd3NnQVNJQklBSkhEWVlCUWU4QUlSQU0vQU1MSUFFaUFTQUNSdzEvUWVvQUlSQU0rd01MSUFFaUFTQUNSdzE3UWVnQUlSQU0rZ01MSUFFaUFTQUNSdzE0UWVZQUlSQU0rUU1MSUFFaUFTQUNSdzBhUVJnaEVBejRBd3NnQVNJQklBSkhEUlJCRWlFUURQY0RDeUFCSWdFZ0FrY05XVUhGQUNFUURQWURDeUFCSWdFZ0FrY05Ta0UvSVJBTTlRTUxJQUVpQVNBQ1J3MUlRVHdoRUF6MEF3c2dBU0lCSUFKSERVRkJNU0VRRFBNREN5QUFMUUF1UVFGR0Rlc0RESWNDQ3lBQUlBRWlBU0FDRU1DQWdJQUFRUUZIRGVZQklBQkNBRGNESUF6bkFRc2dBQ0FCSWdFZ0FoQzBnSUNBQUNJUURlY0JJQUVoQVF6MUFnc0NRQ0FCSWdFZ0FrY05BRUVHSVJBTThBTUxJQUFnQVVFQmFpSUJJQUlRdTRDQWdBQWlFQTNvQVNBQklRRU1NUXNnQUVJQU53TWdRUkloRUF6VkF3c2dBU0lRSUFKSERTdEJIU0VRRE8wREN3SkFJQUVpQVNBQ1JnMEFJQUZCQVdvaEFVRVFJUkFNMUFNTFFRY2hFQXpzQXdzZ0FFSUFJQUFwQXlBaUVTQUNJQUVpRUd1dEloSjlJaE1nRXlBUlZoczNBeUFnRVNBU1ZpSVVSUTNsQVVFSUlSQU02d01MQWtBZ0FTSUJJQUpHRFFBZ0FFR0pnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJRUlFoRUF6U0F3dEJDU0VRRE9vREN5QUJJUUVnQUNrRElGQU41QUVnQVNFQkRQSUNDd0pBSUFFaUFTQUNSdzBBUVFzaEVBenBBd3NnQUNBQlFRRnFJZ0VnQWhDMmdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVVQklBRWhBUXp5QWdzZ0FDQUJJZ0VnQWhDNGdJQ0FBQ0lRRGVZQklBRWhBUXdOQ3lBQUlBRWlBU0FDRUxxQWdJQUFJaEFONXdFZ0FTRUJEUEFDQ3dKQUlBRWlBU0FDUncwQVFROGhFQXpsQXdzZ0FTMEFBQ0lRUVR0R0RRZ2dFRUVOUnczb0FTQUJRUUZxSVFFTTd3SUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM29BU0FCSVFFTThnSUxBMEFDUUNBQkxRQUFRZkMxZ0lBQWFpMEFBQ0lRUVFGR0RRQWdFRUVDUnczckFTQUFLQUlFSVJBZ0FFRUFOZ0lFSUFBZ0VDQUJRUUZxSWdFUXVZQ0FnQUFpRUEzcUFTQUJJUUVNOUFJTElBRkJBV29pQVNBQ1J3MEFDMEVTSVJBTTRnTUxJQUFnQVNJQklBSVF1b0NBZ0FBaUVBM3BBU0FCSVFFTUNnc2dBU0lCSUFKSERRWkJHeUVRRE9BREN3SkFJQUVpQVNBQ1J3MEFRUlloRUF6Z0F3c2dBRUdLZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBQ0FCSUFJUXVJQ0FnQUFpRUEzcUFTQUJJUUZCSUNFUURNWURDd0pBSUFFaUFTQUNSZzBBQTBBQ1FDQUJMUUFBUWZDM2dJQUFhaTBBQUNJUVFRSkdEUUFDUUNBUVFYOXFEZ1RsQWV3QkFPc0I3QUVMSUFGQkFXb2hBVUVJSVJBTXlBTUxJQUZCQVdvaUFTQUNSdzBBQzBFVklSQU0zd01MUVJVaEVBemVBd3NEUUFKQUlBRXRBQUJCOExtQWdBQnFMUUFBSWhCQkFrWU5BQ0FRUVg5cURnVGVBZXdCNEFIckFld0JDeUFCUVFGcUlnRWdBa2NOQUF0QkdDRVFETjBEQ3dKQUlBRWlBU0FDUmcwQUlBQkJpNENBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUVISVJBTXhBTUxRUmtoRUF6Y0F3c2dBVUVCYWlFQkRBSUxBa0FnQVNJVUlBSkhEUUJCR2lFUUROc0RDeUFVSVFFQ1FDQVVMUUFBUVhOcURoVGRBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBdTRDN2dMdUF1NEM3Z0x1QXU0QzdnTHVBZ0R1QWd0QkFDRVFJQUJCQURZQ0hDQUFRYStMZ0lBQU5nSVFJQUJCQWpZQ0RDQUFJQlJCQVdvMkFoUU0yZ01MQWtBZ0FTMEFBQ0lRUVR0R0RRQWdFRUVOUnczb0FTQUJRUUZxSVFFTTVRSUxJQUZCQVdvaEFRdEJJaUVRREw4REN3SkFJQUVpRUNBQ1J3MEFRUndoRUF6WUF3dENBQ0VSSUJBaEFTQVFMUUFBUVZCcURqZm5BZVlCQVFJREJBVUdCd2dBQUFBQUFBQUFDUW9MREEwT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUEVCRVNFeFFBQzBFZUlSQU12UU1MUWdJaEVRemxBUXRDQXlFUkRPUUJDMElFSVJFTTR3RUxRZ1VoRVF6aUFRdENCaUVSRE9FQkMwSUhJUkVNNEFFTFFnZ2hFUXpmQVF0Q0NTRVJETjRCQzBJS0lSRU0zUUVMUWdzaEVRemNBUXRDRENFUkROc0JDMElOSVJFTTJnRUxRZzRoRVF6WkFRdENEeUVSRE5nQkMwSUtJUkVNMXdFTFFnc2hFUXpXQVF0Q0RDRVJETlVCQzBJTklSRU0xQUVMUWc0aEVRelRBUXRDRHlFUkROSUJDMElBSVJFQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQkF0QUFCQlVHb09OK1VCNUFFQUFRSURCQVVHQitZQjVnSG1BZVlCNWdIbUFlWUJDQWtLQ3d3TjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQWVZQjVnSG1BZVlCNWdIbUFlWUI1Z0htQVE0UEVCRVNFK1lCQzBJQ0lSRU01QUVMUWdNaEVRempBUXRDQkNFUkRPSUJDMElGSVJFTTRRRUxRZ1loRVF6Z0FRdENCeUVSRE44QkMwSUlJUkVNM2dFTFFna2hFUXpkQVF0Q0NpRVJETndCQzBJTElSRU0yd0VMUWd3aEVRemFBUXRDRFNFUkROa0JDMElPSVJFTTJBRUxRZzhoRVF6WEFRdENDaUVSRE5ZQkMwSUxJUkVNMVFFTFFnd2hFUXpVQVF0Q0RTRVJETk1CQzBJT0lSRU0wZ0VMUWc4aEVRelJBUXNnQUVJQUlBQXBBeUFpRVNBQ0lBRWlFR3V0SWhKOUloTWdFeUFSVmhzM0F5QWdFU0FTVmlJVVJRM1NBVUVmSVJBTXdBTUxBa0FnQVNJQklBSkdEUUFnQUVHSmdJQ0FBRFlDQ0NBQUlBRTJBZ1FnQVNFQlFTUWhFQXluQXd0QklDRVFETDhEQ3lBQUlBRWlFQ0FDRUw2QWdJQUFRWDlxRGdXMkFRREZBZ0hSQWRJQkMwRVJJUkFNcEFNTElBQkJBVG9BTHlBUUlRRU11d01MSUFFaUFTQUNSdzNTQVVFa0lSQU11d01MSUFFaURTQUNSdzBlUWNZQUlSQU11Z01MSUFBZ0FTSUJJQUlRc29DQWdBQWlFQTNVQVNBQklRRU10UUVMSUFFaUVDQUNSdzBtUWRBQUlSQU11QU1MQWtBZ0FTSUJJQUpIRFFCQktDRVFETGdEQ3lBQVFRQTJBZ1FnQUVHTWdJQ0FBRFlDQ0NBQUlBRWdBUkN4Z0lDQUFDSVFEZE1CSUFFaEFRellBUXNDUUNBQkloQWdBa2NOQUVFcElSQU10d01MSUJBdEFBQWlBVUVnUmcwVUlBRkJDVWNOMHdFZ0VFRUJhaUVCREJVTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRCY0xRU29oRUF5MUF3c0NRQ0FCSWhBZ0FrY05BRUVySVJBTXRRTUxBa0FnRUMwQUFDSUJRUWxHRFFBZ0FVRWdSdzNWQVFzZ0FDMEFMRUVJUmczVEFTQVFJUUVNa1FNTEFrQWdBU0lCSUFKSERRQkJMQ0VRRExRREN5QUJMUUFBUVFwSERkVUJJQUZCQVdvaEFRekpBZ3NnQVNJT0lBSkhEZFVCUVM4aEVBeXlBd3NEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FnRUVGMmFnNEVBTndCM0FFQTJnRUxJQUVoQVF6Z0FRc2dBVUVCYWlJQklBSkhEUUFMUVRFaEVBeXhBd3RCTWlFUUlBRWlGQ0FDUmcyd0F5QUNJQlJySUFBb0FnQWlBV29oRlNBVUlBRnJRUU5xSVJZQ1FBTkFJQlF0QUFBaUYwRWdjaUFYSUJkQnYzOXFRZjhCY1VFYVNSdEIvd0Z4SUFGQjhMdUFnQUJxTFFBQVJ3MEJBa0FnQVVFRFJ3MEFRUVloQVF5V0F3c2dBVUVCYWlFQklCUkJBV29pRkNBQ1J3MEFDeUFBSUJVMkFnQU1zUU1MSUFCQkFEWUNBQ0FVSVFFTTJRRUxRVE1oRUNBQkloUWdBa1lOcndNZ0FpQVVheUFBS0FJQUlnRnFJUlVnRkNBQmEwRUlhaUVXQWtBRFFDQVVMUUFBSWhkQklISWdGeUFYUWI5L2FrSC9BWEZCR2trYlFmOEJjU0FCUWZTN2dJQUFhaTBBQUVjTkFRSkFJQUZCQ0VjTkFFRUZJUUVNbFFNTElBRkJBV29oQVNBVVFRRnFJaFFnQWtjTkFBc2dBQ0FWTmdJQURMQURDeUFBUVFBMkFnQWdGQ0VCRE5nQkMwRTBJUkFnQVNJVUlBSkdEYTRESUFJZ0ZHc2dBQ2dDQUNJQmFpRVZJQlFnQVd0QkJXb2hGZ0pBQTBBZ0ZDMEFBQ0lYUVNCeUlCY2dGMEcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhRd29DQUFHb3RBQUJIRFFFQ1FDQUJRUVZIRFFCQkJ5RUJESlFEQ3lBQlFRRnFJUUVnRkVFQmFpSVVJQUpIRFFBTElBQWdGVFlDQUF5dkF3c2dBRUVBTmdJQUlCUWhBUXpYQVFzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFFR0F2b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJBa1lOQ2lBQklRRU0zUUVMSUFGQkFXb2lBU0FDUncwQUMwRXdJUkFNcmdNTFFUQWhFQXl0QXdzQ1FDQUJJZ0VnQWtZTkFBTkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRjJhZzRFMlFIYUFkb0IyUUhhQVFzZ0FVRUJhaUlCSUFKSERRQUxRVGdoRUF5dEF3dEJPQ0VRREt3REN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBZ0VFRUpSdzBEQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQQ0VRREtzREN3TkFBa0FnQVMwQUFDSVFRU0JHRFFBQ1FBSkFJQkJCZG1vT0JOb0JBUUhhQVFBTElCQkJMRVlOMndFTElBRWhBUXdFQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQeUVRREtvREN5QUJJUUVNMndFTFFjQUFJUkFnQVNJVUlBSkdEYWdESUFJZ0ZHc2dBQ2dDQUNJQmFpRVdJQlFnQVd0QkJtb2hGd0pBQTBBZ0ZDMEFBRUVnY2lBQlFZREFnSUFBYWkwQUFFY05BU0FCUVFaR0RZNERJQUZCQVdvaEFTQVVRUUZxSWhRZ0FrY05BQXNnQUNBV05nSUFES2tEQ3lBQVFRQTJBZ0FnRkNFQkMwRTJJUkFNamdNTEFrQWdBU0lQSUFKSERRQkJ3UUFoRUF5bkF3c2dBRUdNZ0lDQUFEWUNDQ0FBSUE4MkFnUWdEeUVCSUFBdEFDeEJmMm9PQk0wQjFRSFhBZGtCaHdNTElBRkJBV29oQVF6TUFRc0NRQ0FCSWdFZ0FrWU5BQU5BQWtBZ0FTMEFBQ0lRUVNCeUlCQWdFRUcvZjJwQi93RnhRUnBKRzBIL0FYRWlFRUVKUmcwQUlCQkJJRVlOQUFKQUFrQUNRQUpBSUJCQm5YOXFEaE1BQXdNREF3TURBd0VEQXdNREF3TURBd01DQXdzZ0FVRUJhaUVCUVRFaEVBeVJBd3NnQVVFQmFpRUJRVEloRUF5UUF3c2dBVUVCYWlFQlFUTWhFQXlQQXdzZ0FTRUJETkFCQ3lBQlFRRnFJZ0VnQWtjTkFBdEJOU0VRREtVREMwRTFJUkFNcEFNTEFrQWdBU0lCSUFKR0RRQURRQUpBSUFFdEFBQkJnTHlBZ0FCcUxRQUFRUUZHRFFBZ0FTRUJETk1CQ3lBQlFRRnFJZ0VnQWtjTkFBdEJQU0VRREtRREMwRTlJUkFNb3dNTElBQWdBU0lCSUFJUXNJQ0FnQUFpRUEzV0FTQUJJUUVNQVFzZ0VFRUJhaUVCQzBFOElSQU1od01MQWtBZ0FTSUJJQUpIRFFCQndnQWhFQXlnQXdzQ1FBTkFBa0FnQVMwQUFFRjNhZzRZQUFMK0F2NENoQVArQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0wrQXY0Qy9nTCtBdjRDL2dMK0F2NEMvZ0lBL2dJTElBRkJBV29pQVNBQ1J3MEFDMEhDQUNFUURLQURDeUFCUVFGcUlRRWdBQzBBTFVFQmNVVU52UUVnQVNFQkMwRXNJUkFNaFFNTElBRWlBU0FDUnczVEFVSEVBQ0VRREowREN3TkFBa0FnQVMwQUFFR1F3SUNBQUdvdEFBQkJBVVlOQUNBQklRRU10d0lMSUFGQkFXb2lBU0FDUncwQUMwSEZBQ0VRREp3REN5QU5MUUFBSWhCQklFWU5zd0VnRUVFNlJ3MkJBeUFBS0FJRUlRRWdBRUVBTmdJRUlBQWdBU0FORUsrQWdJQUFJZ0VOMEFFZ0RVRUJhaUVCRExNQ0MwSEhBQ0VRSUFFaURTQUNSZzJhQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRVnFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRWkRDZ0lBQWFpMEFBRWNOZ0FNZ0FVRUZSZzMwQWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5YUF3dEJ5QUFoRUNBQklnMGdBa1lObVFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRUphaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUdXd29DQUFHb3RBQUJIRGY4Q0FrQWdBVUVKUncwQVFRSWhBUXoxQWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTW1RTUxBa0FnQVNJTklBSkhEUUJCeVFBaEVBeVpBd3NDUUFKQUlBMHRBQUFpQVVFZ2NpQUJJQUZCdjM5cVFmOEJjVUVhU1J0Qi93RnhRWkovYWc0SEFJQURnQU9BQTRBRGdBTUJnQU1MSUExQkFXb2hBVUUrSVJBTWdBTUxJQTFCQVdvaEFVRS9JUkFNL3dJTFFjb0FJUkFnQVNJTklBSkdEWmNESUFJZ0RXc2dBQ2dDQUNJQmFpRVdJQTBnQVd0QkFXb2hGd05BSUEwdEFBQWlGRUVnY2lBVUlCUkJ2MzlxUWY4QmNVRWFTUnRCL3dGeElBRkJvTUtBZ0FCcUxRQUFSdzM5QWlBQlFRRkdEZkFDSUFGQkFXb2hBU0FOUVFGcUlnMGdBa2NOQUFzZ0FDQVdOZ0lBREpjREMwSExBQ0VRSUFFaURTQUNSZzJXQXlBQ0lBMXJJQUFvQWdBaUFXb2hGaUFOSUFGclFRNXFJUmNEUUNBTkxRQUFJaFJCSUhJZ0ZDQVVRYjkvYWtIL0FYRkJHa2tiUWY4QmNTQUJRYUxDZ0lBQWFpMEFBRWNOL0FJZ0FVRU9SZzN3QWlBQlFRRnFJUUVnRFVFQmFpSU5JQUpIRFFBTElBQWdGallDQUF5V0F3dEJ6QUFoRUNBQklnMGdBa1lObFFNZ0FpQU5heUFBS0FJQUlnRnFJUllnRFNBQmEwRVBhaUVYQTBBZ0RTMEFBQ0lVUVNCeUlCUWdGRUcvZjJwQi93RnhRUnBKRzBIL0FYRWdBVUhBd29DQUFHb3RBQUJIRGZzQ0FrQWdBVUVQUncwQVFRTWhBUXp4QWdzZ0FVRUJhaUVCSUExQkFXb2lEU0FDUncwQUN5QUFJQlkyQWdBTWxRTUxRYzBBSVJBZ0FTSU5JQUpHRFpRRElBSWdEV3NnQUNnQ0FDSUJhaUVXSUEwZ0FXdEJCV29oRndOQUlBMHRBQUFpRkVFZ2NpQVVJQlJCdjM5cVFmOEJjVUVhU1J0Qi93RnhJQUZCME1LQWdBQnFMUUFBUnczNkFnSkFJQUZCQlVjTkFFRUVJUUVNOEFJTElBRkJBV29oQVNBTlFRRnFJZzBnQWtjTkFBc2dBQ0FXTmdJQURKUURDd0pBSUFFaURTQUNSdzBBUWM0QUlSQU1sQU1MQWtBQ1FBSkFBa0FnRFMwQUFDSUJRU0J5SUFFZ0FVRy9mMnBCL3dGeFFScEpHMEgvQVhGQm5YOXFEaE1BL1FMOUF2MEMvUUw5QXYwQy9RTDlBdjBDL1FMOUF2MENBZjBDL1FMOUFnSUQvUUlMSUExQkFXb2hBVUhCQUNFUURQMENDeUFOUVFGcUlRRkJ3Z0FoRUF6OEFnc2dEVUVCYWlFQlFjTUFJUkFNK3dJTElBMUJBV29oQVVIRUFDRVFEUG9DQ3dKQUlBRWlBU0FDUmcwQUlBQkJqWUNBZ0FBMkFnZ2dBQ0FCTmdJRUlBRWhBVUhGQUNFUURQb0NDMEhQQUNFUURKSURDeUFRSVFFQ1FBSkFJQkF0QUFCQmRtb09CQUdvQXFnQ0FLZ0NDeUFRUVFGcUlRRUxRU2NoRUF6NEFnc0NRQ0FCSWdFZ0FrY05BRUhSQUNFUURKRURDd0pBSUFFdEFBQkJJRVlOQUNBQklRRU1qUUVMSUFGQkFXb2hBU0FBTFFBdFFRRnhSUTNIQVNBQklRRU1qQUVMSUFFaUZ5QUNSdzNJQVVIU0FDRVFESThEQzBIVEFDRVFJQUVpRkNBQ1JnMk9BeUFDSUJScklBQW9BZ0FpQVdvaEZpQVVJQUZyUVFGcUlSY0RRQ0FVTFFBQUlBRkIxc0tBZ0FCcUxRQUFSdzNNQVNBQlFRRkdEY2NCSUFGQkFXb2hBU0FVUVFGcUloUWdBa2NOQUFzZ0FDQVdOZ0lBREk0REN3SkFJQUVpQVNBQ1J3MEFRZFVBSVJBTWpnTUxJQUV0QUFCQkNrY056QUVnQVVFQmFpRUJETWNCQ3dKQUlBRWlBU0FDUncwQVFkWUFJUkFNalFNTEFrQUNRQ0FCTFFBQVFYWnFEZ1FBelFITkFRSE5BUXNnQVVFQmFpRUJETWNCQ3lBQlFRRnFJUUZCeWdBaEVBenpBZ3NnQUNBQklnRWdBaEN1Z0lDQUFDSVFEY3NCSUFFaEFVSE5BQ0VRRFBJQ0N5QUFMUUFwUVNKR0RZVURES1lDQ3dKQUlBRWlBU0FDUncwQVFkc0FJUkFNaWdNTFFRQWhGRUVCSVJkQkFTRVdRUUFoRUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVkJxRGdyVUFkTUJBQUVDQXdRRkJnalZBUXRCQWlFUURBWUxRUU1oRUF3RkMwRUVJUkFNQkF0QkJTRVFEQU1MUVFZaEVBd0NDMEVISVJBTUFRdEJDQ0VRQzBFQUlSZEJBQ0VXUVFBaEZBek1BUXRCQ1NFUVFRRWhGRUVBSVJkQkFDRVdETXNCQ3dKQUlBRWlBU0FDUncwQVFkMEFJUkFNaVFNTElBRXRBQUJCTGtjTnpBRWdBVUVCYWlFQkRLWUNDeUFCSWdFZ0FrY056QUZCM3dBaEVBeUhBd3NDUUNBQklnRWdBa1lOQUNBQVFZNkFnSUFBTmdJSUlBQWdBVFlDQkNBQklRRkIwQUFoRUF6dUFndEI0QUFoRUF5R0F3dEI0UUFoRUNBQklnRWdBa1lOaFFNZ0FpQUJheUFBS0FJQUloUnFJUllnQVNBVWEwRURhaUVYQTBBZ0FTMEFBQ0FVUWVMQ2dJQUFhaTBBQUVjTnpRRWdGRUVEUmczTUFTQVVRUUZxSVJRZ0FVRUJhaUlCSUFKSERRQUxJQUFnRmpZQ0FBeUZBd3RCNGdBaEVDQUJJZ0VnQWtZTmhBTWdBaUFCYXlBQUtBSUFJaFJxSVJZZ0FTQVVhMEVDYWlFWEEwQWdBUzBBQUNBVVFlYkNnSUFBYWkwQUFFY056QUVnRkVFQ1JnM09BU0FVUVFGcUlSUWdBVUVCYWlJQklBSkhEUUFMSUFBZ0ZqWUNBQXlFQXd0QjR3QWhFQ0FCSWdFZ0FrWU5nd01nQWlBQmF5QUFLQUlBSWhScUlSWWdBU0FVYTBFRGFpRVhBMEFnQVMwQUFDQVVRZW5DZ0lBQWFpMEFBRWNOeXdFZ0ZFRURSZzNPQVNBVVFRRnFJUlFnQVVFQmFpSUJJQUpIRFFBTElBQWdGallDQUF5REF3c0NRQ0FCSWdFZ0FrY05BRUhsQUNFUURJTURDeUFBSUFGQkFXb2lBU0FDRUtpQWdJQUFJaEFOelFFZ0FTRUJRZFlBSVJBTTZRSUxBa0FnQVNJQklBSkdEUUFEUUFKQUlBRXRBQUFpRUVFZ1JnMEFBa0FDUUFKQUlCQkJ1SDlxRGdzQUFjOEJ6d0hQQWM4Qnp3SFBBYzhCendFQ3p3RUxJQUZCQVdvaEFVSFNBQ0VRRE8wQ0N5QUJRUUZxSVFGQjB3QWhFQXpzQWdzZ0FVRUJhaUVCUWRRQUlSQU02d0lMSUFGQkFXb2lBU0FDUncwQUMwSGtBQ0VRRElJREMwSGtBQ0VRRElFREN3TkFBa0FnQVMwQUFFSHd3b0NBQUdvdEFBQWlFRUVCUmcwQUlCQkJmbW9PQTg4QjBBSFJBZElCQ3lBQlFRRnFJZ0VnQWtjTkFBdEI1Z0FoRUF5QUF3c0NRQ0FCSWdFZ0FrWU5BQ0FCUVFGcUlRRU1Bd3RCNXdBaEVBei9BZ3NEUUFKQUlBRXRBQUJCOE1TQWdBQnFMUUFBSWhCQkFVWU5BQUpBSUJCQmZtb09CTklCMHdIVUFRRFZBUXNnQVNFQlFkY0FJUkFNNXdJTElBRkJBV29pQVNBQ1J3MEFDMEhvQUNFUURQNENDd0pBSUFFaUFTQUNSdzBBUWVrQUlSQU0vZ0lMQWtBZ0FTMEFBQ0lRUVhacURocTZBZFVCMVFHOEFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFkVUIxUUhWQWRVQjFRSFZBZFVCMVFIVkFjb0IxUUhWQVFEVEFRc2dBVUVCYWlFQkMwRUdJUkFNNHdJTEEwQUNRQ0FCTFFBQVFmREdnSUFBYWkwQUFFRUJSZzBBSUFFaEFReWVBZ3NnQVVFQmFpSUJJQUpIRFFBTFFlb0FJUkFNK3dJTEFrQWdBU0lCSUFKR0RRQWdBVUVCYWlFQkRBTUxRZXNBSVJBTStnSUxBa0FnQVNJQklBSkhEUUJCN0FBaEVBejZBZ3NnQVVFQmFpRUJEQUVMQWtBZ0FTSUJJQUpIRFFCQjdRQWhFQXo1QWdzZ0FVRUJhaUVCQzBFRUlSQU0zZ0lMQWtBZ0FTSVVJQUpIRFFCQjdnQWhFQXozQWdzZ0ZDRUJBa0FDUUFKQUlCUXRBQUJCOE1pQWdBQnFMUUFBUVg5cURnZlVBZFVCMWdFQW5BSUJBdGNCQ3lBVVFRRnFJUUVNQ2dzZ0ZFRUJhaUVCRE0wQkMwRUFJUkFnQUVFQU5nSWNJQUJCbTVLQWdBQTJBaEFnQUVFSE5nSU1JQUFnRkVFQmFqWUNGQXoyQWdzQ1FBTkFBa0FnQVMwQUFFSHd5SUNBQUdvdEFBQWlFRUVFUmcwQUFrQUNRQ0FRUVg5cURnZlNBZE1CMUFIWkFRQUVBZGtCQ3lBQklRRkIyZ0FoRUF6Z0Fnc2dBVUVCYWlFQlFkd0FJUkFNM3dJTElBRkJBV29pQVNBQ1J3MEFDMEh2QUNFUURQWUNDeUFCUVFGcUlRRU15d0VMQWtBZ0FTSVVJQUpIRFFCQjhBQWhFQXoxQWdzZ0ZDMEFBRUV2UnczVUFTQVVRUUZxSVFFTUJnc0NRQ0FCSWhRZ0FrY05BRUh4QUNFUURQUUNDd0pBSUJRdEFBQWlBVUV2UncwQUlCUkJBV29oQVVIZEFDRVFETnNDQ3lBQlFYWnFJZ1JCRmtzTjB3RkJBU0FFZEVHSmdJQUNjVVVOMHdFTXlnSUxBa0FnQVNJQklBSkdEUUFnQVVFQmFpRUJRZDRBSVJBTTJnSUxRZklBSVJBTThnSUxBa0FnQVNJVUlBSkhEUUJCOUFBaEVBenlBZ3NnRkNFQkFrQWdGQzBBQUVId3pJQ0FBR290QUFCQmYyb09BOGtDbEFJQTFBRUxRZUVBSVJBTTJBSUxBa0FnQVNJVUlBSkdEUUFEUUFKQUlCUXRBQUJCOE1xQWdBQnFMUUFBSWdGQkEwWU5BQUpBSUFGQmYyb09Bc3NDQU5VQkN5QVVJUUZCM3dBaEVBemFBZ3NnRkVFQmFpSVVJQUpIRFFBTFFmTUFJUkFNOFFJTFFmTUFJUkFNOEFJTEFrQWdBU0lCSUFKR0RRQWdBRUdQZ0lDQUFEWUNDQ0FBSUFFMkFnUWdBU0VCUWVBQUlSQU0xd0lMUWZVQUlSQU03d0lMQWtBZ0FTSUJJQUpIRFFCQjlnQWhFQXp2QWdzZ0FFR1BnSUNBQURZQ0NDQUFJQUUyQWdRZ0FTRUJDMEVESVJBTTFBSUxBMEFnQVMwQUFFRWdSdzNEQWlBQlFRRnFJZ0VnQWtjTkFBdEI5d0FoRUF6c0Fnc0NRQ0FCSWdFZ0FrY05BRUg0QUNFUURPd0NDeUFCTFFBQVFTQkhEYzRCSUFGQkFXb2hBUXp2QVFzZ0FDQUJJZ0VnQWhDc2dJQ0FBQ0lRRGM0QklBRWhBUXlPQWdzQ1FDQUJJZ1FnQWtjTkFFSDZBQ0VRRE9vQ0N5QUVMUUFBUWN3QVJ3M1JBU0FFUVFGcUlRRkJFeUVRRE04QkN3SkFJQUVpQkNBQ1J3MEFRZnNBSVJBTTZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQldvaEVBTkFJQVF0QUFBZ0FVSHd6b0NBQUdvdEFBQkhEZEFCSUFGQkJVWU56Z0VnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCK3dBaEVBem9BZ3NDUUNBQklnUWdBa2NOQUVIOEFDRVFET2dDQ3dKQUFrQWdCQzBBQUVHOWYyb09EQURSQWRFQjBRSFJBZEVCMFFIUkFkRUIwUUhSQVFIUkFRc2dCRUVCYWlFQlFlWUFJUkFNendJTElBUkJBV29oQVVIbkFDRVFETTRDQ3dKQUlBRWlCQ0FDUncwQVFmMEFJUkFNNXdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBbW9oRUFKQUEwQWdCQzBBQUNBQlFlM1BnSUFBYWkwQUFFY056d0VnQVVFQ1JnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjBBSVJBTTV3SUxJQUJCQURZQ0FDQVFRUUZxSVFGQkVDRVFETXdCQ3dKQUlBRWlCQ0FDUncwQVFmNEFJUkFNNWdJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJCV29oRUFKQUEwQWdCQzBBQUNBQlFmYk9nSUFBYWkwQUFFY056Z0VnQVVFRlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjRBSVJBTTVnSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkZpRVFETXNCQ3dKQUlBRWlCQ0FDUncwQVFmOEFJUkFNNVFJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBMm9oRUFKQUEwQWdCQzBBQUNBQlFmek9nSUFBYWkwQUFFY056UUVnQVVFRFJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZjhBSVJBTTVRSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkJTRVFETW9CQ3dKQUlBRWlCQ0FDUncwQVFZQUJJUkFNNUFJTElBUXRBQUJCMlFCSERjc0JJQVJCQVdvaEFVRUlJUkFNeVFFTEFrQWdBU0lFSUFKSERRQkJnUUVoRUF6akFnc0NRQUpBSUFRdEFBQkJzbjlxRGdNQXpBRUJ6QUVMSUFSQkFXb2hBVUhyQUNFUURNb0NDeUFFUVFGcUlRRkI3QUFoRUF6SkFnc0NRQ0FCSWdRZ0FrY05BRUdDQVNFUURPSUNDd0pBQWtBZ0JDMEFBRUc0ZjJvT0NBRExBY3NCeXdITEFjc0J5d0VCeXdFTElBUkJBV29oQVVIcUFDRVFETWtDQ3lBRVFRRnFJUUZCN1FBaEVBeklBZ3NDUUNBQklnUWdBa2NOQUVHREFTRVFET0VDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hFQ0FFSUFGclFRSnFJUlFDUUFOQUlBUXRBQUFnQVVHQXo0Q0FBR290QUFCSERja0JJQUZCQWtZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRURZQ0FFR0RBU0VRRE9FQ0MwRUFJUkFnQUVFQU5nSUFJQlJCQVdvaEFRekdBUXNDUUNBQklnUWdBa2NOQUVHRUFTRVFET0FDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRUnFJUkFDUUFOQUlBUXRBQUFnQVVHRHo0Q0FBR290QUFCSERjZ0JJQUZCQkVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR0VBU0VRRE9BQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNNaEVBekZBUXNDUUNBQklnUWdBa2NOQUVHRkFTRVFETjhDQ3dKQUFrQWdCQzBBQUVHMGYyb09DQURJQWNnQnlBSElBY2dCeUFFQnlBRUxJQVJCQVdvaEFVSHZBQ0VRRE1ZQ0N5QUVRUUZxSVFGQjhBQWhFQXpGQWdzQ1FDQUJJZ1FnQWtjTkFFR0dBU0VRRE40Q0N5QUVMUUFBUWNVQVJ3M0ZBU0FFUVFGcUlRRU1nd0lMQWtBZ0FTSUVJQUpIRFFCQmh3RWhFQXpkQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRURhaUVRQWtBRFFDQUVMUUFBSUFGQmlNK0FnQUJxTFFBQVJ3M0ZBU0FCUVFOR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJod0VoRUF6ZEFnc2dBRUVBTmdJQUlCQkJBV29oQVVFdElSQU13Z0VMQWtBZ0FTSUVJQUpIRFFCQmlBRWhFQXpjQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUlhaUVRQWtBRFFDQUVMUUFBSUFGQjBNK0FnQUJxTFFBQVJ3M0VBU0FCUVFoR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJpQUVoRUF6Y0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcElSQU13UUVMQWtBZ0FTSUJJQUpIRFFCQmlRRWhFQXpiQWd0QkFTRVFJQUV0QUFCQjN3QkhEY0FCSUFGQkFXb2hBUXlCQWdzQ1FDQUJJZ1FnQWtjTkFFR0tBU0VRRE5vQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUZxSVJBRFFDQUVMUUFBSUFGQmpNK0FnQUJxTFFBQVJ3M0JBU0FCUVFGR0RhOENJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRWW9CSVJBTTJRSUxBa0FnQVNJRUlBSkhEUUJCaXdFaEVBelpBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQ2FpRVFBa0FEUUNBRUxRQUFJQUZCanMrQWdBQnFMUUFBUnczQkFTQUJRUUpHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQml3RWhFQXpaQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVDSVJBTXZnRUxBa0FnQVNJRUlBSkhEUUJCakFFaEVBellBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOE0rQWdBQnFMUUFBUnczQUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpBRWhFQXpZQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVmSVJBTXZRRUxBa0FnQVNJRUlBSkhEUUJCalFFaEVBelhBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCOHMrQWdBQnFMUUFBUncyL0FTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQmpRRWhFQXpYQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVKSVJBTXZBRUxBa0FnQVNJRUlBSkhEUUJCamdFaEVBeldBZ3NDUUFKQUlBUXRBQUJCdDM5cURnY0F2d0cvQWI4QnZ3Ry9BUUcvQVFzZ0JFRUJhaUVCUWZnQUlSQU12UUlMSUFSQkFXb2hBVUg1QUNFUURMd0NDd0pBSUFFaUJDQUNSdzBBUVk4QklSQU0xUUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUVpIUGdJQUFhaTBBQUVjTnZRRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFZOEJJUkFNMVFJTElBQkJBRFlDQUNBUVFRRnFJUUZCR0NFUURMb0JDd0pBSUFFaUJDQUNSdzBBUVpBQklSQU0xQUlMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpmUGdJQUFhaTBBQUVjTnZBRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaQUJJUkFNMUFJTElBQkJBRFlDQUNBUVFRRnFJUUZCRnlFUURMa0JDd0pBSUFFaUJDQUNSdzBBUVpFQklSQU0wd0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJtb2hFQUpBQTBBZ0JDMEFBQ0FCUVpyUGdJQUFhaTBBQUVjTnV3RWdBVUVHUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaRUJJUkFNMHdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRlNFUURMZ0JDd0pBSUFFaUJDQUNSdzBBUVpJQklSQU0wZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWFIUGdJQUFhaTBBQUVjTnVnRWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaSUJJUkFNMGdJTElBQkJBRFlDQUNBUVFRRnFJUUZCSGlFUURMY0JDd0pBSUFFaUJDQUNSdzBBUVpNQklSQU0wUUlMSUFRdEFBQkJ6QUJIRGJnQklBUkJBV29oQVVFS0lSQU10Z0VMQWtBZ0JDQUNSdzBBUVpRQklSQU0wQUlMQWtBQ1FDQUVMUUFBUWI5L2FnNFBBTGtCdVFHNUFia0J1UUc1QWJrQnVRRzVBYmtCdVFHNUFia0JBYmtCQ3lBRVFRRnFJUUZCL2dBaEVBeTNBZ3NnQkVFQmFpRUJRZjhBSVJBTXRnSUxBa0FnQkNBQ1J3MEFRWlVCSVJBTXp3SUxBa0FDUUNBRUxRQUFRYjkvYWc0REFMZ0JBYmdCQ3lBRVFRRnFJUUZCL1FBaEVBeTJBZ3NnQkVFQmFpRUVRWUFCSVJBTXRRSUxBa0FnQkNBQ1J3MEFRWllCSVJBTXpnSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQVdvaEVBSkFBMEFnQkMwQUFDQUJRYWZQZ0lBQWFpMEFBRWNOdGdFZ0FVRUJSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVpZQklSQU16Z0lMSUFCQkFEWUNBQ0FRUVFGcUlRRkJDeUVRRExNQkN3SkFJQVFnQWtjTkFFR1hBU0VRRE0wQ0N3SkFBa0FDUUFKQUlBUXRBQUJCVTJvT0l3QzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0J1QUc0QWJnQnVBRzRBYmdCdUFHNEFiZ0JBYmdCdUFHNEFiZ0J1QUVDdUFHNEFiZ0JBN2dCQ3lBRVFRRnFJUUZCK3dBaEVBeTJBZ3NnQkVFQmFpRUJRZndBSVJBTXRRSUxJQVJCQVdvaEJFR0JBU0VRRExRQ0N5QUVRUUZxSVFSQmdnRWhFQXl6QWdzQ1FDQUVJQUpIRFFCQm1BRWhFQXpNQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnFjK0FnQUJxTFFBQVJ3MjBBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJtQUVoRUF6TUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFWklSQU1zUUVMQWtBZ0JDQUNSdzBBUVprQklSQU15d0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkJXb2hFQUpBQTBBZ0JDMEFBQ0FCUWE3UGdJQUFhaTBBQUVjTnN3RWdBVUVGUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFaa0JJUkFNeXdJTElBQkJBRFlDQUNBUVFRRnFJUUZCQmlFUURMQUJDd0pBSUFRZ0FrY05BRUdhQVNFUURNb0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFGcUlSQUNRQU5BSUFRdEFBQWdBVUcwejRDQUFHb3RBQUJIRGJJQklBRkJBVVlOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHYUFTRVFETW9DQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUndoRUF5dkFRc0NRQ0FFSUFKSERRQkJtd0VoRUF6SkFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVCYWlFUUFrQURRQ0FFTFFBQUlBRkJ0cytBZ0FCcUxRQUFSdzJ4QVNBQlFRRkdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCbXdFaEVBekpBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRW5JUkFNcmdFTEFrQWdCQ0FDUncwQVFad0JJUkFNeUFJTEFrQUNRQ0FFTFFBQVFheC9hZzRDQUFHeEFRc2dCRUVCYWlFRVFZWUJJUkFNcndJTElBUkJBV29oQkVHSEFTRVFESzRDQ3dKQUlBUWdBa2NOQUVHZEFTRVFETWNDQ3lBQ0lBUnJJQUFvQWdBaUFXb2hGQ0FFSUFGclFRRnFJUkFDUUFOQUlBUXRBQUFnQVVHNHo0Q0FBR290QUFCSERhOEJJQUZCQVVZTkFTQUJRUUZxSVFFZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFR2RBU0VRRE1jQ0N5QUFRUUEyQWdBZ0VFRUJhaUVCUVNZaEVBeXNBUXNDUUNBRUlBSkhEUUJCbmdFaEVBekdBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFQmFpRVFBa0FEUUNBRUxRQUFJQUZCdXMrQWdBQnFMUUFBUncydUFTQUJRUUZHRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQm5nRWhFQXpHQWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVESVJBTXF3RUxBa0FnQkNBQ1J3MEFRWjhCSVJBTXhRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOclFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUVo4QklSQU14UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJEQ0VRREtvQkN3SkFJQVFnQWtjTkFFR2dBU0VRRE1RQ0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUU5xSVJBQ1FBTkFJQVF0QUFBZ0FVRzh6NENBQUdvdEFBQkhEYXdCSUFGQkEwWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdnQVNFUURNUUNDeUFBUVFBMkFnQWdFRUVCYWlFQlFRMGhFQXlwQVFzQ1FDQUVJQUpIRFFCQm9RRWhFQXpEQWdzQ1FBSkFJQVF0QUFCQnVuOXFEZ3NBckFHc0Fhd0JyQUdzQWF3QnJBR3NBYXdCQWF3QkN5QUVRUUZxSVFSQml3RWhFQXlxQWdzZ0JFRUJhaUVFUVl3QklSQU1xUUlMQWtBZ0JDQUNSdzBBUWFJQklSQU13Z0lMSUFRdEFBQkIwQUJIRGFrQklBUkJBV29oQkF6cEFRc0NRQ0FFSUFKSERRQkJvd0VoRUF6QkFnc0NRQUpBSUFRdEFBQkJ0MzlxRGdjQnFnR3FBYW9CcWdHcUFRQ3FBUXNnQkVFQmFpRUVRWTRCSVJBTXFBSUxJQVJCQVdvaEFVRWlJUkFNcGdFTEFrQWdCQ0FDUncwQVFhUUJJUkFNd0FJTElBSWdCR3NnQUNnQ0FDSUJhaUVVSUFRZ0FXdEJBV29oRUFKQUEwQWdCQzBBQUNBQlFjRFBnSUFBYWkwQUFFY05xQUVnQVVFQlJnMEJJQUZCQVdvaEFTQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRYVFCSVJBTXdBSUxJQUJCQURZQ0FDQVFRUUZxSVFGQkhTRVFES1VCQ3dKQUlBUWdBa2NOQUVHbEFTRVFETDhDQ3dKQUFrQWdCQzBBQUVHdWYyb09Bd0NvQVFHb0FRc2dCRUVCYWlFRVFaQUJJUkFNcGdJTElBUkJBV29oQVVFRUlSQU1wQUVMQWtBZ0JDQUNSdzBBUWFZQklSQU12Z0lMQWtBQ1FBSkFBa0FDUUNBRUxRQUFRYjkvYWc0VkFLb0JxZ0dxQWFvQnFnR3FBYW9CcWdHcUFhb0JBYW9CcWdFQ3FnR3FBUU9xQWFvQkJLb0JDeUFFUVFGcUlRUkJpQUVoRUF5b0Fnc2dCRUVCYWlFRVFZa0JJUkFNcHdJTElBUkJBV29oQkVHS0FTRVFES1lDQ3lBRVFRRnFJUVJCandFaEVBeWxBZ3NnQkVFQmFpRUVRWkVCSVJBTXBBSUxBa0FnQkNBQ1J3MEFRYWNCSVJBTXZRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQW1vaEVBSkFBMEFnQkMwQUFDQUJRZTNQZ0lBQWFpMEFBRWNOcFFFZ0FVRUNSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWFjQklSQU12UUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJFU0VRREtJQkN3SkFJQVFnQWtjTkFFR29BU0VRREx3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSEN6NENBQUdvdEFBQkhEYVFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUdvQVNFUURMd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFTd2hFQXloQVFzQ1FDQUVJQUpIRFFCQnFRRWhFQXk3QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUVhaUVRQWtBRFFDQUVMUUFBSUFGQnhjK0FnQUJxTFFBQVJ3MmpBU0FCUVFSR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJxUUVoRUF5N0Fnc2dBRUVBTmdJQUlCQkJBV29oQVVFcklSQU1vQUVMQWtBZ0JDQUNSdzBBUWFvQklSQU11Z0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFtb2hFQUpBQTBBZ0JDMEFBQ0FCUWNyUGdJQUFhaTBBQUVjTm9nRWdBVUVDUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFhb0JJUkFNdWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRkNFUURKOEJDd0pBSUFRZ0FrY05BRUdyQVNFUURMa0NDd0pBQWtBQ1FBSkFJQVF0QUFCQnZuOXFEZzhBQVFLa0FhUUJwQUdrQWFRQnBBR2tBYVFCcEFHa0FhUUJBNlFCQ3lBRVFRRnFJUVJCa3dFaEVBeWlBZ3NnQkVFQmFpRUVRWlFCSVJBTW9RSUxJQVJCQVdvaEJFR1ZBU0VRREtBQ0N5QUVRUUZxSVFSQmxnRWhFQXlmQWdzQ1FDQUVJQUpIRFFCQnJBRWhFQXk0QWdzZ0JDMEFBRUhGQUVjTm53RWdCRUVCYWlFRURPQUJDd0pBSUFRZ0FrY05BRUd0QVNFUURMY0NDeUFDSUFScklBQW9BZ0FpQVdvaEZDQUVJQUZyUVFKcUlSQUNRQU5BSUFRdEFBQWdBVUhOejRDQUFHb3RBQUJIRFo4QklBRkJBa1lOQVNBQlFRRnFJUUVnQkVFQmFpSUVJQUpIRFFBTElBQWdGRFlDQUVHdEFTRVFETGNDQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRUTRoRUF5Y0FRc0NRQ0FFSUFKSERRQkJyZ0VoRUF5MkFnc2dCQzBBQUVIUUFFY05uUUVnQkVFQmFpRUJRU1VoRUF5YkFRc0NRQ0FFSUFKSERRQkJyd0VoRUF5MUFnc2dBaUFFYXlBQUtBSUFJZ0ZxSVJRZ0JDQUJhMEVJYWlFUUFrQURRQ0FFTFFBQUlBRkIwTStBZ0FCcUxRQUFSdzJkQVNBQlFRaEdEUUVnQVVFQmFpRUJJQVJCQVdvaUJDQUNSdzBBQ3lBQUlCUTJBZ0JCcndFaEVBeTFBZ3NnQUVFQU5nSUFJQkJCQVdvaEFVRXFJUkFNbWdFTEFrQWdCQ0FDUncwQVFiQUJJUkFNdEFJTEFrQUNRQ0FFTFFBQVFhdC9hZzRMQUowQm5RR2RBWjBCblFHZEFaMEJuUUdkQVFHZEFRc2dCRUVCYWlFRVFab0JJUkFNbXdJTElBUkJBV29oQkVHYkFTRVFESm9DQ3dKQUlBUWdBa2NOQUVHeEFTRVFETE1DQ3dKQUFrQWdCQzBBQUVHL2Yyb09GQUNjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUdjQVp3Qm5BR2NBWndCbkFHY0Fad0JuQUVCbkFFTElBUkJBV29oQkVHWkFTRVFESm9DQ3lBRVFRRnFJUVJCbkFFaEVBeVpBZ3NDUUNBRUlBSkhEUUJCc2dFaEVBeXlBZ3NnQWlBRWF5QUFLQUlBSWdGcUlSUWdCQ0FCYTBFRGFpRVFBa0FEUUNBRUxRQUFJQUZCMmMrQWdBQnFMUUFBUncyYUFTQUJRUU5HRFFFZ0FVRUJhaUVCSUFSQkFXb2lCQ0FDUncwQUN5QUFJQlEyQWdCQnNnRWhFQXl5QWdzZ0FFRUFOZ0lBSUJCQkFXb2hBVUVoSVJBTWx3RUxBa0FnQkNBQ1J3MEFRYk1CSVJBTXNRSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQm1vaEVBSkFBMEFnQkMwQUFDQUJRZDNQZ0lBQWFpMEFBRWNObVFFZ0FVRUdSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJNQklSQU1zUUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHaUVRREpZQkN3SkFJQVFnQWtjTkFFRzBBU0VRRExBQ0N3SkFBa0FDUUNBRUxRQUFRYnQvYWc0UkFKb0JtZ0dhQVpvQm1nR2FBWm9CbWdHYUFRR2FBWm9CbWdHYUFab0JBcG9CQ3lBRVFRRnFJUVJCblFFaEVBeVlBZ3NnQkVFQmFpRUVRWjRCSVJBTWx3SUxJQVJCQVdvaEJFR2ZBU0VRREpZQ0N3SkFJQVFnQWtjTkFFRzFBU0VRREs4Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUVZxSVJBQ1FBTkFJQVF0QUFBZ0FVSGt6NENBQUdvdEFBQkhEWmNCSUFGQkJVWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUcxQVNFUURLOENDeUFBUVFBMkFnQWdFRUVCYWlFQlFTZ2hFQXlVQVFzQ1FDQUVJQUpIRFFCQnRnRWhFQXl1QWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUNhaUVRQWtBRFFDQUVMUUFBSUFGQjZzK0FnQUJxTFFBQVJ3MldBU0FCUVFKR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ0Z0VoRUF5dUFnc2dBRUVBTmdJQUlCQkJBV29oQVVFSElSQU1rd0VMQWtBZ0JDQUNSdzBBUWJjQklSQU1yUUlMQWtBQ1FDQUVMUUFBUWJ0L2FnNE9BSllCbGdHV0FaWUJsZ0dXQVpZQmxnR1dBWllCbGdHV0FRR1dBUXNnQkVFQmFpRUVRYUVCSVJBTWxBSUxJQVJCQVdvaEJFR2lBU0VRREpNQ0N3SkFJQVFnQWtjTkFFRzRBU0VRREt3Q0N5QUNJQVJySUFBb0FnQWlBV29oRkNBRUlBRnJRUUpxSVJBQ1FBTkFJQVF0QUFBZ0FVSHR6NENBQUdvdEFBQkhEWlFCSUFGQkFrWU5BU0FCUVFGcUlRRWdCRUVCYWlJRUlBSkhEUUFMSUFBZ0ZEWUNBRUc0QVNFUURLd0NDeUFBUVFBMkFnQWdFRUVCYWlFQlFSSWhFQXlSQVFzQ1FDQUVJQUpIRFFCQnVRRWhFQXlyQWdzZ0FpQUVheUFBS0FJQUlnRnFJUlFnQkNBQmEwRUJhaUVRQWtBRFFDQUVMUUFBSUFGQjhNK0FnQUJxTFFBQVJ3MlRBU0FCUVFGR0RRRWdBVUVCYWlFQklBUkJBV29pQkNBQ1J3MEFDeUFBSUJRMkFnQkJ1UUVoRUF5ckFnc2dBRUVBTmdJQUlCQkJBV29oQVVFZ0lSQU1rQUVMQWtBZ0JDQUNSdzBBUWJvQklSQU1xZ0lMSUFJZ0JHc2dBQ2dDQUNJQmFpRVVJQVFnQVd0QkFXb2hFQUpBQTBBZ0JDMEFBQ0FCUWZMUGdJQUFhaTBBQUVjTmtnRWdBVUVCUmcwQklBRkJBV29oQVNBRVFRRnFJZ1FnQWtjTkFBc2dBQ0FVTmdJQVFib0JJUkFNcWdJTElBQkJBRFlDQUNBUVFRRnFJUUZCRHlFUURJOEJDd0pBSUFRZ0FrY05BRUc3QVNFUURLa0NDd0pBQWtBZ0JDMEFBRUczZjJvT0J3Q1NBWklCa2dHU0FaSUJBWklCQ3lBRVFRRnFJUVJCcFFFaEVBeVFBZ3NnQkVFQmFpRUVRYVlCSVJBTWp3SUxBa0FnQkNBQ1J3MEFRYndCSVJBTXFBSUxJQUlnQkdzZ0FDZ0NBQ0lCYWlFVUlBUWdBV3RCQjJvaEVBSkFBMEFnQkMwQUFDQUJRZlRQZ0lBQWFpMEFBRWNOa0FFZ0FVRUhSZzBCSUFGQkFXb2hBU0FFUVFGcUlnUWdBa2NOQUFzZ0FDQVVOZ0lBUWJ3QklSQU1xQUlMSUFCQkFEWUNBQ0FRUVFGcUlRRkJHeUVRREkwQkN3SkFJQVFnQWtjTkFFRzlBU0VRREtjQ0N3SkFBa0FDUUNBRUxRQUFRYjUvYWc0U0FKRUJrUUdSQVpFQmtRR1JBWkVCa1FHUkFRR1JBWkVCa1FHUkFaRUJrUUVDa1FFTElBUkJBV29oQkVHa0FTRVFESThDQ3lBRVFRRnFJUVJCcHdFaEVBeU9BZ3NnQkVFQmFpRUVRYWdCSVJBTWpRSUxBa0FnQkNBQ1J3MEFRYjRCSVJBTXBnSUxJQVF0QUFCQnpnQkhEWTBCSUFSQkFXb2hCQXpQQVFzQ1FDQUVJQUpIRFFCQnZ3RWhFQXlsQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FFTFFBQVFiOS9hZzRWQUFFQ0E1d0JCQVVHbkFHY0Fad0JCd2dKQ2d1Y0FRd05EZytjQVFzZ0JFRUJhaUVCUWVnQUlSQU1tZ0lMSUFSQkFXb2hBVUhwQUNFUURKa0NDeUFFUVFGcUlRRkI3Z0FoRUF5WUFnc2dCRUVCYWlFQlFmSUFJUkFNbHdJTElBUkJBV29oQVVIekFDRVFESllDQ3lBRVFRRnFJUUZCOWdBaEVBeVZBZ3NnQkVFQmFpRUJRZmNBSVJBTWxBSUxJQVJCQVdvaEFVSDZBQ0VRREpNQ0N5QUVRUUZxSVFSQmd3RWhFQXlTQWdzZ0JFRUJhaUVFUVlRQklSQU1rUUlMSUFSQkFXb2hCRUdGQVNFUURKQUNDeUFFUVFGcUlRUkJrZ0VoRUF5UEFnc2dCRUVCYWlFRVFaZ0JJUkFNamdJTElBUkJBV29oQkVHZ0FTRVFESTBDQ3lBRVFRRnFJUVJCb3dFaEVBeU1BZ3NnQkVFQmFpRUVRYW9CSVJBTWl3SUxBa0FnQkNBQ1JnMEFJQUJCa0lDQWdBQTJBZ2dnQUNBRU5nSUVRYXNCSVJBTWl3SUxRY0FCSVJBTW93SUxJQUFnQlNBQ0VLcUFnSUFBSWdFTml3RWdCU0VCREZ3TEFrQWdCaUFDUmcwQUlBWkJBV29oQlF5TkFRdEJ3Z0VoRUF5aEFnc0RRQUpBSUJBdEFBQkJkbW9PQkl3QkFBQ1BBUUFMSUJCQkFXb2lFQ0FDUncwQUMwSERBU0VRREtBQ0N3SkFJQWNnQWtZTkFDQUFRWkdBZ0lBQU5nSUlJQUFnQnpZQ0JDQUhJUUZCQVNFUURJY0NDMEhFQVNFUURKOENDd0pBSUFjZ0FrY05BRUhGQVNFUURKOENDd0pBQWtBZ0J5MEFBRUYyYWc0RUFjNEJ6Z0VBemdFTElBZEJBV29oQmd5TkFRc2dCMEVCYWlFRkRJa0JDd0pBSUFjZ0FrY05BRUhHQVNFUURKNENDd0pBQWtBZ0J5MEFBRUYyYWc0WEFZOEJqd0VCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3R1BBWThCQUk4QkN5QUhRUUZxSVFjTFFiQUJJUkFNaEFJTEFrQWdDQ0FDUncwQVFjZ0JJUkFNblFJTElBZ3RBQUJCSUVjTmpRRWdBRUVBT3dFeUlBaEJBV29oQVVHekFTRVFESU1DQ3lBQklSY0NRQU5BSUJjaUJ5QUNSZzBCSUFjdEFBQkJVR3BCL3dGeEloQkJDazhOekFFQ1FDQUFMd0V5SWhSQm1UTkxEUUFnQUNBVVFRcHNJaFE3QVRJZ0VFSC8vd056SUJSQi92OERjVWtOQUNBSFFRRnFJUmNnQUNBVUlCQnFJaEE3QVRJZ0VFSC8vd054UWVnSFNRMEJDd3RCQUNFUUlBQkJBRFlDSENBQVFjR0pnSUFBTmdJUUlBQkJEVFlDRENBQUlBZEJBV28yQWhRTW5BSUxRY2NCSVJBTW13SUxJQUFnQ0NBQ0VLNkFnSUFBSWhCRkRjb0JJQkJCRlVjTmpBRWdBRUhJQVRZQ0hDQUFJQWcyQWhRZ0FFSEpsNENBQURZQ0VDQUFRUlUyQWd4QkFDRVFESm9DQ3dKQUlBa2dBa2NOQUVITUFTRVFESm9DQzBFQUlSUkJBU0VYUVFFaEZrRUFJUkFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQ1MwQUFFRlFhZzRLbGdHVkFRQUJBZ01FQlFZSWx3RUxRUUloRUF3R0MwRURJUkFNQlF0QkJDRVFEQVFMUVFVaEVBd0RDMEVHSVJBTUFndEJCeUVRREFFTFFRZ2hFQXRCQUNFWFFRQWhGa0VBSVJRTWpnRUxRUWtoRUVFQklSUkJBQ0VYUVFBaEZneU5BUXNDUUNBS0lBSkhEUUJCemdFaEVBeVpBZ3NnQ2kwQUFFRXVSdzJPQVNBS1FRRnFJUWtNeWdFTElBc2dBa2NOamdGQjBBRWhFQXlYQWdzQ1FDQUxJQUpHRFFBZ0FFR09nSUNBQURZQ0NDQUFJQXMyQWdSQnR3RWhFQXorQVF0QjBRRWhFQXlXQWdzQ1FDQUVJQUpIRFFCQjBnRWhFQXlXQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUVhaUVMQTBBZ0JDMEFBQ0FRUWZ6UGdJQUFhaTBBQUVjTmpnRWdFRUVFUmczcEFTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFNBU0VRREpVQ0N5QUFJQXdnQWhDc2dJQ0FBQ0lCRFkwQklBd2hBUXk0QVFzQ1FDQUVJQUpIRFFCQjFBRWhFQXlVQWdzZ0FpQUVheUFBS0FJQUloQnFJUlFnQkNBUWEwRUJhaUVNQTBBZ0JDMEFBQ0FRUVlIUWdJQUFhaTBBQUVjTmp3RWdFRUVCUmcyT0FTQVFRUUZxSVJBZ0JFRUJhaUlFSUFKSERRQUxJQUFnRkRZQ0FFSFVBU0VRREpNQ0N3SkFJQVFnQWtjTkFFSFdBU0VRREpNQ0N5QUNJQVJySUFBb0FnQWlFR29oRkNBRUlCQnJRUUpxSVFzRFFDQUVMUUFBSUJCQmc5Q0FnQUJxTFFBQVJ3Mk9BU0FRUVFKR0RaQUJJQkJCQVdvaEVDQUVRUUZxSWdRZ0FrY05BQXNnQUNBVU5nSUFRZFlCSVJBTWtnSUxBa0FnQkNBQ1J3MEFRZGNCSVJBTWtnSUxBa0FDUUNBRUxRQUFRYnQvYWc0UUFJOEJqd0dQQVk4Qmp3R1BBWThCandHUEFZOEJqd0dQQVk4Qmp3RUJqd0VMSUFSQkFXb2hCRUc3QVNFUURQa0JDeUFFUVFGcUlRUkJ2QUVoRUF6NEFRc0NRQ0FFSUFKSERRQkIyQUVoRUF5UkFnc2dCQzBBQUVISUFFY05qQUVnQkVFQmFpRUVETVFCQ3dKQUlBUWdBa1lOQUNBQVFaQ0FnSUFBTmdJSUlBQWdCRFlDQkVHK0FTRVFEUGNCQzBIWkFTRVFESThDQ3dKQUlBUWdBa2NOQUVIYUFTRVFESThDQ3lBRUxRQUFRY2dBUmczREFTQUFRUUU2QUNnTXVRRUxJQUJCQWpvQUx5QUFJQVFnQWhDbWdJQ0FBQ0lRRFkwQlFjSUJJUkFNOUFFTElBQXRBQ2hCZjJvT0FyY0J1UUc0QVFzRFFBSkFJQVF0QUFCQmRtb09CQUNPQVk0QkFJNEJDeUFFUVFGcUlnUWdBa2NOQUF0QjNRRWhFQXlMQWdzZ0FFRUFPZ0F2SUFBdEFDMUJCSEZGRFlRQ0N5QUFRUUE2QUM4Z0FFRUJPZ0EwSUFFaEFReU1BUXNnRUVFVlJnM2FBU0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXlJQWdzQ1FDQUFJQkFnQWhDMGdJQ0FBQ0lFRFFBZ0VDRUJESUVDQ3dKQUlBUkJGVWNOQUNBQVFRTTJBaHdnQUNBUU5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF5SUFnc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFhZU9nSUFBTmdJUUlBQkJFallDREVFQUlSQU1od0lMSUJCQkZVWU4xZ0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZHFOZ0lBQU5nSVFJQUJCRkRZQ0RFRUFJUkFNaGdJTElBQW9BZ1FoRnlBQVFRQTJBZ1FnRUNBUnAyb2lGaUVCSUFBZ0Z5QVFJQllnRkJzaUVCQzFnSUNBQUNJVVJRMk5BU0FBUVFjMkFod2dBQ0FRTmdJVUlBQWdGRFlDREVFQUlSQU1oUUlMSUFBZ0FDOEJNRUdBQVhJN0FUQWdBU0VCQzBFcUlSQU02Z0VMSUJCQkZVWU4wUUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWU9NZ0lBQU5nSVFJQUJCRXpZQ0RFRUFJUkFNZ2dJTElCQkJGVVlOendFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVpxUGdJQUFOZ0lRSUFCQklqWUNERUVBSVJBTWdRSUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDM2dJQ0FBQ0lRRFFBZ0FVRUJhaUVCREkwQkN5QUFRUXcyQWh3Z0FDQVFOZ0lNSUFBZ0FVRUJhallDRkVFQUlSQU1nQUlMSUJCQkZVWU56QUVnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWnFQZ0lBQU5nSVFJQUJCSWpZQ0RFRUFJUkFNL3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkMzZ0lDQUFDSVFEUUFnQVVFQmFpRUJESXdCQ3lBQVFRMDJBaHdnQUNBUU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTS9nRUxJQkJCRlVZTnlRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU0vUUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJc0JDeUFBUVE0MkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNL0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIQWxZQ0FBRFlDRUNBQVFRSTJBZ3hCQUNFUURQc0JDeUFRUVJWR0RjVUJJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSEdqSUNBQURZQ0VDQUFRU00yQWd4QkFDRVFEUG9CQ3lBQVFSQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNK1FFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJEUEVCQ3lBQVFSRTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTStBRUxJQkJCRlVZTndRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFjYU1nSUFBTmdJUUlBQkJJellDREVFQUlSQU05d0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzVnSUNBQUNJUURRQWdBVUVCYWlFQkRJZ0JDeUFBUVJNMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOWdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkM1Z0lDQUFDSUVEUUFnQVVFQmFpRUJETzBCQ3lBQVFSUTJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTTlRRUxJQkJCRlVZTnZRRWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFacVBnSUFBTmdJUUlBQkJJallDREVFQUlSQU05QUVMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQzNnSUNBQUNJUURRQWdBVUVCYWlFQkRJWUJDeUFBUVJZMkFod2dBQ0FRTmdJTUlBQWdBVUVCYWpZQ0ZFRUFJUkFNOHdFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkMzZ0lDQUFDSUVEUUFnQVVFQmFpRUJET2tCQ3lBQVFSYzJBaHdnQUNBRU5nSU1JQUFnQVVFQmFqWUNGRUVBSVJBTThnRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFEUEVCQzBJQklSRUxJQkJCQVdvaEFRSkFJQUFwQXlBaUVrTC8vLy8vLy8vLy93OVdEUUFnQUNBU1FnU0dJQkdFTndNZ0lBRWhBUXlFQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWEySmdJQUFOZ0lRSUFCQkREWUNERUVBSVJBTTd3RUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFSE5rNENBQURZQ0VDQUFRUXcyQWd4QkFDRVFETzRCQ3lBQUtBSUVJUmNnQUVFQU5nSUVJQkFnRWFkcUloWWhBU0FBSUJjZ0VDQVdJQlFiSWhBUXRZQ0FnQUFpRkVVTmN5QUFRUVUyQWh3Z0FDQVFOZ0lVSUFBZ0ZEWUNERUVBSVJBTTdRRUxJQUJCQURZQ0hDQUFJQkEyQWhRZ0FFR3FuSUNBQURZQ0VDQUFRUTgyQWd4QkFDRVFET3dCQ3lBQUlCQWdBaEMwZ0lDQUFDSUJEUUVnRUNFQkMwRU9JUkFNMFFFTEFrQWdBVUVWUncwQUlBQkJBallDSENBQUlCQTJBaFFnQUVHd21JQ0FBRFlDRUNBQVFSVTJBZ3hCQUNFUURPb0JDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkJwNDZBZ0FBMkFoQWdBRUVTTmdJTVFRQWhFQXpwQVFzZ0FVRUJhaUVRQWtBZ0FDOEJNQ0lCUVlBQmNVVU5BQUpBSUFBZ0VDQUNFTHVBZ0lBQUlnRU5BQ0FRSVFFTWNBc2dBVUVWUncyNkFTQUFRUVUyQWh3Z0FDQVFOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBenBBUXNDUUNBQlFhQUVjVUdnQkVjTkFDQUFMUUF0UVFKeERRQWdBRUVBTmdJY0lBQWdFRFlDRkNBQVFaYVRnSUFBTmdJUUlBQkJCRFlDREVFQUlSQU02UUVMSUFBZ0VDQUNFTDJBZ0lBQUdpQVFJUUVDUUFKQUFrQUNRQUpBSUFBZ0VDQUNFTE9BZ0lBQURoWUNBUUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFEQkFzZ0FFRUJPZ0F1Q3lBQUlBQXZBVEJCd0FCeU93RXdJQkFoQVF0QkppRVFETkVCQ3lBQVFTTTJBaHdnQUNBUU5nSVVJQUJCcFphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF6cEFRc2dBRUVBTmdJY0lBQWdFRFlDRkNBQVFkV0xnSUFBTmdJUUlBQkJFVFlDREVFQUlSQU02QUVMSUFBdEFDMUJBWEZGRFFGQnd3RWhFQXpPQVFzQ1FDQU5JQUpHRFFBRFFBSkFJQTB0QUFCQklFWU5BQ0FOSVFFTXhBRUxJQTFCQVdvaURTQUNSdzBBQzBFbElSQU01d0VMUVNVaEVBem1BUXNnQUNnQ0JDRUVJQUJCQURZQ0JDQUFJQVFnRFJDdmdJQ0FBQ0lFUlEydEFTQUFRU1kyQWh3Z0FDQUVOZ0lNSUFBZ0RVRUJhallDRkVFQUlSQU01UUVMSUJCQkZVWU5xd0VnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRZjJOZ0lBQU5nSVFJQUJCSFRZQ0RFRUFJUkFNNUFFTElBQkJKellDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6akFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQUNRQUpBSUFBdEFDeEJmbW9PQndZRkJRTUJBZ0FGQ3lBQUlBQXZBVEJCQ0hJN0FUQU1Bd3RCQWlFVURBRUxRUVFoRkFzZ0FFRUJPZ0FzSUFBZ0FDOEJNQ0FVY2pzQk1Bc2dFQ0VCQzBFcklSQU15Z0VMSUFCQkFEWUNIQ0FBSUJBMkFoUWdBRUdya29DQUFEWUNFQ0FBUVFzMkFneEJBQ0VRRE9JQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjRZK0FnQUEyQWhBZ0FFRUtOZ0lNUVFBaEVBemhBUXNnQUVFQU9nQXNJQkFoQVF5OUFRc2dFQ0VCUVFFaEZBSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQUFVTElBQWdBQzhCTUVFSWNqc0JNQXdEQzBFQ0lSUU1BUXRCQkNFVUN5QUFRUUU2QUN3Z0FDQUFMd0V3SUJSeU93RXdDeUFRSVFFTFFTa2hFQXpGQVFzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWZDVWdJQUFOZ0lRSUFCQkF6WUNERUVBSVJBTTNRRUxBa0FnRGkwQUFFRU5SdzBBSUFBb0FnUWhBU0FBUVFBMkFnUUNRQ0FBSUFFZ0RoQ3hnSUNBQUNJQkRRQWdEa0VCYWlFQkRIVUxJQUJCTERZQ0hDQUFJQUUyQWd3Z0FDQU9RUUZxTmdJVVFRQWhFQXpkQVFzZ0FDMEFMVUVCY1VVTkFVSEVBU0VRRE1NQkN3SkFJQTRnQWtjTkFFRXRJUkFNM0FFTEFrQUNRQU5BQWtBZ0RpMEFBRUYyYWc0RUFnQUFBd0FMSUE1QkFXb2lEaUFDUncwQUMwRXRJUkFNM1FFTElBQW9BZ1FoQVNBQVFRQTJBZ1FDUUNBQUlBRWdEaEN4Z0lDQUFDSUJEUUFnRGlFQkRIUUxJQUJCTERZQ0hDQUFJQTQyQWhRZ0FDQUJOZ0lNUVFBaEVBemNBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBT0VMR0FnSUFBSWdFTkFDQU9RUUZxSVFFTWN3c2dBRUVzTmdJY0lBQWdBVFlDRENBQUlBNUJBV28yQWhSQkFDRVFETnNCQ3lBQUtBSUVJUVFnQUVFQU5nSUVJQUFnQkNBT0VMR0FnSUFBSWdRTm9BRWdEaUVCRE00QkN5QVFRU3hIRFFFZ0FVRUJhaUVRUVFFaEFRSkFBa0FDUUFKQUFrQWdBQzBBTEVGN2FnNEVBd0VDQkFBTElCQWhBUXdFQzBFQ0lRRU1BUXRCQkNFQkN5QUFRUUU2QUN3Z0FDQUFMd0V3SUFGeU93RXdJQkFoQVF3QkN5QUFJQUF2QVRCQkNISTdBVEFnRUNFQkMwRTVJUkFNdndFTElBQkJBRG9BTENBQklRRUxRVFFoRUF5OUFRc2dBQ0FBTHdFd1FTQnlPd0V3SUFFaEFRd0NDeUFBS0FJRUlRUWdBRUVBTmdJRUFrQWdBQ0FFSUFFUXNZQ0FnQUFpQkEwQUlBRWhBUXpIQVFzZ0FFRTNOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRE5RQkN5QUFRUWc2QUN3Z0FTRUJDMEV3SVJBTXVRRUxBa0FnQUMwQUtFRUJSZzBBSUFFaEFRd0VDeUFBTFFBdFFRaHhSUTJUQVNBQklRRU1Bd3NnQUMwQU1FRWdjUTJVQVVIRkFTRVFETGNCQ3dKQUlBOGdBa1lOQUFKQUEwQUNRQ0FQTFFBQVFWQnFJZ0ZCL3dGeFFRcEpEUUFnRHlFQlFUVWhFQXk2QVFzZ0FDa0RJQ0lSUXBtejVzeVpzK2JNR1ZZTkFTQUFJQkZDQ240aUVUY0RJQ0FSSUFHdFF2OEJneUlTUW4rRlZnMEJJQUFnRVNBU2ZEY0RJQ0FQUVFGcUlnOGdBa2NOQUF0Qk9TRVFETkVCQ3lBQUtBSUVJUUlnQUVFQU5nSUVJQUFnQWlBUFFRRnFJZ1FRc1lDQWdBQWlBZzJWQVNBRUlRRU13d0VMUVRraEVBelBBUXNDUUNBQUx3RXdJZ0ZCQ0hGRkRRQWdBQzBBS0VFQlJ3MEFJQUF0QUMxQkNIRkZEWkFCQ3lBQUlBRkI5L3NEY1VHQUJISTdBVEFnRHlFQkMwRTNJUkFNdEFFTElBQWdBQzhCTUVFUWNqc0JNQXlyQVFzZ0VFRVZSZzJMQVNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOEk2QWdBQTJBaEFnQUVFY05nSU1RUUFoRUF6TEFRc2dBRUhEQURZQ0hDQUFJQUUyQWd3Z0FDQU5RUUZxTmdJVVFRQWhFQXpLQVFzQ1FDQUJMUUFBUVRwSERRQWdBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUsrQWdJQUFJaEFOQUNBQlFRRnFJUUVNWXdzZ0FFSERBRFlDSENBQUlCQTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBektBUXNnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRYkdSZ0lBQU5nSVFJQUJCQ2pZQ0RFRUFJUkFNeVFFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVHZ21ZQ0FBRFlDRUNBQVFSNDJBZ3hCQUNFUURNZ0JDeUFBUVFBMkFnQUxJQUJCZ0JJN0FTb2dBQ0FYUVFGcUlnRWdBaENvZ0lDQUFDSVFEUUVnQVNFQkMwSEhBQ0VRREt3QkN5QVFRUlZIRFlNQklBQkIwUUEyQWh3Z0FDQUJOZ0lVSUFCQjQ1ZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBekVBUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNWGdzZ0FFSFNBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF6REFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFjR29nSUFBTmdJUUlBQkJCellDRENBQVFRQTJBZ0JCQUNFUURNSUJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhkQ3lBQVFkTUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRRE1FQkMwRUFJUkFnQUVFQU5nSWNJQUFnQVRZQ0ZDQUFRWUNSZ0lBQU5nSVFJQUJCQ1RZQ0RBekFBUXNnRUVFVlJnMTlJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFR1VqWUNBQURZQ0VDQUFRU0UyQWd4QkFDRVFETDhCQzBFQklSWkJBQ0VYUVFBaEZFRUJJUkFMSUFBZ0VEb0FLeUFCUVFGcUlRRUNRQUpBSUFBdEFDMUJFSEVOQUFKQUFrQUNRQ0FBTFFBcURnTUJBQUlFQ3lBV1JRMEREQUlMSUJRTkFRd0NDeUFYUlEwQkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcllDQWdBQWlFQTBBSUFFaEFReGNDeUFBUWRnQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFETDRCQ3lBQUtBSUVJUVFnQUVFQU5nSUVBa0FnQUNBRUlBRVFyWUNBZ0FBaUJBMEFJQUVoQVF5dEFRc2dBRUhaQURZQ0hDQUFJQUUyQWhRZ0FDQUVOZ0lNUVFBaEVBeTlBUXNnQUNnQ0JDRUVJQUJCQURZQ0JBSkFJQUFnQkNBQkVLMkFnSUFBSWdRTkFDQUJJUUVNcXdFTElBQkIyZ0EyQWh3Z0FDQUJOZ0lVSUFBZ0JEWUNERUVBSVJBTXZBRUxJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDdGdJQ0FBQ0lFRFFBZ0FTRUJES2tCQ3lBQVFkd0FOZ0ljSUFBZ0FUWUNGQ0FBSUFRMkFneEJBQ0VRRExzQkN3SkFJQUV0QUFCQlVHb2lFRUgvQVhGQkNrOE5BQ0FBSUJBNkFDb2dBVUVCYWlFQlFjOEFJUkFNb2dFTElBQW9BZ1FoQkNBQVFRQTJBZ1FDUUNBQUlBUWdBUkN0Z0lDQUFDSUVEUUFnQVNFQkRLY0JDeUFBUWQ0QU5nSWNJQUFnQVRZQ0ZDQUFJQVEyQWd4QkFDRVFETG9CQ3lBQVFRQTJBZ0FnRjBFQmFpRUJBa0FnQUMwQUtVRWpUdzBBSUFFaEFReFpDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIwNG1BZ0FBMkFoQWdBRUVJTmdJTVFRQWhFQXk1QVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdBVFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDREF5M0FRc2dBRUVBTmdJQUlCZEJBV29oQVFKQUlBQXRBQ2xCSVVjTkFDQUJJUUVNVmdzZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUVp1S2dJQUFOZ0lRSUFCQkNEWUNERUVBSVJBTXRnRUxJQUJCQURZQ0FDQVhRUUZxSVFFQ1FDQUFMUUFwSWhCQlhXcEJDMDhOQUNBQklRRU1WUXNDUUNBUVFRWkxEUUJCQVNBUWRFSEtBSEZGRFFBZ0FTRUJERlVMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjk0bUFnQUEyQWhBZ0FFRUlOZ0lNRExVQkN5QVFRUlZHRFhFZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWJtTmdJQUFOZ0lRSUFCQkdqWUNERUVBSVJBTXRBRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERlFMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc3dFTElBQW9BZ1FoRUNBQVFRQTJBZ1FDUUNBQUlCQWdBUkNuZ0lDQUFDSVFEUUFnQVNFQkRFMExJQUJCMGdBMkFod2dBQ0FCTmdJVUlBQWdFRFlDREVFQUlSQU1zZ0VMSUFBb0FnUWhFQ0FBUVFBMkFnUUNRQ0FBSUJBZ0FSQ25nSUNBQUNJUURRQWdBU0VCREUwTElBQkIwd0EyQWh3Z0FDQUJOZ0lVSUFBZ0VEWUNERUVBSVJBTXNRRUxJQUFvQWdRaEVDQUFRUUEyQWdRQ1FDQUFJQkFnQVJDbmdJQ0FBQ0lRRFFBZ0FTRUJERkVMSUFCQjVRQTJBaHdnQUNBQk5nSVVJQUFnRURZQ0RFRUFJUkFNc0FFTElBQkJBRFlDSENBQUlBRTJBaFFnQUVIR2lvQ0FBRFlDRUNBQVFRYzJBZ3hCQUNFUURLOEJDeUFBS0FJRUlSQWdBRUVBTmdJRUFrQWdBQ0FRSUFFUXA0Q0FnQUFpRUEwQUlBRWhBUXhKQ3lBQVFkSUFOZ0ljSUFBZ0FUWUNGQ0FBSUJBMkFneEJBQ0VRREs0QkN5QUFLQUlFSVJBZ0FFRUFOZ0lFQWtBZ0FDQVFJQUVRcDRDQWdBQWlFQTBBSUFFaEFReEpDeUFBUWRNQU5nSWNJQUFnQVRZQ0ZDQUFJQkEyQWd4QkFDRVFESzBCQ3lBQUtBSUVJUkFnQUVFQU5nSUVBa0FnQUNBUUlBRVFwNENBZ0FBaUVBMEFJQUVoQVF4TkN5QUFRZVVBTmdJY0lBQWdBVFlDRkNBQUlCQTJBZ3hCQUNFUURLd0JDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkIzSWlBZ0FBMkFoQWdBRUVITmdJTVFRQWhFQXlyQVFzZ0VFRS9SdzBCSUFGQkFXb2hBUXRCQlNFUURKQUJDMEVBSVJBZ0FFRUFOZ0ljSUFBZ0FUWUNGQ0FBUWYyU2dJQUFOZ0lRSUFCQkJ6WUNEQXlvQVFzZ0FDZ0NCQ0VRSUFCQkFEWUNCQUpBSUFBZ0VDQUJFS2VBZ0lBQUloQU5BQ0FCSVFFTVFnc2dBRUhTQURZQ0hDQUFJQUUyQWhRZ0FDQVFOZ0lNUVFBaEVBeW5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JBSkFJQUFnRUNBQkVLZUFnSUFBSWhBTkFDQUJJUUVNUWdzZ0FFSFRBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF5bUFRc2dBQ2dDQkNFUUlBQkJBRFlDQkFKQUlBQWdFQ0FCRUtlQWdJQUFJaEFOQUNBQklRRU1SZ3NnQUVIbEFEWUNIQ0FBSUFFMkFoUWdBQ0FRTmdJTVFRQWhFQXlsQVFzZ0FDZ0NCQ0VCSUFCQkFEWUNCQUpBSUFBZ0FTQVVFS2VBZ0lBQUlnRU5BQ0FVSVFFTVB3c2dBRUhTQURZQ0hDQUFJQlEyQWhRZ0FDQUJOZ0lNUVFBaEVBeWtBUXNnQUNnQ0JDRUJJQUJCQURZQ0JBSkFJQUFnQVNBVUVLZUFnSUFBSWdFTkFDQVVJUUVNUHdzZ0FFSFRBRFlDSENBQUlCUTJBaFFnQUNBQk5nSU1RUUFoRUF5akFRc2dBQ2dDQkNFQklBQkJBRFlDQkFKQUlBQWdBU0FVRUtlQWdJQUFJZ0VOQUNBVUlRRU1Rd3NnQUVIbEFEWUNIQ0FBSUJRMkFoUWdBQ0FCTmdJTVFRQWhFQXlpQVFzZ0FFRUFOZ0ljSUFBZ0ZEWUNGQ0FBUWNPUGdJQUFOZ0lRSUFCQkJ6WUNERUVBSVJBTW9RRUxJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSERqNENBQURZQ0VDQUFRUWMyQWd4QkFDRVFES0FCQzBFQUlSQWdBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREF5ZkFRc2dBRUVBTmdJY0lBQWdGRFlDRkNBQVFZeWNnSUFBTmdJUUlBQkJCellDREVFQUlSQU1uZ0VMSUFCQkFEWUNIQ0FBSUJRMkFoUWdBRUgra1lDQUFEWUNFQ0FBUVFjMkFneEJBQ0VRREowQkN5QUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmpwdUFnQUEyQWhBZ0FFRUdOZ0lNUVFBaEVBeWNBUXNnRUVFVlJnMVhJQUJCQURZQ0hDQUFJQUUyQWhRZ0FFSE1qb0NBQURZQ0VDQUFRU0EyQWd4QkFDRVFESnNCQ3lBQVFRQTJBZ0FnRUVFQmFpRUJRU1FoRUFzZ0FDQVFPZ0FwSUFBb0FnUWhFQ0FBUVFBMkFnUWdBQ0FRSUFFUXE0Q0FnQUFpRUExVUlBRWhBUXcrQ3lBQVFRQTJBZ0FMUVFBaEVDQUFRUUEyQWh3Z0FDQUVOZ0lVSUFCQjhadUFnQUEyQWhBZ0FFRUdOZ0lNREpjQkN5QUJRUlZHRFZBZ0FFRUFOZ0ljSUFBZ0JUWUNGQ0FBUWZDTWdJQUFOZ0lRSUFCQkd6WUNERUVBSVJBTWxnRUxJQUFvQWdRaEJTQUFRUUEyQWdRZ0FDQUZJQkFRcVlDQWdBQWlCUTBCSUJCQkFXb2hCUXRCclFFaEVBeDdDeUFBUWNFQk5nSWNJQUFnQlRZQ0RDQUFJQkJCQVdvMkFoUkJBQ0VRREpNQkN5QUFLQUlFSVFZZ0FFRUFOZ0lFSUFBZ0JpQVFFS21BZ0lBQUlnWU5BU0FRUVFGcUlRWUxRYTRCSVJBTWVBc2dBRUhDQVRZQ0hDQUFJQVkyQWd3Z0FDQVFRUUZxTmdJVVFRQWhFQXlRQVFzZ0FFRUFOZ0ljSUFBZ0J6WUNGQ0FBUVplTGdJQUFOZ0lRSUFCQkRUWUNERUVBSVJBTWp3RUxJQUJCQURZQ0hDQUFJQWcyQWhRZ0FFSGprSUNBQURZQ0VDQUFRUWsyQWd4QkFDRVFESTRCQ3lBQVFRQTJBaHdnQUNBSU5nSVVJQUJCbEkyQWdBQTJBaEFnQUVFaE5nSU1RUUFoRUF5TkFRdEJBU0VXUVFBaEYwRUFJUlJCQVNFUUN5QUFJQkE2QUNzZ0NVRUJhaUVJQWtBQ1FDQUFMUUF0UVJCeERRQUNRQUpBQWtBZ0FDMEFLZzREQVFBQ0JBc2dGa1VOQXd3Q0N5QVVEUUVNQWdzZ0YwVU5BUXNnQUNnQ0JDRVFJQUJCQURZQ0JDQUFJQkFnQ0JDdGdJQ0FBQ0lRUlEwOUlBQkJ5UUUyQWh3Z0FDQUlOZ0lVSUFBZ0VEWUNERUVBSVJBTWpBRUxJQUFvQWdRaEJDQUFRUUEyQWdRZ0FDQUVJQWdRcllDQWdBQWlCRVVOZGlBQVFjb0JOZ0ljSUFBZ0NEWUNGQ0FBSUFRMkFneEJBQ0VRRElzQkN5QUFLQUlFSVFRZ0FFRUFOZ0lFSUFBZ0JDQUpFSzJBZ0lBQUlnUkZEWFFnQUVITEFUWUNIQ0FBSUFrMkFoUWdBQ0FFTmdJTVFRQWhFQXlLQVFzZ0FDZ0NCQ0VFSUFCQkFEWUNCQ0FBSUFRZ0NoQ3RnSUNBQUNJRVJRMXlJQUJCelFFMkFod2dBQ0FLTmdJVUlBQWdCRFlDREVFQUlSQU1pUUVMQWtBZ0N5MEFBRUZRYWlJUVFmOEJjVUVLVHcwQUlBQWdFRG9BS2lBTFFRRnFJUXBCdGdFaEVBeHdDeUFBS0FJRUlRUWdBRUVBTmdJRUlBQWdCQ0FMRUsyQWdJQUFJZ1JGRFhBZ0FFSFBBVFlDSENBQUlBczJBaFFnQUNBRU5nSU1RUUFoRUF5SUFRc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFaQ3pnSUFBTmdJUUlBQkJDRFlDRENBQVFRQTJBZ0JCQUNFUURJY0JDeUFCUVJWR0RUOGdBRUVBTmdJY0lBQWdERFlDRkNBQVFjeU9nSUFBTmdJUUlBQkJJRFlDREVFQUlSQU1oZ0VMSUFCQmdRUTdBU2dnQUNnQ0JDRVFJQUJDQURjREFDQUFJQkFnREVFQmFpSU1FS3VBZ0lBQUloQkZEVGdnQUVIVEFUWUNIQ0FBSUF3MkFoUWdBQ0FRTmdJTVFRQWhFQXlGQVFzZ0FFRUFOZ0lBQzBFQUlSQWdBRUVBTmdJY0lBQWdCRFlDRkNBQVFkaWJnSUFBTmdJUUlBQkJDRFlDREF5REFRc2dBQ2dDQkNFUUlBQkNBRGNEQUNBQUlCQWdDMEVCYWlJTEVLdUFnSUFBSWhBTkFVSEdBU0VRREdrTElBQkJBam9BS0F4VkN5QUFRZFVCTmdJY0lBQWdDellDRkNBQUlCQTJBZ3hCQUNFUURJQUJDeUFRUVJWR0RUY2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFhU01nSUFBTmdJUUlBQkJFRFlDREVFQUlSQU1md3NnQUMwQU5FRUJSdzAwSUFBZ0JDQUNFTHlBZ0lBQUloQkZEVFFnRUVFVlJ3MDFJQUJCM0FFMkFod2dBQ0FFTmdJVUlBQkIxWmFBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXgrQzBFQUlSQWdBRUVBTmdJY0lBQkJyNHVBZ0FBMkFoQWdBRUVDTmdJTUlBQWdGRUVCYWpZQ0ZBeDlDMEVBSVJBTVl3dEJBaUVRREdJTFFRMGhFQXhoQzBFUElSQU1ZQXRCSlNFUURGOExRUk1oRUF4ZUMwRVZJUkFNWFF0QkZpRVFERndMUVJjaEVBeGJDMEVZSVJBTVdndEJHU0VRREZrTFFSb2hFQXhZQzBFYklSQU1Wd3RCSENFUURGWUxRUjBoRUF4VkMwRWZJUkFNVkF0QklTRVFERk1MUVNNaEVBeFNDMEhHQUNFUURGRUxRUzRoRUF4UUMwRXZJUkFNVHd0Qk95RVFERTRMUVQwaEVBeE5DMEhJQUNFUURFd0xRY2tBSVJBTVN3dEJ5d0FoRUF4S0MwSE1BQ0VRREVrTFFjNEFJUkFNU0F0QjBRQWhFQXhIQzBIVkFDRVFERVlMUWRnQUlSQU1SUXRCMlFBaEVBeEVDMEhiQUNFUURFTUxRZVFBSVJBTVFndEI1UUFoRUF4QkMwSHhBQ0VRREVBTFFmUUFJUkFNUHd0QmpRRWhFQXcrQzBHWEFTRVFERDBMUWFrQklSQU1QQXRCckFFaEVBdzdDMEhBQVNFUUREb0xRYmtCSVJBTU9RdEJyd0VoRUF3NEMwR3hBU0VRRERjTFFiSUJJUkFNTmd0QnRBRWhFQXcxQzBHMUFTRVFERFFMUWJvQklSQU1Nd3RCdlFFaEVBd3lDMEcvQVNFUURERUxRY0VCSVJBTU1Bc2dBRUVBTmdJY0lBQWdCRFlDRkNBQVFlbUxnSUFBTmdJUUlBQkJIellDREVFQUlSQU1TQXNnQUVIYkFUWUNIQ0FBSUFRMkFoUWdBRUg2bG9DQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVjTElBQkIrQUEyQWh3Z0FDQU1OZ0lVSUFCQnlwaUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEdDeUFBUWRFQU5nSWNJQUFnQlRZQ0ZDQUFRYkNYZ0lBQU5nSVFJQUJCRlRZQ0RFRUFJUkFNUlFzZ0FFSDVBRFlDSENBQUlBRTJBaFFnQUNBUU5nSU1RUUFoRUF4RUN5QUFRZmdBTmdJY0lBQWdBVFlDRkNBQVFjcVlnSUFBTmdJUUlBQkJGVFlDREVFQUlSQU1Rd3NnQUVIa0FEWUNIQ0FBSUFFMkFoUWdBRUhqbDRDQUFEWUNFQ0FBUVJVMkFneEJBQ0VRREVJTElBQkIxd0EyQWh3Z0FDQUJOZ0lVSUFCQnlaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBeEJDeUFBUVFBMkFod2dBQ0FCTmdJVUlBQkJ1WTJBZ0FBMkFoQWdBRUVhTmdJTVFRQWhFQXhBQ3lBQVFjSUFOZ0ljSUFBZ0FUWUNGQ0FBUWVPWWdJQUFOZ0lRSUFCQkZUWUNERUVBSVJBTVB3c2dBRUVBTmdJRUlBQWdEeUFQRUxHQWdJQUFJZ1JGRFFFZ0FFRTZOZ0ljSUFBZ0JEWUNEQ0FBSUE5QkFXbzJBaFJCQUNFUURENExJQUFvQWdRaEJDQUFRUUEyQWdRQ1FDQUFJQVFnQVJDeGdJQ0FBQ0lFUlEwQUlBQkJPellDSENBQUlBUTJBZ3dnQUNBQlFRRnFOZ0lVUVFBaEVBdytDeUFCUVFGcUlRRU1MUXNnRDBFQmFpRUJEQzBMSUFCQkFEWUNIQ0FBSUE4MkFoUWdBRUhra29DQUFEWUNFQ0FBUVFRMkFneEJBQ0VRRERzTElBQkJOallDSENBQUlBUTJBaFFnQUNBQ05nSU1RUUFoRUF3NkN5QUFRUzQyQWh3Z0FDQU9OZ0lVSUFBZ0JEWUNERUVBSVJBTU9Rc2dBRUhRQURZQ0hDQUFJQUUyQWhRZ0FFR1JtSUNBQURZQ0VDQUFRUlUyQWd4QkFDRVFERGdMSUExQkFXb2hBUXdzQ3lBQVFSVTJBaHdnQUNBQk5nSVVJQUJCZ3BtQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3MkN5QUFRUnMyQWh3Z0FDQUJOZ0lVSUFCQmtaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBdzFDeUFBUVE4MkFod2dBQ0FCTmdJVUlBQkJrWmVBZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXcwQ3lBQVFRczJBaHdnQUNBQk5nSVVJQUJCa1plQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3ekN5QUFRUm8yQWh3Z0FDQUJOZ0lVSUFCQmdwbUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3lDeUFBUVFzMkFod2dBQ0FCTmdJVUlBQkJncG1BZ0FBMkFoQWdBRUVWTmdJTVFRQWhFQXd4Q3lBQVFRbzJBaHdnQUNBQk5nSVVJQUJCNUphQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3d0N5QUFRUjQyQWh3Z0FDQUJOZ0lVSUFCQitaZUFnQUEyQWhBZ0FFRVZOZ0lNUVFBaEVBd3ZDeUFBUVFBMkFod2dBQ0FRTmdJVUlBQkIybzJBZ0FBMkFoQWdBRUVVTmdJTVFRQWhFQXd1Q3lBQVFRUTJBaHdnQUNBQk5nSVVJQUJCc0ppQWdBQTJBaEFnQUVFVk5nSU1RUUFoRUF3dEN5QUFRUUEyQWdBZ0MwRUJhaUVMQzBHNEFTRVFEQklMSUFCQkFEWUNBQ0FRUVFGcUlRRkI5UUFoRUF3UkN5QUJJUUVDUUNBQUxRQXBRUVZIRFFCQjR3QWhFQXdSQzBIaUFDRVFEQkFMUVFBaEVDQUFRUUEyQWh3Z0FFSGtrWUNBQURZQ0VDQUFRUWMyQWd3Z0FDQVVRUUZxTmdJVURDZ0xJQUJCQURZQ0FDQVhRUUZxSVFGQndBQWhFQXdPQzBFQklRRUxJQUFnQVRvQUxDQUFRUUEyQWdBZ0YwRUJhaUVCQzBFb0lSQU1Dd3NnQVNFQkMwRTRJUkFNQ1FzQ1FDQUJJZzhnQWtZTkFBTkFBa0FnRHkwQUFFR0F2b0NBQUdvdEFBQWlBVUVCUmcwQUlBRkJBa2NOQXlBUFFRRnFJUUVNQkFzZ0QwRUJhaUlQSUFKSERRQUxRVDRoRUF3aUMwRStJUkFNSVFzZ0FFRUFPZ0FzSUE4aEFRd0JDMEVMSVJBTUJndEJPaUVRREFVTElBRkJBV29oQVVFdElSQU1CQXNnQUNBQk9nQXNJQUJCQURZQ0FDQVdRUUZxSVFGQkRDRVFEQU1MSUFCQkFEWUNBQ0FYUVFGcUlRRkJDaUVRREFJTElBQkJBRFlDQUFzZ0FFRUFPZ0FzSUEwaEFVRUpJUkFNQUFzTFFRQWhFQ0FBUVFBMkFod2dBQ0FMTmdJVUlBQkJ6WkNBZ0FBMkFoQWdBRUVKTmdJTURCY0xRUUFoRUNBQVFRQTJBaHdnQUNBS05nSVVJQUJCNllxQWdBQTJBaEFnQUVFSk5nSU1EQllMUVFBaEVDQUFRUUEyQWh3Z0FDQUpOZ0lVSUFCQnQ1Q0FnQUEyQWhBZ0FFRUpOZ0lNREJVTFFRQWhFQ0FBUVFBMkFod2dBQ0FJTmdJVUlBQkJuSkdBZ0FBMkFoQWdBRUVKTmdJTURCUUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCelpDQWdBQTJBaEFnQUVFSk5nSU1EQk1MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjZZcUFnQUEyQWhBZ0FFRUpOZ0lNREJJTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ0NUNBZ0FBMkFoQWdBRUVKTmdJTURCRUxRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCbkpHQWdBQTJBaEFnQUVFSk5nSU1EQkFMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmw1V0FnQUEyQWhBZ0FFRVBOZ0lNREE4TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJsNVdBZ0FBMkFoQWdBRUVQTmdJTURBNExRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCd0pLQWdBQTJBaEFnQUVFTE5nSU1EQTBMUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQmxZbUFnQUEyQWhBZ0FFRUxOZ0lNREF3TFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkI0WStBZ0FBMkFoQWdBRUVLTmdJTURBc0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCKzQrQWdBQTJBaEFnQUVFS05nSU1EQW9MUVFBaEVDQUFRUUEyQWh3Z0FDQUJOZ0lVSUFCQjhabUFnQUEyQWhBZ0FFRUNOZ0lNREFrTFFRQWhFQ0FBUVFBMkFod2dBQ0FCTmdJVUlBQkJ4SlNBZ0FBMkFoQWdBRUVDTmdJTURBZ0xRUUFoRUNBQVFRQTJBaHdnQUNBQk5nSVVJQUJCOHBXQWdBQTJBaEFnQUVFQ05nSU1EQWNMSUFCQkFqWUNIQ0FBSUFFMkFoUWdBRUdjbW9DQUFEWUNFQ0FBUVJZMkFneEJBQ0VRREFZTFFRRWhFQXdGQzBIVUFDRVFJQUVpQkNBQ1JnMEVJQU5CQ0dvZ0FDQUVJQUpCMk1LQWdBQkJDaERGZ0lDQUFDQURLQUlNSVFRZ0F5Z0NDQTREQVFRQ0FBc1F5b0NBZ0FBQUN5QUFRUUEyQWh3Z0FFRzFtb0NBQURZQ0VDQUFRUmMyQWd3Z0FDQUVRUUZxTmdJVVFRQWhFQXdDQ3lBQVFRQTJBaHdnQUNBRU5nSVVJQUJCeXBxQWdBQTJBaEFnQUVFSk5nSU1RUUFoRUF3QkN3SkFJQUVpQkNBQ1J3MEFRU0loRUF3QkN5QUFRWW1BZ0lBQU5nSUlJQUFnQkRZQ0JFRWhJUkFMSUFOQkVHb2tnSUNBZ0FBZ0VBdXZBUUVDZnlBQktBSUFJUVlDUUFKQUlBSWdBMFlOQUNBRUlBWnFJUVFnQmlBRGFpQUNheUVISUFJZ0JrRi9jeUFGYWlJR2FpRUZBMEFDUUNBQ0xRQUFJQVF0QUFCR0RRQkJBaUVFREFNTEFrQWdCZzBBUVFBaEJDQUZJUUlNQXdzZ0JrRi9haUVHSUFSQkFXb2hCQ0FDUVFGcUlnSWdBMGNOQUFzZ0J5RUdJQU1oQWdzZ0FFRUJOZ0lBSUFFZ0JqWUNBQ0FBSUFJMkFnUVBDeUFCUVFBMkFnQWdBQ0FFTmdJQUlBQWdBallDQkFzS0FDQUFFTWVBZ0lBQUMvSTJBUXQvSTRDQWdJQUFRUkJySWdFa2dJQ0FnQUFDUUVFQUtBS2cwSUNBQUEwQVFRQVF5NENBZ0FCQmdOU0VnQUJySWdKQjJRQkpEUUJCQUNFREFrQkJBQ2dDNE5PQWdBQWlCQTBBUVFCQ2Z6Y0M3Tk9BZ0FCQkFFS0FnSVNBZ0lEQUFEY0M1Tk9BZ0FCQkFDQUJRUWhxUVhCeFFkaXExYW9GY3lJRU5nTGcwNENBQUVFQVFRQTJBdlRUZ0lBQVFRQkJBRFlDeE5PQWdBQUxRUUFnQWpZQ3pOT0FnQUJCQUVHQTFJU0FBRFlDeU5PQWdBQkJBRUdBMUlTQUFEWUNtTkNBZ0FCQkFDQUVOZ0tzMElDQUFFRUFRWDgyQXFqUWdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBdEJnTlNFZ0FCQmVFR0ExSVNBQUd0QkQzRkJBRUdBMUlTQUFFRUlha0VQY1JzaUEyb2lCRUVFYWlBQ1FVaHFJZ1VnQTJzaUEwRUJjallDQUVFQVFRQW9BdkRUZ0lBQU5nS2swSUNBQUVFQUlBTTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQkJnTlNFZ0FBZ0JXcEJPRFlDQkFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVIc0FVc05BQUpBUVFBb0FvalFnSUFBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdKQkEzWWlCSFlpQTBFRGNVVU5BQUpBQWtBZ0EwRUJjU0FFY2tFQmN5SUZRUU4wSWdSQnNOQ0FnQUJxSWdNZ0JFRzQwSUNBQUdvb0FnQWlCQ2dDQ0NJQ1J3MEFRUUFnQmtGK0lBVjNjVFlDaU5DQWdBQU1BUXNnQXlBQ05nSUlJQUlnQXpZQ0RBc2dCRUVJYWlFRElBUWdCVUVEZENJRlFRTnlOZ0lFSUFRZ0JXb2lCQ0FFS0FJRVFRRnlOZ0lFREF3TElBSkJBQ2dDa05DQWdBQWlCMDBOQVFKQUlBTkZEUUFDUUFKQUlBTWdCSFJCQWlBRWRDSURRUUFnQTJ0eWNTSURRUUFnQTJ0eFFYOXFJZ01nQTBFTWRrRVFjU0lEZGlJRVFRVjJRUWh4SWdVZ0EzSWdCQ0FGZGlJRFFRSjJRUVJ4SWdSeUlBTWdCSFlpQTBFQmRrRUNjU0lFY2lBRElBUjJJZ05CQVhaQkFYRWlCSElnQXlBRWRtb2lCRUVEZENJRFFiRFFnSUFBYWlJRklBTkJ1TkNBZ0FCcUtBSUFJZ01vQWdnaUFFY05BRUVBSUFaQmZpQUVkM0VpQmpZQ2lOQ0FnQUFNQVFzZ0JTQUFOZ0lJSUFBZ0JUWUNEQXNnQXlBQ1FRTnlOZ0lFSUFNZ0JFRURkQ0lFYWlBRUlBSnJJZ1UyQWdBZ0F5QUNhaUlBSUFWQkFYSTJBZ1FDUUNBSFJRMEFJQWRCZUhGQnNOQ0FnQUJxSVFKQkFDZ0NuTkNBZ0FBaEJBSkFBa0FnQmtFQklBZEJBM1owSWdoeERRQkJBQ0FHSUFoeU5nS0kwSUNBQUNBQ0lRZ01BUXNnQWlnQ0NDRUlDeUFJSUFRMkFnd2dBaUFFTmdJSUlBUWdBallDRENBRUlBZzJBZ2dMSUFOQkNHb2hBMEVBSUFBMkFwelFnSUFBUVFBZ0JUWUNrTkNBZ0FBTURBdEJBQ2dDak5DQWdBQWlDVVVOQVNBSlFRQWdDV3R4UVg5cUlnTWdBMEVNZGtFUWNTSURkaUlFUVFWMlFRaHhJZ1VnQTNJZ0JDQUZkaUlEUVFKMlFRUnhJZ1J5SUFNZ0JIWWlBMEVCZGtFQ2NTSUVjaUFESUFSMklnTkJBWFpCQVhFaUJISWdBeUFFZG1wQkFuUkJ1TktBZ0FCcUtBSUFJZ0FvQWdSQmVIRWdBbXNoQkNBQUlRVUNRQU5BQWtBZ0JTZ0NFQ0lERFFBZ0JVRVVhaWdDQUNJRFJRMENDeUFES0FJRVFYaHhJQUpySWdVZ0JDQUZJQVJKSWdVYklRUWdBeUFBSUFVYklRQWdBeUVGREFBTEN5QUFLQUlZSVFvQ1FDQUFLQUlNSWdnZ0FFWU5BQ0FBS0FJSUlnTkJBQ2dDbU5DQWdBQkpHaUFJSUFNMkFnZ2dBeUFJTmdJTURBc0xBa0FnQUVFVWFpSUZLQUlBSWdNTkFDQUFLQUlRSWdORkRRTWdBRUVRYWlFRkN3TkFJQVVoQ3lBRElnaEJGR29pQlNnQ0FDSUREUUFnQ0VFUWFpRUZJQWdvQWhBaUF3MEFDeUFMUVFBMkFnQU1DZ3RCZnlFQ0lBQkJ2MzlMRFFBZ0FFRVRhaUlEUVhCeElRSkJBQ2dDak5DQWdBQWlCMFVOQUVFQUlRc0NRQ0FDUVlBQ1NRMEFRUjhoQ3lBQ1FmLy8vd2RMRFFBZ0EwRUlkaUlESUFOQmdQNC9ha0VRZGtFSWNTSURkQ0lFSUFSQmdPQWZha0VRZGtFRWNTSUVkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBRElBUnlJQVZ5YXlJRFFRRjBJQUlnQTBFVmFuWkJBWEZ5UVJ4cUlRc0xRUUFnQW1zaEJBSkFBa0FDUUFKQUlBdEJBblJCdU5LQWdBQnFLQUlBSWdVTkFFRUFJUU5CQUNFSURBRUxRUUFoQXlBQ1FRQkJHU0FMUVFGMmF5QUxRUjlHRzNRaEFFRUFJUWdEUUFKQUlBVW9BZ1JCZUhFZ0Ftc2lCaUFFVHcwQUlBWWhCQ0FGSVFnZ0JnMEFRUUFoQkNBRklRZ2dCU0VEREFNTElBTWdCVUVVYWlnQ0FDSUdJQVlnQlNBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lGUmhzZ0F5QUdHeUVESUFCQkFYUWhBQ0FGRFFBTEN3SkFJQU1nQ0hJTkFFRUFJUWhCQWlBTGRDSURRUUFnQTJ0eUlBZHhJZ05GRFFNZ0EwRUFJQU5yY1VGL2FpSURJQU5CREhaQkVIRWlBM1lpQlVFRmRrRUljU0lBSUFOeUlBVWdBSFlpQTBFQ2RrRUVjU0lGY2lBRElBVjJJZ05CQVhaQkFuRWlCWElnQXlBRmRpSURRUUYyUVFGeElnVnlJQU1nQlhacVFRSjBRYmpTZ0lBQWFpZ0NBQ0VEQ3lBRFJRMEJDd05BSUFNb0FnUkJlSEVnQW1zaUJpQUVTU0VBQWtBZ0F5Z0NFQ0lGRFFBZ0EwRVVhaWdDQUNFRkN5QUdJQVFnQUJzaEJDQURJQWdnQUJzaENDQUZJUU1nQlEwQUN3c2dDRVVOQUNBRVFRQW9BcERRZ0lBQUlBSnJUdzBBSUFnb0FoZ2hDd0pBSUFnb0Fnd2lBQ0FJUmcwQUlBZ29BZ2dpQTBFQUtBS1kwSUNBQUVrYUlBQWdBellDQ0NBRElBQTJBZ3dNQ1FzQ1FDQUlRUlJxSWdVb0FnQWlBdzBBSUFnb0FoQWlBMFVOQXlBSVFSQnFJUVVMQTBBZ0JTRUdJQU1pQUVFVWFpSUZLQUlBSWdNTkFDQUFRUkJxSVFVZ0FDZ0NFQ0lERFFBTElBWkJBRFlDQUF3SUN3SkFRUUFvQXBEUWdJQUFJZ01nQWtrTkFFRUFLQUtjMElDQUFDRUVBa0FDUUNBRElBSnJJZ1ZCRUVrTkFDQUVJQUpxSWdBZ0JVRUJjallDQkVFQUlBVTJBcERRZ0lBQVFRQWdBRFlDbk5DQWdBQWdCQ0FEYWlBRk5nSUFJQVFnQWtFRGNqWUNCQXdCQ3lBRUlBTkJBM0kyQWdRZ0JDQURhaUlESUFNb0FnUkJBWEkyQWdSQkFFRUFOZ0tjMElDQUFFRUFRUUEyQXBEUWdJQUFDeUFFUVFocUlRTU1DZ3NDUUVFQUtBS1UwSUNBQUNJQUlBSk5EUUJCQUNnQ29OQ0FnQUFpQXlBQ2FpSUVJQUFnQW1zaUJVRUJjallDQkVFQUlBVTJBcFRRZ0lBQVFRQWdCRFlDb05DQWdBQWdBeUFDUVFOeU5nSUVJQU5CQ0dvaEF3d0tDd0pBQWtCQkFDZ0M0Tk9BZ0FCRkRRQkJBQ2dDNk5PQWdBQWhCQXdCQzBFQVFuODNBdXpUZ0lBQVFRQkNnSUNFZ0lDQXdBQTNBdVRUZ0lBQVFRQWdBVUVNYWtGd2NVSFlxdFdxQlhNMkF1RFRnSUFBUVFCQkFEWUM5Tk9BZ0FCQkFFRUFOZ0xFMDRDQUFFR0FnQVFoQkF0QkFDRURBa0FnQkNBQ1FjY0FhaUlIYWlJR1FRQWdCR3NpQzNFaUNDQUNTdzBBUVFCQk1EWUMrTk9BZ0FBTUNnc0NRRUVBS0FMQTA0Q0FBQ0lEUlEwQUFrQkJBQ2dDdU5PQWdBQWlCQ0FJYWlJRklBUk5EUUFnQlNBRFRRMEJDMEVBSVFOQkFFRXdOZ0w0MDRDQUFBd0tDMEVBTFFERTA0Q0FBRUVFY1EwRUFrQUNRQUpBUVFBb0FxRFFnSUFBSWdSRkRRQkJ5Tk9BZ0FBaEF3TkFBa0FnQXlnQ0FDSUZJQVJMRFFBZ0JTQURLQUlFYWlBRVN3MERDeUFES0FJSUlnTU5BQXNMUVFBUXk0Q0FnQUFpQUVGL1JnMEZJQWdoQmdKQVFRQW9BdVRUZ0lBQUlnTkJmMm9pQkNBQWNVVU5BQ0FJSUFCcklBUWdBR3BCQUNBRGEzRnFJUVlMSUFZZ0FrME5CU0FHUWY3Ly8vOEhTdzBGQWtCQkFDZ0N3Tk9BZ0FBaUEwVU5BRUVBS0FLNDA0Q0FBQ0lFSUFacUlnVWdCRTBOQmlBRklBTkxEUVlMSUFZUXk0Q0FnQUFpQXlBQVJ3MEJEQWNMSUFZZ0FHc2dDM0VpQmtIKy8vLy9CMHNOQkNBR0VNdUFnSUFBSWdBZ0F5Z0NBQ0FES0FJRWFrWU5BeUFBSVFNTEFrQWdBMEYvUmcwQUlBSkJ5QUJxSUFaTkRRQUNRQ0FISUFaclFRQW9BdWpUZ0lBQUlnUnFRUUFnQkd0eElnUkIvdi8vL3dkTkRRQWdBeUVBREFjTEFrQWdCQkRMZ0lDQUFFRi9SZzBBSUFRZ0Jtb2hCaUFESVFBTUJ3dEJBQ0FHYXhETGdJQ0FBQm9NQkFzZ0F5RUFJQU5CZjBjTkJRd0RDMEVBSVFnTUJ3dEJBQ0VBREFVTElBQkJmMGNOQWd0QkFFRUFLQUxFMDRDQUFFRUVjallDeE5PQWdBQUxJQWhCL3YvLy93ZExEUUVnQ0JETGdJQ0FBQ0VBUVFBUXk0Q0FnQUFoQXlBQVFYOUdEUUVnQTBGL1JnMEJJQUFnQTA4TkFTQURJQUJySWdZZ0FrRTRhazBOQVF0QkFFRUFLQUs0MDRDQUFDQUdhaUlETmdLNDA0Q0FBQUpBSUFOQkFDZ0N2Tk9BZ0FCTkRRQkJBQ0FETmdLODA0Q0FBQXNDUUFKQUFrQUNRRUVBS0FLZzBJQ0FBQ0lFUlEwQVFjalRnSUFBSVFNRFFDQUFJQU1vQWdBaUJTQURLQUlFSWdocVJnMENJQU1vQWdnaUF3MEFEQU1MQ3dKQUFrQkJBQ2dDbU5DQWdBQWlBMFVOQUNBQUlBTlBEUUVMUVFBZ0FEWUNtTkNBZ0FBTFFRQWhBMEVBSUFZMkFzelRnSUFBUVFBZ0FEWUN5Tk9BZ0FCQkFFRi9OZ0tvMElDQUFFRUFRUUFvQXVEVGdJQUFOZ0tzMElDQUFFRUFRUUEyQXRUVGdJQUFBMEFnQTBIRTBJQ0FBR29nQTBHNDBJQ0FBR29pQkRZQ0FDQUVJQU5Cc05DQWdBQnFJZ1UyQWdBZ0EwRzgwSUNBQUdvZ0JUWUNBQ0FEUWN6UWdJQUFhaUFEUWNEUWdJQUFhaUlGTmdJQUlBVWdCRFlDQUNBRFFkVFFnSUFBYWlBRFFjalFnSUFBYWlJRU5nSUFJQVFnQlRZQ0FDQURRZERRZ0lBQWFpQUVOZ0lBSUFOQklHb2lBMEdBQWtjTkFBc2dBRUY0SUFCclFROXhRUUFnQUVFSWFrRVBjUnNpQTJvaUJDQUdRVWhxSWdVZ0Eyc2lBMEVCY2pZQ0JFRUFRUUFvQXZEVGdJQUFOZ0trMElDQUFFRUFJQU0yQXBUUWdJQUFRUUFnQkRZQ29OQ0FnQUFnQUNBRmFrRTROZ0lFREFJTElBTXRBQXhCQ0hFTkFDQUVJQVZKRFFBZ0JDQUFUdzBBSUFSQmVDQUVhMEVQY1VFQUlBUkJDR3BCRDNFYklnVnFJZ0JCQUNnQ2xOQ0FnQUFnQm1vaUN5QUZheUlGUVFGeU5nSUVJQU1nQ0NBR2FqWUNCRUVBUVFBb0F2RFRnSUFBTmdLazBJQ0FBRUVBSUFVMkFwVFFnSUFBUVFBZ0FEWUNvTkNBZ0FBZ0JDQUxha0U0TmdJRURBRUxBa0FnQUVFQUtBS1kwSUNBQUNJSVR3MEFRUUFnQURZQ21OQ0FnQUFnQUNFSUN5QUFJQVpxSVFWQnlOT0FnQUFoQXdKQUFrQUNRQUpBQWtBQ1FBSkFBMEFnQXlnQ0FDQUZSZzBCSUFNb0FnZ2lBdzBBREFJTEN5QURMUUFNUVFoeFJRMEJDMEhJMDRDQUFDRURBMEFDUUNBREtBSUFJZ1VnQkVzTkFDQUZJQU1vQWdScUlnVWdCRXNOQXdzZ0F5Z0NDQ0VEREFBTEN5QURJQUEyQWdBZ0F5QURLQUlFSUFacU5nSUVJQUJCZUNBQWEwRVBjVUVBSUFCQkNHcEJEM0ViYWlJTElBSkJBM0kyQWdRZ0JVRjRJQVZyUVE5eFFRQWdCVUVJYWtFUGNSdHFJZ1lnQ3lBQ2FpSUNheUVEQWtBZ0JpQUVSdzBBUVFBZ0FqWUNvTkNBZ0FCQkFFRUFLQUtVMElDQUFDQURhaUlETmdLVTBJQ0FBQ0FDSUFOQkFYSTJBZ1FNQXdzQ1FDQUdRUUFvQXB6UWdJQUFSdzBBUVFBZ0FqWUNuTkNBZ0FCQkFFRUFLQUtRMElDQUFDQURhaUlETmdLUTBJQ0FBQ0FDSUFOQkFYSTJBZ1FnQWlBRGFpQUROZ0lBREFNTEFrQWdCaWdDQkNJRVFRTnhRUUZIRFFBZ0JFRjRjU0VIQWtBQ1FDQUVRZjhCU3cwQUlBWW9BZ2dpQlNBRVFRTjJJZ2hCQTNSQnNOQ0FnQUJxSWdCR0dnSkFJQVlvQWd3aUJDQUZSdzBBUVFCQkFDZ0NpTkNBZ0FCQmZpQUlkM0UyQW9qUWdJQUFEQUlMSUFRZ0FFWWFJQVFnQlRZQ0NDQUZJQVEyQWd3TUFRc2dCaWdDR0NFSkFrQUNRQ0FHS0FJTUlnQWdCa1lOQUNBR0tBSUlJZ1FnQ0VrYUlBQWdCRFlDQ0NBRUlBQTJBZ3dNQVFzQ1FDQUdRUlJxSWdRb0FnQWlCUTBBSUFaQkVHb2lCQ2dDQUNJRkRRQkJBQ0VBREFFTEEwQWdCQ0VJSUFVaUFFRVVhaUlFS0FJQUlnVU5BQ0FBUVJCcUlRUWdBQ2dDRUNJRkRRQUxJQWhCQURZQ0FBc2dDVVVOQUFKQUFrQWdCaUFHS0FJY0lnVkJBblJCdU5LQWdBQnFJZ1FvQWdCSERRQWdCQ0FBTmdJQUlBQU5BVUVBUVFBb0FvelFnSUFBUVg0Z0JYZHhOZ0tNMElDQUFBd0NDeUFKUVJCQkZDQUpLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFrMkFoZ0NRQ0FHS0FJUUlnUkZEUUFnQUNBRU5nSVFJQVFnQURZQ0dBc2dCaWdDRkNJRVJRMEFJQUJCRkdvZ0JEWUNBQ0FFSUFBMkFoZ0xJQWNnQTJvaEF5QUdJQWRxSWdZb0FnUWhCQXNnQmlBRVFYNXhOZ0lFSUFJZ0Eyb2dBellDQUNBQ0lBTkJBWEkyQWdRQ1FDQURRZjhCU3cwQUlBTkJlSEZCc05DQWdBQnFJUVFDUUFKQVFRQW9Bb2pRZ0lBQUlnVkJBU0FEUVFOMmRDSURjUTBBUVFBZ0JTQURjallDaU5DQWdBQWdCQ0VEREFFTElBUW9BZ2doQXdzZ0F5QUNOZ0lNSUFRZ0FqWUNDQ0FDSUFRMkFnd2dBaUFETmdJSURBTUxRUjhoQkFKQUlBTkIvLy8vQjBzTkFDQURRUWgySWdRZ0JFR0EvajlxUVJCMlFRaHhJZ1IwSWdVZ0JVR0E0QjlxUVJCMlFRUnhJZ1YwSWdBZ0FFR0FnQTlxUVJCMlFRSnhJZ0IwUVE5MklBUWdCWElnQUhKcklnUkJBWFFnQXlBRVFSVnFka0VCY1hKQkhHb2hCQXNnQWlBRU5nSWNJQUpDQURjQ0VDQUVRUUowUWJqU2dJQUFhaUVGQWtCQkFDZ0NqTkNBZ0FBaUFFRUJJQVIwSWdoeERRQWdCU0FDTmdJQVFRQWdBQ0FJY2pZQ2pOQ0FnQUFnQWlBRk5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUF3c2dBMEVBUVJrZ0JFRUJkbXNnQkVFZlJodDBJUVFnQlNnQ0FDRUFBMEFnQUNJRktBSUVRWGh4SUFOR0RRSWdCRUVkZGlFQUlBUkJBWFFoQkNBRklBQkJCSEZxUVJCcUlnZ29BZ0FpQUEwQUN5QUlJQUkyQWdBZ0FpQUZOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BZ3NnQUVGNElBQnJRUTl4UVFBZ0FFRUlha0VQY1JzaUEyb2lDeUFHUVVocUlnZ2dBMnNpQTBFQmNqWUNCQ0FBSUFocVFUZzJBZ1FnQkNBRlFUY2dCV3RCRDNGQkFDQUZRVWxxUVE5eEcycEJRV29pQ0NBSUlBUkJFR3BKR3lJSVFTTTJBZ1JCQUVFQUtBTHcwNENBQURZQ3BOQ0FnQUJCQUNBRE5nS1UwSUNBQUVFQUlBczJBcURRZ0lBQUlBaEJFR3BCQUNrQzBOT0FnQUEzQWdBZ0NFRUFLUUxJMDRDQUFEY0NDRUVBSUFoQkNHbzJBdERUZ0lBQVFRQWdCallDek5PQWdBQkJBQ0FBTmdMSTA0Q0FBRUVBUVFBMkF0VFRnSUFBSUFoQkpHb2hBd05BSUFOQkJ6WUNBQ0FEUVFScUlnTWdCVWtOQUFzZ0NDQUVSZzBESUFnZ0NDZ0NCRUYrY1RZQ0JDQUlJQWdnQkdzaUFEWUNBQ0FFSUFCQkFYSTJBZ1FDUUNBQVFmOEJTdzBBSUFCQmVIRkJzTkNBZ0FCcUlRTUNRQUpBUVFBb0FvalFnSUFBSWdWQkFTQUFRUU4yZENJQWNRMEFRUUFnQlNBQWNqWUNpTkNBZ0FBZ0F5RUZEQUVMSUFNb0FnZ2hCUXNnQlNBRU5nSU1JQU1nQkRZQ0NDQUVJQU0yQWd3Z0JDQUZOZ0lJREFRTFFSOGhBd0pBSUFCQi8vLy9CMHNOQUNBQVFRaDJJZ01nQTBHQS9qOXFRUkIyUVFoeElnTjBJZ1VnQlVHQTRCOXFRUkIyUVFSeElnVjBJZ2dnQ0VHQWdBOXFRUkIyUVFKeElnaDBRUTkySUFNZ0JYSWdDSEpySWdOQkFYUWdBQ0FEUVJWcWRrRUJjWEpCSEdvaEF3c2dCQ0FETmdJY0lBUkNBRGNDRUNBRFFRSjBRYmpTZ0lBQWFpRUZBa0JCQUNnQ2pOQ0FnQUFpQ0VFQklBTjBJZ1p4RFFBZ0JTQUVOZ0lBUVFBZ0NDQUdjallDak5DQWdBQWdCQ0FGTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQkFzZ0FFRUFRUmtnQTBFQmRtc2dBMEVmUmh0MElRTWdCU2dDQUNFSUEwQWdDQ0lGS0FJRVFYaHhJQUJHRFFNZ0EwRWRkaUVJSUFOQkFYUWhBeUFGSUFoQkJIRnFRUkJxSWdZb0FnQWlDQTBBQ3lBR0lBUTJBZ0FnQkNBRk5nSVlJQVFnQkRZQ0RDQUVJQVEyQWdnTUF3c2dCU2dDQ0NJRElBSTJBZ3dnQlNBQ05nSUlJQUpCQURZQ0dDQUNJQVUyQWd3Z0FpQUROZ0lJQ3lBTFFRaHFJUU1NQlFzZ0JTZ0NDQ0lESUFRMkFnd2dCU0FFTmdJSUlBUkJBRFlDR0NBRUlBVTJBZ3dnQkNBRE5nSUlDMEVBS0FLVTBJQ0FBQ0lESUFKTkRRQkJBQ2dDb05DQWdBQWlCQ0FDYWlJRklBTWdBbXNpQTBFQmNqWUNCRUVBSUFNMkFwVFFnSUFBUVFBZ0JUWUNvTkNBZ0FBZ0JDQUNRUU55TmdJRUlBUkJDR29oQXd3REMwRUFJUU5CQUVFd05nTDQwNENBQUF3Q0N3SkFJQXRGRFFBQ1FBSkFJQWdnQ0NnQ0hDSUZRUUowUWJqU2dJQUFhaUlES0FJQVJ3MEFJQU1nQURZQ0FDQUFEUUZCQUNBSFFYNGdCWGR4SWdjMkFvelFnSUFBREFJTElBdEJFRUVVSUFzb0FoQWdDRVliYWlBQU5nSUFJQUJGRFFFTElBQWdDellDR0FKQUlBZ29BaEFpQTBVTkFDQUFJQU0yQWhBZ0F5QUFOZ0lZQ3lBSVFSUnFLQUlBSWdORkRRQWdBRUVVYWlBRE5nSUFJQU1nQURZQ0dBc0NRQUpBSUFSQkQwc05BQ0FJSUFRZ0Ftb2lBMEVEY2pZQ0JDQUlJQU5xSWdNZ0F5Z0NCRUVCY2pZQ0JBd0JDeUFJSUFKcUlnQWdCRUVCY2pZQ0JDQUlJQUpCQTNJMkFnUWdBQ0FFYWlBRU5nSUFBa0FnQkVIL0FVc05BQ0FFUVhoeFFiRFFnSUFBYWlFREFrQUNRRUVBS0FLSTBJQ0FBQ0lGUVFFZ0JFRURkblFpQkhFTkFFRUFJQVVnQkhJMkFvalFnSUFBSUFNaEJBd0JDeUFES0FJSUlRUUxJQVFnQURZQ0RDQURJQUEyQWdnZ0FDQUROZ0lNSUFBZ0JEWUNDQXdCQzBFZklRTUNRQ0FFUWYvLy93ZExEUUFnQkVFSWRpSURJQU5CZ1A0L2FrRVFka0VJY1NJRGRDSUZJQVZCZ09BZmFrRVFka0VFY1NJRmRDSUNJQUpCZ0lBUGFrRVFka0VDY1NJQ2RFRVBkaUFESUFWeUlBSnlheUlEUVFGMElBUWdBMEVWYW5aQkFYRnlRUnhxSVFNTElBQWdBellDSENBQVFnQTNBaEFnQTBFQ2RFRzQwb0NBQUdvaEJRSkFJQWRCQVNBRGRDSUNjUTBBSUFVZ0FEWUNBRUVBSUFjZ0FuSTJBb3pRZ0lBQUlBQWdCVFlDR0NBQUlBQTJBZ2dnQUNBQU5nSU1EQUVMSUFSQkFFRVpJQU5CQVhacklBTkJIMFliZENFRElBVW9BZ0FoQWdKQUEwQWdBaUlGS0FJRVFYaHhJQVJHRFFFZ0EwRWRkaUVDSUFOQkFYUWhBeUFGSUFKQkJIRnFRUkJxSWdZb0FnQWlBZzBBQ3lBR0lBQTJBZ0FnQUNBRk5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTUFRc2dCU2dDQ0NJRElBQTJBZ3dnQlNBQU5nSUlJQUJCQURZQ0dDQUFJQVUyQWd3Z0FDQUROZ0lJQ3lBSVFRaHFJUU1NQVFzQ1FDQUtSUTBBQWtBQ1FDQUFJQUFvQWh3aUJVRUNkRUc0MG9DQUFHb2lBeWdDQUVjTkFDQURJQWcyQWdBZ0NBMEJRUUFnQ1VGK0lBVjNjVFlDak5DQWdBQU1BZ3NnQ2tFUVFSUWdDaWdDRUNBQVJodHFJQWcyQWdBZ0NFVU5BUXNnQ0NBS05nSVlBa0FnQUNnQ0VDSURSUTBBSUFnZ0F6WUNFQ0FESUFnMkFoZ0xJQUJCRkdvb0FnQWlBMFVOQUNBSVFSUnFJQU0yQWdBZ0F5QUlOZ0lZQ3dKQUFrQWdCRUVQU3cwQUlBQWdCQ0FDYWlJRFFRTnlOZ0lFSUFBZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFREFFTElBQWdBbW9pQlNBRVFRRnlOZ0lFSUFBZ0FrRURjallDQkNBRklBUnFJQVEyQWdBQ1FDQUhSUTBBSUFkQmVIRkJzTkNBZ0FCcUlRSkJBQ2dDbk5DQWdBQWhBd0pBQWtCQkFTQUhRUU4yZENJSUlBWnhEUUJCQUNBSUlBWnlOZ0tJMElDQUFDQUNJUWdNQVFzZ0FpZ0NDQ0VJQ3lBSUlBTTJBZ3dnQWlBRE5nSUlJQU1nQWpZQ0RDQURJQWcyQWdnTFFRQWdCVFlDbk5DQWdBQkJBQ0FFTmdLUTBJQ0FBQXNnQUVFSWFpRURDeUFCUVJCcUpJQ0FnSUFBSUFNTENnQWdBQkRKZ0lDQUFBdmlEUUVIZndKQUlBQkZEUUFnQUVGNGFpSUJJQUJCZkdvb0FnQWlBa0Y0Y1NJQWFpRURBa0FnQWtFQmNRMEFJQUpCQTNGRkRRRWdBU0FCS0FJQUlnSnJJZ0ZCQUNnQ21OQ0FnQUFpQkVrTkFTQUNJQUJxSVFBQ1FDQUJRUUFvQXB6UWdJQUFSZzBBQWtBZ0FrSC9BVXNOQUNBQktBSUlJZ1FnQWtFRGRpSUZRUU4wUWJEUWdJQUFhaUlHUmhvQ1FDQUJLQUlNSWdJZ0JFY05BRUVBUVFBb0FvalFnSUFBUVg0Z0JYZHhOZ0tJMElDQUFBd0RDeUFDSUFaR0dpQUNJQVEyQWdnZ0JDQUNOZ0lNREFJTElBRW9BaGdoQndKQUFrQWdBU2dDRENJR0lBRkdEUUFnQVNnQ0NDSUNJQVJKR2lBR0lBSTJBZ2dnQWlBR05nSU1EQUVMQWtBZ0FVRVVhaUlDS0FJQUlnUU5BQ0FCUVJCcUlnSW9BZ0FpQkEwQVFRQWhCZ3dCQ3dOQUlBSWhCU0FFSWdaQkZHb2lBaWdDQUNJRURRQWdCa0VRYWlFQ0lBWW9BaEFpQkEwQUN5QUZRUUEyQWdBTElBZEZEUUVDUUFKQUlBRWdBU2dDSENJRVFRSjBRYmpTZ0lBQWFpSUNLQUlBUncwQUlBSWdCallDQUNBR0RRRkJBRUVBS0FLTTBJQ0FBRUYrSUFSM2NUWUNqTkNBZ0FBTUF3c2dCMEVRUVJRZ0J5Z0NFQ0FCUmh0cUlBWTJBZ0FnQmtVTkFnc2dCaUFITmdJWUFrQWdBU2dDRUNJQ1JRMEFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFTQUdRUlJxSUFJMkFnQWdBaUFHTmdJWURBRUxJQU1vQWdRaUFrRURjVUVEUncwQUlBTWdBa0YrY1RZQ0JFRUFJQUEyQXBEUWdJQUFJQUVnQUdvZ0FEWUNBQ0FCSUFCQkFYSTJBZ1FQQ3lBQklBTlBEUUFnQXlnQ0JDSUNRUUZ4UlEwQUFrQUNRQ0FDUVFKeERRQUNRQ0FEUVFBb0FxRFFnSUFBUncwQVFRQWdBVFlDb05DQWdBQkJBRUVBS0FLVTBJQ0FBQ0FBYWlJQU5nS1UwSUNBQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BMEVBUVFBMkFwRFFnSUFBUVFCQkFEWUNuTkNBZ0FBUEN3SkFJQU5CQUNnQ25OQ0FnQUJIRFFCQkFDQUJOZ0tjMElDQUFFRUFRUUFvQXBEUWdJQUFJQUJxSWdBMkFwRFFnSUFBSUFFZ0FFRUJjallDQkNBQklBQnFJQUEyQWdBUEN5QUNRWGh4SUFCcUlRQUNRQUpBSUFKQi93RkxEUUFnQXlnQ0NDSUVJQUpCQTNZaUJVRURkRUd3MElDQUFHb2lCa1lhQWtBZ0F5Z0NEQ0lDSUFSSERRQkJBRUVBS0FLSTBJQ0FBRUYrSUFWM2NUWUNpTkNBZ0FBTUFnc2dBaUFHUmhvZ0FpQUVOZ0lJSUFRZ0FqWUNEQXdCQ3lBREtBSVlJUWNDUUFKQUlBTW9BZ3dpQmlBRFJnMEFJQU1vQWdnaUFrRUFLQUtZMElDQUFFa2FJQVlnQWpZQ0NDQUNJQVkyQWd3TUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFR0RBRUxBMEFnQWlFRklBUWlCa0VVYWlJQ0tBSUFJZ1FOQUNBR1FSQnFJUUlnQmlnQ0VDSUVEUUFMSUFWQkFEWUNBQXNnQjBVTkFBSkFBa0FnQXlBREtBSWNJZ1JCQW5SQnVOS0FnQUJxSWdJb0FnQkhEUUFnQWlBR05nSUFJQVlOQVVFQVFRQW9Bb3pRZ0lBQVFYNGdCSGR4TmdLTTBJQ0FBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQmpZQ0FDQUdSUTBCQ3lBR0lBYzJBaGdDUUNBREtBSVFJZ0pGRFFBZ0JpQUNOZ0lRSUFJZ0JqWUNHQXNnQXlnQ0ZDSUNSUTBBSUFaQkZHb2dBallDQUNBQ0lBWTJBaGdMSUFFZ0FHb2dBRFlDQUNBQklBQkJBWEkyQWdRZ0FVRUFLQUtjMElDQUFFY05BVUVBSUFBMkFwRFFnSUFBRHdzZ0F5QUNRWDV4TmdJRUlBRWdBR29nQURZQ0FDQUJJQUJCQVhJMkFnUUxBa0FnQUVIL0FVc05BQ0FBUVhoeFFiRFFnSUFBYWlFQ0FrQUNRRUVBS0FLSTBJQ0FBQ0lFUVFFZ0FFRURkblFpQUhFTkFFRUFJQVFnQUhJMkFvalFnSUFBSUFJaEFBd0JDeUFDS0FJSUlRQUxJQUFnQVRZQ0RDQUNJQUUyQWdnZ0FTQUNOZ0lNSUFFZ0FEWUNDQThMUVI4aEFnSkFJQUJCLy8vL0Iwc05BQ0FBUVFoMklnSWdBa0dBL2o5cVFSQjJRUWh4SWdKMElnUWdCRUdBNEI5cVFSQjJRUVJ4SWdSMElnWWdCa0dBZ0E5cVFSQjJRUUp4SWdaMFFROTJJQUlnQkhJZ0JuSnJJZ0pCQVhRZ0FDQUNRUlZxZGtFQmNYSkJIR29oQWdzZ0FTQUNOZ0ljSUFGQ0FEY0NFQ0FDUVFKMFFialNnSUFBYWlFRUFrQUNRRUVBS0FLTTBJQ0FBQ0lHUVFFZ0FuUWlBM0VOQUNBRUlBRTJBZ0JCQUNBR0lBTnlOZ0tNMElDQUFDQUJJQVEyQWhnZ0FTQUJOZ0lJSUFFZ0FUWUNEQXdCQ3lBQVFRQkJHU0FDUVFGMmF5QUNRUjlHRzNRaEFpQUVLQUlBSVFZQ1FBTkFJQVlpQkNnQ0JFRjRjU0FBUmcwQklBSkJIWFloQmlBQ1FRRjBJUUlnQkNBR1FRUnhha0VRYWlJREtBSUFJZ1lOQUFzZ0F5QUJOZ0lBSUFFZ0JEWUNHQ0FCSUFFMkFnd2dBU0FCTmdJSURBRUxJQVFvQWdnaUFDQUJOZ0lNSUFRZ0FUWUNDQ0FCUVFBMkFoZ2dBU0FFTmdJTUlBRWdBRFlDQ0F0QkFFRUFLQUtvMElDQUFFRi9haUlCUVg4Z0FSczJBcWpRZ0lBQUN3c0VBQUFBQzA0QUFrQWdBQTBBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQmYwd05BQUpBSUFCQkVIWkFBQ0lBUVg5SERRQkJBRUV3TmdMNDA0Q0FBRUYvRHdzZ0FFRVFkQThMRU1xQWdJQUFBQXZ5QWdJRGZ3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FpQUFhaUlEUVg5cUlBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRjlhaUFCT2dBQUlBTkJmbW9nQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQmZHb2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtGOGFpQUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJlR29nQVRZQ0FDQUNRWFJxSUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRWEJxSUFFMkFnQWdBa0ZzYWlBQk5nSUFJQUpCYUdvZ0FUWUNBQ0FDUVdScUlBRTJBZ0FnQkNBRFFRUnhRUmh5SWdWcklnSkJJRWtOQUNBQnJVS0JnSUNBRUg0aEJpQURJQVZxSVFFRFFDQUJJQVkzQXhnZ0FTQUdOd01RSUFFZ0JqY0RDQ0FCSUFZM0F3QWdBVUVnYWlFQklBSkJZR29pQWtFZlN3MEFDd3NnQUFzTGprZ0JBRUdBQ0F1R1NBRUFBQUFDQUFBQUF3QUFBQUFBQUFBQUFBQUFCQUFBQUFVQUFBQUFBQUFBQUFBQUFBWUFBQUFIQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0J4ZFdWeWVRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgySnZaSGtBUTI5dWRHVnVkQzFNWlc1bmRHZ2diM1psY21ac2IzY0FRMmgxYm1zZ2MybDZaU0J2ZG1WeVpteHZkd0JTWlhOd2IyNXpaU0J2ZG1WeVpteHZkd0JKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnU0ZSVVVDOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJRzFsZEdodlpDQm1iM0lnVWxSVFVDOTRMbmdnY21WeGRXVnpkQUJGZUhCbFkzUmxaQ0JUVDFWU1EwVWdiV1YwYUc5a0lHWnZjaUJKUTBVdmVDNTRJSEpsY1hWbGMzUUFTVzUyWVd4cFpDQmphR0Z5SUdsdUlIVnliQ0JtY21GbmJXVnVkQ0J6ZEdGeWRBQkZlSEJsWTNSbFpDQmtiM1FBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl6ZEdGMGRYTUFTVzUyWVd4cFpDQnlaWE53YjI1elpTQnpkR0YwZFhNQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN3QlZjMlZ5SUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5eVpYTmxkR0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMmhsWVdSbGNtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZbVZuYVc1Z0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5emRHRjBkWE5mWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRYSnNYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJWeWRtVnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIWmhiSFZsSUdOb1lYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ1ptbGxiR1FnWTJoaGNnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzWmxjbk5wYjI0QVNXNTJZV3hwWkNCdGFXNXZjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdiV0ZxYjNJZ2RtVnljMmx2YmdCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lFTlNURVlnWVdaMFpYSWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lFaFVWRkFnZG1WeWMybHZiZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjBiMnRsYmdCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNWeWJBQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNuTWdhVzRnZFhKc0FGVnVaWGh3WldOMFpXUWdjM1JoY25RZ1kyaGhjaUJwYmlCMWNtd0FSRzkxWW14bElFQWdhVzRnZFhKc0FFVnRjSFI1SUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUVOdmJuUmxiblF0VEdWdVozUm9BRVIxY0d4cFkyRjBaU0JEYjI1MFpXNTBMVXhsYm1kMGFBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEJoZEdnQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnWTJGdUozUWdZbVVnY0hKbGMyVnVkQ0IzYVhSb0lGUnlZVzV6Wm1WeUxVVnVZMjlrYVc1bkFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlHaGxZV1JsY2lCMllXeDFaUUJKYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFnYUdWaFpHVnlJSFpoYkhWbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdVZ2RtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCeGRXOTBaV1FnZG1Gc2RXVUFVR0YxYzJWa0lHSjVJRzl1WDJobFlXUmxjbk5mWTI5dGNHeGxkR1VBU1c1MllXeHBaQ0JGVDBZZ2MzUmhkR1VBYjI1ZmNtVnpaWFFnY0dGMWMyVUFiMjVmWTJoMWJtdGZhR1ZoWkdWeUlIQmhkWE5sQUc5dVgyMWxjM05oWjJWZlltVm5hVzRnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYM1poYkhWbElIQmhkWE5sQUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MlpYSnphVzl1WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNWeWJGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOWphSFZ1YTE5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsSUhCaGRYTmxBRlZ1Wlhod1pXTjBaV1FnYzNCaFkyVWdZV1owWlhJZ2MzUmhjblFnYkdsdVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nYm1GdFpRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCVmJtVjRjR1ZqZEdWa0lHTm9ZWElnYVc0Z2RYSnNJSE5qYUdWdFlRQlNaWEYxWlhOMElHaGhjeUJwYm5aaGJHbGtJR0JVY21GdWMyWmxjaTFGYm1OdlpHbHVaMkFBVTFkSlZFTklYMUJTVDFoWkFGVlRSVjlRVWs5WVdRQk5TMEZEVkVsV1NWUlpBRlZPVUZKUFEwVlRVMEZDVEVWZlJVNVVTVlJaQUVOUFVGa0FUVTlXUlVSZlVFVlNUVUZPUlU1VVRGa0FWRTlQWDBWQlVreFpBRTVQVkVsR1dRQkdRVWxNUlVSZlJFVlFSVTVFUlU1RFdRQkNRVVJmUjBGVVJWZEJXUUJRVEVGWkFGQlZWQUJEU0VWRFMwOVZWQUJIUVZSRlYwRlpYMVJKVFVWUFZWUUFVa1ZSVlVWVFZGOVVTVTFGVDFWVUFFNUZWRmRQVWt0ZlEwOU9Ua1ZEVkY5VVNVMUZUMVZVQUVOUFRrNUZRMVJKVDA1ZlZFbE5SVTlWVkFCTVQwZEpUbDlVU1UxRlQxVlVBRTVGVkZkUFVrdGZVa1ZCUkY5VVNVMUZUMVZVQUZCUFUxUUFUVWxUUkVsU1JVTlVSVVJmVWtWUlZVVlRWQUJEVEVsRlRsUmZRMHhQVTBWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlNVDBGRVgwSkJURUZPUTBWRVgxSkZVVlZGVTFRQVFrRkVYMUpGVVZWRlUxUUFTRlJVVUY5U1JWRlZSVk5VWDFORlRsUmZWRTlmU0ZSVVVGTmZVRTlTVkFCU1JWQlBVbFFBU1UxZlFWOVVSVUZRVDFRQVVrVlRSVlJmUTA5T1ZFVk9WQUJPVDE5RFQwNVVSVTVVQUZCQlVsUkpRVXhmUTA5T1ZFVk9WQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVRWRUZPVkFCSVVFVmZRMEpmVWtWVFJWUUFSMFZVQUVoUVJWOVRWRkpKUTFRQVEwOU9Sa3hKUTFRQVZFVk5VRTlTUVZKWlgxSkZSRWxTUlVOVUFGQkZVazFCVGtWT1ZGOVNSVVJKVWtWRFZBQkRUMDVPUlVOVUFFMVZURlJKWDFOVVFWUlZVd0JJVUVWZlNVNVdRVXhKUkY5VFZFRlVWVk1BVkU5UFgwMUJUbGxmVWtWUlZVVlRWRk1BUlVGU1RGbGZTRWxPVkZNQVZVNUJWa0ZKVEVGQ1RFVmZSazlTWDB4RlIwRk1YMUpGUVZOUFRsTUFUMUJVU1U5T1V3QlRWMGxVUTBoSlRrZGZVRkpQVkU5RFQweFRBRlpCVWtsQlRsUmZRVXhUVDE5T1JVZFBWRWxCVkVWVEFFMVZURlJKVUV4RlgwTklUMGxEUlZNQVNVNVVSVkpPUVV4ZlUwVlNWa1ZTWDBWU1VrOVNBRmRGUWw5VFJWSldSVkpmVlU1TFRrOVhUbDlGVWxKUFVnQlNRVWxNUjFWT1gwVlNVazlTQUVsRVJVNVVTVlJaWDFCU1QxWkpSRVZTWDBGVlZFaEZUbFJKUTBGVVNVOU9YMFZTVWs5U0FGTlRURjlEUlZKVVNVWkpRMEZVUlY5RlVsSlBVZ0JKVGxaQlRFbEVYMWhmUms5U1YwRlNSRVZFWDBaUFVnQlRSVlJmVUVGU1FVMUZWRVZTQUVkRlZGOVFRVkpCVFVWVVJWSUFTRkJGWDFWVFJWSUFVMFZGWDA5VVNFVlNBRWhRUlY5RFFsOURTRlZPUzE5SVJVRkVSVklBVFV0RFFVeEZUa1JCVWdCVFJWUlZVQUJYUlVKZlUwVlNWa1ZTWDBsVFgwUlBWMDRBVkVWQlVrUlBWMDRBU0ZCRlgwTk1UMU5GUkY5RFQwNU9SVU5VU1U5T0FFaEZWVkpKVTFSSlExOUZXRkJKVWtGVVNVOU9BRVJKVTBOUFRrNUZRMVJGUkY5UFVFVlNRVlJKVDA0QVRrOU9YMEZWVkVoUFVrbFVRVlJKVmtWZlNVNUdUMUpOUVZSSlQwNEFTRkJGWDBsT1ZrRk1TVVJmVmtWU1UwbFBUZ0JJVUVWZlEwSmZUVVZUVTBGSFJWOUNSVWRKVGdCVFNWUkZYMGxUWDBaU1QxcEZUZ0JJVUVWZlNVNVdRVXhKUkY5SVJVRkVSVkpmVkU5TFJVNEFTVTVXUVV4SlJGOVVUMHRGVGdCR1QxSkNTVVJFUlU0QVJVNUlRVTVEUlY5WlQxVlNYME5CVEUwQVNGQkZYMGxPVmtGTVNVUmZWVkpNQUVKTVQwTkxSVVJmUWxsZlVFRlNSVTVVUVV4ZlEwOU9WRkpQVEFCTlMwTlBUQUJCUTB3QVNGQkZYMGxPVkVWU1RrRk1BRkpGVVZWRlUxUmZTRVZCUkVWU1gwWkpSVXhFVTE5VVQwOWZURUZTUjBWZlZVNVBSa1pKUTBsQlRBQklVRVZmVDBzQVZVNU1TVTVMQUZWT1RFOURTd0JRVWtrQVVrVlVVbGxmVjBsVVNBQklVRVZmU1U1V1FVeEpSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQklVRVZmVlU1RldGQkZRMVJGUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJHVEZWVFNBQlFVazlRVUVGVVEwZ0FUUzFUUlVGU1EwZ0FWVkpKWDFSUFQxOU1UMDVIQUZCU1QwTkZVMU5KVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlRUlZKVFNWTlVSVTVVWDFkQlVrNUpUa2NBVFVsVFEwVk1URUZPUlU5VlUxOVhRVkpPU1U1SEFFaFFSVjlKVGxaQlRFbEVYMVJTUVU1VFJrVlNYMFZPUTA5RVNVNUhBRVY0Y0dWamRHVmtJRU5TVEVZQVNGQkZYMGxPVmtGTVNVUmZRMGhWVGt0ZlUwbGFSUUJOVDFaRkFFTlBUbFJKVGxWRkFFaFFSVjlEUWw5VFZFRlVWVk5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsTmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxWkZVbE5KVDA1ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFWU1RGOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVGtGTlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlRVMEZIUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmVFVWVVNFOUVYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlJrbEZURVJmUTA5TlVFeEZWRVVBUkVWTVJWUkZBRWhRUlY5SlRsWkJURWxFWDBWUFJsOVRWRUZVUlFCSlRsWkJURWxFWDFOVFRGOURSVkpVU1VaSlEwRlVSUUJRUVZWVFJRQk9UMTlTUlZOUVQwNVRSUUJWVGxOVlVGQlBVbFJGUkY5TlJVUkpRVjlVV1ZCRkFFZFBUa1VBVGs5VVgwRkRRMFZRVkVGQ1RFVUFVMFZTVmtsRFJWOVZUa0ZXUVVsTVFVSk1SUUJTUVU1SFJWOU9UMVJmVTBGVVNWTkdTVUZDVEVVQVQxSkpSMGxPWDBsVFgxVk9Va1ZCUTBoQlFreEZBRkpGVTFCUFRsTkZYMGxUWDFOVVFVeEZBRkJWVWtkRkFFMUZVa2RGQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVUFVa1ZSVlVWVFZGOUlSVUZFUlZKZlZFOVBYMHhCVWtkRkFGQkJXVXhQUVVSZlZFOVBYMHhCVWtkRkFFbE9VMVZHUmtsRFNVVk9WRjlUVkU5U1FVZEZBRWhRUlY5UVFWVlRSVVJmVlZCSFVrRkVSUUJJVUVWZlVFRlZVMFZFWDBneVgxVlFSMUpCUkVVQVUwOVZVa05GQUVGT1RrOVZUa05GQUZSU1FVTkZBRWhRUlY5VlRrVllVRVZEVkVWRVgxTlFRVU5GQUVSRlUwTlNTVUpGQUZWT1UxVkNVME5TU1VKRkFGSkZRMDlTUkFCSVVFVmZTVTVXUVV4SlJGOU5SVlJJVDBRQVRrOVVYMFpQVlU1RUFGQlNUMUJHU1U1RUFGVk9Ra2xPUkFCU1JVSkpUa1FBVlU1QlZWUklUMUpKV2tWRUFFMUZWRWhQUkY5T1QxUmZRVXhNVDFkRlJBQklWRlJRWDFaRlVsTkpUMDVmVGs5VVgxTlZVRkJQVWxSRlJBQkJURkpGUVVSWlgxSkZVRTlTVkVWRUFFRkRRMFZRVkVWRUFFNVBWRjlKVFZCTVJVMUZUbFJGUkFCTVQwOVFYMFJGVkVWRFZFVkVBRWhRUlY5RFVsOUZXRkJGUTFSRlJBQklVRVZmVEVaZlJWaFFSVU5VUlVRQVExSkZRVlJGUkFCSlRWOVZVMFZFQUVoUVJWOVFRVlZUUlVRQVZFbE5SVTlWVkY5UFEwTlZVa1ZFQUZCQldVMUZUbFJmVWtWUlZVbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gxSkZVVlZKVWtWRUFGQlNUMWhaWDBGVlZFaEZUbFJKUTBGVVNVOU9YMUpGVVZWSlVrVkVBRTVGVkZkUFVrdGZRVlZVU0VWT1ZFbERRVlJKVDA1ZlVrVlJWVWxTUlVRQVRFVk9SMVJJWDFKRlVWVkpVa1ZFQUZOVFRGOURSVkpVU1VaSlEwRlVSVjlTUlZGVlNWSkZSQUJWVUVkU1FVUkZYMUpGVVZWSlVrVkVBRkJCUjBWZlJWaFFTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZSa0ZKVEVWRUFFVllVRVZEVkVGVVNVOU9YMFpCU1V4RlJBQlNSVlpCVEVsRVFWUkpUMDVmUmtGSlRFVkVBRk5UVEY5SVFVNUVVMGhCUzBWZlJrRkpURVZFQUV4UFEwdEZSQUJVVWtGT1UwWlBVazFCVkVsUFRsOUJVRkJNU1VWRUFFNVBWRjlOVDBSSlJrbEZSQUJPVDFSZlJWaFVSVTVFUlVRQVFrRk9SRmRKUkZSSVgweEpUVWxVWDBWWVEwVkZSRVZFQUZOSlZFVmZTVk5mVDFaRlVreFBRVVJGUkFCSVJVRkVBRVY0Y0dWamRHVmtJRWhVVkZBdkFBQmVFd0FBSmhNQUFEQVFBQUR3RndBQW5STUFBQlVTQUFBNUZ3QUE4QklBQUFvUUFBQjFFZ0FBclJJQUFJSVRBQUJQRkFBQWZ4QUFBS0FWQUFBakZBQUFpUklBQUlzVUFBQk5GUUFBMUJFQUFNOFVBQUFRR0FBQXlSWUFBTndXQUFEQkVRQUE0QmNBQUxzVUFBQjBGQUFBZkJVQUFPVVVBQUFJRndBQUh4QUFBR1VWQUFDakZBQUFLQlVBQUFJVkFBQ1pGUUFBTEJBQUFJc1pBQUJQRHdBQTFBNEFBR29RQUFET0VBQUFBaGNBQUlrT0FBQnVFd0FBSEJNQUFHWVVBQUJXRndBQXdSTUFBTTBUQUFCc0V3QUFhQmNBQUdZWEFBQmZGd0FBSWhNQUFNNFBBQUJwRGdBQTJBNEFBR01XQUFETEV3QUFxZzRBQUNnWEFBQW1Gd0FBeFJNQUFGMFdBQURvRVFBQVp4TUFBR1VUQUFEeUZnQUFjeE1BQUIwWEFBRDVGZ0FBOHhFQUFNOE9BQURPRlFBQURCSUFBTE1SQUFDbEVRQUFZUkFBQURJWEFBQzdFd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCc2IzTmxaV1Z3TFdGc2FYWmxBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFRQUJBUUVCQVFBQUFRRUFBUUVBQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0FBQUFBQUFBQUFBQUFBQUFBQUFISmhibk5tWlhJdFpXNWpiMlJwYm1kd1ozSmhaR1VOQ2cwS0RRcFRUUTBLRFFwVVZGQXZRMFV2VkZOUUx3QUFBQUFBQUFBQUFBQUFBQUVDQUFFREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFBQUFBQkFnQUJBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFCQVFVQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFBQUFBQkFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFNVBWVTVEUlVWRFMwOVZWRTVGUTFSRlZFVkRVa2xDUlV4VlUwaEZWRVZCUkZORlFWSkRTRkpIUlVOVVNWWkpWRmxNUlU1RVFWSldSVTlVU1VaWlVGUkpUMDVUUTBoVFJVRlpVMVJCVkVOSVIwVlBVa1JKVWtWRFZFOVNWRkpEU0ZCQlVrRk5SVlJGVWxWU1EwVkNVME5TU1VKRlFWSkVUMWRPUVVORlNVNUVUa3REUzFWQ1UwTlNTVUpGU0ZSVVVDOUJSRlJRTHc9PSdcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cF9zaW1kLXdhc20uanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key)=>{\n        const value = obj[key];\n        if (typeof value === \"number\") {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsU0FBU0UsVUFBVUMsR0FBRztJQUNsQixNQUFNQyxNQUFNLENBQUM7SUFDYk4sT0FBT08sSUFBSSxDQUFDRixLQUFLRyxPQUFPLENBQUMsQ0FBQ0M7UUFDdEIsTUFBTU4sUUFBUUUsR0FBRyxDQUFDSSxJQUFJO1FBQ3RCLElBQUksT0FBT04sVUFBVSxVQUFVO1lBQzNCRyxHQUFHLENBQUNHLElBQUksR0FBR047UUFDZjtJQUNKO0lBQ0EsT0FBT0c7QUFDWDtBQUNBSixpQkFBaUIsR0FBR0UsV0FDcEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanM/Y2NlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bVRvTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24gZW51bVRvTWFwKG9iaikge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW51bVRvTWFwID0gZW51bVRvTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bVRvTWFwIiwib2JqIiwicmVzIiwia2V5cyIsImZvckVhY2giLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst Agent = __webpack_require__(/*! ../agent */ \"(rsc)/./node_modules/undici/lib/agent.js\");\nconst { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst Dispatcher = __webpack_require__(/*! ../dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher.js\");\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(rsc)/./node_modules/undici/lib/mock/pluralizer.js\");\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\");\nclass FakeWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value;\n    }\n}\nclass MockAgent extends Dispatcher {\n    constructor(opts){\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        // Instantiate Agent and encapsulate\n        if (opts && opts.agent && typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts && opts.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n    }\n    get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n    }\n    dispatch(opts, handler) {\n        // Call MockAgent.get to perform additional setup before dispatching as normal\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n    }\n    async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n    }\n    deactivate() {\n        this[kIsMockActive] = false;\n    }\n    activate() {\n        this[kIsMockActive] = true;\n    }\n    enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n            if (Array.isArray(this[kNetConnect])) {\n                this[kNetConnect].push(matcher);\n            } else {\n                this[kNetConnect] = [\n                    matcher\n                ];\n            }\n        } else if (typeof matcher === \"undefined\") {\n            this[kNetConnect] = true;\n        } else {\n            throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n    }\n    disableNetConnect() {\n        this[kNetConnect] = false;\n    }\n    // This is required to bypass issues caused by using global symbols - see:\n    // https://github.com/nodejs/undici/issues/1447\n    get isMockActive() {\n        return this[kIsMockActive];\n    }\n    [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, new FakeWeakRef(dispatcher));\n    }\n    [kFactory](origin) {\n        const mockOptions = Object.assign({\n            agent: this\n        }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n    }\n    [kMockAgentGet](origin) {\n        // First check if we can immediately find it\n        const ref = this[kClients].get(origin);\n        if (ref) {\n            return ref.deref();\n        }\n        // If the origin is not a string create a dummy parent pool and return to user\n        if (typeof origin !== \"string\") {\n            const dispatcher = this[kFactory](\"http://localhost:9999\");\n            this[kMockAgentSet](origin, dispatcher);\n            return dispatcher;\n        }\n        // If we match, create a pool and assign the same dispatches\n        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])){\n            const nonExplicitDispatcher = nonExplicitRef.deref();\n            if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n                const dispatcher = this[kFactory](origin);\n                this[kMockAgentSet](origin, dispatcher);\n                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n                return dispatcher;\n            }\n        }\n    }\n    [kGetNetConnect]() {\n        return this[kNetConnect];\n    }\n    pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope.deref()[kDispatches].map((dispatch)=>({\n                    ...dispatch,\n                    origin\n                }))).filter(({ pending })=>pending);\n    }\n    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n            return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n    }\n}\nmodule.exports = MockAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNLEVBQ0pFLE1BQU0sRUFDTkMsYUFBYSxFQUNiQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1QsR0FBR1YsbUJBQU9BLENBQUM7QUFDWixNQUFNVyxhQUFhWCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNWSxXQUFXWixtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQUVhLFVBQVUsRUFBRUMsZ0JBQWdCLEVBQUUsR0FBR2QsbUJBQU9BLENBQUM7QUFDakQsTUFBTSxFQUFFZSxvQkFBb0IsRUFBRUMsV0FBVyxFQUFFLEdBQUdoQixtQkFBT0EsQ0FBQztBQUN0RCxNQUFNaUIsYUFBYWpCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1rQixhQUFhbEIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTW1CLCtCQUErQm5CLG1CQUFPQSxDQUFDO0FBRTdDLE1BQU1vQjtJQUNKQyxZQUFhQyxLQUFLLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2Y7SUFFQUMsUUFBUztRQUNQLE9BQU8sSUFBSSxDQUFDRCxLQUFLO0lBQ25CO0FBQ0Y7QUFFQSxNQUFNRSxrQkFBa0JQO0lBQ3RCSSxZQUFhSSxJQUFJLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUVOLElBQUksQ0FBQ2xCLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNELGNBQWMsR0FBRztRQUV0QixvQ0FBb0M7UUFDcEMsSUFBS21CLFFBQVFBLEtBQUtDLEtBQUssSUFBSSxPQUFPRCxLQUFLQyxLQUFLLENBQUNDLFFBQVEsS0FBSyxZQUFhO1lBQ3JFLE1BQU0sSUFB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Q0FBQztBQUMzQixFQUFFaUQsV0FBV0UsS0FBSyxDQUFDLENBQUMsRUFBRUYsV0FBV0csSUFBSSxDQUFDLENBQUMsRUFBRUgsV0FBV0ksRUFBRSxDQUFDOztBQUV2RCxFQUFFTiw2QkFBNkJPLE1BQU0sQ0FBQ1QsU0FBUztBQUMvQyxDQUFDLENBQUNVLElBQUk7SUFDSjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanM/OWFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ2xpZW50cyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi4vYWdlbnQnKVxuY29uc3Qge1xuICBrQWdlbnQsXG4gIGtNb2NrQWdlbnRTZXQsXG4gIGtNb2NrQWdlbnRHZXQsXG4gIGtEaXNwYXRjaGVzLFxuICBrSXNNb2NrQWN0aXZlLFxuICBrTmV0Q29ubmVjdCxcbiAga0dldE5ldENvbm5lY3QsXG4gIGtPcHRpb25zLFxuICBrRmFjdG9yeVxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9tb2NrLXBvb2wnKVxuY29uc3QgeyBtYXRjaFZhbHVlLCBidWlsZE1vY2tPcHRpb25zIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyJylcbmNvbnN0IFBsdXJhbGl6ZXIgPSByZXF1aXJlKCcuL3BsdXJhbGl6ZXInKVxuY29uc3QgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IHJlcXVpcmUoJy4vcGVuZGluZy1pbnRlcmNlcHRvcnMtZm9ybWF0dGVyJylcblxuY2xhc3MgRmFrZVdlYWtSZWYge1xuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIGRlcmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG59XG5cbmNsYXNzIE1vY2tBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuXG4gICAgLy8gSW5zdGFudGlhdGUgQWdlbnQgYW5kIGVuY2Fwc3VsYXRlXG4gICAgaWYgKChvcHRzICYmIG9wdHMuYWdlbnQgJiYgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cbiAgICBjb25zdCBhZ2VudCA9IG9wdHMgJiYgb3B0cy5hZ2VudCA/IG9wdHMuYWdlbnQgOiBuZXcgQWdlbnQob3B0cylcbiAgICB0aGlzW2tBZ2VudF0gPSBhZ2VudFxuXG4gICAgdGhpc1trQ2xpZW50c10gPSBhZ2VudFtrQ2xpZW50c11cbiAgICB0aGlzW2tPcHRpb25zXSA9IGJ1aWxkTW9ja09wdGlvbnMob3B0cylcbiAgfVxuXG4gIGdldCAob3JpZ2luKSB7XG4gICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tNb2NrQWdlbnRHZXRdKG9yaWdpbilcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9yaWdpbilcbiAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgIH1cbiAgICByZXR1cm4gZGlzcGF0Y2hlclxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAvLyBDYWxsIE1vY2tBZ2VudC5nZXQgdG8gcGVyZm9ybSBhZGRpdGlvbmFsIHNldHVwIGJlZm9yZSBkaXNwYXRjaGluZyBhcyBub3JtYWxcbiAgICB0aGlzLmdldChvcHRzLm9yaWdpbilcbiAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBjbG9zZSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKClcbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG4gIH1cblxuICBkZWFjdGl2YXRlICgpIHtcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gZmFsc2VcbiAgfVxuXG4gIGFjdGl2YXRlICgpIHtcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuICB9XG5cbiAgZW5hYmxlTmV0Q29ubmVjdCAobWF0Y2hlcikge1xuICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1hdGNoZXIgPT09ICdmdW5jdGlvbicgfHwgbWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpc1trTmV0Q29ubmVjdF0pKSB7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdLnB1c2gobWF0Y2hlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gW21hdGNoZXJdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNba05ldENvbm5lY3RdID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdGNoZXIuIE11c3QgYmUgb25lIG9mIFN0cmluZ3xGdW5jdGlvbnxSZWdFeHAuJylcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlTmV0Q29ubmVjdCAoKSB7XG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSBmYWxzZVxuICB9XG5cbiAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBieXBhc3MgaXNzdWVzIGNhdXNlZCBieSB1c2luZyBnbG9iYWwgc3ltYm9scyAtIHNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE0NDdcbiAgZ2V0IGlzTW9ja0FjdGl2ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0lzTW9ja0FjdGl2ZV1cbiAgfVxuXG4gIFtrTW9ja0FnZW50U2V0XSAob3JpZ2luLCBkaXNwYXRjaGVyKSB7XG4gICAgdGhpc1trQ2xpZW50c10uc2V0KG9yaWdpbiwgbmV3IEZha2VXZWFrUmVmKGRpc3BhdGNoZXIpKVxuICB9XG5cbiAgW2tGYWN0b3J5XSAob3JpZ2luKSB7XG4gICAgY29uc3QgbW9ja09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWdlbnQ6IHRoaXMgfSwgdGhpc1trT3B0aW9uc10pXG4gICAgcmV0dXJuIHRoaXNba09wdGlvbnNdICYmIHRoaXNba09wdGlvbnNdLmNvbm5lY3Rpb25zID09PSAxXG4gICAgICA/IG5ldyBNb2NrQ2xpZW50KG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gICAgICA6IG5ldyBNb2NrUG9vbChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICB9XG5cbiAgW2tNb2NrQWdlbnRHZXRdIChvcmlnaW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgZmluZCBpdFxuICAgIGNvbnN0IHJlZiA9IHRoaXNba0NsaWVudHNdLmdldChvcmlnaW4pXG4gICAgaWYgKHJlZikge1xuICAgICAgcmV0dXJuIHJlZi5kZXJlZigpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9yaWdpbiBpcyBub3QgYSBzdHJpbmcgY3JlYXRlIGEgZHVtbXkgcGFyZW50IHBvb2wgYW5kIHJldHVybiB0byB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0oJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OScpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgbWF0Y2gsIGNyZWF0ZSBhIHBvb2wgYW5kIGFzc2lnbiB0aGUgc2FtZSBkaXNwYXRjaGVzXG4gICAgZm9yIChjb25zdCBba2V5TWF0Y2hlciwgbm9uRXhwbGljaXRSZWZdIG9mIEFycmF5LmZyb20odGhpc1trQ2xpZW50c10pKSB7XG4gICAgICBjb25zdCBub25FeHBsaWNpdERpc3BhdGNoZXIgPSBub25FeHBsaWNpdFJlZi5kZXJlZigpXG4gICAgICBpZiAobm9uRXhwbGljaXREaXNwYXRjaGVyICYmIHR5cGVvZiBrZXlNYXRjaGVyICE9PSAnc3RyaW5nJyAmJiBtYXRjaFZhbHVlKGtleU1hdGNoZXIsIG9yaWdpbikpIHtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9yaWdpbilcbiAgICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICAgIGRpc3BhdGNoZXJba0Rpc3BhdGNoZXNdID0gbm9uRXhwbGljaXREaXNwYXRjaGVyW2tEaXNwYXRjaGVzXVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtrR2V0TmV0Q29ubmVjdF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tOZXRDb25uZWN0XVxuICB9XG5cbiAgcGVuZGluZ0ludGVyY2VwdG9ycyAoKSB7XG4gICAgY29uc3QgbW9ja0FnZW50Q2xpZW50cyA9IHRoaXNba0NsaWVudHNdXG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShtb2NrQWdlbnRDbGllbnRzLmVudHJpZXMoKSlcbiAgICAgIC5mbGF0TWFwKChbb3JpZ2luLCBzY29wZV0pID0+IHNjb3BlLmRlcmVmKClba0Rpc3BhdGNoZXNdLm1hcChkaXNwYXRjaCA9PiAoeyAuLi5kaXNwYXRjaCwgb3JpZ2luIH0pKSlcbiAgICAgIC5maWx0ZXIoKHsgcGVuZGluZyB9KSA9PiBwZW5kaW5nKVxuICB9XG5cbiAgYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzICh7IHBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSBuZXcgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlcigpIH0gPSB7fSkge1xuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdJbnRlcmNlcHRvcnMoKVxuXG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwbHVyYWxpemVyID0gbmV3IFBsdXJhbGl6ZXIoJ2ludGVyY2VwdG9yJywgJ2ludGVyY2VwdG9ycycpLnBsdXJhbGl6ZShwZW5kaW5nLmxlbmd0aClcblxuICAgIHRocm93IG5ldyBVbmRpY2lFcnJvcihgXG4ke3BsdXJhbGl6ZXIuY291bnR9ICR7cGx1cmFsaXplci5ub3VufSAke3BsdXJhbGl6ZXIuaXN9IHBlbmRpbmc6XG5cbiR7cGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlci5mb3JtYXQocGVuZGluZyl9XG5gLnRyaW0oKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tBZ2VudFxuIl0sIm5hbWVzIjpbImtDbGllbnRzIiwicmVxdWlyZSIsIkFnZW50Iiwia0FnZW50Iiwia01vY2tBZ2VudFNldCIsImtNb2NrQWdlbnRHZXQiLCJrRGlzcGF0Y2hlcyIsImtJc01vY2tBY3RpdmUiLCJrTmV0Q29ubmVjdCIsImtHZXROZXRDb25uZWN0Iiwia09wdGlvbnMiLCJrRmFjdG9yeSIsIk1vY2tDbGllbnQiLCJNb2NrUG9vbCIsIm1hdGNoVmFsdWUiLCJidWlsZE1vY2tPcHRpb25zIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJVbmRpY2lFcnJvciIsIkRpc3BhdGNoZXIiLCJQbHVyYWxpemVyIiwiUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciIsIkZha2VXZWFrUmVmIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsImRlcmVmIiwiTW9ja0FnZW50Iiwib3B0cyIsImFnZW50IiwiZGlzcGF0Y2giLCJnZXQiLCJvcmlnaW4iLCJkaXNwYXRjaGVyIiwiaGFuZGxlciIsImNsb3NlIiwiY2xlYXIiLCJkZWFjdGl2YXRlIiwiYWN0aXZhdGUiLCJlbmFibGVOZXRDb25uZWN0IiwibWF0Y2hlciIsIlJlZ0V4cCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJkaXNhYmxlTmV0Q29ubmVjdCIsImlzTW9ja0FjdGl2ZSIsInNldCIsIm1vY2tPcHRpb25zIiwiT2JqZWN0IiwiYXNzaWduIiwiY29ubmVjdGlvbnMiLCJyZWYiLCJrZXlNYXRjaGVyIiwibm9uRXhwbGljaXRSZWYiLCJmcm9tIiwibm9uRXhwbGljaXREaXNwYXRjaGVyIiwicGVuZGluZ0ludGVyY2VwdG9ycyIsIm1vY2tBZ2VudENsaWVudHMiLCJlbnRyaWVzIiwiZmxhdE1hcCIsInNjb3BlIiwibWFwIiwiZmlsdGVyIiwicGVuZGluZyIsImFzc2VydE5vUGVuZGluZ0ludGVyY2VwdG9ycyIsInBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIiLCJsZW5ndGgiLCJwbHVyYWxpemVyIiwicGx1cmFsaXplIiwiY291bnQiLCJub3VuIiwiaXMiLCJmb3JtYXQiLCJ0cmltIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Client = __webpack_require__(/*! ../client */ \"(rsc)/./node_modules/undici/lib/client.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */ class MockClient extends Client {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFRSxpQkFBaUIsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQ0pHLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxNQUFNLEVBQ05DLGNBQWMsRUFDZEMsT0FBTyxFQUNQQyxpQkFBaUIsRUFDakJDLFVBQVUsRUFDWCxHQUFHVCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRVUsZUFBZSxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU1XLFVBQVVYLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU0sRUFBRVksb0JBQW9CLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFFekM7O0NBRUMsR0FDRCxNQUFNYSxtQkFBbUJaO0lBQ3ZCYSxZQUFhQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNELFFBQVFDO1FBRWQsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEtBQUssSUFBSSxPQUFPRCxLQUFLQyxLQUFLLENBQUNDLFFBQVEsS0FBSyxZQUFZO1lBQ3JFLE1BQU0sSUFBSU4scUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDUixXQUFXLEdBQUdZLEtBQUtDLEtBQUs7UUFDN0IsSUFBSSxDQUFDVixRQUFRLEdBQUdRO1FBQ2hCLElBQUksQ0FBQ1osWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDTSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxJQUFJLENBQUNVLFFBQVE7UUFDdkMsSUFBSSxDQUFDWixlQUFlLEdBQUcsSUFBSSxDQUFDYSxLQUFLLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBRTNDLElBQUksQ0FBQ0YsUUFBUSxHQUFHaEIsa0JBQWtCbUIsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDRixLQUFLLEdBQUcsSUFBSSxDQUFDZCxPQUFPO0lBQzNCO0lBRUEsSUFBSSxDQUFDTSxRQUFRRixVQUFVLENBQUMsR0FBSTtRQUMxQixPQUFPLElBQUksQ0FBQ0EsV0FBVztJQUN6QjtJQUVBOztHQUVDLEdBQ0RhLFVBQVdOLElBQUksRUFBRTtRQUNmLE9BQU8sSUFBSU4sZ0JBQWdCTSxNQUFNLElBQUksQ0FBQ2IsWUFBWTtJQUNwRDtJQUVBLE1BQU0sQ0FBQ0UsT0FBTyxHQUFJO1FBQ2hCLE1BQU1OLFVBQVUsSUFBSSxDQUFDTyxlQUFlO1FBQ3BDLElBQUksQ0FBQ0csV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0wsV0FBVyxDQUFDTyxRQUFRWSxRQUFRLENBQUMsQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQ2pCLFFBQVE7SUFDekQ7QUFDRjtBQUVBa0IsT0FBT0MsT0FBTyxHQUFHYiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWNsaWVudC5qcz9jNzZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrQ2xpZW50IHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIENsaWVudCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0NsaWVudFxuIl0sIm5hbWVzIjpbInByb21pc2lmeSIsInJlcXVpcmUiLCJDbGllbnQiLCJidWlsZE1vY2tEaXNwYXRjaCIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtPcmlnaW5hbERpc3BhdGNoIiwia0Nvbm5lY3RlZCIsIk1vY2tJbnRlcmNlcHRvciIsIlN5bWJvbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk1vY2tDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9yaWdpbiIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiY2xvc2UiLCJiaW5kIiwiY2FsbCIsImludGVyY2VwdCIsImtDbGllbnRzIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nclass MockNotMatchedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n    }\n}\nmodule.exports = {\n    MockNotMatchedError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxXQUFXLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFaEMsTUFBTUMsNEJBQTRCRjtJQUNoQ0csWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTkMsTUFBTUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFSjtRQUM5QixJQUFJLENBQUNLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZlI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qcz84NTBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIE1vY2tOb3RNYXRjaGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2NrTm90TWF0Y2hlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNb2NrTm90TWF0Y2hlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcydcbiAgICB0aGlzLmNvZGUgPSAnVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1vY2tOb3RNYXRjaGVkRXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJVbmRpY2lFcnJvciIsInJlcXVpcmUiLCJNb2NrTm90TWF0Y2hlZEVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm5hbWUiLCJjb2RlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\n/**\n * Defines the scope API for an interceptor reply\n */ class MockScope {\n    constructor(mockDispatch){\n        this[kMockDispatch] = mockDispatch;\n    }\n    /**\n   * Delay a reply by a set amount in ms.\n   */ delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n            throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n    }\n    /**\n   * For a defined reply, never mark as consumed.\n   */ persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n    }\n    /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */ times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n            throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n    }\n}\n/**\n * Defines an interceptor for a Mock\n */ class MockInterceptor {\n    constructor(opts, mockDispatches){\n        if (typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n            throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n            opts.method = \"GET\";\n        }\n        // See https://github.com/nodejs/undici/issues/1245\n        // As per RFC 3986, clients are not supposed to send URI\n        // fragments to servers when they retrieve a document,\n        if (typeof opts.path === \"string\") {\n            if (opts.query) {\n                opts.path = buildURL(opts.path, opts.query);\n            } else {\n                // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n                const parsedURL = new URL(opts.path, \"data://\");\n                opts.path = parsedURL.pathname + parsedURL.search;\n            }\n        }\n        if (typeof opts.method === \"string\") {\n            opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n    }\n    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? {\n            \"content-length\": responseData.length\n        } : {};\n        const headers = {\n            ...this[kDefaultHeaders],\n            ...contentLength,\n            ...responseOptions.headers\n        };\n        const trailers = {\n            ...this[kDefaultTrailers],\n            ...responseOptions.trailers\n        };\n        return {\n            statusCode,\n            data,\n            headers,\n            trailers\n        };\n    }\n    validateReplyParameters(statusCode, data, responseOptions) {\n        if (typeof statusCode === \"undefined\") {\n            throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof data === \"undefined\") {\n            throw new InvalidArgumentError(\"data must be defined\");\n        }\n        if (typeof responseOptions !== \"object\") {\n            throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n    }\n    /**\n   * Mock an undici request with a defined reply.\n   */ reply(replyData) {\n        // Values of reply aren't available right now as they\n        // can only be available when the reply callback is invoked.\n        if (typeof replyData === \"function\") {\n            // We'll first wrap the provided callback in another function,\n            // this function will properly resolve the data from the callback\n            // when invoked.\n            const wrappedDefaultsCallback = (opts)=>{\n                // Our reply options callback contains the parameter for statusCode, data and options.\n                const resolvedData = replyData(opts);\n                // Check if it is in the right format\n                if (typeof resolvedData !== \"object\") {\n                    throw new InvalidArgumentError(\"reply options callback must return an object\");\n                }\n                const { statusCode, data = \"\", responseOptions = {} } = resolvedData;\n                this.validateReplyParameters(statusCode, data, responseOptions);\n                // Since the values can be obtained immediately we return them\n                // from this higher order function that will be resolved later.\n                return {\n                    ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n                };\n            };\n            // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n            return new MockScope(newMockDispatch);\n        }\n        // We can have either one or three parameters, if we get here,\n        // we should have 1-3 parameters. So we spread the arguments of\n        // this function to obtain the parameters, since replyData will always\n        // just be the statusCode.\n        const [statusCode, data = \"\", responseOptions = {}] = [\n            ...arguments\n        ];\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Send in-already provided data like usual\n        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Mock an undici request with a defined error.\n   */ replyWithError(error) {\n        if (typeof error === \"undefined\") {\n            throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n            error\n        });\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */ defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n            throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n    }\n    /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */ defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n            throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n    }\n    /**\n   * Set reply content length header for replies on the interceptor\n   */ replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n    }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGVBQWUsRUFBRUMsUUFBUSxFQUFFQyxlQUFlLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDL0QsTUFBTSxFQUNKQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsZUFBZSxFQUNmQyxnQkFBZ0IsRUFDaEJDLGNBQWMsRUFDZEMsYUFBYSxFQUNkLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTyxvQkFBb0IsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUN6QyxNQUFNLEVBQUVRLFFBQVEsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUU3Qjs7Q0FFQyxHQUNELE1BQU1TO0lBQ0pDLFlBQWFDLFlBQVksQ0FBRTtRQUN6QixJQUFJLENBQUNMLGNBQWMsR0FBR0s7SUFDeEI7SUFFQTs7R0FFQyxHQUNEQyxNQUFPQyxRQUFRLEVBQUU7UUFDZixJQUFJLE9BQU9BLGFBQWEsWUFBWSxDQUFDQyxPQUFPQyxTQUFTLENBQUNGLGFBQWFBLFlBQVksR0FBRztZQUNoRixNQUFNLElBQUlOLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ0QsY0FBYyxDQUFDTSxLQUFLLEdBQUdDO1FBQzVCLE9BQU8sSUFBSTtJQUNiO0lBRUE7O0dBRUMsR0FDREcsVUFBVztRQUNULElBQUksQ0FBQ1YsY0FBYyxDQUFDVSxPQUFPLEdBQUc7UUFDOUIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFQyxHQUNEQyxNQUFPQyxXQUFXLEVBQUU7UUFDbEIsSUFBSSxPQUFPQSxnQkFBZ0IsWUFBWSxDQUFDSixPQUFPQyxTQUFTLENBQUNHLGdCQUFnQkEsZUFBZSxHQUFHO1lBQ3pGLE1BQU0sSUFBSVgscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDRCxjQUFjLENBQUNXLEtBQUssR0FBR0M7UUFDNUIsT0FBTyxJQUFJO0lBQ2I7QUFDRjtB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YjtJQUVBOztHQUVDLEdBQ0RhLHFCQUFzQlosUUFBUSxFQUFFO1FBQzlCLElBQUksT0FBT0EsYUFBYSxhQUFhO1lBQ25DLE1BQU0sSUFBSS9CLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ0gsaUJBQWlCLEdBQUdrQztRQUN6QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVDLEdBQ0RhLHFCQUFzQjtRQUNwQixJQUFJLENBQUM5QyxlQUFlLEdBQUc7UUFDdkIsT0FBTyxJQUFJO0lBQ2I7QUFDRjtBQUVBK0MsOEJBQThCLEdBQUdqQztBQUNqQ2lDLHdCQUF3QixHQUFHM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1pbnRlcmNlcHRvci5qcz9iY2U0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGdldFJlc3BvbnNlRGF0YSwgYnVpbGRLZXksIGFkZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtEaXNwYXRjaEtleSxcbiAga0RlZmF1bHRIZWFkZXJzLFxuICBrRGVmYXVsdFRyYWlsZXJzLFxuICBrQ29udGVudExlbmd0aCxcbiAga01vY2tEaXNwYXRjaFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2NvcGUgQVBJIGZvciBhbiBpbnRlcmNlcHRvciByZXBseVxuICovXG5jbGFzcyBNb2NrU2NvcGUge1xuICBjb25zdHJ1Y3RvciAobW9ja0Rpc3BhdGNoKSB7XG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXSA9IG1vY2tEaXNwYXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIERlbGF5IGEgcmVwbHkgYnkgYSBzZXQgYW1vdW50IGluIG1zLlxuICAgKi9cbiAgZGVsYXkgKHdhaXRJbk1zKSB7XG4gICAgaWYgKHR5cGVvZiB3YWl0SW5NcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIod2FpdEluTXMpIHx8IHdhaXRJbk1zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignd2FpdEluTXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLmRlbGF5ID0gd2FpdEluTXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGRlZmluZWQgcmVwbHksIG5ldmVyIG1hcmsgYXMgY29uc3VtZWQuXG4gICAqL1xuICBwZXJzaXN0ICgpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnBlcnNpc3QgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBvbmUgdG8gZGVmaW5lIGEgcmVwbHkgZm9yIGEgc2V0IGFtb3VudCBvZiBtYXRjaGluZyByZXF1ZXN0cy5cbiAgICovXG4gIHRpbWVzIChyZXBlYXRUaW1lcykge1xuICAgIGlmICh0eXBlb2YgcmVwZWF0VGltZXMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHJlcGVhdFRpbWVzKSB8fCByZXBlYXRUaW1lcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3JlcGVhdFRpbWVzIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS50aW1lcyA9IHJlcGVhdFRpbWVzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgYW4gaW50ZXJjZXB0b3IgZm9yIGEgTW9ja1xuICovXG5jbGFzcyBNb2NrSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9ja0Rpc3BhdGNoZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5wYXRoIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgfVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTI0NVxuICAgIC8vIEFzIHBlciBSRkMgMzk4NiwgY2xpZW50cyBhcmUgbm90IHN1cHBvc2VkIHRvIHNlbmQgVVJJXG4gICAgLy8gZnJhZ21lbnRzIHRvIHNlcnZlcnMgd2hlbiB0aGV5IHJldHJpZXZlIGEgZG9jdW1lbnQsXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0cy5xdWVyeSkge1xuICAgICAgICBvcHRzLnBhdGggPSBidWlsZFVSTChvcHRzLnBhdGgsIG9wdHMucXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYXRjaGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvbWFpbi9saWIvZmV0Y2gvaW5kZXguanMjTDE4MTFcbiAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChvcHRzLnBhdGgsICdkYXRhOi8vJylcbiAgICAgICAgb3B0cy5wYXRoID0gcGFyc2VkVVJMLnBhdGhuYW1lICsgcGFyc2VkVVJMLnNlYXJjaFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cy5tZXRob2QgPSBvcHRzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgdGhpc1trRGlzcGF0Y2hLZXldID0gYnVpbGRLZXkob3B0cylcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IG1vY2tEaXNwYXRjaGVzXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0ge31cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0ge31cbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGZhbHNlXG4gIH1cblxuICBjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEgKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyAnY29udGVudC1sZW5ndGgnOiByZXNwb25zZURhdGEubGVuZ3RoIH0gOiB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfVxuICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfVxuICB9XG5cbiAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMgKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzQ29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc3RhdHVzQ29kZSBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2RhdGEgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZU9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Jlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgcmVwbHkuXG4gICAqL1xuICByZXBseSAocmVwbHlEYXRhKSB7XG4gICAgLy8gVmFsdWVzIG9mIHJlcGx5IGFyZW4ndCBhdmFpbGFibGUgcmlnaHQgbm93IGFzIHRoZXlcbiAgICAvLyBjYW4gb25seSBiZSBhdmFpbGFibGUgd2hlbiB0aGUgcmVwbHkgY2FsbGJhY2sgaXMgaW52b2tlZC5cbiAgICBpZiAodHlwZW9mIHJlcGx5RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UnbGwgZmlyc3Qgd3JhcCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgaW4gYW5vdGhlciBmdW5jdGlvbixcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBwcm9wZXJseSByZXNvbHZlIHRoZSBkYXRhIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAvLyB3aGVuIGludm9rZWQuXG4gICAgICBjb25zdCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayA9IChvcHRzKSA9PiB7XG4gICAgICAgIC8vIE91ciByZXBseSBvcHRpb25zIGNhbGxiYWNrIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIgZm9yIHN0YXR1c0NvZGUsIGRhdGEgYW5kIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRGF0YSA9IHJlcGx5RGF0YShvcHRzKVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBseSBvcHRpb25zIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGRhdGEgPSAnJywgcmVzcG9uc2VPcHRpb25zID0ge30gfSA9IHJlc29sdmVkRGF0YVxuICAgICAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcbiAgICAgICAgLy8gU2luY2UgdGhlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgaW1tZWRpYXRlbHkgd2UgcmV0dXJuIHRoZW1cbiAgICAgICAgLy8gZnJvbSB0aGlzIGhpZ2hlciBvcmRlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEoc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB1c3VhbCBkaXNwYXRjaCBkYXRhLCBidXQgdGhpcyB0aW1lIHNldCB0aGUgZGF0YSBwYXJhbWV0ZXIgdG8gZnVuY3Rpb24gdGhhdCB3aWxsIGV2ZW50dWFsbHkgcHJvdmlkZSBkYXRhLlxuICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrKVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgW3N0YXR1c0NvZGUsIGRhdGEgPSAnJywgcmVzcG9uc2VPcHRpb25zID0ge31dID0gWy4uLmFyZ3VtZW50c11cbiAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucylcblxuICAgIC8vIFNlbmQgaW4tYWxyZWFkeSBwcm92aWRlZCBkYXRhIGxpa2UgdXN1YWxcbiAgICBjb25zdCBkaXNwYXRjaERhdGEgPSB0aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMpXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIGRpc3BhdGNoRGF0YSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCBlcnJvci5cbiAgICovXG4gIHJlcGx5V2l0aEVycm9yIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Vycm9yIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHsgZXJyb3IgfSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgaGVhZGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5SGVhZGVycyAoaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IHRyYWlsZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlUcmFpbGVycyAodHJhaWxlcnMpIHtcbiAgICBpZiAodHlwZW9mIHRyYWlsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd0cmFpbGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB0cmFpbGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlcGx5IGNvbnRlbnQgbGVuZ3RoIGhlYWRlciBmb3IgcmVwbGllcyBvbiB0aGUgaW50ZXJjZXB0b3JcbiAgICovXG4gIHJlcGx5Q29udGVudExlbmd0aCAoKSB7XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3Jcbm1vZHVsZS5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZVxuIl0sIm5hbWVzIjpbImdldFJlc3BvbnNlRGF0YSIsImJ1aWxkS2V5IiwiYWRkTW9ja0Rpc3BhdGNoIiwicmVxdWlyZSIsImtEaXNwYXRjaGVzIiwia0Rpc3BhdGNoS2V5Iiwia0RlZmF1bHRIZWFkZXJzIiwia0RlZmF1bHRUcmFpbGVycyIsImtDb250ZW50TGVuZ3RoIiwia01vY2tEaXNwYXRjaCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiYnVpbGRVUkwiLCJNb2NrU2NvcGUiLCJjb25zdHJ1Y3RvciIsIm1vY2tEaXNwYXRjaCIsImRlbGF5Iiwid2FpdEluTXMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJwZXJzaXN0IiwidGltZXMiLCJyZXBlYXRUaW1lcyIsIk1vY2tJbnRlcmNlcHRvciIsIm9wdHMiLCJtb2NrRGlzcGF0Y2hlcyIsInBhdGgiLCJtZXRob2QiLCJxdWVyeSIsInBhcnNlZFVSTCIsIlVSTCIsInBhdGhuYW1lIiwic2VhcmNoIiwidG9VcHBlckNhc2UiLCJjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEiLCJzdGF0dXNDb2RlIiwiZGF0YSIsInJlc3BvbnNlT3B0aW9ucyIsInJlc3BvbnNlRGF0YSIsImNvbnRlbnRMZW5ndGgiLCJsZW5ndGgiLCJoZWFkZXJzIiwidHJhaWxlcnMiLCJ2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyIsInJlcGx5IiwicmVwbHlEYXRhIiwid3JhcHBlZERlZmF1bHRzQ2FsbGJhY2siLCJyZXNvbHZlZERhdGEiLCJuZXdNb2NrRGlzcGF0Y2giLCJhcmd1bWVudHMiLCJkaXNwYXRjaERhdGEiLCJyZXBseVdpdGhFcnJvciIsImVycm9yIiwiZGVmYXVsdFJlcGx5SGVhZGVycyIsImRlZmF1bHRSZXBseVRyYWlsZXJzIiwicmVwbHlDb250ZW50TGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst Pool = __webpack_require__(/*! ../pool */ \"(rsc)/./node_modules/undici/lib/pool.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */ class MockPool extends Pool {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUUsaUJBQWlCLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDdEMsTUFBTSxFQUNKRyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsTUFBTSxFQUNOQyxjQUFjLEVBQ2RDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1gsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVVLGVBQWUsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNVyxVQUFVWCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVZLG9CQUFvQixFQUFFLEdBQUdaLG1CQUFPQSxDQUFDO0FBRXpDOztDQUVDLEdBQ0QsTUFBTWEsaUJBQWlCWjtJQUNyQmEsWUFBYUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDekIsS0FBSyxDQUFDRCxRQUFRQztRQUVkLElBQUksQ0FBQ0EsUUFBUSxDQUFDQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtBQUssWUFBWTtZQUNyRSxNQUFNLElBQUlOLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ1IsV0FBVyxHQUFHWSxLQUFLQyxLQUFLO1FBQzdCLElBQUksQ0FBQ1YsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNaLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ00sV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsSUFBSSxDQUFDVSxRQUFRO1FBQ3ZDLElBQUksQ0FBQ1osZUFBZSxHQUFHLElBQUksQ0FBQ2EsS0FBSyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUUzQyxJQUFJLENBQUNGLFFBQVEsR0FBR2hCLGtCQUFrQm1CLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ2QsT0FBTztJQUMzQjtJQUVBLElBQUksQ0FBQ00sUUFBUUYsVUFBVSxDQUFDLEdBQUk7UUFDMUIsT0FBTyxJQUFJLENBQUNBLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUNEYSxVQUFXTixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUlOLGdCQUFnQk0sTUFBTSxJQUFJLENBQUNiLFlBQVk7SUFDcEQ7SUFFQSxNQUFNLENBQUNFLE9BQU8sR0FBSTtRQUNoQixNQUFNTixVQUFVLElBQUksQ0FBQ08sZUFBZTtRQUNwQyxJQUFJLENBQUNHLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNMLFdBQVcsQ0FBQ08sUUFBUVksUUFBUSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixRQUFRO0lBQ3pEO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1wb29sLmpzPzRhNjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuLi9wb29sJylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlKCcuL21vY2staW50ZXJjZXB0b3InKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogTW9ja1Bvb2wgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgUG9vbCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrUG9vbCBleHRlbmRzIFBvb2wge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMVxuICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaFxuICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKVxuICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV1cbiAgfVxuXG4gIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBiYXNlIGludGVyY2VwdG9yIGZvciBtb2NraW5nIHJlcGxpZXMgZnJvbSB1bmRpY2kuXG4gICAqL1xuICBpbnRlcmNlcHQgKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUG9vbFxuIl0sIm5hbWVzIjpbInByb21pc2lmeSIsInJlcXVpcmUiLCJQb29sIiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJrRGlzcGF0Y2hlcyIsImtNb2NrQWdlbnQiLCJrQ2xvc2UiLCJrT3JpZ2luYWxDbG9zZSIsImtPcmlnaW4iLCJrT3JpZ2luYWxEaXNwYXRjaCIsImtDb25uZWN0ZWQiLCJNb2NrSW50ZXJjZXB0b3IiLCJTeW1ib2xzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJNb2NrUG9vbCIsImNvbnN0cnVjdG9yIiwib3JpZ2luIiwib3B0cyIsImFnZW50IiwiZGlzcGF0Y2giLCJjbG9zZSIsImJpbmQiLCJjYWxsIiwiaW50ZXJjZXB0Iiwia0NsaWVudHMiLCJkZWxldGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kAgent: Symbol(\"agent\"),\n    kOptions: Symbol(\"options\"),\n    kFactory: Symbol(\"factory\"),\n    kDispatches: Symbol(\"dispatches\"),\n    kDispatchKey: Symbol(\"dispatch key\"),\n    kDefaultHeaders: Symbol(\"default headers\"),\n    kDefaultTrailers: Symbol(\"default trailers\"),\n    kContentLength: Symbol(\"content length\"),\n    kMockAgent: Symbol(\"mock agent\"),\n    kMockAgentSet: Symbol(\"mock agent set\"),\n    kMockAgentGet: Symbol(\"mock agent get\"),\n    kMockDispatch: Symbol(\"mock dispatch\"),\n    kClose: Symbol(\"close\"),\n    kOriginalClose: Symbol(\"original agent close\"),\n    kOrigin: Symbol(\"origin\"),\n    kIsMockActive: Symbol(\"is mock active\"),\n    kNetConnect: Symbol(\"net connect\"),\n    kGetNetConnect: Symbol(\"get net connect\"),\n    kConnected: Symbol(\"connected\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsUUFBUUMsT0FBTztJQUNmQyxVQUFVRCxPQUFPO0lBQ2pCRSxVQUFVRixPQUFPO0lBQ2pCRyxhQUFhSCxPQUFPO0lBQ3BCSSxjQUFjSixPQUFPO0lBQ3JCSyxpQkFBaUJMLE9BQU87SUFDeEJNLGtCQUFrQk4sT0FBTztJQUN6Qk8sZ0JBQWdCUCxPQUFPO0lBQ3ZCUSxZQUFZUixPQUFPO0lBQ25CUyxlQUFlVCxPQUFPO0lBQ3RCVSxlQUFlVixPQUFPO0lBQ3RCVyxlQUFlWCxPQUFPO0lBQ3RCWSxRQUFRWixPQUFPO0lBQ2ZhLGdCQUFnQmIsT0FBTztJQUN2QmMsU0FBU2QsT0FBTztJQUNoQmUsZUFBZWYsT0FBTztJQUN0QmdCLGFBQWFoQixPQUFPO0lBQ3BCaUIsZ0JBQWdCakIsT0FBTztJQUN2QmtCLFlBQVlsQixPQUFPO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcz81YTFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0FnZW50IiwiU3ltYm9sIiwia09wdGlvbnMiLCJrRmFjdG9yeSIsImtEaXNwYXRjaGVzIiwia0Rpc3BhdGNoS2V5Iiwia0RlZmF1bHRIZWFkZXJzIiwia0RlZmF1bHRUcmFpbGVycyIsImtDb250ZW50TGVuZ3RoIiwia01vY2tBZ2VudCIsImtNb2NrQWdlbnRTZXQiLCJrTW9ja0FnZW50R2V0Iiwia01vY2tEaXNwYXRjaCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtJc01vY2tBY3RpdmUiLCJrTmV0Q29ubmVjdCIsImtHZXROZXRDb25uZWN0Iiwia0Nvbm5lY3RlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { buildURL, nop } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { types: { isPromise } } = __webpack_require__(/*! util */ \"util\");\nfunction matchValue(match, value) {\n    if (typeof match === \"string\") {\n        return match === value;\n    }\n    if (match instanceof RegExp) {\n        return match.test(value);\n    }\n    if (typeof match === \"function\") {\n        return match(value) === true;\n    }\n    return false;\n}\nfunction lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n                return headers[i + 1];\n            }\n        }\n        return undefined;\n    } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n    } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n    }\n}\n/** @param {string[]} headers */ function buildHeadersFromArray(headers) {\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2){\n        entries.push([\n            clone[index],\n            clone[index + 1]\n        ]);\n    }\n    return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === \"function\") {\n        if (Array.isArray(headers)) {\n            headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === \"undefined\") {\n        return true;\n    }\n    if (typeof headers !== \"object\" || typeof mockDispatch.headers !== \"object\") {\n        return false;\n    }\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction safeUrl(path) {\n    if (typeof path !== \"string\") {\n        return path;\n    }\n    const pathSegments = path.split(\"?\");\n    if (pathSegments.length !== 2) {\n        return path;\n    }\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join(\"?\");\n}\nfunction matchKey(mockDispatch, { path, method, body, headers }) {\n    const pathMatch = matchValue(mockDispatch.path, path);\n    const methodMatch = matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== \"undefined\" ? matchValue(mockDispatch.body, body) : true;\n    const headersMatch = matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n    if (Buffer.isBuffer(data)) {\n        return data;\n    } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n    } else {\n        return data.toString();\n    }\n}\nfunction getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    }\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);\n    }\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body })=>typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);\n    }\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers}'`);\n    }\n    return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === \"function\" ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) {\n            return false;\n        }\n        return matchKey(dispatch, key);\n    });\n    if (index !== -1) {\n        mockDispatches.splice(index, 1);\n    }\n}\nfunction buildKey(opts) {\n    const { path, method, body, headers, query } = opts;\n    return {\n        path,\n        method,\n        body,\n        headers,\n        query\n    };\n}\nfunction generateKeyValues(data) {\n    return Object.entries(data).reduce((keyValuePairs, [key, value])=>[\n            ...keyValuePairs,\n            Buffer.from(`${key}`),\n            Array.isArray(value) ? value.map((x)=>Buffer.from(`${x}`)) : Buffer.from(`${value}`)\n        ], []);\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function getStatusText(statusCode) {\n    return STATUS_CODES[statusCode] || \"unknown\";\n}\nasync function getResponse(body) {\n    const buffers = [];\n    for await (const data of body){\n        buffers.push(data);\n    }\n    return Buffer.concat(buffers).toString(\"utf8\");\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = buildKey(opts);\n    const mockDispatch = getMockDispatch(this[kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) {\n        mockDispatch.data = {\n            ...mockDispatch.data,\n            ...mockDispatch.data.callback(opts)\n        };\n    }\n    // Parse mockDispatch data\n    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;\n    const { timesInvoked, times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(()=>{\n            handleReply(this[kDispatches]);\n        }, delay);\n    } else {\n        handleReply(this[kDispatches]);\n    }\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === \"function\" ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if (isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = getResponseData(body);\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.abort = nop;\n        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData(Buffer.from(responseData));\n        handler.onComplete(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction buildMockDispatch() {\n    const agent = this[kMockAgent];\n    const origin = this[kOrigin];\n    const originalDispatch = this[kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n            try {\n                mockDispatch.call(this, opts, handler);\n            } catch (error) {\n                if (error instanceof MockNotMatchedError) {\n                    const netConnect = agent[kGetNetConnect]();\n                    if (netConnect === false) {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                    }\n                    if (checkNetConnect(netConnect, origin)) {\n                        originalDispatch.call(this, opts, handler);\n                    } else {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        } else {\n            originalDispatch.call(this, opts, handler);\n        }\n    };\n}\nfunction checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) {\n        return true;\n    } else if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) {\n        return true;\n    }\n    return false;\n}\nfunction buildMockOptions(opts) {\n    if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\nmodule.exports = {\n    getResponseData,\n    getMockDispatch,\n    addMockDispatch,\n    deleteMockDispatch,\n    buildKey,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG1CQUFtQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLGlCQUFpQixFQUNqQkMsT0FBTyxFQUNQQyxjQUFjLEVBQ2YsR0FBR0wsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVNLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRVEsWUFBWSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFDSlMsT0FBTyxFQUNMQyxTQUFTLEVBQ1YsRUFDRixHQUFHVixtQkFBT0EsQ0FBQztBQUVaLFNBQVNXLFdBQVlDLEtBQUssRUFBRUMsS0FBSztJQUMvQixJQUFJLE9BQU9ELFVBQVUsVUFBVTtRQUM3QixPQUFPQSxVQUFVQztJQUNuQjtJQUNBLElBQUlELGlCQUFpQkUsUUFBUTtRQUMzQixPQUFPRixNQUFNRyxJQUFJLENBQUNGO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPRCxVQUFVLFlBQVk7UUFDL0IsT0FBT0EsTUFBTUMsV0FBVztJQUMxQjtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGlCQUFrQkMsT0FBTztJQUNoQyxPQUFPQyxPQUFPQyxXQUFXLENBQ3ZCRCxPQUFPRSxPQUFPLENBQUNILFNBQVNJLEdBQUcsQ0FBQyxDQUFDLENBQUNDLFlBQVlDLFlBQVk7UUFDcEQsT0FBTztZQUFDRCxXQUFXRSxpQkFBaUI7WUFBSUQ7U0FBWTtJQUN0RDtBQUVKO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0UsZ0JBQWlCUixPQUFPLEVBQUVTLEdBQUc7SUFDcEMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDWCxVQUFVO1FBQzFCLElBQUssSUFBSVksSUFBSSxHQUFHQSxJQUFJWixRQUFRYSxNQUFNLEVBQUVELEtBQUss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d0JBQ3ZDQyxpQkFBaUJFLElBQUksQ0FBQyxJQUFJLEVBQUVsQyxNQUFNVztvQkFDcEMsT0FBTzt3QkFDTCxNQUFNLElBQUlwRyxvQkFBb0IsQ0FBQyxFQUFFbUYsTUFBTTBDLE9BQU8sQ0FBQywrQkFBK0IsRUFBRUwsT0FBTyw2REFBNkQsQ0FBQztvQkFDdko7Z0JBQ0YsT0FBTztvQkFDTCxNQUFNckM7Z0JBQ1I7WUFDRjtRQUNGLE9BQU87WUFDTHNDLGlCQUFpQkUsSUFBSSxDQUFDLElBQUksRUFBRWxDLE1BQU1XO1FBQ3BDO0lBQ0Y7QUFDRjtBQUVBLFNBQVMwQixnQkFBaUJGLFVBQVUsRUFBRUosTUFBTTtJQUMxQyxNQUFNTyxNQUFNLElBQUlDLElBQUlSO0lBQ3BCLElBQUlJLGVBQWUsTUFBTTtRQUN2QixPQUFPO0lBQ1QsT0FBTyxJQUFJaEcsTUFBTUMsT0FBTyxDQUFDK0YsZUFBZUEsV0FBV0ssSUFBSSxDQUFDLENBQUNDLFVBQVl0SCxXQUFXc0gsU0FBU0gsSUFBSUksSUFBSSxJQUFJO1FBQ25HLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNDLGlCQUFrQjNDLElBQUk7SUFDN0IsSUFBSUEsTUFBTTtRQUNSLE1BQU0sRUFBRThCLEtBQUssRUFBRSxHQUFHYyxhQUFhLEdBQUc1QztRQUNsQyxPQUFPNEM7SUFDVDtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmM0U7SUFDQU07SUFDQVE7SUFDQVU7SUFDQUk7SUFDQUU7SUFDQTlFO0lBQ0FxRjtJQUNBRjtJQUNBdkQ7SUFDQThFO0lBQ0FRO0lBQ0FNO0lBQ0ExRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanM/ZTlhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNb2NrTm90TWF0Y2hlZEVycm9yIH0gPSByZXF1aXJlKCcuL21vY2stZXJyb3JzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrT3JpZ2luLFxuICBrR2V0TmV0Q29ubmVjdFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgYnVpbGRVUkwsIG5vcCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgU1RBVFVTX0NPREVTIH0gPSByZXF1aXJlKCdodHRwJylcbmNvbnN0IHtcbiAgdHlwZXM6IHtcbiAgICBpc1Byb21pc2VcbiAgfVxufSA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBtYXRjaFZhbHVlIChtYXRjaCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWF0Y2ggPT09IHZhbHVlXG4gIH1cbiAgaWYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIG1hdGNoLnRlc3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXRjaCh2YWx1ZSkgPT09IHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbG93ZXJDYXNlRW50cmllcyAoaGVhZGVycykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpLm1hcCgoW2hlYWRlck5hbWUsIGhlYWRlclZhbHVlXSkgPT4ge1xuICAgICAgcmV0dXJuIFtoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCksIGhlYWRlclZhbHVlXVxuICAgIH0pXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vaW5kZXgnKS5IZWFkZXJzfHN0cmluZ1tdfFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZnVuY3Rpb24gZ2V0SGVhZGVyQnlOYW1lIChoZWFkZXJzLCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChoZWFkZXJzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IGtleS50b0xvY2FsZUxvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJzW2kgKyAxXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVycy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaGVhZGVycy5nZXQoa2V5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpW2tleS50b0xvY2FsZUxvd2VyQ2FzZSgpXVxuICB9XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnNGcm9tQXJyYXkgKGhlYWRlcnMpIHsgLy8gZmV0Y2ggSGVhZGVyc0xpc3RcbiAgY29uc3QgY2xvbmUgPSBoZWFkZXJzLnNsaWNlKClcbiAgY29uc3QgZW50cmllcyA9IFtdXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjbG9uZS5sZW5ndGg7IGluZGV4ICs9IDIpIHtcbiAgICBlbnRyaWVzLnB1c2goW2Nsb25lW2luZGV4XSwgY2xvbmVbaW5kZXggKyAxXV0pXG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKVxufVxuXG5mdW5jdGlvbiBtYXRjaEhlYWRlcnMgKG1vY2tEaXNwYXRjaCwgaGVhZGVycykge1xuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHsgLy8gZmV0Y2ggSGVhZGVyc0xpc3RcbiAgICAgIGhlYWRlcnMgPSBidWlsZEhlYWRlcnNGcm9tQXJyYXkoaGVhZGVycylcbiAgICB9XG4gICAgcmV0dXJuIG1vY2tEaXNwYXRjaC5oZWFkZXJzKGhlYWRlcnMgPyBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpIDoge30pXG4gIH1cbiAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBbbWF0Y2hIZWFkZXJOYW1lLCBtYXRjaEhlYWRlclZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtb2NrRGlzcGF0Y2guaGVhZGVycykpIHtcbiAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IGdldEhlYWRlckJ5TmFtZShoZWFkZXJzLCBtYXRjaEhlYWRlck5hbWUpXG5cbiAgICBpZiAoIW1hdGNoVmFsdWUobWF0Y2hIZWFkZXJWYWx1ZSwgaGVhZGVyVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc2FmZVVybCAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHBhdGhTZWdtZW50cyA9IHBhdGguc3BsaXQoJz8nKVxuXG4gIGlmIChwYXRoU2VnbWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIGNvbnN0IHFwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoU2VnbWVudHMucG9wKCkpXG4gIHFwLnNvcnQoKVxuICByZXR1cm4gWy4uLnBhdGhTZWdtZW50cywgcXAudG9TdHJpbmcoKV0uam9pbignPycpXG59XG5cbmZ1bmN0aW9uIG1hdGNoS2V5IChtb2NrRGlzcGF0Y2gsIHsgcGF0aCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzIH0pIHtcbiAgY29uc3QgcGF0aE1hdGNoID0gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gucGF0aCwgcGF0aClcbiAgY29uc3QgbWV0aG9kTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5tZXRob2QsIG1ldGhvZClcbiAgY29uc3QgYm9keU1hdGNoID0gdHlwZW9mIG1vY2tEaXNwYXRjaC5ib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLmJvZHksIGJvZHkpIDogdHJ1ZVxuICBjb25zdCBoZWFkZXJzTWF0Y2ggPSBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKVxuICByZXR1cm4gcGF0aE1hdGNoICYmIG1ldGhvZE1hdGNoICYmIGJvZHlNYXRjaCAmJiBoZWFkZXJzTWF0Y2hcbn1cblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VEYXRhIChkYXRhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgYmFzZVBhdGggPSBrZXkucXVlcnkgPyBidWlsZFVSTChrZXkucGF0aCwga2V5LnF1ZXJ5KSA6IGtleS5wYXRoXG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IHR5cGVvZiBiYXNlUGF0aCA9PT0gJ3N0cmluZycgPyBzYWZlVXJsKGJhc2VQYXRoKSA6IGJhc2VQYXRoXG5cbiAgLy8gTWF0Y2ggcGF0aFxuICBsZXQgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IGNvbnN1bWVkIH0pID0+ICFjb25zdW1lZCkuZmlsdGVyKCh7IHBhdGggfSkgPT4gbWF0Y2hWYWx1ZShzYWZlVXJsKHBhdGgpLCByZXNvbHZlZFBhdGgpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIG1ldGhvZFxuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IG1ldGhvZCB9KSA9PiBtYXRjaFZhbHVlKG1ldGhvZCwga2V5Lm1ldGhvZCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIG1ldGhvZCAnJHtrZXkubWV0aG9kfSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggYm9keVxuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IGJvZHkgfSkgPT4gdHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShib2R5LCBrZXkuYm9keSkgOiB0cnVlKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBib2R5ICcke2tleS5ib2R5fSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggaGVhZGVyc1xuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKChtb2NrRGlzcGF0Y2gpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGtleS5oZWFkZXJzKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgaGVhZGVycyAnJHt0eXBlb2Yga2V5LmhlYWRlcnMgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkoa2V5LmhlYWRlcnMpIDoga2V5LmhlYWRlcnN9J2ApXG4gIH1cblxuICByZXR1cm4gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzWzBdXG59XG5cbmZ1bmN0aW9uIGFkZE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSwgZGF0YSkge1xuICBjb25zdCBiYXNlRGF0YSA9IHsgdGltZXNJbnZva2VkOiAwLCB0aW1lczogMSwgcGVyc2lzdDogZmFsc2UsIGNvbnN1bWVkOiBmYWxzZSB9XG4gIGNvbnN0IHJlcGx5RGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nID8geyBjYWxsYmFjazogZGF0YSB9IDogeyAuLi5kYXRhIH1cbiAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0geyAuLi5iYXNlRGF0YSwgLi4ua2V5LCBwZW5kaW5nOiB0cnVlLCBkYXRhOiB7IGVycm9yOiBudWxsLCAuLi5yZXBseURhdGEgfSB9XG4gIG1vY2tEaXNwYXRjaGVzLnB1c2gobmV3TW9ja0Rpc3BhdGNoKVxuICByZXR1cm4gbmV3TW9ja0Rpc3BhdGNoXG59XG5cbmZ1bmN0aW9uIGRlbGV0ZU1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBpbmRleCA9IG1vY2tEaXNwYXRjaGVzLmZpbmRJbmRleChkaXNwYXRjaCA9PiB7XG4gICAgaWYgKCFkaXNwYXRjaC5jb25zdW1lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBtYXRjaEtleShkaXNwYXRjaCwga2V5KVxuICB9KVxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbW9ja0Rpc3BhdGNoZXMuc3BsaWNlKGluZGV4LCAxKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkS2V5IChvcHRzKSB7XG4gIGNvbnN0IHsgcGF0aCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzLCBxdWVyeSB9ID0gb3B0c1xuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5VmFsdWVzIChkYXRhKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGtleVZhbHVlUGFpcnMsIFtrZXksIHZhbHVlXSkgPT4gW1xuICAgIC4uLmtleVZhbHVlUGFpcnMsXG4gICAgQnVmZmVyLmZyb20oYCR7a2V5fWApLFxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHggPT4gQnVmZmVyLmZyb20oYCR7eH1gKSkgOiBCdWZmZXIuZnJvbShgJHt2YWx1ZX1gKVxuICBdLCBbXSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNUZXh0IChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0gfHwgJ3Vua25vd24nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlIChib2R5KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgYm9keSkge1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqXG4gKiBNb2NrIGRpc3BhdGNoIGZ1bmN0aW9uIHVzZWQgdG8gc2ltdWxhdGUgdW5kaWNpIGRpc3BhdGNoZXNcbiAqL1xuZnVuY3Rpb24gbW9ja0Rpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gIC8vIEdldCBtb2NrIGRpc3BhdGNoIGZyb20gYnVpbHQga2V5XG4gIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpXG4gIGNvbnN0IG1vY2tEaXNwYXRjaCA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuXG4gIG1vY2tEaXNwYXRjaC50aW1lc0ludm9rZWQrK1xuXG4gIC8vIEhlcmUncyB3aGVyZSB3ZSByZXNvbHZlIGEgY2FsbGJhY2sgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGZvciB0aGUgZGlzcGF0Y2ggZGF0YS5cbiAgaWYgKG1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKSB7XG4gICAgbW9ja0Rpc3BhdGNoLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaC5kYXRhLCAuLi5tb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjayhvcHRzKSB9XG4gIH1cblxuICAvLyBQYXJzZSBtb2NrRGlzcGF0Y2ggZGF0YVxuICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yIH0sIGRlbGF5LCBwZXJzaXN0IH0gPSBtb2NrRGlzcGF0Y2hcbiAgY29uc3QgeyB0aW1lc0ludm9rZWQsIHRpbWVzIH0gPSBtb2NrRGlzcGF0Y2hcblxuICAvLyBJZiBpdCdzIHVzZWQgdXAgYW5kIG5vdCBwZXJzaXN0ZW50LCBtYXJrIGFzIGNvbnN1bWVkXG4gIG1vY2tEaXNwYXRjaC5jb25zdW1lZCA9ICFwZXJzaXN0ICYmIHRpbWVzSW52b2tlZCA+PSB0aW1lc1xuICBtb2NrRGlzcGF0Y2gucGVuZGluZyA9IHRpbWVzSW52b2tlZCA8IHRpbWVzXG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0cmlnZ2VyIGRpc3BhdGNoIGVycm9yXG4gIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuICAgIGhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0IHdpdGggYSBkZWxheSBpZiBuZWNlc3NhcnlcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgICB9LCBkZWxheSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlcGx5IChtb2NrRGlzcGF0Y2hlcywgX2RhdGEgPSBkYXRhKSB7XG4gICAgLy8gZmV0Y2gncyBIZWFkZXJzTGlzdCBpcyBhIDFEIHN0cmluZyBhcnJheVxuICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA6IG9wdHMuaGVhZGVyc1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gX2RhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KVxuICAgICAgOiBfZGF0YVxuXG4gICAgLy8gdXRpbC50eXBlcy5pc1Byb21pc2UgaXMgbGlrZWx5IG5lZWRlZCBmb3IgamVzdC5cbiAgICBpZiAoaXNQcm9taXNlKGJvZHkpKSB7XG4gICAgICAvLyBJZiBoYW5kbGVSZXBseSBpcyBhc3luY2hyb25vdXMsIHRocm93aW5nIGFuIGVycm9yXG4gICAgICAvLyBpbiB0aGUgY2FsbGJhY2sgd2lsbCByZWplY3QgdGhlIHByb21pc2UsIHJhdGhlciB0aGFuXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRocm93IHRoZSBlcnJvciwgd2hpY2ggYnJlYWtzIHNvbWUgdGVzdHMuXG4gICAgICAvLyBSYXRoZXIsIHdlIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byByZXNvbHZlIGlmIGl0IGlzIGFcbiAgICAgIC8vIHByb21pc2UsIGFuZCB0aGVuIHJlLXJ1biBoYW5kbGVSZXBseSB3aXRoIHRoZSBuZXcgYm9keS5cbiAgICAgIGJvZHkudGhlbigobmV3RGF0YSkgPT4gaGFuZGxlUmVwbHkobW9ja0Rpc3BhdGNoZXMsIG5ld0RhdGEpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLmFib3J0ID0gbm9wXG4gICAgaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgcmVzcG9uc2VIZWFkZXJzLCByZXN1bWUsIGdldFN0YXR1c1RleHQoc3RhdHVzQ29kZSkpXG4gICAgaGFuZGxlci5vbkRhdGEoQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGUocmVzcG9uc2VUcmFpbGVycylcbiAgICBkZWxldGVNb2NrRGlzcGF0Y2gobW9ja0Rpc3BhdGNoZXMsIGtleSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3VtZSAoKSB7fVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW9ja0Rpc3BhdGNoICgpIHtcbiAgY29uc3QgYWdlbnQgPSB0aGlzW2tNb2NrQWdlbnRdXG4gIGNvbnN0IG9yaWdpbiA9IHRoaXNba09yaWdpbl1cbiAgY29uc3Qgb3JpZ2luYWxEaXNwYXRjaCA9IHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGFnZW50LmlzTW9ja0FjdGl2ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbW9ja0Rpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE1vY2tOb3RNYXRjaGVkRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBuZXRDb25uZWN0ID0gYWdlbnRba0dldE5ldENvbm5lY3RdKClcbiAgICAgICAgICBpZiAobmV0Q29ubmVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7b3JpZ2lufSB3YXMgbm90IGFsbG93ZWQgKG5ldC5jb25uZWN0IGRpc2FibGVkKWApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGVja05ldENvbm5lY3QobmV0Q29ubmVjdCwgb3JpZ2luKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGAke2Vycm9yLm1lc3NhZ2V9OiBzdWJzZXF1ZW50IHJlcXVlc3QgdG8gb3JpZ2luICR7b3JpZ2lufSB3YXMgbm90IGFsbG93ZWQgKG5ldC5jb25uZWN0IGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIG9yaWdpbilgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbmFsRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05ldENvbm5lY3QgKG5ldENvbm5lY3QsIG9yaWdpbikge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKG9yaWdpbilcbiAgaWYgKG5ldENvbm5lY3QgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV0Q29ubmVjdCkgJiYgbmV0Q29ubmVjdC5zb21lKChtYXRjaGVyKSA9PiBtYXRjaFZhbHVlKG1hdGNoZXIsIHVybC5ob3N0KSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBidWlsZE1vY2tPcHRpb25zIChvcHRzKSB7XG4gIGlmIChvcHRzKSB7XG4gICAgY29uc3QgeyBhZ2VudCwgLi4ubW9ja09wdGlvbnMgfSA9IG9wdHNcbiAgICByZXR1cm4gbW9ja09wdGlvbnNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UmVzcG9uc2VEYXRhLFxuICBnZXRNb2NrRGlzcGF0Y2gsXG4gIGFkZE1vY2tEaXNwYXRjaCxcbiAgZGVsZXRlTW9ja0Rpc3BhdGNoLFxuICBidWlsZEtleSxcbiAgZ2VuZXJhdGVLZXlWYWx1ZXMsXG4gIG1hdGNoVmFsdWUsXG4gIGdldFJlc3BvbnNlLFxuICBnZXRTdGF0dXNUZXh0LFxuICBtb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkTW9ja0Rpc3BhdGNoLFxuICBjaGVja05ldENvbm5lY3QsXG4gIGJ1aWxkTW9ja09wdGlvbnMsXG4gIGdldEhlYWRlckJ5TmFtZVxufVxuIl0sIm5hbWVzIjpbIk1vY2tOb3RNYXRjaGVkRXJyb3IiLCJyZXF1aXJlIiwia0Rpc3BhdGNoZXMiLCJrTW9ja0FnZW50Iiwia09yaWdpbmFsRGlzcGF0Y2giLCJrT3JpZ2luIiwia0dldE5ldENvbm5lY3QiLCJidWlsZFVSTCIsIm5vcCIsIlNUQVRVU19DT0RFUyIsInR5cGVzIiwiaXNQcm9taXNlIiwibWF0Y2hWYWx1ZSIsIm1hdGNoIiwidmFsdWUiLCJSZWdFeHAiLCJ0ZXN0IiwibG93ZXJDYXNlRW50cmllcyIsImhlYWRlcnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJoZWFkZXJOYW1lIiwiaGVhZGVyVmFsdWUiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImdldEhlYWRlckJ5TmFtZSIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJnZXQiLCJidWlsZEhlYWRlcnNGcm9tQXJyYXkiLCJjbG9uZSIsInNsaWNlIiwiaW5kZXgiLCJwdXNoIiwibWF0Y2hIZWFkZXJzIiwibW9ja0Rpc3BhdGNoIiwibWF0Y2hIZWFkZXJOYW1lIiwibWF0Y2hIZWFkZXJWYWx1ZSIsInNhZmVVcmwiLCJwYXRoIiwicGF0aFNlZ21lbnRzIiwic3BsaXQiLCJxcCIsIlVSTFNlYXJjaFBhcmFtcyIsInBvcCIsInNvcnQiLCJ0b1N0cmluZyIsImpvaW4iLCJtYXRjaEtleSIsIm1ldGhvZCIsImJvZHkiLCJwYXRoTWF0Y2giLCJtZXRob2RNYXRjaCIsImJvZHlNYXRjaCIsImhlYWRlcnNNYXRjaCIsImdldFJlc3BvbnNlRGF0YSIsImRhdGEiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRNb2NrRGlzcGF0Y2giLCJtb2NrRGlzcGF0Y2hlcyIsImJhc2VQYXRoIiwicXVlcnkiLCJyZXNvbHZlZFBhdGgiLCJtYXRjaGVkTW9ja0Rpc3BhdGNoZXMiLCJmaWx0ZXIiLCJjb25zdW1lZCIsImFkZE1vY2tEaXNwYXRjaCIsImJhc2VEYXRhIiwidGltZXNJbnZva2VkIiwidGltZXMiLCJwZXJzaXN0IiwicmVwbHlEYXRhIiwiY2FsbGJhY2siLCJuZXdNb2NrRGlzcGF0Y2giLCJwZW5kaW5nIiwiZXJyb3IiLCJkZWxldGVNb2NrRGlzcGF0Y2giLCJmaW5kSW5kZXgiLCJkaXNwYXRjaCIsInNwbGljZSIsImJ1aWxkS2V5Iiwib3B0cyIsImdlbmVyYXRlS2V5VmFsdWVzIiwicmVkdWNlIiwia2V5VmFsdWVQYWlycyIsImZyb20iLCJ4IiwiZ2V0U3RhdHVzVGV4dCIsInN0YXR1c0NvZGUiLCJnZXRSZXNwb25zZSIsImJ1ZmZlcnMiLCJjb25jYXQiLCJoYW5kbGVyIiwidHJhaWxlcnMiLCJkZWxheSIsIm9uRXJyb3IiLCJzZXRUaW1lb3V0IiwiaGFuZGxlUmVwbHkiLCJfZGF0YSIsIm9wdHNIZWFkZXJzIiwidGhlbiIsIm5ld0RhdGEiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZVRyYWlsZXJzIiwiYWJvcnQiLCJvbkhlYWRlcnMiLCJyZXN1bWUiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJhZ2VudCIsIm9yaWdpbiIsIm9yaWdpbmFsRGlzcGF0Y2giLCJpc01vY2tBY3RpdmUiLCJjYWxsIiwibmV0Q29ubmVjdCIsIm1lc3NhZ2UiLCJjaGVja05ldENvbm5lY3QiLCJ1cmwiLCJVUkwiLCJzb21lIiwibWF0Y2hlciIsImhvc3QiLCJidWlsZE1vY2tPcHRpb25zIiwibW9ja09wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\nconst { Console } = __webpack_require__(/*! console */ \"console\");\n/**\n * Gets the output of `console.table(…)` as a string.\n */ module.exports = class PendingInterceptorsFormatter {\n    constructor({ disableColors } = {}){\n        this.transform = new Transform({\n            transform (chunk, _enc, cb) {\n                cb(null, chunk);\n            }\n        });\n        this.logger = new Console({\n            stdout: this.transform,\n            inspectOptions: {\n                colors: !disableColors && !process.env.CI\n            }\n        });\n    }\n    format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({\n                Method: method,\n                Origin: origin,\n                Path: path,\n                \"Status code\": statusCode,\n                Persistent: persist ? \"✅\" : \"❌\",\n                Invocations: timesInvoked,\n                Remaining: persist ? Infinity : times - timesInvoked\n            }));\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBRTVCOztDQUVDLEdBQ0RFLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQkMsWUFBYSxFQUFFQyxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJUixVQUFVO1lBQzdCUSxXQUFXQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtnQkFDeEJBLEdBQUcsTUFBTUY7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDRyxNQUFNLEdBQUcsSUFBSVYsUUFBUTtZQUN4QlcsUUFBUSxJQUFJLENBQUNMLFNBQVM7WUFDdEJNLGdCQUFnQjtnQkFDZEMsUUFBUSxDQUFDUixpQkFBaUIsQ0FBQ1MsUUFBUUMsR0FBRyxDQUFDQyxFQUFFO1lBQzNDO1FBQ0Y7SUFDRjtJQUVBQyxPQUFRQyxtQkFBbUIsRUFBRTtRQUMzQixNQUFNQyxvQkFBb0JELG9CQUFvQkUsR0FBRyxDQUMvQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUUsR0FBTTtnQkFDakZDLFFBQVFSO2dCQUNSUyxRQUFRRjtnQkFDUkcsTUFBTVQ7Z0JBQ04sZUFBZUU7Z0JBQ2ZRLFlBQVlQLFVBQVUsTUFBTTtnQkFDNUJRLGFBQWFOO2dCQUNiTyxXQUFXVCxVQUFVVSxXQUFXVCxRQUFRQztZQUMxQztRQUVGLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQzBCLEtBQUssQ0FBQ2pCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDYixTQUFTLENBQUMrQixJQUFJLEdBQUdDLFFBQVE7SUFDdkM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXIuanM/NTBiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB7IENvbnNvbGUgfSA9IHJlcXVpcmUoJ2NvbnNvbGUnKVxuXG4vKipcbiAqIEdldHMgdGhlIG91dHB1dCBvZiBgY29uc29sZS50YWJsZSjigKYpYCBhcyBhIHN0cmluZy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IgKHsgZGlzYWJsZUNvbG9ycyB9ID0ge30pIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgICAgdHJhbnNmb3JtIChjaHVuaywgX2VuYywgY2IpIHtcbiAgICAgICAgY2IobnVsbCwgY2h1bmspXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMubG9nZ2VyID0gbmV3IENvbnNvbGUoe1xuICAgICAgc3Rkb3V0OiB0aGlzLnRyYW5zZm9ybSxcbiAgICAgIGluc3BlY3RPcHRpb25zOiB7XG4gICAgICAgIGNvbG9yczogIWRpc2FibGVDb2xvcnMgJiYgIXByb2Nlc3MuZW52LkNJXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZvcm1hdCAocGVuZGluZ0ludGVyY2VwdG9ycykge1xuICAgIGNvbnN0IHdpdGhQcmV0dHlIZWFkZXJzID0gcGVuZGluZ0ludGVyY2VwdG9ycy5tYXAoXG4gICAgICAoeyBtZXRob2QsIHBhdGgsIGRhdGE6IHsgc3RhdHVzQ29kZSB9LCBwZXJzaXN0LCB0aW1lcywgdGltZXNJbnZva2VkLCBvcmlnaW4gfSkgPT4gKHtcbiAgICAgICAgTWV0aG9kOiBtZXRob2QsXG4gICAgICAgIE9yaWdpbjogb3JpZ2luLFxuICAgICAgICBQYXRoOiBwYXRoLFxuICAgICAgICAnU3RhdHVzIGNvZGUnOiBzdGF0dXNDb2RlLFxuICAgICAgICBQZXJzaXN0ZW50OiBwZXJzaXN0ID8gJ+KchScgOiAn4p2MJyxcbiAgICAgICAgSW52b2NhdGlvbnM6IHRpbWVzSW52b2tlZCxcbiAgICAgICAgUmVtYWluaW5nOiBwZXJzaXN0ID8gSW5maW5pdHkgOiB0aW1lcyAtIHRpbWVzSW52b2tlZFxuICAgICAgfSkpXG5cbiAgICB0aGlzLmxvZ2dlci50YWJsZSh3aXRoUHJldHR5SGVhZGVycylcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVhZCgpLnRvU3RyaW5nKClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJDb25zb2xlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIiLCJjb25zdHJ1Y3RvciIsImRpc2FibGVDb2xvcnMiLCJ0cmFuc2Zvcm0iLCJjaHVuayIsIl9lbmMiLCJjYiIsImxvZ2dlciIsInN0ZG91dCIsImluc3BlY3RPcHRpb25zIiwiY29sb3JzIiwicHJvY2VzcyIsImVudiIsIkNJIiwiZm9ybWF0IiwicGVuZGluZ0ludGVyY2VwdG9ycyIsIndpdGhQcmV0dHlIZWFkZXJzIiwibWFwIiwibWV0aG9kIiwicGF0aCIsImRhdGEiLCJzdGF0dXNDb2RlIiwicGVyc2lzdCIsInRpbWVzIiwidGltZXNJbnZva2VkIiwib3JpZ2luIiwiTWV0aG9kIiwiT3JpZ2luIiwiUGF0aCIsIlBlcnNpc3RlbnQiLCJJbnZvY2F0aW9ucyIsIlJlbWFpbmluZyIsIkluZmluaXR5IiwidGFibGUiLCJyZWFkIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst singulars = {\n    pronoun: \"it\",\n    is: \"is\",\n    was: \"was\",\n    this: \"this\"\n};\nconst plurals = {\n    pronoun: \"they\",\n    is: \"are\",\n    was: \"were\",\n    this: \"these\"\n};\nmodule.exports = class Pluralizer {\n    constructor(singular, plural){\n        this.singular = singular;\n        this.plural = plural;\n    }\n    pluralize(count) {\n        const one = count === 1;\n        const keys = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return {\n            ...keys,\n            count,\n            noun\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZO0lBQ2hCQyxTQUFTO0lBQ1RDLElBQUk7SUFDSkMsS0FBSztJQUNMQyxNQUFNO0FBQ1I7QUFFQSxNQUFNQyxVQUFVO0lBQ2RKLFNBQVM7SUFDVEMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLE1BQU07QUFDUjtBQUVBRSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckJDLFlBQWFDLFFBQVEsRUFBRUMsTUFBTSxDQUFFO1FBQzdCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDaEI7SUFFQUMsVUFBV0MsS0FBSyxFQUFFO1FBQ2hCLE1BQU1DLE1BQU1ELFVBQVU7UUFDdEIsTUFBTUUsT0FBT0QsTUFBTWQsWUFBWUs7UUFDL0IsTUFBTVcsT0FBT0YsTUFBTSxJQUFJLENBQUNKLFFBQVEsR0FBRyxJQUFJLENBQUNDLE1BQU07UUFDOUMsT0FBTztZQUFFLEdBQUdJLElBQUk7WUFBRUY7WUFBT0c7UUFBSztJQUNoQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanM/YzdhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2luZ3VsYXJzID0ge1xuICBwcm9ub3VuOiAnaXQnLFxuICBpczogJ2lzJyxcbiAgd2FzOiAnd2FzJyxcbiAgdGhpczogJ3RoaXMnXG59XG5cbmNvbnN0IHBsdXJhbHMgPSB7XG4gIHByb25vdW46ICd0aGV5JyxcbiAgaXM6ICdhcmUnLFxuICB3YXM6ICd3ZXJlJyxcbiAgdGhpczogJ3RoZXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdXJhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoc2luZ3VsYXIsIHBsdXJhbCkge1xuICAgIHRoaXMuc2luZ3VsYXIgPSBzaW5ndWxhclxuICAgIHRoaXMucGx1cmFsID0gcGx1cmFsXG4gIH1cblxuICBwbHVyYWxpemUgKGNvdW50KSB7XG4gICAgY29uc3Qgb25lID0gY291bnQgPT09IDFcbiAgICBjb25zdCBrZXlzID0gb25lID8gc2luZ3VsYXJzIDogcGx1cmFsc1xuICAgIGNvbnN0IG5vdW4gPSBvbmUgPyB0aGlzLnNpbmd1bGFyIDogdGhpcy5wbHVyYWxcbiAgICByZXR1cm4geyAuLi5rZXlzLCBjb3VudCwgbm91biB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzaW5ndWxhcnMiLCJwcm9ub3VuIiwiaXMiLCJ3YXMiLCJ0aGlzIiwicGx1cmFscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJQbHVyYWxpemVyIiwiY29uc3RydWN0b3IiLCJzaW5ndWxhciIsInBsdXJhbCIsInBsdXJhbGl6ZSIsImNvdW50Iiwib25lIiwia2V5cyIsIm5vdW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/node/fixed-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/node/fixed-queue.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */ \n// Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\nclass FixedCircularBuffer {\n    constructor(){\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === undefined) return null;\n        this.list[this.bottom] = undefined;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n    }\n}\nmodule.exports = class FixedQueue {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer();\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(data) {\n        if (this.head.isFull()) {\n            // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n            // and sets it as the new main queue.\n            this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n    }\n    shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n            // If there is another queue, it forms the new tail.\n            this.tail = tail.next;\n        }\n        return next;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9ub2RlL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixHQUVsQjtBQUVBLGtEQUFrRDtBQUVsRCw4RUFBOEU7QUFDOUUsTUFBTUEsUUFBUTtBQUNkLE1BQU1DLFFBQVFELFFBQVE7QUFFdEIsc0VBQXNFO0FBQ3RFLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0YsbUVBQW1FO0FBQ25FLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsMkVBQTJFO0FBQzNFLEVBQUU7QUFDRiwrREFBK0Q7QUFDL0Qsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsRUFBRTtBQUNGLG1FQUFtRTtBQUNuRSxvRUFBb0U7QUFDcEUsZ0JBQWdCO0FBQ2hCLEVBQUU7QUFDRiw0REFBNEQ7QUFDNUQsd0VBQXdFO0FBQ3hFLGtDQUFrQztBQUVsQyxNQUFNRTtJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlDLE1BQU1QO1FBQ3RCLElBQUksQ0FBQ1EsSUFBSSxHQUFHO0lBQ2Q7SUFFQUMsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDSixHQUFHLEtBQUssSUFBSSxDQUFDRCxNQUFNO0lBQ2pDO0lBRUFNLFNBQVM7UUFDUCxPQUFPLENBQUMsSUFBSyxDQUFDTCxHQUFHLEdBQUcsSUFBS0osS0FBSSxNQUFPLElBQUksQ0FBQ0csTUFBTTtJQUNqRDtJQUVBTyxLQUFLQyxJQUFJLEVBQUU7UUFDVCxJQUFJLENBQUNOLElBQUksQ0FBQyxJQUFJLENBQUNELEdBQUcsQ0FBQyxHQUFHTztRQUN0QixJQUFJLENBQUNQLEdBQUcsR0FBRyxJQUFLLENBQUNBLEdBQUcsR0FBRyxJQUFLSjtJQUM5QjtJQUVBWSxRQUFRO1FBQ04sTUFBTUMsV0FBVyxJQUFJLENBQUNSLElBQUksQ0FBQyxJQUFJLENBQUNGLE1BQU0sQ0FBQztRQUN2QyxJQUFJVSxhQUFhQyxXQUNmLE9BQU87UUFDVCxJQUFJLENBQUNULElBQUksQ0FBQyxJQUFJLENBQUNGLE1BQU0sQ0FBQyxHQUFHVztRQUN6QixJQUFJLENBQUNYLE1BQU0sR0FBRyxJQUFLLENBQUNBLE1BQU0sR0FBRyxJQUFLSDtRQUNsQyxPQUFPYTtJQUNUO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCZixhQUFjO1FBQ1osSUFBSSxDQUFDZ0IsSUFBSSxHQUFHLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlsQjtJQUM5QjtJQUVBTyxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNVLElBQUksQ0FBQ1YsT0FBTztJQUMxQjtJQUVBRSxLQUFLQyxJQUFJLEVBQUU7UUFDVCxJQUFJLElBQUksQ0FBQ08sSUFBSSxDQUFDVCxNQUFNLElBQUk7WUFDdEIseUVBQXlFO1lBQ3pFLHFDQUFxQztZQUNyQyxJQUFJLENBQUNTLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ1gsSUFBSSxHQUFHLElBQUlOO1FBQ25DO1FBQ0EsSUFBSSxDQUFDaUIsSUFBSSxDQUFDUixJQUFJLENBQUNDO0lBQ2pCO0lBRUFDLFFBQVE7UUFDTixNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNWixPQUFPWSxLQUFLUCxLQUFLO1FBQ3ZCLElBQUlPLEtBQUtYLE9BQU8sTUFBTVcsS0FBS1osSUFBSSxLQUFLLE1BQU07WUFDeEMsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ1ksSUFBSSxHQUFHQSxLQUFLWixJQUFJO1FBQ3ZCO1FBQ0EsT0FBT0E7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9ub2RlL2ZpeGVkLXF1ZXVlLmpzPzE2ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8vIEV4dHJhY3RlZCBmcm9tIG5vZGUvbGliL2ludGVybmFsL2ZpeGVkX3F1ZXVlLmpzXG5cbi8vIEN1cnJlbnRseSBvcHRpbWFsIHF1ZXVlIHNpemUsIHRlc3RlZCBvbiBWOCA2LjAgLSA2LjYuIE11c3QgYmUgcG93ZXIgb2YgdHdvLlxuY29uc3Qga1NpemUgPSAyMDQ4O1xuY29uc3Qga01hc2sgPSBrU2l6ZSAtIDE7XG5cbi8vIFRoZSBGaXhlZFF1ZXVlIGlzIGltcGxlbWVudGVkIGFzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IG9mIGZpeGVkLXNpemVcbi8vIGNpcmN1bGFyIGJ1ZmZlcnMuIEl0IGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gIGhlYWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFxuLy8gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgPC0tLS0tXFwgICAgICAgKy0tLS0tLS0tLS0tKyA8LS0tLS0tXFwgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICBcXC0tLS0tIHwgICBuZXh0ICAgIHwgICAgICAgICBcXC0tLS0tLS0gfCAgIG5leHQgICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgIGJvdHRvbSAtLT4gfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgIC4uLiAgICB8ICAgICAgICAgICAgICAgfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHwgPC0tIHRvcCAgdG9wIC0tPiB8ICBbZW1wdHldICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vXG4vLyBPciwgaWYgdGhlcmUgaXMgb25seSBvbmUgY2lyY3VsYXIgYnVmZmVyLCBpdCBsb29rcyBzb21ldGhpbmdcbi8vIGxpa2UgZWl0aGVyIG9mIHRoZXNlOlxuLy9cbi8vICBoZWFkICAgdGFpbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgICB0YWlsXG4vLyAgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHxcbi8vICAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgdlxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXSAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICAgICAgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gQWRkaW5nIGEgdmFsdWUgbWVhbnMgbW92aW5nIGB0b3BgIGZvcndhcmQgYnkgb25lLCByZW1vdmluZyBtZWFuc1xuLy8gbW92aW5nIGBib3R0b21gIGZvcndhcmQgYnkgb25lLiBBZnRlciByZWFjaGluZyB0aGUgZW5kLCB0aGUgcXVldWVcbi8vIHdyYXBzIGFyb3VuZC5cbi8vXG4vLyBXaGVuIGB0b3AgPT09IGJvdHRvbWAgdGhlIGN1cnJlbnQgcXVldWUgaXMgZW1wdHkgYW5kIHdoZW5cbi8vIGB0b3AgKyAxID09PSBib3R0b21gIGl0J3MgZnVsbC4gVGhpcyB3YXN0ZXMgYSBzaW5nbGUgc3BhY2Ugb2Ygc3RvcmFnZVxuLy8gYnV0IGFsbG93cyBtdWNoIHF1aWNrZXIgY2hlY2tzLlxuXG5jbGFzcyBGaXhlZENpcmN1bGFyQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib3R0b20gPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICB0aGlzLmxpc3QgPSBuZXcgQXJyYXkoa1NpemUpO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBpc0Z1bGwoKSB7XG4gICAgcmV0dXJuICgodGhpcy50b3AgKyAxKSAmIGtNYXNrKSA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICB0aGlzLmxpc3RbdGhpcy50b3BdID0gZGF0YTtcbiAgICB0aGlzLnRvcCA9ICh0aGlzLnRvcCArIDEpICYga01hc2s7XG4gIH1cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCBuZXh0SXRlbSA9IHRoaXMubGlzdFt0aGlzLmJvdHRvbV07XG4gICAgaWYgKG5leHRJdGVtID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0aGlzLmxpc3RbdGhpcy5ib3R0b21dID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gKHRoaXMuYm90dG9tICsgMSkgJiBrTWFzaztcbiAgICByZXR1cm4gbmV4dEl0ZW07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaXhlZFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KCk7XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICBpZiAodGhpcy5oZWFkLmlzRnVsbCgpKSB7XG4gICAgICAvLyBIZWFkIGlzIGZ1bGw6IENyZWF0ZXMgYSBuZXcgcXVldWUsIHNldHMgdGhlIG9sZCBxdWV1ZSdzIGAubmV4dGAgdG8gaXQsXG4gICAgICAvLyBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IG1haW4gcXVldWUuXG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gICAgfVxuICAgIHRoaXMuaGVhZC5wdXNoKGRhdGEpO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMudGFpbDtcbiAgICBjb25zdCBuZXh0ID0gdGFpbC5zaGlmdCgpO1xuICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcXVldWUsIGl0IGZvcm1zIHRoZSBuZXcgdGFpbC5cbiAgICAgIHRoaXMudGFpbCA9IHRhaWwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsia1NpemUiLCJrTWFzayIsIkZpeGVkQ2lyY3VsYXJCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImJvdHRvbSIsInRvcCIsImxpc3QiLCJBcnJheSIsIm5leHQiLCJpc0VtcHR5IiwiaXNGdWxsIiwicHVzaCIsImRhdGEiLCJzaGlmdCIsIm5leHRJdGVtIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyIsIkZpeGVkUXVldWUiLCJoZWFkIiwidGFpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/node/fixed-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/pool-base.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/pool-base.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher-base.js\");\nconst FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ \"(rsc)/./node_modules/undici/lib/node/fixed-queue.js\");\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(rsc)/./node_modules/undici/lib/pool-stats.js\");\nconst kClients = Symbol(\"clients\");\nconst kNeedDrain = Symbol(\"needDrain\");\nconst kQueue = Symbol(\"queue\");\nconst kClosedResolve = Symbol(\"closed resolve\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kGetDispatcher = Symbol(\"get dispatcher\");\nconst kAddClient = Symbol(\"add client\");\nconst kRemoveClient = Symbol(\"remove client\");\nconst kStats = Symbol(\"stats\");\nclass PoolBase extends DispatcherBase {\n    constructor(){\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = function onDrain(origin, targets) {\n            const queue = pool[kQueue];\n            let needDrain = false;\n            while(!needDrain){\n                const item = queue.shift();\n                if (!item) {\n                    break;\n                }\n                pool[kQueued]--;\n                needDrain = !this.dispatch(item.opts, item.handler);\n            }\n            this[kNeedDrain] = needDrain;\n            if (!this[kNeedDrain] && pool[kNeedDrain]) {\n                pool[kNeedDrain] = false;\n                pool.emit(\"drain\", origin, [\n                    pool,\n                    ...targets\n                ]);\n            }\n            if (pool[kClosedResolve] && queue.isEmpty()) {\n                Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);\n            }\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            pool.emit(\"connect\", origin, [\n                pool,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            pool.emit(\"disconnect\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            pool.emit(\"connectionError\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain];\n    }\n    get [kConnected]() {\n        return this[kClients].filter((client)=>client[kConnected]).length;\n    }\n    get [kFree]() {\n        return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;\n    }\n    get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]){\n            ret += pending;\n        }\n        return ret;\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]){\n            ret += running;\n        }\n        return ret;\n    }\n    get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]){\n            ret += size;\n        }\n        return ret;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n            return Promise.all(this[kClients].map((c)=>c.close()));\n        } else {\n            return new Promise((resolve)=>{\n                this[kClosedResolve] = resolve;\n            });\n        }\n    }\n    async [kDestroy](err) {\n        while(true){\n            const item = this[kQueue].shift();\n            if (!item) {\n                break;\n            }\n            item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c)=>c.destroy(err)));\n    }\n    [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n            this[kNeedDrain] = true;\n            this[kQueue].push({\n                opts,\n                handler\n            });\n            this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n            dispatcher[kNeedDrain] = true;\n            this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n    }\n    [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n            process.nextTick(()=>{\n                if (this[kNeedDrain]) {\n                    this[kOnDrain](client[kUrl], [\n                        this,\n                        client\n                    ]);\n                }\n            });\n        }\n        return this;\n    }\n    [kRemoveClient](client) {\n        client.close(()=>{\n            const idx = this[kClients].indexOf(client);\n            if (idx !== -1) {\n                this[kClients].splice(idx, 1);\n            }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    }\n}\nmodule.exports = {\n    PoolBase,\n    kClients,\n    kNeedDrain,\n    kAddClient,\n    kRemoveClient,\n    kGetDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUUsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFDcEgsTUFBTWEsWUFBWWIsbUJBQU9BLENBQUM7QUFFMUIsTUFBTWMsV0FBV0MsT0FBTztBQUN4QixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLFNBQVNGLE9BQU87QUFDdEIsTUFBTUcsaUJBQWlCSCxPQUFPO0FBQzlCLE1BQU1JLFdBQVdKLE9BQU87QUFDeEIsTUFBTUssYUFBYUwsT0FBTztBQUMxQixNQUFNTSxnQkFBZ0JOLE9BQU87QUFDN0IsTUFBTU8scUJBQXFCUCxPQUFPO0FBQ2xDLE1BQU1RLGlCQUFpQlIsT0FBTztBQUM5QixNQUFNUyxhQUFhVCxPQUFPO0FBQzFCLE1BQU1VLGdCQUFnQlYsT0FBTztBQUM3QixNQUFNVyxTQUFTWCxPQUFPO0FBRXRCLE1BQU1ZLGlCQUFpQjVCO0lBQ3JCNkIsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNYLE9BQU8sR0FBRyxJQUFJaEI7UUFDbkIsSUFBSSxDQUFDYSxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUVoQixNQUFNdUIsT0FBTyxJQUFJO1FBRWpCLElBQUksQ0FBQ1YsU0FBUyxHQUFHLFNBQVNXLFFBQVNDLE1BQU0sRUFBRUMsT0FBTztZQUNoRCxNQUFNQyxRQUFRSixJQUFJLENBQUNaLE9BQU87WUFFMUIsSUFBSWlCLFlBQVk7WUFFaEIsTUFBTyxDQUFDQSxV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O1FBQ3BCQSxPQUNHWSxFQUFFLENBQUMsU0FBUyxJQUFJLENBQUMzQyxTQUFTLEVBQzFCMkMsRUFBRSxDQUFDLFdBQVcsSUFBSSxDQUFDMUMsV0FBVyxFQUM5QjBDLEVBQUUsQ0FBQyxjQUFjLElBQUksQ0FBQ3pDLGNBQWMsRUFDcEN5QyxFQUFFLENBQUMsbUJBQW1CLElBQUksQ0FBQ3hDLG1CQUFtQjtRQUVqRCxJQUFJLENBQUNSLFNBQVMsQ0FBQytDLElBQUksQ0FBQ1g7UUFFcEIsSUFBSSxJQUFJLENBQUNsQyxXQUFXLEVBQUU7WUFDcEIrQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2YsSUFBSSxJQUFJLENBQUNoRCxXQUFXLEVBQUU7b0JBQ3BCLElBQUksQ0FBQ0csU0FBUyxDQUFDK0IsTUFBTSxDQUFDekMsS0FBSyxFQUFFO3dCQUFDLElBQUk7d0JBQUV5QztxQkFBTztnQkFDN0M7WUFDRjtRQUNGO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFFQSxDQUFDekIsY0FBYyxDQUFFeUIsTUFBTSxFQUFFO1FBQ3ZCQSxPQUFPSixLQUFLLENBQUM7WUFDWCxNQUFNbUIsTUFBTSxJQUFJLENBQUNuRCxTQUFTLENBQUNvRCxPQUFPLENBQUNoQjtZQUNuQyxJQUFJZSxRQUFRLENBQUMsR0FBRztnQkFDZCxJQUFJLENBQUNuRCxTQUFTLENBQUNxRCxNQUFNLENBQUNGLEtBQUs7WUFDN0I7UUFDRjtRQUVBLElBQUksQ0FBQ2pELFdBQVcsR0FBRyxJQUFJLENBQUNGLFNBQVMsQ0FBQ3NELElBQUksQ0FBQ1IsQ0FBQUEsYUFDckMsQ0FBQ0EsVUFBVSxDQUFDNUMsV0FBVyxJQUN2QjRDLFdBQVdTLE1BQU0sS0FBSyxRQUN0QlQsV0FBV1UsU0FBUyxLQUFLO0lBRTdCO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y3QztJQUNBYjtJQUNBRTtJQUNBUTtJQUNBQztJQUNBRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLWJhc2UuanM/MWJjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBGaXhlZFF1ZXVlID0gcmVxdWlyZSgnLi9ub2RlL2ZpeGVkLXF1ZXVlJylcbmNvbnN0IHsga0Nvbm5lY3RlZCwga1NpemUsIGtSdW5uaW5nLCBrUGVuZGluZywga1F1ZXVlZCwga0J1c3ksIGtGcmVlLCBrVXJsLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IFBvb2xTdGF0cyA9IHJlcXVpcmUoJy4vcG9vbC1zdGF0cycpXG5cbmNvbnN0IGtDbGllbnRzID0gU3ltYm9sKCdjbGllbnRzJylcbmNvbnN0IGtOZWVkRHJhaW4gPSBTeW1ib2woJ25lZWREcmFpbicpXG5jb25zdCBrUXVldWUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKCdjbG9zZWQgcmVzb2x2ZScpXG5jb25zdCBrT25EcmFpbiA9IFN5bWJvbCgnb25EcmFpbicpXG5jb25zdCBrT25Db25uZWN0ID0gU3ltYm9sKCdvbkNvbm5lY3QnKVxuY29uc3Qga09uRGlzY29ubmVjdCA9IFN5bWJvbCgnb25EaXNjb25uZWN0JylcbmNvbnN0IGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbCgnb25Db25uZWN0aW9uRXJyb3InKVxuY29uc3Qga0dldERpc3BhdGNoZXIgPSBTeW1ib2woJ2dldCBkaXNwYXRjaGVyJylcbmNvbnN0IGtBZGRDbGllbnQgPSBTeW1ib2woJ2FkZCBjbGllbnQnKVxuY29uc3Qga1JlbW92ZUNsaWVudCA9IFN5bWJvbCgncmVtb3ZlIGNsaWVudCcpXG5jb25zdCBrU3RhdHMgPSBTeW1ib2woJ3N0YXRzJylcblxuY2xhc3MgUG9vbEJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBuZXcgRml4ZWRRdWV1ZSgpXG4gICAgdGhpc1trQ2xpZW50c10gPSBbXVxuICAgIHRoaXNba1F1ZXVlZF0gPSAwXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1xuXG4gICAgdGhpc1trT25EcmFpbl0gPSBmdW5jdGlvbiBvbkRyYWluIChvcmlnaW4sIHRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHF1ZXVlID0gcG9vbFtrUXVldWVdXG5cbiAgICAgIGxldCBuZWVkRHJhaW4gPSBmYWxzZVxuXG4gICAgICB3aGlsZSAoIW5lZWREcmFpbikge1xuICAgICAgICBjb25zdCBpdGVtID0gcXVldWUuc2hpZnQoKVxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHBvb2xba1F1ZXVlZF0tLVxuICAgICAgICBuZWVkRHJhaW4gPSAhdGhpcy5kaXNwYXRjaChpdGVtLm9wdHMsIGl0ZW0uaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgdGhpc1trTmVlZERyYWluXSA9IG5lZWREcmFpblxuXG4gICAgICBpZiAoIXRoaXNba05lZWREcmFpbl0gJiYgcG9vbFtrTmVlZERyYWluXSkge1xuICAgICAgICBwb29sW2tOZWVkRHJhaW5dID0gZmFsc2VcbiAgICAgICAgcG9vbC5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgICAgfVxuXG4gICAgICBpZiAocG9vbFtrQ2xvc2VkUmVzb2x2ZV0gJiYgcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgIFByb21pc2VcbiAgICAgICAgICAuYWxsKHBvb2xba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgICAgICAgLnRoZW4ocG9vbFtrQ2xvc2VkUmVzb2x2ZV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdHNdID0gbmV3IFBvb2xTdGF0cyh0aGlzKVxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tOZWVkRHJhaW5dXG4gIH1cblxuICBnZXQgW2tDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrRnJlZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSAmJiAhY2xpZW50W2tOZWVkRHJhaW5dKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba1BlbmRpbmddICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1BlbmRpbmddOiBwZW5kaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBwZW5kaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgeyBba1J1bm5pbmddOiBydW5uaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBydW5uaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1NpemVdICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1NpemVdOiBzaXplIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBzaXplXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBzdGF0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0YXRzXVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW2tRdWV1ZV0uaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKGMgPT4gYy5jbG9zZSgpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gcmVzb2x2ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba1F1ZXVlXS5zaGlmdCgpXG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGl0ZW0uaGFuZGxlci5vbkVycm9yKGVycilcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKGMgPT4gYy5kZXN0cm95KGVycikpKVxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgdGhpc1trUXVldWVdLnB1c2goeyBvcHRzLCBoYW5kbGVyIH0pXG4gICAgICB0aGlzW2tRdWV1ZWRdKytcbiAgICB9IGVsc2UgaWYgKCFkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpKSB7XG4gICAgICBkaXNwYXRjaGVyW2tOZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgdGhpc1trTmVlZERyYWluXSA9ICF0aGlzW2tHZXREaXNwYXRjaGVyXSgpXG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzW2tOZWVkRHJhaW5dXG4gIH1cblxuICBba0FkZENsaWVudF0gKGNsaWVudCkge1xuICAgIGNsaWVudFxuICAgICAgLm9uKCdkcmFpbicsIHRoaXNba09uRHJhaW5dKVxuICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXNba09uRGlzY29ubmVjdF0pXG4gICAgICAub24oJ2Nvbm5lY3Rpb25FcnJvcicsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSlcblxuICAgIHRoaXNba0NsaWVudHNdLnB1c2goY2xpZW50KVxuXG4gICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNba09uRHJhaW5dKGNsaWVudFtrVXJsXSwgW3RoaXMsIGNsaWVudF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFtrUmVtb3ZlQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50LmNsb3NlKCgpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IHRoaXNba0NsaWVudHNdLmluZGV4T2YoY2xpZW50KVxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpc1trTmVlZERyYWluXSA9IHRoaXNba0NsaWVudHNdLnNvbWUoZGlzcGF0Y2hlciA9PiAoXG4gICAgICAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSAmJlxuICAgICAgZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrUmVtb3ZlQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufVxuIl0sIm5hbWVzIjpbIkRpc3BhdGNoZXJCYXNlIiwicmVxdWlyZSIsIkZpeGVkUXVldWUiLCJrQ29ubmVjdGVkIiwia1NpemUiLCJrUnVubmluZyIsImtQZW5kaW5nIiwia1F1ZXVlZCIsImtCdXN5Iiwia0ZyZWUiLCJrVXJsIiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJQb29sU3RhdHMiLCJrQ2xpZW50cyIsIlN5bWJvbCIsImtOZWVkRHJhaW4iLCJrUXVldWUiLCJrQ2xvc2VkUmVzb2x2ZSIsImtPbkRyYWluIiwia09uQ29ubmVjdCIsImtPbkRpc2Nvbm5lY3QiLCJrT25Db25uZWN0aW9uRXJyb3IiLCJrR2V0RGlzcGF0Y2hlciIsImtBZGRDbGllbnQiLCJrUmVtb3ZlQ2xpZW50Iiwia1N0YXRzIiwiUG9vbEJhc2UiLCJjb25zdHJ1Y3RvciIsInBvb2wiLCJvbkRyYWluIiwib3JpZ2luIiwidGFyZ2V0cyIsInF1ZXVlIiwibmVlZERyYWluIiwiaXRlbSIsInNoaWZ0IiwiZGlzcGF0Y2giLCJvcHRzIiwiaGFuZGxlciIsImVtaXQiLCJpc0VtcHR5IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImMiLCJjbG9zZSIsInRoZW4iLCJlcnIiLCJmaWx0ZXIiLCJjbGllbnQiLCJsZW5ndGgiLCJyZXQiLCJwZW5kaW5nIiwicnVubmluZyIsInNpemUiLCJzdGF0cyIsInJlc29sdmUiLCJvbkVycm9yIiwiZGVzdHJveSIsImRpc3BhdGNoZXIiLCJwdXNoIiwib24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwic29tZSIsImNsb3NlZCIsImRlc3Ryb3llZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/pool-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/pool-stats.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/pool-stats.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst kPool = Symbol(\"pool\");\nclass PoolStats {\n    constructor(pool){\n        this[kPool] = pool;\n    }\n    get connected() {\n        return this[kPool][kConnected];\n    }\n    get free() {\n        return this[kPool][kFree];\n    }\n    get pending() {\n        return this[kPool][kPending];\n    }\n    get queued() {\n        return this[kPool][kQueued];\n    }\n    get running() {\n        return this[kPool][kRunning];\n    }\n    get size() {\n        return this[kPool][kSize];\n    }\n}\nmodule.exports = PoolStats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLXN0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBRUEsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMxRSxNQUFNQyxRQUFRQyxPQUFPO0FBRXJCLE1BQU1DO0lBQ0pDLFlBQWFDLElBQUksQ0FBRTtRQUNqQixJQUFJLENBQUNKLE1BQU0sR0FBR0k7SUFDaEI7SUFFQSxJQUFJQyxZQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ04sV0FBVztJQUNoQztJQUVBLElBQUlZLE9BQVE7UUFDVixPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDUCxNQUFNO0lBQzNCO0lBRUEsSUFBSWMsVUFBVztRQUNiLE9BQU8sSUFBSSxDQUFDUCxNQUFNLENBQUNMLFNBQVM7SUFDOUI7SUFFQSxJQUFJYSxTQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNSLE1BQU0sQ0FBQ0osUUFBUTtJQUM3QjtJQUVBLElBQUlhLFVBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1QsTUFBTSxDQUFDSCxTQUFTO0lBQzlCO0lBRUEsSUFBSWEsT0FBUTtRQUNWLE9BQU8sSUFBSSxDQUFDVixNQUFNLENBQUNGLE1BQU07SUFDM0I7QUFDRjtBQUVBYSxPQUFPQyxPQUFPLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLXN0YXRzLmpzPzBlMWIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBrRnJlZSwga0Nvbm5lY3RlZCwga1BlbmRpbmcsIGtRdWV1ZWQsIGtSdW5uaW5nLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi9jb3JlL3N5bWJvbHMnKVxuY29uc3Qga1Bvb2wgPSBTeW1ib2woJ3Bvb2wnKVxuXG5jbGFzcyBQb29sU3RhdHMge1xuICBjb25zdHJ1Y3RvciAocG9vbCkge1xuICAgIHRoaXNba1Bvb2xdID0gcG9vbFxuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tDb25uZWN0ZWRdXG4gIH1cblxuICBnZXQgZnJlZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tGcmVlXVxuICB9XG5cbiAgZ2V0IHBlbmRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUGVuZGluZ11cbiAgfVxuXG4gIGdldCBxdWV1ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUXVldWVkXVxuICB9XG5cbiAgZ2V0IHJ1bm5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUnVubmluZ11cbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1NpemVdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sU3RhdHNcbiJdLCJuYW1lcyI6WyJrRnJlZSIsImtDb25uZWN0ZWQiLCJrUGVuZGluZyIsImtRdWV1ZWQiLCJrUnVubmluZyIsImtTaXplIiwicmVxdWlyZSIsImtQb29sIiwiU3ltYm9sIiwiUG9vbFN0YXRzIiwiY29uc3RydWN0b3IiLCJwb29sIiwiY29ubmVjdGVkIiwiZnJlZSIsInBlbmRpbmciLCJxdWV1ZWQiLCJydW5uaW5nIiwic2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/pool-stats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/pool.js":
/*!*****************************************!*\
  !*** ./node_modules/undici/lib/pool.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/pool-base.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/client.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ./core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\");\nconst kOptions = Symbol(\"options\");\nconst kConnections = Symbol(\"connections\");\nconst kFactory = Symbol(\"factory\");\nfunction defaultFactory(origin, opts) {\n    return new Client(origin, opts);\n}\nclass Pool extends PoolBase {\n    constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n            throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout == null ? 10e3 : connectTimeout,\n                ...util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];\n        this[kConnections] = connections || null;\n        this[kUrl] = util.parseOrigin(origin);\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect,\n            allowH2\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kFactory] = factory;\n    }\n    [kGetDispatcher]() {\n        let dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain]);\n        if (dispatcher) {\n            return dispatcher;\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n            dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n            this[kAddClient](dispatcher);\n        }\n        return dispatcher;\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLGNBQWMsRUFDZixHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSkUsb0JBQW9CLEVBQ3JCLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ1osTUFBTUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSSxJQUFJLEVBQUVDLGFBQWEsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDO0FBRS9CLE1BQU1PLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsZUFBZUQsT0FBTztBQUM1QixNQUFNRSxXQUFXRixPQUFPO0FBRXhCLFNBQVNHLGVBQWdCQyxNQUFNLEVBQUVDLElBQUk7SUFDbkMsT0FBTyxJQUFJWixPQUFPVyxRQUFRQztBQUM1QjtBQUVBLE1BQU1DLGFBQWFuQjtJQUNqQm9CLFlBQWFILE1BQU0sRUFBRSxFQUNuQkksV0FBVyxFQUNYQyxVQUFVTixjQUFjLEVBQ3hCTyxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsR0FBRyxFQUNIQyxpQkFBaUIsRUFDakJDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyw4QkFBOEIsRUFDOUJDLE9BQU8sRUFDUCxHQUFHQyxTQUNKLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLO1FBRUwsSUFBSVYsZUFBZSxRQUFTLEVBQUNXLE9BQU9DLFFBQVEsQ0FBQ1osZ0JBQWdCQSxjQUFjLElBQUk7WUFDN0UsTUFBTSxJQUFJZCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9lLFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUlmLHFCQUFxQjtRQUNqQztRQUVBLElBQUlnQixXQUFXLFFBQVEsT0FBT0EsWUFBWSxjQUFjLE9BQU9BLFlBQVksVUFBVTtZQUNuRixNQUFNLElBQUloQixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9nQixZQUFZLFlBQVk7WUFDakNBLFVBQVVaLGVBQWU7Z0JBQ3ZCLEdBQUdjLEdBQUc7Z0JBQ05DO2dCQUNBSTtnQkFDQUg7Z0JBQ0FPLFNBQVNWLGtCQUFrQixPQUFPLE9BQU9BO2dCQUN6QyxHQUFJaEIsS0FBSzJCLHVCQUF1QixJQUFJUCxtQkFBbUI7b0JBQUVBO29CQUFrQkM7Z0JBQStCLElBQUlPLFNBQVM7Z0JBQ3ZILEdBQUdiLE9BQU87WUFDWjtRQUNGO1FBRUEsSUFBSSxDQUFDYixjQUFjLEdBQUdxQixRQUFRTSxZQUFZLElBQUlOLFFBQVFNLFlBQVksQ0FBQ2xCLElBQUksSUFBSW1CLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxJQUM5R1ksUUFBUU0sWUFBWSxDQUFDbEIsSUFBSSxHQUN6QixFQUFFO1FBQ04sSUFBSSxDQUFDTCxhQUFhLEdBQUdPLGVBQWU7UUFDcEMsSUFBSSxDQUFDWixLQUFLLEdBQUdELEtBQUtnQyxXQUFXLENBQUN2QjtRQUM5QixJQUFJLENBQUNMLFNBQVMsR0FBRztZQUFFLEdBQUdKLEtBQUtpQyxTQUFTLENBQUNWLFFBQVE7WUFBRVI7WUFBU087UUFBUTtRQUNoRSxJQUFJLENBQUNsQixTQUFTLENBQUN5QixZQUFZLEdBQUdOLFFBQVFNLFlBQVksR0FDOUM7WUFBRSxHQUFHTixRQUFRTSxZQUFZO1FBQUMsSUFDMUJEO1FBQ0osSUFBSSxDQUFDckIsU0FBUyxHQUFHTztJQUNuQjtJQUVBLENBQUNsQixlQUFlLEdBQUk7UUFDbEIsSUFBSXNDLGFBQWEsSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsSUFBSSxDQUFDRCxDQUFBQSxhQUFjLENBQUNBLFVBQVUsQ0FBQ3hDLFdBQVc7UUFFMUUsSUFBSXdDLFlBQVk7WUFDZCxPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzVCLGFBQWEsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQzJDLE1BQU0sR0FBRyxJQUFJLENBQUM5QixhQUFhLEVBQUU7WUFDckU0QixhQUFhLElBQUksQ0FBQzNCLFNBQVMsQ0FBQyxJQUFJLENBQUNOLEtBQUssRUFBRSxJQUFJLENBQUNHLFNBQVM7WUFDdEQsSUFBSSxDQUFDVCxXQUFXLENBQUN1QztRQUNuQjtRQUVBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBRyxPQUFPQyxPQUFPLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcG9vbC5qcz84Y2U0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrVXJsLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuL2NvcmUvc3ltYm9scycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0Nvbm5lY3Rpb25zID0gU3ltYm9sKCdjb25uZWN0aW9ucycpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgY29ubmVjdGlvbnMsXG4gICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgdGxzLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIHNvY2tldFBhdGgsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgYWxsb3dIMixcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCA9PSBudWxsID8gMTBlMyA6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAuLi4odXRpbC5ub2RlSGFzQXV0b1NlbGVjdEZhbWlseSAmJiBhdXRvU2VsZWN0RmFtaWx5ID8geyBhdXRvU2VsZWN0RmFtaWx5LCBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgfSA6IHVuZGVmaW5lZCksXG4gICAgICAgIC4uLmNvbm5lY3RcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzICYmIG9wdGlvbnMuaW50ZXJjZXB0b3JzLlBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sKVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trQ29ubmVjdGlvbnNdID0gY29ubmVjdGlvbnMgfHwgbnVsbFxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKG9yaWdpbilcbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QsIGFsbG93SDIgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZChkaXNwYXRjaGVyID0+ICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dKVxuXG4gICAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW2tDb25uZWN0aW9uc10gfHwgdGhpc1trQ2xpZW50c10ubGVuZ3RoIDwgdGhpc1trQ29ubmVjdGlvbnNdKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0odGhpc1trVXJsXSwgdGhpc1trT3B0aW9uc10pXG4gICAgICB0aGlzW2tBZGRDbGllbnRdKGRpc3BhdGNoZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6WyJQb29sQmFzZSIsImtDbGllbnRzIiwia05lZWREcmFpbiIsImtBZGRDbGllbnQiLCJrR2V0RGlzcGF0Y2hlciIsInJlcXVpcmUiLCJDbGllbnQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInV0aWwiLCJrVXJsIiwia0ludGVyY2VwdG9ycyIsImJ1aWxkQ29ubmVjdG9yIiwia09wdGlvbnMiLCJTeW1ib2wiLCJrQ29ubmVjdGlvbnMiLCJrRmFjdG9yeSIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwib3B0cyIsIlBvb2wiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25zIiwiZmFjdG9yeSIsImNvbm5lY3QiLCJjb25uZWN0VGltZW91dCIsInRscyIsIm1heENhY2hlZFNlc3Npb25zIiwic29ja2V0UGF0aCIsImF1dG9TZWxlY3RGYW1pbHkiLCJhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQiLCJhbGxvd0gyIiwib3B0aW9ucyIsIk51bWJlciIsImlzRmluaXRlIiwidGltZW91dCIsIm5vZGVIYXNBdXRvU2VsZWN0RmFtaWx5IiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VPcmlnaW4iLCJkZWVwQ2xvbmUiLCJkaXNwYXRjaGVyIiwiZmluZCIsImxlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/proxy-agent.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/proxy-agent.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ./core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/agent.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/pool.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher-base.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ./core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\");\nconst kAgent = Symbol(\"proxy agent\");\nconst kClient = Symbol(\"proxy client\");\nconst kProxyHeaders = Symbol(\"proxy headers\");\nconst kRequestTls = Symbol(\"request tls settings\");\nconst kProxyTls = Symbol(\"proxy tls settings\");\nconst kConnectEndpoint = Symbol(\"connect endpoint function\");\nfunction defaultProtocolPort(protocol) {\n    return protocol === \"https:\" ? 443 : 80;\n}\nfunction buildProxyOptions(opts) {\n    if (typeof opts === \"string\") {\n        opts = {\n            uri: opts\n        };\n    }\n    if (!opts || !opts.uri) {\n        throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n    }\n    return {\n        uri: opts.uri,\n        protocol: opts.protocol || \"https\"\n    };\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n    constructor(opts){\n        super(opts);\n        this[kProxy] = buildProxyOptions(opts);\n        this[kAgent] = new Agent(opts);\n        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n        if (typeof opts === \"string\") {\n            opts = {\n                uri: opts\n            };\n        }\n        if (!opts || !opts.uri) {\n            throw new InvalidArgumentError(\"Proxy opts.uri is mandatory\");\n        }\n        const { clientFactory = defaultFactory } = opts;\n        if (typeof clientFactory !== \"function\") {\n            throw new InvalidArgumentError(\"Proxy opts.clientFactory must be a function.\");\n        }\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = opts.headers || {};\n        if (opts.auth && opts.token) {\n            throw new InvalidArgumentError(\"opts.auth cannot be used in combination with opts.token\");\n        } else if (opts.auth) {\n            /* @deprecated in favour of opts.token */ this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        } else if (opts.token) {\n            this[kProxyHeaders][\"proxy-authorization\"] = opts.token;\n        }\n        const resolvedUrl = new URL(opts.uri);\n        const { origin, port, host } = resolvedUrl;\n        const connect = buildConnector({\n            ...opts.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...opts.requestTls\n        });\n        this[kClient] = clientFactory(resolvedUrl, {\n            connect\n        });\n        this[kAgent] = new Agent({\n            ...opts,\n            connect: async (opts, callback)=>{\n                let requestedHost = opts.host;\n                if (!opts.port) {\n                    requestedHost += `:${defaultProtocolPort(opts.protocol)}`;\n                }\n                try {\n                    const { socket, statusCode } = await this[kClient].connect({\n                        origin,\n                        port,\n                        path: requestedHost,\n                        signal: opts.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host\n                        }\n                    });\n                    if (statusCode !== 200) {\n                        socket.on(\"error\", ()=>{}).destroy();\n                        callback(new RequestAbortedError(\"Proxy response !== 200 when HTTP Tunneling\"));\n                    }\n                    if (opts.protocol !== \"https:\") {\n                        callback(null, socket);\n                        return;\n                    }\n                    let servername;\n                    if (this[kRequestTls]) {\n                        servername = this[kRequestTls].servername;\n                    } else {\n                        servername = opts.servername;\n                    }\n                    this[kConnectEndpoint]({\n                        ...opts,\n                        servername,\n                        httpSocket: socket\n                    }, callback);\n                } catch (err) {\n                    callback(err);\n                }\n            }\n        });\n    }\n    dispatch(opts, handler) {\n        const { host } = new URL(opts.origin);\n        const headers = buildHeaders(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        return this[kAgent].dispatch({\n            ...opts,\n            headers: {\n                ...headers,\n                host\n            }\n        }, handler);\n    }\n    async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n    }\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */ function buildHeaders(headers) {\n    // When using undici.fetch, the headers list is stored\n    // as an array.\n    if (Array.isArray(headers)) {\n        /** @type {Record<string, string>} */ const headersPair = {};\n        for(let i = 0; i < headers.length; i += 2){\n            headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n    }\n    return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */ function throwIfProxyAuthIsSent(headers) {\n    const existProxyAuth = headers && Object.keys(headers).find((key)=>key.toLowerCase() === \"proxy-authorization\");\n    if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n    }\n}\nmodule.exports = ProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9wcm94eS1hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVELE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1JLGlCQUFpQkosbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFSyxvQkFBb0IsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDOUQsTUFBTU8saUJBQWlCUCxtQkFBT0EsQ0FBQztBQUUvQixNQUFNUSxTQUFTQyxPQUFPO0FBQ3RCLE1BQU1DLFVBQVVELE9BQU87QUFDdkIsTUFBTUUsZ0JBQWdCRixPQUFPO0FBQzdCLE1BQU1HLGNBQWNILE9BQU87QUFDM0IsTUFBTUksWUFBWUosT0FBTztBQUN6QixNQUFNSyxtQkFBbUJMLE9BQU87QUFFaEMsU0FBU00sb0JBQXFCQyxRQUFRO0lBQ3BDLE9BQU9BLGFBQWEsV0FBVyxNQUFNO0FBQ3ZDO0FBRUEsU0FBU0Msa0JBQW1CQyxJQUFJO0lBQzlCLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzVCQSxPQUFPO1lBQUVDLEtBQUtEO1FBQUs7SUFDckI7SUFFQSxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0MsR0FBRyxFQUFFO1FBQ3RCLE1BQU0sSUFBSWQscUJBQXFCO0lBQ2pDO0lBRUEsT0FBTztRQUNMYyxLQUFLRCxLQUFLQyxHQUFHO1FBQ2JILFVBQVVFLEtBQUtGLFFBQVEsSUFBSTtJQUM3QjtBQUNGO0FBRUEsU0FBU0ksZUFBZ0JDLE1BQU0sRUFBRUgsSUFBSTtJQUNuQyxPQUFPLElBQUlmLEtBQUtrQixRQUFRSDtBQUMxQjtBQUVBLE1B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QUksR0FBR0EsSUFBSXhCLFFBQVF5QixNQUFNLEVBQUVELEtBQUssRUFBRztZQUMxQ0QsV0FBVyxDQUFDdkIsT0FBTyxDQUFDd0IsRUFBRSxDQUFDLEdBQUd4QixPQUFPLENBQUN3QixJQUFJLEVBQUU7UUFDMUM7UUFFQSxPQUFPRDtJQUNUO0lBRUEsT0FBT3ZCO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3FCLHVCQUF3QnJCLE9BQU87SUFDdEMsTUFBTTBCLGlCQUFpQjFCLFdBQVcyQixPQUFPQyxJQUFJLENBQUM1QixTQUMzQzZCLElBQUksQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxXQUFXLE9BQU87SUFDdkMsSUFBSUwsZ0JBQWdCO1FBQ2xCLE1BQU0sSUFBSW5ELHFCQUFxQjtJQUNqQztBQUNGO0FBRUF5RCxPQUFPQyxPQUFPLEdBQUd6QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvcHJveHktYWdlbnQuanM/OTQ2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrUHJveHksIGtDbG9zZSwga0Rlc3Ryb3ksIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9jb3JlL2Nvbm5lY3QnKVxuXG5jb25zdCBrQWdlbnQgPSBTeW1ib2woJ3Byb3h5IGFnZW50JylcbmNvbnN0IGtDbGllbnQgPSBTeW1ib2woJ3Byb3h5IGNsaWVudCcpXG5jb25zdCBrUHJveHlIZWFkZXJzID0gU3ltYm9sKCdwcm94eSBoZWFkZXJzJylcbmNvbnN0IGtSZXF1ZXN0VGxzID0gU3ltYm9sKCdyZXF1ZXN0IHRscyBzZXR0aW5ncycpXG5jb25zdCBrUHJveHlUbHMgPSBTeW1ib2woJ3Byb3h5IHRscyBzZXR0aW5ncycpXG5jb25zdCBrQ29ubmVjdEVuZHBvaW50ID0gU3ltYm9sKCdjb25uZWN0IGVuZHBvaW50IGZ1bmN0aW9uJylcblxuZnVuY3Rpb24gZGVmYXVsdFByb3RvY29sUG9ydCAocHJvdG9jb2wpIHtcbiAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwXG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJveHlPcHRpb25zIChvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzID0geyB1cmk6IG9wdHMgfVxuICB9XG5cbiAgaWYgKCFvcHRzIHx8ICFvcHRzLnVyaSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy51cmkgaXMgbWFuZGF0b3J5JylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXJpOiBvcHRzLnVyaSxcbiAgICBwcm90b2NvbDogb3B0cy5wcm90b2NvbCB8fCAnaHR0cHMnXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpc1trUHJveHldID0gYnVpbGRQcm94eU9wdGlvbnMob3B0cylcbiAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQob3B0cylcbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0cy5pbnRlcmNlcHRvcnMgJiYgb3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudCAmJiBBcnJheS5pc0FycmF5KG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnQpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnRcbiAgICAgIDogW11cblxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMgPSB7IHVyaTogb3B0cyB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLnVyaSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLnVyaSBpcyBtYW5kYXRvcnknKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY2xpZW50RmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5IH0gPSBvcHRzXG5cbiAgICBpZiAodHlwZW9mIGNsaWVudEZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy5jbGllbnRGYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIHRoaXNba1JlcXVlc3RUbHNdID0gb3B0cy5yZXF1ZXN0VGxzXG4gICAgdGhpc1trUHJveHlUbHNdID0gb3B0cy5wcm94eVRsc1xuICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSBvcHRzLmhlYWRlcnMgfHwge31cblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKG9wdHMudXJpKVxuICAgIGNvbnN0IHsgb3JpZ2luLCBwb3J0LCBob3N0IH0gPSByZXNvbHZlZFVybFxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHJlc29sdmVkVXJsLCB7IGNvbm5lY3QgfSlcbiAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbm5lY3Q6IGFzeW5jIChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgcmVxdWVzdGVkSG9zdCA9IG9wdHMuaG9zdFxuICAgICAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgICAgIHJlcXVlc3RlZEhvc3QgKz0gYDoke2RlZmF1bHRQcm90b2NvbFBvcnQob3B0cy5wcm90b2NvbCl9YFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uY29ubmVjdCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdGVkSG9zdCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnRoaXNba1Byb3h5SGVhZGVyc10sXG4gICAgICAgICAgICAgIGhvc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7fSkuZGVzdHJveSgpXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcignUHJveHkgcmVzcG9uc2UgIT09IDIwMCB3aGVuIEhUVFAgVHVubmVsaW5nJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc29ja2V0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzZXJ2ZXJuYW1lXG4gICAgICAgICAgaWYgKHRoaXNba1JlcXVlc3RUbHNdKSB7XG4gICAgICAgICAgICBzZXJ2ZXJuYW1lID0gdGhpc1trUmVxdWVzdFRsc10uc2VydmVybmFtZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0oeyAuLi5vcHRzLCBzZXJ2ZXJuYW1lLCBodHRwU29ja2V0OiBzb2NrZXQgfSwgY2FsbGJhY2spXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHsgaG9zdCB9ID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKG9wdHMuaGVhZGVycylcbiAgICB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgaG9zdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgIClcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uY2xvc2UoKVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmRlc3Ryb3koKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uZGVzdHJveSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVycyAoaGVhZGVycykge1xuICAvLyBXaGVuIHVzaW5nIHVuZGljaS5mZXRjaCwgdGhlIGhlYWRlcnMgbGlzdCBpcyBzdG9yZWRcbiAgLy8gYXMgYW4gYXJyYXkuXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIGNvbnN0IGhlYWRlcnNQYWlyID0ge31cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaGVhZGVyc1BhaXJbaGVhZGVyc1tpXV0gPSBoZWFkZXJzW2kgKyAxXVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzUGFpclxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqXG4gKiBQcmV2aW91cyB2ZXJzaW9ucyBvZiBQcm94eUFnZW50IHN1Z2dlc3RzIHRoZSBQcm94eS1BdXRob3JpemF0aW9uIGluIHJlcXVlc3QgaGVhZGVyc1xuICogTmV2ZXJ0aGVsZXNzLCBpdCB3YXMgY2hhbmdlZCBhbmQgdG8gYXZvaWQgYSBzZWN1cml0eSB2dWxuZXJhYmlsaXR5IGJ5IGVuZCB1c2Vyc1xuICogdGhpcyBjaGVjayB3YXMgY3JlYXRlZC5cbiAqIEl0IHNob3VsZCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAqL1xuZnVuY3Rpb24gdGhyb3dJZlByb3h5QXV0aElzU2VudCAoaGVhZGVycykge1xuICBjb25zdCBleGlzdFByb3h5QXV0aCA9IGhlYWRlcnMgJiYgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAuZmluZCgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3Byb3h5LWF1dGhvcml6YXRpb24nKVxuICBpZiAoZXhpc3RQcm94eUF1dGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5LUF1dGhvcml6YXRpb24gc2hvdWxkIGJlIHNlbnQgaW4gUHJveHlBZ2VudCBjb25zdHJ1Y3RvcicpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm94eUFnZW50XG4iXSwibmFtZXMiOlsia1Byb3h5Iiwia0Nsb3NlIiwia0Rlc3Ryb3kiLCJrSW50ZXJjZXB0b3JzIiwicmVxdWlyZSIsIlVSTCIsIkFnZW50IiwiUG9vbCIsIkRpc3BhdGNoZXJCYXNlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiYnVpbGRDb25uZWN0b3IiLCJrQWdlbnQiLCJTeW1ib2wiLCJrQ2xpZW50Iiwia1Byb3h5SGVhZGVycyIsImtSZXF1ZXN0VGxzIiwia1Byb3h5VGxzIiwia0Nvbm5lY3RFbmRwb2ludCIsImRlZmF1bHRQcm90b2NvbFBvcnQiLCJwcm90b2NvbCIsImJ1aWxkUHJveHlPcHRpb25zIiwib3B0cyIsInVyaSIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwiUHJveHlBZ2VudCIsImNvbnN0cnVjdG9yIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xpZW50RmFjdG9yeSIsInJlcXVlc3RUbHMiLCJwcm94eVRscyIsImhlYWRlcnMiLCJhdXRoIiwidG9rZW4iLCJyZXNvbHZlZFVybCIsInBvcnQiLCJob3N0IiwiY29ubmVjdCIsImNhbGxiYWNrIiwicmVxdWVzdGVkSG9zdCIsInNvY2tldCIsInN0YXR1c0NvZGUiLCJwYXRoIiwic2lnbmFsIiwib24iLCJkZXN0cm95Iiwic2VydmVybmFtZSIsImh0dHBTb2NrZXQiLCJlcnIiLCJkaXNwYXRjaCIsImhhbmRsZXIiLCJidWlsZEhlYWRlcnMiLCJ0aHJvd0lmUHJveHlBdXRoSXNTZW50IiwiY2xvc2UiLCJoZWFkZXJzUGFpciIsImkiLCJsZW5ndGgiLCJleGlzdFByb3h5QXV0aCIsIk9iamVjdCIsImtleXMiLCJmaW5kIiwia2V5IiwidG9Mb3dlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/timers.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/timers.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\nlet fastNow = Date.now();\nlet fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let len = fastTimers.length;\n    let idx = 0;\n    while(idx < len){\n        const timer = fastTimers[idx];\n        if (timer.state === 0) {\n            timer.state = fastNow + timer.delay;\n        } else if (timer.state > 0 && fastNow >= timer.state) {\n            timer.state = -1;\n            timer.callback(timer.opaque);\n        }\n        if (timer.state === -1) {\n            timer.state = -2;\n            if (idx !== len - 1) {\n                fastTimers[idx] = fastTimers.pop();\n            } else {\n                fastTimers.pop();\n            }\n            len -= 1;\n        } else {\n            idx += 1;\n        }\n    }\n    if (fastTimers.length > 0) {\n        refreshTimeout();\n    }\n}\nfunction refreshTimeout() {\n    if (fastNowTimeout && fastNowTimeout.refresh) {\n        fastNowTimeout.refresh();\n    } else {\n        clearTimeout(fastNowTimeout);\n        fastNowTimeout = setTimeout(onTimeout, 1e3);\n        if (fastNowTimeout.unref) {\n            fastNowTimeout.unref();\n        }\n    }\n}\nclass Timeout {\n    constructor(callback, delay, opaque){\n        this.callback = callback;\n        this.delay = delay;\n        this.opaque = opaque;\n        //  -2 not in timer list\n        //  -1 in timer list but inactive\n        //   0 in timer list waiting for time\n        // > 0 in timer list waiting for time to expire\n        this.state = -2;\n        this.refresh();\n    }\n    refresh() {\n        if (this.state === -2) {\n            fastTimers.push(this);\n            if (!fastNowTimeout || fastTimers.length === 1) {\n                refreshTimeout();\n            }\n        }\n        this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n}\nmodule.exports = {\n    setTimeout (callback, delay, opaque) {\n        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);\n    },\n    clearTimeout (timeout) {\n        if (timeout instanceof Timeout) {\n            timeout.clear();\n        } else {\n            clearTimeout(timeout);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi90aW1lcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxVQUFVQyxLQUFLQyxHQUFHO0FBQ3RCLElBQUlDO0FBRUosTUFBTUMsYUFBYSxFQUFFO0FBRXJCLFNBQVNDO0lBQ1BMLFVBQVVDLEtBQUtDLEdBQUc7SUFFbEIsSUFBSUksTUFBTUYsV0FBV0csTUFBTTtJQUMzQixJQUFJQyxNQUFNO0lBQ1YsTUFBT0EsTUFBTUYsSUFBSztRQUNoQixNQUFNRyxRQUFRTCxVQUFVLENBQUNJLElBQUk7UUFFN0IsSUFBSUMsTUFBTUMsS0FBSyxLQUFLLEdBQUc7WUFDckJELE1BQU1DLEtBQUssR0FBR1YsVUFBVVMsTUFBTUUsS0FBSztRQUNyQyxPQUFPLElBQUlGLE1BQU1DLEtBQUssR0FBRyxLQUFLVixXQUFXUyxNQUFNQyxLQUFLLEVBQUU7WUFDcERELE1BQU1DLEtBQUssR0FBRyxDQUFDO1lBQ2ZELE1BQU1HLFFBQVEsQ0FBQ0gsTUFBTUksTUFBTTtRQUM3QjtRQUVBLElBQUlKLE1BQU1DLEtBQUssS0FBSyxDQUFDLEdBQUc7WUFDdEJELE1BQU1DLEtBQUssR0FBRyxDQUFDO1lBQ2YsSUFBSUYsUUFBUUYsTUFBTSxHQUFHO2dCQUNuQkYsVUFBVSxDQUFDSSxJQUFJLEdBQUdKLFdBQVdVLEdBQUc7WUFDbEMsT0FBTztnQkFDTFYsV0FBV1UsR0FBRztZQUNoQjtZQUNBUixPQUFPO1FBQ1QsT0FBTztZQUNMRSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlKLFdBQVdHLE1BQU0sR0FBRyxHQUFHO1FBQ3pCUTtJQUNGO0FBQ0Y7QUFFQSxTQUFTQTtJQUNQLElBQUlaLGtCQUFrQkEsZUFBZWEsT0FBTyxFQUFFO1FBQzVDYixlQUFlYSxPQUFPO0lBQ3hCLE9BQU87UUFDTEMsYUFBYWQ7UUFDYkEsaUJBQWlCZSxXQUFXYixXQUFXO1FBQ3ZDLElBQUlGLGVBQWVnQixLQUFLLEVBQUU7WUFDeEJoQixlQUFlZ0IsS0FBSztRQUN0QjtJQUNGO0FBQ0Y7QUFFQSxNQUFNQztJQUNKQyxZQUFhVCxRQUFRLEVBQUVELEtBQUssRUFBRUUsTUFBTSxDQUFFO1FBQ3BDLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFFZCx3QkFBd0I7UUFDeEIsaUNBQWlDO1FBQ2pDLHFDQUFxQztRQUNyQywrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDSCxLQUFLLEdBQUcsQ0FBQztRQUVkLElBQUksQ0FBQ00sT0FBTztJQUNkO0lBRUFBLFVBQVc7UUFDVCxJQUFJLElBQUksQ0FBQ04sS0FBSyxLQUFLLENBQUMsR0FBRztZQUNyQk4sV0FBV2tCLElBQUksQ0FBQyxJQUFJO1lBQ3BCLElBQUksQ0FBQ25CLGtCQUFrQkMsV0FBV0csTUFBTSxLQUFLLEdBQUc7Z0JBQzlDUTtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNMLEtBQUssR0FBRztJQUNmO0lBRUFhLFFBQVM7UUFDUCxJQUFJLENBQUNiLEtBQUssR0FBRyxDQUFDO0lBQ2hCO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZQLFlBQVlOLFFBQVEsRUFBRUQsS0FBSyxFQUFFRSxNQUFNO1FBQ2pDLE9BQU9GLFFBQVEsTUFDWE8sV0FBV04sVUFBVUQsT0FBT0UsVUFDNUIsSUFBSU8sUUFBUVIsVUFBVUQsT0FBT0U7SUFDbkM7SUFDQUksY0FBY1MsT0FBTztRQUNuQixJQUFJQSxtQkFBbUJOLFNBQVM7WUFDOUJNLFFBQVFILEtBQUs7UUFDZixPQUFPO1lBQ0xOLGFBQWFTO1FBQ2Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi90aW1lcnMuanM/ZDcwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IGZhc3ROb3cgPSBEYXRlLm5vdygpXG5sZXQgZmFzdE5vd1RpbWVvdXRcblxuY29uc3QgZmFzdFRpbWVycyA9IFtdXG5cbmZ1bmN0aW9uIG9uVGltZW91dCAoKSB7XG4gIGZhc3ROb3cgPSBEYXRlLm5vdygpXG5cbiAgbGV0IGxlbiA9IGZhc3RUaW1lcnMubGVuZ3RoXG4gIGxldCBpZHggPSAwXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBjb25zdCB0aW1lciA9IGZhc3RUaW1lcnNbaWR4XVxuXG4gICAgaWYgKHRpbWVyLnN0YXRlID09PSAwKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IGZhc3ROb3cgKyB0aW1lci5kZWxheVxuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhdGUgPiAwICYmIGZhc3ROb3cgPj0gdGltZXIuc3RhdGUpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTFcbiAgICAgIHRpbWVyLmNhbGxiYWNrKHRpbWVyLm9wYXF1ZSlcbiAgICB9XG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IC0xKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IC0yXG4gICAgICBpZiAoaWR4ICE9PSBsZW4gLSAxKSB7XG4gICAgICAgIGZhc3RUaW1lcnNbaWR4XSA9IGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH1cbiAgICAgIGxlbiAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCArPSAxXG4gICAgfVxuICB9XG5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoID4gMCkge1xuICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZyZXNoVGltZW91dCAoKSB7XG4gIGlmIChmYXN0Tm93VGltZW91dCAmJiBmYXN0Tm93VGltZW91dC5yZWZyZXNoKSB7XG4gICAgZmFzdE5vd1RpbWVvdXQucmVmcmVzaCgpXG4gIH0gZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGZhc3ROb3dUaW1lb3V0KVxuICAgIGZhc3ROb3dUaW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIDFlMylcbiAgICBpZiAoZmFzdE5vd1RpbWVvdXQudW5yZWYpIHtcbiAgICAgIGZhc3ROb3dUaW1lb3V0LnVucmVmKClcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVGltZW91dCB7XG4gIGNvbnN0cnVjdG9yIChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheVxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlXG5cbiAgICAvLyAgLTIgbm90IGluIHRpbWVyIGxpc3RcbiAgICAvLyAgLTEgaW4gdGltZXIgbGlzdCBidXQgaW5hY3RpdmVcbiAgICAvLyAgIDAgaW4gdGltZXIgbGlzdCB3YWl0aW5nIGZvciB0aW1lXG4gICAgLy8gPiAwIGluIHRpbWVyIGxpc3Qgd2FpdGluZyBmb3IgdGltZSB0byBleHBpcmVcbiAgICB0aGlzLnN0YXRlID0gLTJcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gIH1cblxuICByZWZyZXNoICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gLTIpIHtcbiAgICAgIGZhc3RUaW1lcnMucHVzaCh0aGlzKVxuICAgICAgaWYgKCFmYXN0Tm93VGltZW91dCB8fCBmYXN0VGltZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZWZyZXNoVGltZW91dCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IDBcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLnN0YXRlID0gLTFcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0VGltZW91dCAoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpIHtcbiAgICByZXR1cm4gZGVsYXkgPCAxZTNcbiAgICAgID8gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgICAgIDogbmV3IFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpXG4gIH0sXG4gIGNsZWFyVGltZW91dCAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0IGluc3RhbmNlb2YgVGltZW91dCkge1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImZhc3ROb3ciLCJEYXRlIiwibm93IiwiZmFzdE5vd1RpbWVvdXQiLCJmYXN0VGltZXJzIiwib25UaW1lb3V0IiwibGVuIiwibGVuZ3RoIiwiaWR4IiwidGltZXIiLCJzdGF0ZSIsImRlbGF5IiwiY2FsbGJhY2siLCJvcGFxdWUiLCJwb3AiLCJyZWZyZXNoVGltZW91dCIsInJlZnJlc2giLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJUaW1lb3V0IiwiY29uc3RydWN0b3IiLCJwdXNoIiwiY2xlYXIiLCJtb2R1bGUiLCJleHBvcnRzIiwidGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/timers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/connection.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/connection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { uid, states } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kByteParser, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/websocket/symbols.js\");\nconst { fireEvent, failWebsocketConnection } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/websocket/util.js\");\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/websocket/events.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/fetch/request.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/fetch/index.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/fetch/headers.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/./node_modules/undici/lib/global.js\");\nconst { kHeadersList } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\");\nconst channels = {};\nchannels.open = diagnosticsChannel.channel(\"undici:websocket:open\");\nchannels.close = diagnosticsChannel.channel(\"undici:websocket:close\");\nchannels.socketError = diagnosticsChannel.channel(\"undici:websocket:socket_error\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === \"ws:\" ? \"http:\" : \"https:\";\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = makeRequest({\n        urlList: [\n            requestURL\n        ],\n        serviceWorkers: \"none\",\n        referrer: \"no-referrer\",\n        mode: \"websocket\",\n        credentials: \"include\",\n        cache: \"no-store\",\n        redirect: \"error\"\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = new Headers(options.headers)[kHeadersList];\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n    // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = crypto.randomBytes(16).toString(\"base64\");\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n    //    header list.\n    request.headersList.append(\"sec-websocket-key\", keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n    //    header list.\n    request.headersList.append(\"sec-websocket-version\", \"13\");\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n    //    list.\n    for (const protocol of protocols){\n        request.headersList.append(\"sec-websocket-protocol\", protocol);\n    }\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    // TODO: enable once permessage-deflate is supported\n    const permessageDeflate = \"\" // 'permessage-deflate; 15'\n    ;\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     request’s header list.\n    // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = fetching({\n        request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher ?? getGlobalDispatcher(),\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === \"error\" || response.status !== 101) {\n                failWebsocketConnection(ws, \"Received network error or non-101 status code.\");\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and response’s\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Server did not respond with sent protocols.\");\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n                failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Connection\")?.toLowerCase() !== \"upgrade\") {\n                failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get(\"Sec-WebSocket-Accept\");\n            const digest = crypto.createHash(\"sha1\").update(keyValue + uid).digest(\"base64\");\n            if (secWSAccept !== digest) {\n                failWebsocketConnection(ws, \"Incorrect hash received in Sec-WebSocket-Accept header.\");\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get(\"Sec-WebSocket-Extensions\");\n            if (secExtension !== null && secExtension !== permessageDeflate) {\n                failWebsocketConnection(ws, \"Received different permessage-deflate than the one set.\");\n                return;\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get(\"Sec-WebSocket-Protocol\");\n            if (secProtocol !== null && secProtocol !== request.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Protocol was not set in the opening handshake.\");\n                return;\n            }\n            response.socket.on(\"data\", onSocketData);\n            response.socket.on(\"close\", onSocketClose);\n            response.socket.on(\"error\", onSocketError);\n            if (channels.open.hasSubscribers) {\n                channels.open.publish({\n                    address: response.socket.address(),\n                    protocol: secProtocol,\n                    extensions: secExtension\n                });\n            }\n            onEstablish(response);\n        }\n    });\n    return controller;\n}\n/**\n * @param {Buffer} chunk\n */ function onSocketData(chunk) {\n    if (!this.ws[kByteParser].write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function onSocketClose() {\n    const { ws } = this;\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[kSentClose] && ws[kReceivedClose];\n    let code = 1005;\n    let reason = \"\";\n    const result = ws[kByteParser].closingInfo;\n    if (result) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[kSentClose]) {\n        // If _The WebSocket\n        // Connection is Closed_ and no Close control frame was received by the\n        // endpoint (such as could occur if the underlying transport connection\n        // is lost), _The WebSocket Connection Close Code_ is considered to be\n        // 1006.\n        code = 1006;\n    }\n    // 1. Change the ready state to CLOSED (3).\n    ws[kReadyState] = states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    fireEvent(\"close\", ws, CloseEvent, {\n        wasClean,\n        code,\n        reason\n    });\n    if (channels.close.hasSubscribers) {\n        channels.close.publish({\n            websocket: ws,\n            code,\n            reason\n        });\n    }\n}\nfunction onSocketError(error) {\n    const { ws } = this;\n    ws[kReadyState] = states.CLOSING;\n    if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(error);\n    }\n    this.destroy();\n}\nmodule.exports = {\n    establishWebSocketConnection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLHFCQUFxQkMsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQ0pHLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGNBQWMsRUFDZixHQUFHTixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU8sU0FBUyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUN2RCxNQUFNLEVBQUVTLFVBQVUsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVVLFdBQVcsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVXLFFBQVEsRUFBRSxHQUFHWCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVZLE9BQU8sRUFBRSxHQUFHWixtQkFBT0EsQ0FBQztBQUM1QixNQUFNLEVBQUVhLG1CQUFtQixFQUFFLEdBQUdiLG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFBRWMsWUFBWSxFQUFFLEdBQUdkLG1CQUFPQSxDQUFDO0FBRWpDLE1BQU1lLFdBQVcsQ0FBQztBQUNsQkEsU0FBU0MsSUFBSSxHQUFHakIsbUJBQW1Ca0IsT0FBTyxDQUFDO0FBQzNDRixTQUFTRyxLQUFLLEdBQUduQixtQkFBbUJrQixPQUFPLENBQUM7QUFDNUNGLFNBQVNJLFdBQVcsR0FBR3BCLG1CQUFtQmtCLE9BQU8sQ0FBQztBQUVsRCw2QkFBNkIsR0FDN0IsSUFBSUc7QUFDSixJQUFJO0lBQ0ZBLFNBQVNwQixtQkFBT0EsQ0FBQztBQUNuQixFQUFFLE9BQU0sQ0FFUjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTcUIsNkJBQThCQyxHQUFHLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxXQUFXLEVB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Q0FBQztZQUNyQlksV0FBV3REO1lBQ1hpRDtZQUNBQztRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNWLGNBQWVlLEtBQUs7SUFDM0IsTUFBTSxFQUFFdkQsRUFBRSxFQUFFLEdBQUcsSUFBSTtJQUVuQkEsRUFBRSxDQUFDckIsWUFBWSxHQUFHRCxPQUFPOEUsT0FBTztJQUVoQyxJQUFJakUsU0FBU0ksV0FBVyxDQUFDOEMsY0FBYyxFQUFFO1FBQ3ZDbEQsU0FBU0ksV0FBVyxDQUFDK0MsT0FBTyxDQUFDYTtJQUMvQjtJQUVBLElBQUksQ0FBQ0UsT0FBTztBQUNkO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmOUQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanM/OTU5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCB7IHVpZCwgc3RhdGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7XG4gIGtSZWFkeVN0YXRlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlcixcbiAga1JlY2VpdmVkQ2xvc2Vcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBmaXJlRXZlbnQsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBDbG9zZUV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5jb25zdCB7IG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2luZGV4JylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbCcpXG5jb25zdCB7IGtIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY29uc3QgY2hhbm5lbHMgPSB7fVxuY2hhbm5lbHMub3BlbiA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKVxuY2hhbm5lbHMuY2xvc2UgPSBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpjbG9zZScpXG5jaGFubmVscy5zb2NrZXRFcnJvciA9IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvcicpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG59IGNhdGNoIHtcblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC13ZWJzb2NrZXQtZXN0YWJsaXNoXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0geyhyZXNwb25zZTogYW55KSA9PiB2b2lkfSBvbkVzdGFibGlzaFxuICogQHBhcmFtIHtQYXJ0aWFsPGltcG9ydCgnLi4vLi4vdHlwZXMvd2Vic29ja2V0JykuV2ViU29ja2V0SW5pdD59IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiAodXJsLCBwcm90b2NvbHMsIHdzLCBvbkVzdGFibGlzaCwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIGFuZCByZWRpcmVjdCBtb2RlIGlzIFwiZXJyb3JcIi5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgc2VydmljZVdvcmtlcnM6ICdub25lJyxcbiAgICByZWZlcnJlcjogJ25vLXJlZmVycmVyJyxcbiAgICBtb2RlOiAnd2Vic29ja2V0JyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGNhY2hlOiAnbm8tc3RvcmUnLFxuICAgIHJlZGlyZWN0OiAnZXJyb3InXG4gIH0pXG5cbiAgLy8gTm90ZTogdW5kaWNpIGV4dGVuc2lvbiwgYWxsb3cgc2V0dGluZyBjdXN0b20gaGVhZGVycy5cbiAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVtrSGVhZGVyc0xpc3RdXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICAvLyBUT0RPOiBlbmFibGUgb25jZSBwZXJtZXNzYWdlLWRlZmxhdGUgaXMgc3VwcG9ydGVkXG4gIGNvbnN0IHBlcm1lc3NhZ2VEZWZsYXRlID0gJycgLy8gJ3Blcm1lc3NhZ2UtZGVmbGF0ZTsgMTUnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIgPz8gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpLFxuICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgIC8vIDEuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciBvciBpdHMgc3RhdHVzIGlzIG5vdCAxMDEsXG4gICAgICAvLyAgICBmYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgbmV0d29yayBlcnJvciBvciBub24tMTAxIHN0YXR1cyBjb2RlLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBwcm90b2NvbHMgaXMgbm90IHRoZSBlbXB0eSBsaXN0IGFuZCBleHRyYWN0aW5nIGhlYWRlclxuICAgICAgLy8gICAgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGFuZCByZXNwb25zZeKAmXNcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IHJlc3VsdHMgaW4gbnVsbCwgZmFpbHVyZSwgb3IgdGhlIGVtcHR5IGJ5dGVcbiAgICAgIC8vICAgIHNlcXVlbmNlLCB0aGVuIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IDAgJiYgIXJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIHNlbnQgcHJvdG9jb2xzLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBGb2xsb3cgdGhlIHJlcXVpcmVtZW50cyBzdGF0ZWQgc3RlcCAyIHRvIHN0ZXAgNiwgaW5jbHVzaXZlLFxuICAgICAgLy8gICAgb2YgdGhlIGxhc3Qgc2V0IG9mIHN0ZXBzIGluIHNlY3Rpb24gNC4xIG9mIFRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIFByb3RvY29sIHRvIHZhbGlkYXRlIHJlc3BvbnNlLiBUaGlzIGVpdGhlciByZXN1bHRzIGluIGZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBvciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgICAgIC8vICAgIGVzdGFibGlzaGVkLlxuXG4gICAgICAvLyAyLiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYW4gfFVwZ3JhZGV8IGhlYWRlciBmaWVsZCBvciB0aGUgfFVwZ3JhZGV8XG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBhbiBBU0NJSSBjYXNlLVxuICAgICAgLy8gICAgaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIndlYnNvY2tldFwiLCB0aGUgY2xpZW50IE1VU1RcbiAgICAgIC8vICAgIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdVcGdyYWRlJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3Qgc2V0IFVwZ3JhZGUgaGVhZGVyIHRvIFwid2Vic29ja2V0XCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgb3IgdGhlXG4gICAgICAvLyAgICB8Q29ubmVjdGlvbnwgaGVhZGVyIGZpZWxkIGRvZXNuJ3QgY29udGFpbiBhIHRva2VuIHRoYXQgaXMgYW5cbiAgICAgIC8vICAgIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIlVwZ3JhZGVcIiwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnQ29ubmVjdGlvbicpPy50b0xvd2VyQ2FzZSgpICE9PSAndXBncmFkZScpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgQ29ubmVjdGlvbiBoZWFkZXIgdG8gXCJ1cGdyYWRlXCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgaGVhZGVyIGZpZWxkIG9yXG4gICAgICAvLyAgICB0aGUgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBjb250YWlucyBhIHZhbHVlIG90aGVyIHRoYW4gdGhlXG4gICAgICAvLyAgICBiYXNlNjQtZW5jb2RlZCBTSEEtMSBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgfFNlYy1XZWJTb2NrZXQtXG4gICAgICAvLyAgICBLZXl8IChhcyBhIHN0cmluZywgbm90IGJhc2U2NC1kZWNvZGVkKSB3aXRoIHRoZSBzdHJpbmcgXCIyNThFQUZBNS1cbiAgICAgIC8vICAgIEU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiIGJ1dCBpZ25vcmluZyBhbnkgbGVhZGluZyBhbmRcbiAgICAgIC8vICAgIHRyYWlsaW5nIHdoaXRlc3BhY2UsIHRoZSBjbGllbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyAgICBDb25uZWN0aW9uXy5cbiAgICAgIGNvbnN0IHNlY1dTQWNjZXB0ID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUFjY2VwdCcpXG4gICAgICBjb25zdCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShrZXlWYWx1ZSArIHVpZCkuZGlnZXN0KCdiYXNlNjQnKVxuICAgICAgaWYgKHNlY1dTQWNjZXB0ICE9PSBkaWdlc3QpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdJbmNvcnJlY3QgaGFzaCByZWNlaXZlZCBpbiBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnN8IGhlYWRlclxuICAgICAgLy8gICAgZmllbGQgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGFuIGV4dGVuc2lvblxuICAgICAgLy8gICAgdGhhdCB3YXMgbm90IHByZXNlbnQgaW4gdGhlIGNsaWVudCdzIGhhbmRzaGFrZSAodGhlIHNlcnZlciBoYXNcbiAgICAgIC8vICAgIGluZGljYXRlZCBhbiBleHRlbnNpb24gbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLiAgKFRoZSBwYXJzaW5nIG9mIHRoaXNcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCB0byBkZXRlcm1pbmUgd2hpY2ggZXh0ZW5zaW9ucyBhcmUgcmVxdWVzdGVkIGlzXG4gICAgICAvLyAgICBkaXNjdXNzZWQgaW4gU2VjdGlvbiA5LjEuKVxuICAgICAgY29uc3Qgc2VjRXh0ZW5zaW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnKVxuXG4gICAgICBpZiAoc2VjRXh0ZW5zaW9uICE9PSBudWxsICYmIHNlY0V4dGVuc2lvbiAhPT0gcGVybWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBkaWZmZXJlbnQgcGVybWVzc2FnZS1kZWZsYXRlIHRoYW4gdGhlIG9uZSBzZXQuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBoZWFkZXIgZmllbGRcbiAgICAgIC8vICAgIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhIHN1YnByb3RvY29sIHRoYXQgd2FzXG4gICAgICAvLyAgICBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhcyBpbmRpY2F0ZWQgYVxuICAgICAgLy8gICAgc3VicHJvdG9jb2wgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjUHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKVxuXG4gICAgICBpZiAoc2VjUHJvdG9jb2wgIT09IG51bGwgJiYgc2VjUHJvdG9jb2wgIT09IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdQcm90b2NvbCB3YXMgbm90IHNldCBpbiB0aGUgb3BlbmluZyBoYW5kc2hha2UuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignZGF0YScsIG9uU29ja2V0RGF0YSlcbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG5cbiAgICAgIGlmIChjaGFubmVscy5vcGVuLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLm9wZW4ucHVibGlzaCh7XG4gICAgICAgICAgYWRkcmVzczogcmVzcG9uc2Uuc29ja2V0LmFkZHJlc3MoKSxcbiAgICAgICAgICBwcm90b2NvbDogc2VjUHJvdG9jb2wsXG4gICAgICAgICAgZXh0ZW5zaW9uczogc2VjRXh0ZW5zaW9uXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG9uRXN0YWJsaXNoKHJlc3BvbnNlKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gY29udHJvbGxlclxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICovXG5mdW5jdGlvbiBvblNvY2tldERhdGEgKGNodW5rKSB7XG4gIGlmICghdGhpcy53c1trQnl0ZVBhcnNlcl0ud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS40XG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG5cbiAgLy8gSWYgdGhlIFRDUCBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWZ0ZXIgdGhlXG4gIC8vIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSB3YXMgY29tcGxldGVkLCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgLy8gaXMgc2FpZCB0byBoYXZlIGJlZW4gY2xvc2VkIF9jbGVhbmx5Xy5cbiAgY29uc3Qgd2FzQ2xlYW4gPSB3c1trU2VudENsb3NlXSAmJiB3c1trUmVjZWl2ZWRDbG9zZV1cblxuICBsZXQgY29kZSA9IDEwMDVcbiAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgY29uc3QgcmVzdWx0ID0gd3Nba0J5dGVQYXJzZXJdLmNsb3NpbmdJbmZvXG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGNvZGUgPSByZXN1bHQuY29kZSA/PyAxMDA1XG4gICAgcmVhc29uID0gcmVzdWx0LnJlYXNvblxuICB9IGVsc2UgaWYgKCF3c1trU2VudENsb3NlXSkge1xuICAgIC8vIElmIF9UaGUgV2ViU29ja2V0XG4gICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgIC8vIGlzIGxvc3QpLCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLyAxMDA2LlxuICAgIGNvZGUgPSAxMDA2XG4gIH1cblxuICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TRURcblxuICAvLyAyLiBJZiB0aGUgdXNlciBhZ2VudCB3YXMgcmVxdWlyZWQgdG8gZmFpbCB0aGUgV2ViU29ja2V0XG4gIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAvLyAgICBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgY2xvc2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsXG4gIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gIC8vICAgIGFuZCBmYWxzZSBvdGhlcndpc2UsIHRoZSBjb2RlIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0b1xuICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgLy8gICAgZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICAvLyAgICByZWFzb24uXG4gIGZpcmVFdmVudCgnY2xvc2UnLCB3cywgQ2xvc2VFdmVudCwge1xuICAgIHdhc0NsZWFuLCBjb2RlLCByZWFzb25cbiAgfSlcblxuICBpZiAoY2hhbm5lbHMuY2xvc2UuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5jbG9zZS5wdWJsaXNoKHtcbiAgICAgIHdlYnNvY2tldDogd3MsXG4gICAgICBjb2RlLFxuICAgICAgcmVhc29uXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBvblNvY2tldEVycm9yIChlcnJvcikge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG5cbiAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcblxuICBpZiAoY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zb2NrZXRFcnJvci5wdWJsaXNoKGVycm9yKVxuICB9XG5cbiAgdGhpcy5kZXN0cm95KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb25cbn1cbiJdLCJuYW1lcyI6WyJkaWFnbm9zdGljc0NoYW5uZWwiLCJyZXF1aXJlIiwidWlkIiwic3RhdGVzIiwia1JlYWR5U3RhdGUiLCJrU2VudENsb3NlIiwia0J5dGVQYXJzZXIiLCJrUmVjZWl2ZWRDbG9zZSIsImZpcmVFdmVudCIsImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIiwiQ2xvc2VFdmVudCIsIm1ha2VSZXF1ZXN0IiwiZmV0Y2hpbmciLCJIZWFkZXJzIiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsImtIZWFkZXJzTGlzdCIsImNoYW5uZWxzIiwib3BlbiIsImNoYW5uZWwiLCJjbG9zZSIsInNvY2tldEVycm9yIiwiY3J5cHRvIiwiZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiIsInVybCIsInByb3RvY29scyIsIndzIiwib25Fc3RhYmxpc2giLCJvcHRpb25zIiwicmVxdWVzdFVSTCIsInByb3RvY29sIiwicmVxdWVzdCIsInVybExpc3QiLCJzZXJ2aWNlV29ya2VycyIsInJlZmVycmVyIiwibW9kZSIsImNyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWRpcmVjdCIsImhlYWRlcnMiLCJoZWFkZXJzTGlzdCIsImtleVZhbHVlIiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsImFwcGVuZCIsInBlcm1lc3NhZ2VEZWZsYXRlIiwiY29udHJvbGxlciIsInVzZVBhcmFsbGVsUXVldWUiLCJkaXNwYXRjaGVyIiwicHJvY2Vzc1Jlc3BvbnNlIiwicmVzcG9uc2UiLCJ0eXBlIiwic3RhdHVzIiwibGVuZ3RoIiwiZ2V0IiwidG9Mb3dlckNhc2UiLCJzZWNXU0FjY2VwdCIsImRpZ2VzdCIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJzZWNFeHRlbnNpb24iLCJzZWNQcm90b2NvbCIsInNvY2tldCIsIm9uIiwib25Tb2NrZXREYXRhIiwib25Tb2NrZXRDbG9zZSIsIm9uU29ja2V0RXJyb3IiLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJhZGRyZXNzIiwiZXh0ZW5zaW9ucyIsImNodW5rIiwid3JpdGUiLCJwYXVzZSIsIndhc0NsZWFuIiwiY29kZSIsInJlYXNvbiIsInJlc3VsdCIsImNsb3NpbmdJbmZvIiwiQ0xPU0VEIiwid2Vic29ja2V0IiwiZXJyb3IiLCJDTE9TSU5HIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\nconst states = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\nconst opcodes = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xA\n};\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n;\nconst parserStates = {\n    INFO: 0,\n    PAYLOADLENGTH_16: 2,\n    PAYLOADLENGTH_64: 3,\n    READ_DATA: 4\n};\nconst emptyBuffer = Buffer.allocUnsafe(0);\nmodule.exports = {\n    uid,\n    staticPropertyDescriptors,\n    states,\n    opcodes,\n    maxUnsigned16Bit,\n    parserStates,\n    emptyBuffer\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsbURBQW1EO0FBQ25ELGtEQUFrRDtBQUNsRCxlQUFlO0FBQ2YsOERBQThEO0FBQzlELE1BQU1BLE1BQU07QUFFWiwrQkFBK0IsR0FDL0IsTUFBTUMsNEJBQTRCO0lBQ2hDQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsY0FBYztBQUNoQjtBQUVBLE1BQU1DLFNBQVM7SUFDYkMsWUFBWTtJQUNaQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsUUFBUTtBQUNWO0FBRUEsTUFBTUMsVUFBVTtJQUNkQyxjQUFjO0lBQ2RDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsTUFBTTtBQUNSO0FBRUEsTUFBTUMsbUJBQW1CLEtBQUssS0FBSyxFQUFFLFFBQVE7O0FBRTdDLE1BQU1DLGVBQWU7SUFDbkJDLE1BQU07SUFDTkMsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7SUFDbEJDLFdBQVc7QUFDYjtBQUVBLE1BQU1DLGNBQWNDLE9BQU9DLFdBQVcsQ0FBQztBQUV2Q0MsT0FBT0MsT0FBTyxHQUFHO0lBQ2YzQjtJQUNBQztJQUNBSTtJQUNBSztJQUNBTztJQUNBQztJQUNBSztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvY29uc3RhbnRzLmpzP2I3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIFRoaXMgaXMgYSBHbG9iYWxseSBVbmlxdWUgSWRlbnRpZmllciB1bmlxdWUgdXNlZFxuLy8gdG8gdmFsaWRhdGUgdGhhdCB0aGUgZW5kcG9pbnQgYWNjZXB0cyB3ZWJzb2NrZXRcbi8vIGNvbm5lY3Rpb25zLlxuLy8gU2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NDU1Lmh0bWwjc2VjdGlvbi0xLjNcbmNvbnN0IHVpZCA9ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnXG5cbi8qKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfSAqL1xuY29uc3Qgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59XG5cbmNvbnN0IHN0YXRlcyA9IHtcbiAgQ09OTkVDVElORzogMCxcbiAgT1BFTjogMSxcbiAgQ0xPU0lORzogMixcbiAgQ0xPU0VEOiAzXG59XG5cbmNvbnN0IG9wY29kZXMgPSB7XG4gIENPTlRJTlVBVElPTjogMHgwLFxuICBURVhUOiAweDEsXG4gIEJJTkFSWTogMHgyLFxuICBDTE9TRTogMHg4LFxuICBQSU5HOiAweDksXG4gIFBPTkc6IDB4QVxufVxuXG5jb25zdCBtYXhVbnNpZ25lZDE2Qml0ID0gMiAqKiAxNiAtIDEgLy8gNjU1MzVcblxuY29uc3QgcGFyc2VyU3RhdGVzID0ge1xuICBJTkZPOiAwLFxuICBQQVlMT0FETEVOR1RIXzE2OiAyLFxuICBQQVlMT0FETEVOR1RIXzY0OiAzLFxuICBSRUFEX0RBVEE6IDRcbn1cblxuY29uc3QgZW1wdHlCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVpZCxcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgc3RhdGVzLFxuICBvcGNvZGVzLFxuICBtYXhVbnNpZ25lZDE2Qml0LFxuICBwYXJzZXJTdGF0ZXMsXG4gIGVtcHR5QnVmZmVyXG59XG4iXSwibmFtZXMiOlsidWlkIiwic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInN0YXRlcyIsIkNPTk5FQ1RJTkciLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIm9wY29kZXMiLCJDT05USU5VQVRJT04iLCJURVhUIiwiQklOQVJZIiwiQ0xPU0UiLCJQSU5HIiwiUE9ORyIsIm1heFVuc2lnbmVkMTZCaXQiLCJwYXJzZXJTdGF0ZXMiLCJJTkZPIiwiUEFZTE9BRExFTkdUSF8xNiIsIlBBWUxPQURMRU5HVEhfNjQiLCJSRUFEX0RBVEEiLCJlbXB0eUJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/websocket/events.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { MessagePort } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */ class MessageEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get data() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.data;\n    }\n    get origin() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.origin;\n    }\n    get lastEventId() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.lastEventId;\n    }\n    get source() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.source;\n    }\n    get ports() {\n        webidl.brandCheck(this, MessageEvent);\n        if (!Object.isFrozen(this.#eventInit.ports)) {\n            Object.freeze(this.#eventInit.ports);\n        }\n        return this.#eventInit.ports;\n    }\n    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = \"\", lastEventId = \"\", source = null, ports = []) {\n        webidl.brandCheck(this, MessageEvent);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"MessageEvent.initMessageEvent\"\n        });\n        return new MessageEvent(type, {\n            bubbles,\n            cancelable,\n            data,\n            origin,\n            lastEventId,\n            source,\n            ports\n        });\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */ class CloseEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"CloseEvent constructor\"\n        });\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get wasClean() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.wasClean;\n    }\n    get code() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.code;\n    }\n    get reason() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.reason;\n    }\n}\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict){\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"ErrorEvent constructor\"\n        });\n        super(type, eventInitDict);\n        type = webidl.converters.DOMString(type);\n        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});\n        this.#eventInit = eventInitDict;\n    }\n    get message() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.message;\n    }\n    get filename() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.filename;\n    }\n    get lineno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.lineno;\n    }\n    get colno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.colno;\n    }\n    get error() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.error;\n    }\n}\nObject.defineProperties(MessageEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"MessageEvent\",\n        configurable: true\n    },\n    data: kEnumerableProperty,\n    origin: kEnumerableProperty,\n    lastEventId: kEnumerableProperty,\n    source: kEnumerableProperty,\n    ports: kEnumerableProperty,\n    initMessageEvent: kEnumerableProperty\n});\nObject.defineProperties(CloseEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CloseEvent\",\n        configurable: true\n    },\n    reason: kEnumerableProperty,\n    code: kEnumerableProperty,\n    wasClean: kEnumerableProperty\n});\nObject.defineProperties(ErrorEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"ErrorEvent\",\n        configurable: true\n    },\n    message: kEnumerableProperty,\n    filename: kEnumerableProperty,\n    lineno: kEnumerableProperty,\n    colno: kEnumerableProperty,\n    error: kEnumerableProperty\n});\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);\nwebidl.converters[\"sequence<MessagePort>\"] = webidl.sequenceConverter(webidl.converters.MessagePort);\nconst eventInit = [\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    }\n];\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"data\",\n        converter: webidl.converters.any,\n        defaultValue: null\n    },\n    {\n        key: \"origin\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lastEventId\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"source\",\n        // Node doesn't implement WindowProxy or ServiceWorker, so the only\n        // valid value for source is a MessagePort.\n        converter: webidl.nullableConverter(webidl.converters.MessagePort),\n        defaultValue: null\n    },\n    {\n        key: \"ports\",\n        converter: webidl.converters[\"sequence<MessagePort>\"],\n        get defaultValue () {\n            return [];\n        }\n    }\n]);\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"wasClean\",\n        converter: webidl.converters.boolean,\n        defaultValue: false\n    },\n    {\n        key: \"code\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: 0\n    },\n    {\n        key: \"reason\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    }\n]);\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"message\",\n        converter: webidl.converters.DOMString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"filename\",\n        converter: webidl.converters.USVString,\n        defaultValue: \"\"\n    },\n    {\n        key: \"lineno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"colno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: 0\n    },\n    {\n        key: \"error\",\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    MessageEvent,\n    CloseEvent,\n    ErrorEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUVFLFdBQVcsRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUVoQzs7Q0FFQyxHQUNELE1BQU1HLHFCQUFxQkM7SUFDekIsQ0FBQ0MsU0FBUztJQUVWQyxZQUFhQyxJQUFJLEVBQUVDLGdCQUFnQixDQUFDLENBQUMsQ0FBRTtRQUNyQ1QsT0FBT1UsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQTJCO1FBRTlFSixPQUFPUixPQUFPYSxVQUFVLENBQUNDLFNBQVMsQ0FBQ047UUFDbkNDLGdCQUFnQlQsT0FBT2EsVUFBVSxDQUFDRSxnQkFBZ0IsQ0FBQ047UUFFbkQsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQyxDQUFDSCxTQUFTLEdBQUdHO0lBQ3BCO0lBRUEsSUFBSU8sT0FBUTtRQUNWaEIsT0FBT2lCLFVBQVUsQ0FBQyxJQUFJLEVBQUViO1FBRXhCLE9BQU8sSUFBSSxDQUFDLENBQUNFLFNBQVMsQ0FBQ1UsSUFBSTtJQUM3QjtJQUVBLElBQUlFLFNBQVU7UUFDWmxCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNZLE1BQU07SUFDL0I7SUFFQSxJQUFJQyxjQUFlO1FBQ2pCbkIsT0FBT2lCLFVBQVUsQ0FBQyxJQUFJLEVBQUViO1FBRXhCLE9BQU8sSUFBSSxDQUFDLENBQUNFLFNBQVMsQ0FBQ2EsV0FBVztJQUNwQztJQUVBLElBQUlDLFNBQVU7UUFDWnBCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDRSxTQUFTLENBQUNjLE1BQU07SUFDL0I7SUFFQSxJQUFJQyxRQUFTO1FBQ1hyQixPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsSUFBSSxDQUFDa0IsT0FBT0MsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDakIsU0FBUyxDQUFDZSxLQUFLLEdBQUc7WUFDM0NDLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQ2xCLFNBQVMsQ0FBQ2UsS0FBSztRQUNyQztRQUVBLE9BQU8sSUFBSSxDQUFDLENBQUNmLFNBQVMsQ0FBQ2UsS0FBSztJQUM5QjtJQUVBSSxpQkFDRWpCLElBQUksRUFDSmtCLFVBQVUsS0FBSyxFQUNmQyxhQUFhLEtBQUssRUFDbEJYLE9BQU8sSUFBSSxFQUNYRSxTQUFTLEVBQUUsRUFDWEMsY0FBYyxFQUFFLEVBQ2hCQyxTQUFTLElBQUksRUFDYkMsUUFBUSxFQUFFLEVBQ1Y7UUFDQXJCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFYjtRQUV4QkosT0FBT1UsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQWdDO1FBRW5GLE9BQU8sSUFBSVIsYUFBYUksTUFBTTtZQUM1QmtCO1lBQVNDO1lBQVlYO1lBQU1FO1lBQVFDO1lBQWFDO1lBQVFDO1FBQzFEO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTU8sbUJBQW1CdkI7SUFDdkIsQ0FBQ0MsU0FBUztJQUVWQyxZQUFhQyxJQUFJLEVBQUVDLGdCQUFnQixDQUFDLENBQUMsQ0FBRTtRQUNyQ1QsT0FBT1UsbUJBQW1CLENBQUNDLFdBQVcsR0FBRztZQUFFQyxRQUFRO1FBQXlCO1FBRTVFSixPQUFPUixPQUFPYSxVQUFVLENBQUNDLFNBQVMsQ0FBQ047UUFDbkNDLGdCQUFnQlQsT0FBT2EsVUFBVSxDQUFDZ0IsY0FBYyxDQUFDcEI7UUFFakQsS0FBSyxDQUFDRCxNQUFNQztRQUVaLElBQUksQ0FBQyxDQUFDSCxTQUFTLEdBQUdHO0lBQ3BCO0lBRUEsSUFBSXFCLFdBQVk7UUFDZDlCLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFVztRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDdEIsU0FBUyxDQUFDd0IsUUFBUTtJQUNqQztJQUVBLElBQUlDLE9BQVE7UUFDVi9CLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFVztRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDdEIsU0FBUyxDQUFDeUIsSUFBSTtJQUM3QjtJQUVBLElBQUlDLFNBQVU7UUFDWmhDLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFVztRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDdEIsU0FBUyxDQUFDMEIsTUFBTTtJQUMvQjtBQUNGO0FBRUEsa0ZBQWtGO0FBQ2xGLE1BQU1DLG1CQUFtQjVCO0lBQ3ZCLENBQUNDLFNBQVM7SUFFVkMsWUFBYUMsSUFBSSxFQUFFQyxhQUFhLENBQUU7UUFDaENULE9BQU9VLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7WUFBRUMsUUFBUTtRQUF5QjtRQUU1RSxLQUFLLENBQUNKLE1BQU1DO1FBRVpELE9BQU9SLE9BQU9hLFVBQVUsQ0FBQ0MsU0FBUyxDQUFDTjtRQUNuQ0MsZ0JBQWdCVCxPQUFPYSxVQUFVLENBQUNxQixjQUFjLENBQUN6QixpQkFBaUIsQ0FBQztRQUVuRSxJQUFJLENBQUMsQ0FBQ0gsU0FBUyxHQUFHRztJQUNwQjtJQUVBLElBQUkwQixVQUFXO1FBQ2JuQyxPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWdCO1FBRXhCLE9BQU8sSUFBSSxDQUFDLENBQUMzQixTQUFTLENBQUM2QixPQUFPO0lBQ2hDO0lBRUEsSUFBSUMsV0FBWTtRQUNkcEMsT0FBT2lCLFVBQVUsQ0FBQyxJQUFJLEVBQUVnQjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDM0IsU0FBUyxDQUFDOEIsUUFBUTtJQUNqQztJQUVBLElBQUlDLFNBQVU7UUFDWnJDLE9BQU9pQixVQUFVLENBQUMsSUFBSSxFQUFFZ0I7UUFFeEIsT0FBTyxJQUFJLENBQUMsQ0FBQzNCLFNBQVMsQ0FBQytCLE1BQU07SUFDL0I7SUFFQSxJQUFJQyxRQUFTO1FBQ1h0QyxPQUFPaUIsVUFBVSxDQUFDLElBQUksRUFBRWdCO1FBRXhCLE9BQU8sSUFBSSxDQUFDLENBQUMzQixTQUFTLENBQUNnQyxLQUFLO0lBQzlCO0lBRUEsSUFBSUMsUUFBUztRQUNYdkMsT0FBT2lCLFVBQVUsQ0FBQyxJQUFJLEVBQUVnQjtRQUV4QixPQUFPLElBQUksQ0FBQyxDQUFDM0IsU0FBUyxDQUFDaUMsS0FBSztJQUM5QjtBQUNGO0FBRUFqQixPQUFPa0IsZ0JBQWdCLENBQUNwQyxhQUFhcUMsU0FBUyxFQUFFO0lBQzlDLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxFQUFFO1FBQ3BCQyxPQUFPO1FBQ1BDLGNBQWM7SUFDaEI7SUFDQTdCLE1BQU1kO0lBQ05nQixRQUFRaEI7SUFDUmlCLGFBQWFqQjtJQUNia0IsUUFBUWxCO0lBQ1JtQixPQUFPbkI7SUFDUHVCLGtCQUFrQnZCO0FBQ3BCO0FBRUFvQixPQUFPa0IsZ0JBQWdCLENBQUNaLFdBQVdhLFNBQVMsRUFBRTtJQUM1QyxDQUFDQyxPQUFPQyxXQUFXLENBQUMsRUFBRTtRQUNwQkMsT0FBTztRQUNQQyxjQUFjO0lBQ2hCO0lBQ0FiLFFBQVE5QjtJQUNSNkIsTUFBTTdCO0lBQ040QixVQUFVNUI7QUFDWjtBQUVBb0IsT0FBT2tCLGdCQUFnQixDQUFDUCxXQUFXUSxTQUFTLEVBQUU7SUFDNUMsQ0FBQ0MsT0FBT0MsV0FBVyxDQUFDLEVBQUU7UUFDcEJDLE9BQU87UUFDUEMsY0FBYztJQUNoQjtJQUNBVixTQUFTakM7SUFDVGtDLFVBQVVsQztJQUNWbUMsUUFBUW5DO0lBQ1JvQyxPQUFPcEM7SUFDUHFDLE9BQU9yQztBQUNUO0FBRUFGLE9BQU9hLFVBQVUsQ0FBQ1YsV0FBVyxHQUFHSCxPQUFPOEMsa0JBQWtCLENBQUMzQztBQUUxREgsT0FBT2EsVUFBVSxDQUFDLHdCQUF3QixHQUFHYixPQUFPK0MsaUJBQWlCLENBQ25FL0MsT0FBT2EsVUFBVSxDQUFDVixXQUFXO0FBRy9CLE1BQU1HLFlBQVk7SUFDaEI7UUFDRTBDLEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQ3FDLE9BQU87UUFDcENDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUNxQyxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDcUMsT0FBTztRQUNwQ0MsY0FBYztJQUNoQjtDQUNEO0FBRURuRCxPQUFPYSxVQUFVLENBQUNFLGdCQUFnQixHQUFHZixPQUFPb0QsbUJBQW1CLENBQUM7T0FDM0Q5QztJQUNIO1FBQ0UwQyxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUN3QyxHQUFHO1FBQ2hDRixjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDeUMsU0FBUztRQUN0Q0gsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQ0MsU0FBUztRQUN0Q3FDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0wsbUVBQW1FO1FBQ25FLDJDQUEyQztRQUMzQ0MsV0FBV2pELE9BQU91RCxpQkFBaUIsQ0FBQ3ZELE9BQU9hLFVBQVUsQ0FBQ1YsV0FBVztRQUNqRWdELGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUMsd0JBQXdCO1FBQ3JELElBQUlzQyxnQkFBZ0I7WUFDbEIsT0FBTyxFQUFFO1FBQ1g7SUFDRjtDQUNEO0FBRURuRCxPQUFPYSxVQUFVLENBQUNnQixjQUFjLEdBQUc3QixPQUFPb0QsbUJBQW1CLENBQUM7T0FDekQ5QztJQUNIO1FBQ0UwQyxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUNxQyxPQUFPO1FBQ3BDQyxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDLGlCQUFpQjtRQUM5Q3NDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUN5QyxTQUFTO1FBQ3RDSCxjQUFjO0lBQ2hCO0NBQ0Q7QUFFRG5ELE9BQU9hLFVBQVUsQ0FBQ3FCLGNBQWMsR0FBR2xDLE9BQU9vRCxtQkFBbUIsQ0FBQztPQUN6RDlDO0lBQ0g7UUFDRTBDLEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQ0MsU0FBUztRQUN0Q3FDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUN5QyxTQUFTO1FBQ3RDSCxjQUFjO0lBQ2hCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXakQsT0FBT2EsVUFBVSxDQUFDLGdCQUFnQjtRQUM3Q3NDLGNBQWM7SUFDaEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdqRCxPQUFPYSxVQUFVLENBQUMsZ0JBQWdCO1FBQzdDc0MsY0FBYztJQUNoQjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2pELE9BQU9hLFVBQVUsQ0FBQ3dDLEdBQUc7SUFDbEM7Q0FDRDtBQUVERyxPQUFPQyxPQUFPLEdBQUc7SUFDZnJEO0lBQ0F3QjtJQUNBSztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZXZlbnRzLmpzPzE2MjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBNZXNzYWdlUG9ydCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCNtZXNzYWdlZXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdNZXNzYWdlRXZlbnQgY29uc3RydWN0b3InIH0pXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQoZXZlbnRJbml0RGljdClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5kYXRhXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm9yaWdpblxuICB9XG5cbiAgZ2V0IGxhc3RFdmVudElkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lmxhc3RFdmVudElkXG4gIH1cblxuICBnZXQgc291cmNlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnNvdXJjZVxuICB9XG5cbiAgZ2V0IHBvcnRzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih0aGlzLiNldmVudEluaXQucG9ydHMpKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMuI2V2ZW50SW5pdC5wb3J0cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnBvcnRzXG4gIH1cblxuICBpbml0TWVzc2FnZUV2ZW50IChcbiAgICB0eXBlLFxuICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICBjYW5jZWxhYmxlID0gZmFsc2UsXG4gICAgZGF0YSA9IG51bGwsXG4gICAgb3JpZ2luID0gJycsXG4gICAgbGFzdEV2ZW50SWQgPSAnJyxcbiAgICBzb3VyY2UgPSBudWxsLFxuICAgIHBvcnRzID0gW11cbiAgKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCB7IGhlYWRlcjogJ01lc3NhZ2VFdmVudC5pbml0TWVzc2FnZUV2ZW50JyB9KVxuXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlRXZlbnQodHlwZSwge1xuICAgICAgYnViYmxlcywgY2FuY2VsYWJsZSwgZGF0YSwgb3JpZ2luLCBsYXN0RXZlbnRJZCwgc291cmNlLCBwb3J0c1xuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1jbG9zZWV2ZW50LWludGVyZmFjZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdDbG9zZUV2ZW50IGNvbnN0cnVjdG9yJyB9KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdChldmVudEluaXREaWN0KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCB3YXNDbGVhbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQud2FzQ2xlYW5cbiAgfVxuXG4gIGdldCBjb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2RlXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5yZWFzb25cbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjdGhlLWVycm9yZXZlbnQtaW50ZXJmYWNlXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnRXJyb3JFdmVudCBjb25zdHJ1Y3RvcicgfSlcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgbWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubWVzc2FnZVxuICB9XG5cbiAgZ2V0IGZpbGVuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5maWxlbmFtZVxuICB9XG5cbiAgZ2V0IGxpbmVubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGluZW5vXG4gIH1cblxuICBnZXQgY29sbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvbG5vXG4gIH1cblxuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmVycm9yXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnTWVzc2FnZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgZGF0YToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3JpZ2luOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0RXZlbnRJZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc291cmNlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwb3J0czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaW5pdE1lc3NhZ2VFdmVudDoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xvc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Nsb3NlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICByZWFzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdhc0NsZWFuOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFcnJvckV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRXJyb3JFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZpbGVuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsaW5lbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvbG5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKE1lc3NhZ2VQb3J0KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0XG4pXG5cbmNvbnN0IGV2ZW50SW5pdCA9IFtcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdvcmlnaW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xhc3RFdmVudElkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzb3VyY2UnLFxuICAgIC8vIE5vZGUgZG9lc24ndCBpbXBsZW1lbnQgV2luZG93UHJveHkgb3IgU2VydmljZVdvcmtlciwgc28gdGhlIG9ubHlcbiAgICAvLyB2YWxpZCB2YWx1ZSBmb3Igc291cmNlIGlzIGEgTWVzc2FnZVBvcnQuXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQpLFxuICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAncG9ydHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddLFxuICAgIGdldCBkZWZhdWx0VmFsdWUgKCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5DbG9zZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnd2FzQ2xlYW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAncmVhc29uJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdtZXNzYWdlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdmaWxlbmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGluZW5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb2xubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICB7XG4gICAga2V5OiAnZXJyb3InLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNZXNzYWdlRXZlbnQsXG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnRcbn1cbiJdLCJuYW1lcyI6WyJ3ZWJpZGwiLCJyZXF1aXJlIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIk1lc3NhZ2VQb3J0IiwiTWVzc2FnZUV2ZW50IiwiRXZlbnQiLCJldmVudEluaXQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJldmVudEluaXREaWN0IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsImNvbnZlcnRlcnMiLCJET01TdHJpbmciLCJNZXNzYWdlRXZlbnRJbml0IiwiZGF0YSIsImJyYW5kQ2hlY2siLCJvcmlnaW4iLCJsYXN0RXZlbnRJZCIsInNvdXJjZSIsInBvcnRzIiwiT2JqZWN0IiwiaXNGcm96ZW4iLCJmcmVlemUiLCJpbml0TWVzc2FnZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJDbG9zZUV2ZW50IiwiQ2xvc2VFdmVudEluaXQiLCJ3YXNDbGVhbiIsImNvZGUiLCJyZWFzb24iLCJFcnJvckV2ZW50IiwiRXJyb3JFdmVudEluaXQiLCJtZXNzYWdlIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJjb2xubyIsImVycm9yIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJzZXF1ZW5jZUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImJvb2xlYW4iLCJkZWZhdWx0VmFsdWUiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwiYW55IiwiVVNWU3RyaW5nIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/frame.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/websocket/frame.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/websocket/constants.js\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n} catch  {}\nclass WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n        this.maskKey = crypto.randomBytes(4);\n    }\n    createFrame(opcode) {\n        const bodyLength = this.frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength // 0-125\n        ;\n        let offset = 6;\n        if (bodyLength > maxUnsigned16Bit) {\n            offset += 8 // payload length is next 8 bytes\n            ;\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2 // payload length is next 2 bytes\n            ;\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80 // FIN\n        ;\n        buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n        ;\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = this.maskKey[0];\n        buffer[offset - 3] = this.maskKey[1];\n        buffer[offset - 2] = this.maskKey[2];\n        buffer[offset - 1] = this.maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) {\n            buffer.writeUInt16BE(bodyLength, 2);\n        } else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80 // MASK\n        ;\n        // mask body\n        for(let i = 0; i < bodyLength; i++){\n            buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];\n        }\n        return buffer;\n    }\n}\nmodule.exports = {\n    WebsocketFrameSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvZnJhbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGdCQUFnQixFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXJDLDZCQUE2QixHQUM3QixJQUFJQztBQUNKLElBQUk7SUFDRkEsU0FBU0QsbUJBQU9BLENBQUM7QUFDbkIsRUFBRSxPQUFNLENBRVI7QUFFQSxNQUFNRTtJQUNKOztHQUVDLEdBQ0RDLFlBQWFDLElBQUksQ0FBRTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0Q7UUFDakIsSUFBSSxDQUFDRSxPQUFPLEdBQUdMLE9BQU9NLFdBQVcsQ0FBQztJQUNwQztJQUVBQyxZQUFhQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsYUFBYSxJQUFJLENBQUNMLFNBQVMsRUFBRU0sY0FBYztRQUVqRCxtQkFBbUIsR0FDbkIsSUFBSUMsZ0JBQWdCRixXQUFXLFFBQVE7O1FBQ3ZDLElBQUlHLFNBQVM7UUFFYixJQUFJSCxhQUFhWCxrQkFBa0I7WUFDakNjLFVBQVUsRUFBRSxpQ0FBaUM7O1lBQzdDRCxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJRixhQUFhLEtBQUs7WUFDM0JHLFVBQVUsRUFBRSxpQ0FBaUM7O1lBQzdDRCxnQkFBZ0I7UUFDbEI7UUFFQSxNQUFNRSxTQUFTQyxPQUFPQyxXQUFXLENBQUNOLGFBQWFHO1FBRS9DLHNEQUFzRDtRQUN0REMsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN4QkEsTUFBTSxDQUFDLEVBQUUsSUFBSSxLQUFLLE1BQU07O1FBQ3hCQSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUNBLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBRyxJQUFLTCxPQUFPLFNBQVM7O1FBRWpELDZEQUE2RCxHQUM3REssTUFBTSxDQUFDRCxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQyxFQUFFO1FBQ3BDUSxNQUFNLENBQUNELFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDLEVBQUU7UUFDcENRLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUMsRUFBRTtRQUNwQ1EsTUFBTSxDQUFDRCxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQyxFQUFFO1FBRXBDUSxNQUFNLENBQUMsRUFBRSxHQUFHRjtRQUVaLElBQUlBLGtCQUFrQixLQUFLO1lBQ3pCRSxPQUFPRyxhQUFhLENBQUNQLFlBQVk7UUFDbkMsT0FBTyxJQUFJRSxrQkFBa0IsS0FBSztZQUNoQyxnQ0FBZ0M7WUFDaENFLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDeEJBLE9BQU9JLFdBQVcsQ0FBQ1IsWUFBWSxHQUFHO1FBQ3BDO1FBRUFJLE1BQU0sQ0FBQyxFQUFFLElBQUksS0FBSyxPQUFPOztRQUV6QixZQUFZO1FBQ1osSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlULFlBQVlTLElBQUs7WUFDbkNMLE1BQU0sQ0FBQ0QsU0FBU00sRUFBRSxHQUFHLElBQUksQ0FBQ2QsU0FBUyxDQUFDYyxFQUFFLEdBQUcsSUFBSSxDQUFDYixPQUFPLENBQUNhLElBQUksRUFBRTtRQUM5RDtRQUVBLE9BQU9MO0lBQ1Q7QUFDRjtBQUVBTSxPQUFPQyxPQUFPLEdBQUc7SUFDZm5CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYnNvY2tldC9mcmFtZS5qcz8zMzk4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG1heFVuc2lnbmVkMTZCaXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2NyeXB0bycpfSAqL1xubGV0IGNyeXB0b1xudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbn0gY2F0Y2gge1xuXG59XG5cbmNsYXNzIFdlYnNvY2tldEZyYW1lU2VuZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnx1bmRlZmluZWR9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5mcmFtZURhdGEgPSBkYXRhXG4gICAgdGhpcy5tYXNrS2V5ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpXG4gIH1cblxuICBjcmVhdGVGcmFtZSAob3Bjb2RlKSB7XG4gICAgY29uc3QgYm9keUxlbmd0aCA9IHRoaXMuZnJhbWVEYXRhPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gYm9keUxlbmd0aCAvLyAwLTEyNVxuICAgIGxldCBvZmZzZXQgPSA2XG5cbiAgICBpZiAoYm9keUxlbmd0aCA+IG1heFVuc2lnbmVkMTZCaXQpIHtcbiAgICAgIG9mZnNldCArPSA4IC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgOCBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyN1xuICAgIH0gZWxzZSBpZiAoYm9keUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDIgLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCAyIGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJvZHlMZW5ndGggKyBvZmZzZXQpXG5cbiAgICAvLyBDbGVhciBmaXJzdCAyIGJ5dGVzLCBldmVyeXRoaW5nIGVsc2UgaXMgb3ZlcndyaXR0ZW5cbiAgICBidWZmZXJbMF0gPSBidWZmZXJbMV0gPSAwXG4gICAgYnVmZmVyWzBdIHw9IDB4ODAgLy8gRklOXG4gICAgYnVmZmVyWzBdID0gKGJ1ZmZlclswXSAmIDB4RjApICsgb3Bjb2RlIC8vIG9wY29kZVxuXG4gICAgLyohIHdzLiBNSVQgTGljZW5zZS4gRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+ICovXG4gICAgYnVmZmVyW29mZnNldCAtIDRdID0gdGhpcy5tYXNrS2V5WzBdXG4gICAgYnVmZmVyW29mZnNldCAtIDNdID0gdGhpcy5tYXNrS2V5WzFdXG4gICAgYnVmZmVyW29mZnNldCAtIDJdID0gdGhpcy5tYXNrS2V5WzJdXG4gICAgYnVmZmVyW29mZnNldCAtIDFdID0gdGhpcy5tYXNrS2V5WzNdXG5cbiAgICBidWZmZXJbMV0gPSBwYXlsb2FkTGVuZ3RoXG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShib2R5TGVuZ3RoLCAyKVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAvLyBDbGVhciBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aFxuICAgICAgYnVmZmVyWzJdID0gYnVmZmVyWzNdID0gMFxuICAgICAgYnVmZmVyLndyaXRlVUludEJFKGJvZHlMZW5ndGgsIDQsIDYpXG4gICAgfVxuXG4gICAgYnVmZmVyWzFdIHw9IDB4ODAgLy8gTUFTS1xuXG4gICAgLy8gbWFzayBib2R5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHRoaXMuZnJhbWVEYXRhW2ldIF4gdGhpcy5tYXNrS2V5W2kgJSA0XVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2Vic29ja2V0RnJhbWVTZW5kXG59XG4iXSwibmFtZXMiOlsibWF4VW5zaWduZWQxNkJpdCIsInJlcXVpcmUiLCJjcnlwdG8iLCJXZWJzb2NrZXRGcmFtZVNlbmQiLCJjb25zdHJ1Y3RvciIsImRhdGEiLCJmcmFtZURhdGEiLCJtYXNrS2V5IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVGcmFtZSIsIm9wY29kZSIsImJvZHlMZW5ndGgiLCJieXRlTGVuZ3RoIiwicGF5bG9hZExlbmd0aCIsIm9mZnNldCIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiaSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/frame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/receiver.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/websocket/receiver.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst { parserStates, opcodes, states, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/websocket/constants.js\");\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/websocket/symbols.js\");\nconst { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/websocket/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/websocket/frame.js\");\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nconst channels = {};\nchannels.ping = diagnosticsChannel.channel(\"undici:websocket:ping\");\nchannels.pong = diagnosticsChannel.channel(\"undici:websocket:pong\");\nclass ByteParser extends Writable {\n    #buffers;\n    #byteOffset;\n    #state;\n    #info;\n    #fragments;\n    constructor(ws){\n        super();\n        this.#buffers = [];\n        this.#byteOffset = 0;\n        this.#state = parserStates.INFO;\n        this.#info = {};\n        this.#fragments = [];\n        this.ws = ws;\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(true){\n            if (this.#state === parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.fin = (buffer[0] & 0x80) !== 0;\n                this.#info.opcode = buffer[0] & 0x0F;\n                // If we receive a fragmented message, we use the type of the first\n                // frame to parse the full message as binary/text, when it's terminated\n                this.#info.originalOpcode ??= this.#info.opcode;\n                this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;\n                if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {\n                    // Only text and binary frames can be fragmented\n                    failWebsocketConnection(this.ws, \"Invalid frame type was fragmented.\");\n                    return;\n                }\n                const payloadLength = buffer[1] & 0x7F;\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = parserStates.READ_DATA;\n                } else if (payloadLength === 126) {\n                    this.#state = parserStates.PAYLOADLENGTH_16;\n                } else if (payloadLength === 127) {\n                    this.#state = parserStates.PAYLOADLENGTH_64;\n                }\n                if (this.#info.fragmented && payloadLength > 125) {\n                    // A fragmented frame can't be fragmented itself\n                    failWebsocketConnection(this.ws, \"Fragmented frame exceeded 125 bytes.\");\n                    return;\n                } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {\n                    // Control frames can have a payload length of 125 bytes MAX\n                    failWebsocketConnection(this.ws, \"Payload length for control frame exceeded 125 bytes.\");\n                    return;\n                } else if (this.#info.opcode === opcodes.CLOSE) {\n                    if (payloadLength === 1) {\n                        failWebsocketConnection(this.ws, \"Received close frame with a 1-byte body.\");\n                        return;\n                    }\n                    const body = this.consume(payloadLength);\n                    this.#info.closeInfo = this.parseCloseBody(false, body);\n                    if (!this.ws[kSentClose]) {\n                        // If an endpoint receives a Close frame and did not previously send a\n                        // Close frame, the endpoint MUST send a Close frame in response.  (When\n                        // sending a Close frame in response, the endpoint typically echos the\n                        // status code it received.)\n                        const body = Buffer.allocUnsafe(2);\n                        body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                        const closeFrame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{\n                            if (!err) {\n                                this.ws[kSentClose] = true;\n                            }\n                        });\n                    }\n                    // Upon either sending or receiving a Close control frame, it is said\n                    // that _The WebSocket Closing Handshake is Started_ and that the\n                    // WebSocket connection is in the CLOSING state.\n                    this.ws[kReadyState] = states.CLOSING;\n                    this.ws[kReceivedClose] = true;\n                    this.end();\n                    return;\n                } else if (this.#info.opcode === opcodes.PING) {\n                    // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n                    // response, unless it already received a Close frame.\n                    // A Pong frame sent in response to a Ping frame must have identical\n                    // \"Application data\"\n                    const body = this.consume(payloadLength);\n                    if (!this.ws[kReceivedClose]) {\n                        const frame = new WebsocketFrameSend(body);\n                        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n                        if (channels.ping.hasSubscribers) {\n                            channels.ping.publish({\n                                payload: body\n                            });\n                        }\n                    }\n                    this.#state = parserStates.INFO;\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                } else if (this.#info.opcode === opcodes.PONG) {\n                    // A Pong frame MAY be sent unsolicited.  This serves as a\n                    // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n                    // not expected.\n                    const body = this.consume(payloadLength);\n                    if (channels.pong.hasSubscribers) {\n                        channels.pong.publish({\n                            payload: body\n                        });\n                    }\n                    if (this.#byteOffset > 0) {\n                        continue;\n                    } else {\n                        callback();\n                        return;\n                    }\n                }\n            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) {\n                    return callback();\n                }\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maxinimum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    failWebsocketConnection(this.ws, \"Received payload length > 2^31 bytes.\");\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) {\n                    // If there is still more data in this chunk that needs to be read\n                    return callback();\n                } else if (this.#byteOffset >= this.#info.payloadLength) {\n                    // If the server sent multiple frames in a single chunk\n                    const body = this.consume(this.#info.payloadLength);\n                    this.#fragments.push(body);\n                    // If the frame is unfragmented, or a fragmented frame was terminated,\n                    // a message was received\n                    if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {\n                        const fullMessage = Buffer.concat(this.#fragments);\n                        websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);\n                        this.#info = {};\n                        this.#fragments.length = 0;\n                    }\n                    this.#state = parserStates.INFO;\n                }\n            }\n            if (this.#byteOffset > 0) {\n                continue;\n            } else {\n                callback();\n                break;\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer|null}\n   */ consume(n) {\n        if (n > this.#byteOffset) {\n            return null;\n        } else if (n === 0) {\n            return emptyBuffer;\n        }\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(onlyCode, data) {\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) {\n            // _The WebSocket Connection Close Code_ is\n            // defined as the status code (Section 7.4) contained in the first Close\n            // control frame received by the application\n            code = data.readUInt16BE(0);\n        }\n        if (onlyCode) {\n            if (!isValidStatusCode(code)) {\n                return null;\n            }\n            return {\n                code\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n            reason = reason.subarray(3);\n        }\n        if (code !== undefined && !isValidStatusCode(code)) {\n            return null;\n        }\n        try {\n            // TODO: optimize this\n            reason = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(reason);\n        } catch  {\n            return null;\n        }\n        return {\n            code,\n            reason\n        };\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\nmodule.exports = {\n    ByteParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRUUsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQy9ELE1BQU0sRUFBRU0sV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsY0FBYyxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBQ3ZFLE1BQU0sRUFBRVUsaUJBQWlCLEVBQUVDLHVCQUF1QixFQUFFQyx3QkFBd0IsRUFBRSxHQUFHWixtQkFBT0EsQ0FBQztBQUN6RixNQUFNLEVBQUVhLGtCQUFrQixFQUFFLEdBQUdiLG1CQUFPQSxDQUFDO0FBRXZDLGlFQUFpRTtBQUNqRSw2REFBNkQ7QUFDN0Qsc0RBQXNEO0FBQ3RELGtEQUFrRDtBQUVsRCxNQUFNYyxXQUFXLENBQUM7QUFDbEJBLFNBQVNDLElBQUksR0FBR2QsbUJBQW1CZSxPQUFPLENBQUM7QUFDM0NGLFNBQVNHLElBQUksR0FBR2hCLG1CQUFtQmUsT0FBTyxDQUFDO0FBRTNDLE1BQU1FLG1CQUFtQm5CO0lBQ3ZCLENBQUNvQixPQUFPLENBQUs7SUFDYixDQUFDQyxVQUFVLENBQUk7SUFFZixDQUFDQyxLQUFLLENBQW9CO0lBRTFCLENBQUNDLElBQUksQ0FBSztJQUNWLENBQUNDLFNBQVMsQ0FBSztJQUVmQyxZQUFhQyxFQUFFLENBQUU7UUFDZixLQUFLO2FBVFAsQ0FBQ04sT0FBTyxHQUFHLEVBQUU7YUFDYixDQUFDQyxVQUFVLEdBQUc7YUFFZCxDQUFDQyxLQUFLLEdBQUduQixhQUFhd0IsSUFBSTthQUUxQixDQUFDSixJQUFJLEdBQUcsQ0FBQzthQUNULENBQUNDLFNBQVMsR0FBRyxFQUFF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QU0sSUFBSSxHQUFHO1lBQ3BCLDJDQUEyQztZQUMzQyx3RUFBd0U7WUFDeEUsNENBQTRDO1lBQzVDd0IsT0FBT3lCLEtBQUtiLFlBQVksQ0FBQztRQUMzQjtRQUVBLElBQUlZLFVBQVU7WUFDWixJQUFJLENBQUN0RSxrQkFBa0I4QyxPQUFPO2dCQUM1QixPQUFPO1lBQ1Q7WUFFQSxPQUFPO2dCQUFFQTtZQUFLO1FBQ2hCO1FBRUEsOERBQThEO1FBQzlELG1CQUFtQixHQUNuQixJQUFJMEIsU0FBU0QsS0FBS0YsUUFBUSxDQUFDO1FBRTNCLGFBQWE7UUFDYixJQUFJRyxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQVFBLE1BQU0sQ0FBQyxFQUFFLEtBQUssUUFBUUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxNQUFNO1lBQ2xFQSxTQUFTQSxPQUFPSCxRQUFRLENBQUM7UUFDM0I7UUFFQSxJQUFJdkIsU0FBUzJCLGFBQWEsQ0FBQ3pFLGtCQUFrQjhDLE9BQU87WUFDbEQsT0FBTztRQUNUO1FBRUEsSUFBSTtZQUNGLHNCQUFzQjtZQUN0QjBCLFNBQVMsSUFBSUUsWUFBWSxTQUFTO2dCQUFFQyxPQUFPO1lBQUssR0FBR0MsTUFBTSxDQUFDSjtRQUM1RCxFQUFFLE9BQU07WUFDTixPQUFPO1FBQ1Q7UUFFQSxPQUFPO1lBQUUxQjtZQUFNMEI7UUFBTztJQUN4QjtJQUVBLElBQUlLLGNBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsQ0FBQ2pFLElBQUksQ0FBQzZCLFNBQVM7SUFDN0I7QUFDRjtBQUVBcUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z2RTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvcmVjZWl2ZXIuanM/YjkxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ2RpYWdub3N0aWNzX2NoYW5uZWwnKVxuY29uc3QgeyBwYXJzZXJTdGF0ZXMsIG9wY29kZXMsIHN0YXRlcywgZW1wdHlCdWZmZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga1JlYWR5U3RhdGUsIGtTZW50Q2xvc2UsIGtSZXNwb25zZSwga1JlY2VpdmVkQ2xvc2UgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiwgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuXG4vLyBUaGlzIGNvZGUgd2FzIGluZmx1ZW5jZWQgYnkgd3MgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFybm91dCBLYXplbWllciBhbmQgY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgTHVpZ2kgUGluY2EgYW5kIGNvbnRyaWJ1dG9yc1xuXG5jb25zdCBjaGFubmVscyA9IHt9XG5jaGFubmVscy5waW5nID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycpXG5jaGFubmVscy5wb25nID0gZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycpXG5cbmNsYXNzIEJ5dGVQYXJzZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gICNidWZmZXJzID0gW11cbiAgI2J5dGVPZmZzZXQgPSAwXG5cbiAgI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAjaW5mbyA9IHt9XG4gICNmcmFnbWVudHMgPSBbXVxuXG4gIGNvbnN0cnVjdG9yICh3cykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMud3MgPSB3c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAqL1xuICBfd3JpdGUgKGNodW5rLCBfLCBjYWxsYmFjaykge1xuICAgIHRoaXMuI2J1ZmZlcnMucHVzaChjaHVuaylcbiAgICB0aGlzLiNieXRlT2Zmc2V0ICs9IGNodW5rLmxlbmd0aFxuXG4gICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUnVucyB3aGVuZXZlciBhIG5ldyBjaHVuayBpcyByZWNlaXZlZC5cbiAgICogQ2FsbGJhY2sgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyBidWZmZXJpbmcsXG4gICAqIG9yIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGJ1ZmZlcmVkIHRvIHBhcnNlLlxuICAgKi9cbiAgcnVuIChjYWxsYmFjaykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5JTkZPKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBlbm91Z2ggYnl0ZXMgdG8gcGFyc2UgdGhlIHBheWxvYWQgbGVuZ3RoLCBldGMuXG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcblxuICAgICAgICB0aGlzLiNpbmZvLmZpbiA9IChidWZmZXJbMF0gJiAweDgwKSAhPT0gMFxuICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9IGJ1ZmZlclswXSAmIDB4MEZcblxuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgZnJhZ21lbnRlZCBtZXNzYWdlLCB3ZSB1c2UgdGhlIHR5cGUgb2YgdGhlIGZpcnN0XG4gICAgICAgIC8vIGZyYW1lIHRvIHBhcnNlIHRoZSBmdWxsIG1lc3NhZ2UgYXMgYmluYXJ5L3RleHQsIHdoZW4gaXQncyB0ZXJtaW5hdGVkXG4gICAgICAgIHRoaXMuI2luZm8ub3JpZ2luYWxPcGNvZGUgPz89IHRoaXMuI2luZm8ub3Bjb2RlXG5cbiAgICAgICAgdGhpcy4jaW5mby5mcmFnbWVudGVkID0gIXRoaXMuI2luZm8uZmluICYmIHRoaXMuI2luZm8ub3Bjb2RlICE9PSBvcGNvZGVzLkNPTlRJTlVBVElPTlxuXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgdGhpcy4jaW5mby5vcGNvZGUgIT09IG9wY29kZXMuQklOQVJZICYmIHRoaXMuI2luZm8ub3Bjb2RlICE9PSBvcGNvZGVzLlRFWFQpIHtcbiAgICAgICAgICAvLyBPbmx5IHRleHQgYW5kIGJpbmFyeSBmcmFtZXMgY2FuIGJlIGZyYWdtZW50ZWRcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnSW52YWxpZCBmcmFtZSB0eXBlIHdhcyBmcmFnbWVudGVkLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gYnVmZmVyWzFdICYgMHg3RlxuXG4gICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoIDw9IDEyNSkge1xuICAgICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IHBheWxvYWRMZW5ndGhcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiBwYXlsb2FkTGVuZ3RoID4gMTI1KSB7XG4gICAgICAgICAgLy8gQSBmcmFnbWVudGVkIGZyYW1lIGNhbid0IGJlIGZyYWdtZW50ZWQgaXRzZWxmXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ZyYWdtZW50ZWQgZnJhbWUgZXhjZWVkZWQgMTI1IGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgKHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLlBJTkcgfHxcbiAgICAgICAgICAgIHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLlBPTkcgfHxcbiAgICAgICAgICAgIHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLkNMT1NFKSAmJlxuICAgICAgICAgIHBheWxvYWRMZW5ndGggPiAxMjVcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gQ29udHJvbCBmcmFtZXMgY2FuIGhhdmUgYSBwYXlsb2FkIGxlbmd0aCBvZiAxMjUgYnl0ZXMgTUFYXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1BheWxvYWQgbGVuZ3RoIGZvciBjb250cm9sIGZyYW1lIGV4Y2VlZGVkIDEyNSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLkNMT1NFKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBjbG9zZSBmcmFtZSB3aXRoIGEgMS1ieXRlIGJvZHkuJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUocGF5bG9hZExlbmd0aClcblxuICAgICAgICAgIHRoaXMuI2luZm8uY2xvc2VJbmZvID0gdGhpcy5wYXJzZUNsb3NlQm9keShmYWxzZSwgYm9keSlcblxuICAgICAgICAgIGlmICghdGhpcy53c1trU2VudENsb3NlXSkge1xuICAgICAgICAgICAgLy8gSWYgYW4gZW5kcG9pbnQgcmVjZWl2ZXMgYSBDbG9zZSBmcmFtZSBhbmQgZGlkIG5vdCBwcmV2aW91c2x5IHNlbmQgYVxuICAgICAgICAgICAgLy8gQ2xvc2UgZnJhbWUsIHRoZSBlbmRwb2ludCBNVVNUIHNlbmQgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZS4gIChXaGVuXG4gICAgICAgICAgICAvLyBzZW5kaW5nIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UsIHRoZSBlbmRwb2ludCB0eXBpY2FsbHkgZWNob3MgdGhlXG4gICAgICAgICAgICAvLyBzdGF0dXMgY29kZSBpdCByZWNlaXZlZC4pXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICAgICAgICBib2R5LndyaXRlVUludDE2QkUodGhpcy4jaW5mby5jbG9zZUluZm8uY29kZSwgMClcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlRnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQud3JpdGUoXG4gICAgICAgICAgICAgIGNsb3NlRnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSksXG4gICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgdGhpcy53c1trU2VudENsb3NlXSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgICAgICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAgICAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICAgICAgICAgIHRoaXMud3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgICAgICAgICB0aGlzLndzW2tSZWNlaXZlZENsb3NlXSA9IHRydWVcblxuICAgICAgICAgIHRoaXMuZW5kKClcblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLlBJTkcpIHtcbiAgICAgICAgICAvLyBVcG9uIHJlY2VpcHQgb2YgYSBQaW5nIGZyYW1lLCBhbiBlbmRwb2ludCBNVVNUIHNlbmQgYSBQb25nIGZyYW1lIGluXG4gICAgICAgICAgLy8gcmVzcG9uc2UsIHVubGVzcyBpdCBhbHJlYWR5IHJlY2VpdmVkIGEgQ2xvc2UgZnJhbWUuXG4gICAgICAgICAgLy8gQSBQb25nIGZyYW1lIHNlbnQgaW4gcmVzcG9uc2UgdG8gYSBQaW5nIGZyYW1lIG11c3QgaGF2ZSBpZGVudGljYWxcbiAgICAgICAgICAvLyBcIkFwcGxpY2F0aW9uIGRhdGFcIlxuXG4gICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZShwYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgICAgaWYgKCF0aGlzLndzW2tSZWNlaXZlZENsb3NlXSkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5QT05HKSlcblxuICAgICAgICAgICAgaWYgKGNoYW5uZWxzLnBpbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgY2hhbm5lbHMucGluZy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBib2R5XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuXG4gICAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4jaW5mby5vcGNvZGUgPT09IG9wY29kZXMuUE9ORykge1xuICAgICAgICAgIC8vIEEgUG9uZyBmcmFtZSBNQVkgYmUgc2VudCB1bnNvbGljaXRlZC4gIFRoaXMgc2VydmVzIGFzIGFcbiAgICAgICAgICAvLyB1bmlkaXJlY3Rpb25hbCBoZWFydGJlYXQuICBBIHJlc3BvbnNlIHRvIGFuIHVuc29saWNpdGVkIFBvbmcgZnJhbWUgaXNcbiAgICAgICAgICAvLyBub3QgZXhwZWN0ZWQuXG5cbiAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgICBpZiAoY2hhbm5lbHMucG9uZy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgY2hhbm5lbHMucG9uZy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfMTYpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSgyKVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2QkUoMClcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NCkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDgpXG4gICAgICAgIGNvbnN0IHVwcGVyID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuXG4gICAgICAgIC8vIDJeMzEgaXMgdGhlIG1heGluaW11bSBieXRlcyBhbiBhcnJheWJ1ZmZlciBjYW4gY29udGFpblxuICAgICAgICAvLyBvbiAzMi1iaXQgc3lzdGVtcy4gQWx0aG91Z2gsIG9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzXG4gICAgICAgIC8vIDJeNTMtMSBieXRlcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0ludmFsaWRfYXJyYXlfbGVuZ3RoXG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9jb21tb24vZ2xvYmFscy5oO2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlO2Jwdj0xO2JwdD0xO2w9MTI3NVxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvb2JqZWN0cy9qcy1hcnJheS1idWZmZXIuaDtsPTM0O2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlXG4gICAgICAgIGlmICh1cHBlciA+IDIgKiogMzEgLSAxKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JlY2VpdmVkIHBheWxvYWQgbGVuZ3RoID4gMl4zMSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDQpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gKHVwcGVyIDw8IDgpICsgbG93ZXJcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBKSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgc3RpbGwgbW9yZSBkYXRhIGluIHRoaXMgY2h1bmsgdGhhdCBuZWVkcyB0byBiZSByZWFkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiNieXRlT2Zmc2V0ID49IHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgc2VudCBtdWx0aXBsZSBmcmFtZXMgaW4gYSBzaW5nbGUgY2h1bmtcblxuICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUodGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLnB1c2goYm9keSlcblxuICAgICAgICAgIC8vIElmIHRoZSBmcmFtZSBpcyB1bmZyYWdtZW50ZWQsIG9yIGEgZnJhZ21lbnRlZCBmcmFtZSB3YXMgdGVybWluYXRlZCxcbiAgICAgICAgICAvLyBhIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkXG4gICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZyYWdtZW50ZWQgfHwgKHRoaXMuI2luZm8uZmluICYmIHRoaXMuI2luZm8ub3Bjb2RlID09PSBvcGNvZGVzLkNPTlRJTlVBVElPTikpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gQnVmZmVyLmNvbmNhdCh0aGlzLiNmcmFnbWVudHMpXG5cbiAgICAgICAgICAgIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCh0aGlzLndzLCB0aGlzLiNpbmZvLm9yaWdpbmFsT3Bjb2RlLCBmdWxsTWVzc2FnZSlcblxuICAgICAgICAgICAgdGhpcy4jaW5mbyA9IHt9XG4gICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA+IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBuIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIEJ1ZmZlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge0J1ZmZlcnxudWxsfVxuICAgKi9cbiAgY29uc3VtZSAobikge1xuICAgIGlmIChuID4gdGhpcy4jYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eUJ1ZmZlclxuICAgIH1cblxuICAgIGlmICh0aGlzLiNidWZmZXJzWzBdLmxlbmd0aCA9PT0gbikge1xuICAgICAgdGhpcy4jYnl0ZU9mZnNldCAtPSB0aGlzLiNidWZmZXJzWzBdLmxlbmd0aFxuICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcnMuc2hpZnQoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKVxuICAgIGxldCBvZmZzZXQgPSAwXG5cbiAgICB3aGlsZSAob2Zmc2V0ICE9PSBuKSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy4jYnVmZmVyc1swXVxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IG5leHRcblxuICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA9PT0gbikge1xuICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggKyBvZmZzZXQgPiBuKSB7XG4gICAgICAgIGJ1ZmZlci5zZXQobmV4dC5zdWJhcnJheSgwLCBuIC0gb2Zmc2V0KSwgb2Zmc2V0KVxuICAgICAgICB0aGlzLiNidWZmZXJzWzBdID0gbmV4dC5zdWJhcnJheShuIC0gb2Zmc2V0KVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IG5leHQubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jYnl0ZU9mZnNldCAtPSBuXG5cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICBwYXJzZUNsb3NlQm9keSAob25seUNvZGUsIGRhdGEpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgY29kZVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDIpIHtcbiAgICAgIC8vIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXNcbiAgICAgIC8vIGRlZmluZWQgYXMgdGhlIHN0YXR1cyBjb2RlIChTZWN0aW9uIDcuNCkgY29udGFpbmVkIGluIHRoZSBmaXJzdCBDbG9zZVxuICAgICAgLy8gY29udHJvbCBmcmFtZSByZWNlaXZlZCBieSB0aGUgYXBwbGljYXRpb25cbiAgICAgIGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKVxuICAgIH1cblxuICAgIGlmIChvbmx5Q29kZSkge1xuICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBjb2RlIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNlxuICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgIGxldCByZWFzb24gPSBkYXRhLnN1YmFycmF5KDIpXG5cbiAgICAvLyBSZW1vdmUgQk9NXG4gICAgaWYgKHJlYXNvblswXSA9PT0gMHhFRiAmJiByZWFzb25bMV0gPT09IDB4QkIgJiYgcmVhc29uWzJdID09PSAweEJGKSB7XG4gICAgICByZWFzb24gPSByZWFzb24uc3ViYXJyYXkoMylcbiAgICB9XG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpc1xuICAgICAgcmVhc29uID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSkuZGVjb2RlKHJlYXNvbilcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29kZSwgcmVhc29uIH1cbiAgfVxuXG4gIGdldCBjbG9zaW5nSW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luZm8uY2xvc2VJbmZvXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJ5dGVQYXJzZXJcbn1cbiJdLCJuYW1lcyI6WyJXcml0YWJsZSIsInJlcXVpcmUiLCJkaWFnbm9zdGljc0NoYW5uZWwiLCJwYXJzZXJTdGF0ZXMiLCJvcGNvZGVzIiwic3RhdGVzIiwiZW1wdHlCdWZmZXIiLCJrUmVhZHlTdGF0ZSIsImtTZW50Q2xvc2UiLCJrUmVzcG9uc2UiLCJrUmVjZWl2ZWRDbG9zZSIsImlzVmFsaWRTdGF0dXNDb2RlIiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJ3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQiLCJXZWJzb2NrZXRGcmFtZVNlbmQiLCJjaGFubmVscyIsInBpbmciLCJjaGFubmVsIiwicG9uZyIsIkJ5dGVQYXJzZXIiLCJidWZmZXJzIiwiYnl0ZU9mZnNldCIsInN0YXRlIiwiaW5mbyIsImZyYWdtZW50cyIsImNvbnN0cnVjdG9yIiwid3MiLCJJTkZPIiwiX3dyaXRlIiwiY2h1bmsiLCJfIiwiY2FsbGJhY2siLCJwdXNoIiwibGVuZ3RoIiwicnVuIiwiYnVmZmVyIiwiY29uc3VtZSIsImZpbiIsIm9wY29kZSIsIm9yaWdpbmFsT3Bjb2RlIiwiZnJhZ21lbnRlZCIsIkNPTlRJTlVBVElPTiIsIkJJTkFSWSIsIlRFWFQiLCJwYXlsb2FkTGVuZ3RoIiwiUkVBRF9EQVRBIiwiUEFZTE9BRExFTkdUSF8xNiIsIlBBWUxPQURMRU5HVEhfNjQiLCJQSU5HIiwiUE9ORyIsIkNMT1NFIiwiYm9keSIsImNsb3NlSW5mbyIsInBhcnNlQ2xvc2VCb2R5IiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQxNkJFIiwiY29kZSIsImNsb3NlRnJhbWUiLCJzb2NrZXQiLCJ3cml0ZSIsImNyZWF0ZUZyYW1lIiwiZXJyIiwiQ0xPU0lORyIsImVuZCIsImZyYW1lIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwicGF5bG9hZCIsInJlYWRVSW50MTZCRSIsInVwcGVyIiwicmVhZFVJbnQzMkJFIiwibG93ZXIiLCJmdWxsTWVzc2FnZSIsImNvbmNhdCIsIm4iLCJzaGlmdCIsIm9mZnNldCIsIm5leHQiLCJzZXQiLCJzdWJhcnJheSIsIm9ubHlDb2RlIiwiZGF0YSIsInJlYXNvbiIsInVuZGVmaW5lZCIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGUiLCJjbG9zaW5nSW5mbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/websocket/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    kWebSocketURL: Symbol(\"url\"),\n    kReadyState: Symbol(\"ready state\"),\n    kController: Symbol(\"controller\"),\n    kResponse: Symbol(\"response\"),\n    kBinaryType: Symbol(\"binary type\"),\n    kSentClose: Symbol(\"sent close\"),\n    kReceivedClose: Symbol(\"received close\"),\n    kByteParser: Symbol(\"byte parser\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsZUFBZUMsT0FBTztJQUN0QkMsYUFBYUQsT0FBTztJQUNwQkUsYUFBYUYsT0FBTztJQUNwQkcsV0FBV0gsT0FBTztJQUNsQkksYUFBYUosT0FBTztJQUNwQkssWUFBWUwsT0FBTztJQUNuQk0sZ0JBQWdCTixPQUFPO0lBQ3ZCTyxhQUFhUCxPQUFPO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvc3ltYm9scy5qcz9hMzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1dlYlNvY2tldFVSTDogU3ltYm9sKCd1cmwnKSxcbiAga1JlYWR5U3RhdGU6IFN5bWJvbCgncmVhZHkgc3RhdGUnKSxcbiAga0NvbnRyb2xsZXI6IFN5bWJvbCgnY29udHJvbGxlcicpLFxuICBrUmVzcG9uc2U6IFN5bWJvbCgncmVzcG9uc2UnKSxcbiAga0JpbmFyeVR5cGU6IFN5bWJvbCgnYmluYXJ5IHR5cGUnKSxcbiAga1NlbnRDbG9zZTogU3ltYm9sKCdzZW50IGNsb3NlJyksXG4gIGtSZWNlaXZlZENsb3NlOiBTeW1ib2woJ3JlY2VpdmVkIGNsb3NlJyksXG4gIGtCeXRlUGFyc2VyOiBTeW1ib2woJ2J5dGUgcGFyc2VyJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia1dlYlNvY2tldFVSTCIsIlN5bWJvbCIsImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrUmVzcG9uc2UiLCJrQmluYXJ5VHlwZSIsImtTZW50Q2xvc2UiLCJrUmVjZWl2ZWRDbG9zZSIsImtCeXRlUGFyc2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/websocket/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/websocket/symbols.js\");\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/websocket/constants.js\");\nconst { MessageEvent, ErrorEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/websocket/events.js\");\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n */ function isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[kReadyState] === states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[kReadyState] === states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n */ function isClosed(ws) {\n    return ws[kReadyState] === states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {EventInit | undefined} eventInitDict\n */ function fireEvent(e, target, eventConstructor = Event, eventInitDict) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize event’s type attribute to e.\n    const event = new eventConstructor(e, eventInitDict) // eslint-disable-line new-cap\n    ;\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[kReadyState] !== states.OPEN) {\n        return;\n    }\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === opcodes.TEXT) {\n        // -> type indicates that the data is Text\n        //      a new DOMString containing data\n        try {\n            dataForEvent = new TextDecoder(\"utf-8\", {\n                fatal: true\n            }).decode(data);\n        } catch  {\n            failWebsocketConnection(ws, \"Received invalid UTF-8 in text frame.\");\n            return;\n        }\n    } else if (type === opcodes.BINARY) {\n        if (ws[kBinaryType] === \"blob\") {\n            // -> type indicates that the data is Binary and binary type is \"blob\"\n            //      a new Blob object, created in the relevant Realm of the WebSocket\n            //      object, that represents data as its raw data\n            dataForEvent = new Blob([\n                data\n            ]);\n        } else {\n            // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n            //      a new ArrayBuffer object, created in the relevant Realm of the\n            //      WebSocket object, whose contents are data\n            dataForEvent = new Uint8Array(data).buffer;\n        }\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    object’s url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent(\"message\", ws, MessageEvent, {\n        origin: ws[kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) {\n        return false;\n    }\n    for (const char of protocol){\n        const code = char.charCodeAt(0);\n        if (code < 0x21 || code > 0x7E || char === \"(\" || char === \")\" || char === \"<\" || char === \">\" || char === \"@\" || char === \",\" || char === \";\" || char === \":\" || char === \"\\\\\" || char === '\"' || char === \"/\" || char === \"[\" || char === \"]\" || char === \"?\" || char === \"=\" || char === \"{\" || char === \"}\" || code === 32 || // SP\n        code === 9 // HT\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) {\n        return code !== 1004 && // reserved\n        code !== 1005 && // \"MUST NOT be set as a status code\"\n        code !== 1006 // \"MUST NOT be set as a status code\"\n        ;\n    }\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function failWebsocketConnection(ws, reason) {\n    const { [kController]: controller, [kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) {\n        response.socket.destroy();\n    }\n    if (reason) {\n        fireEvent(\"error\", ws, ErrorEvent, {\n            error: new Error(reason)\n        });\n    }\n}\nmodule.exports = {\n    isEstablished,\n    isClosing,\n    isClosed,\n    fireEvent,\n    isValidSubprotocol,\n    isValidStatusCode,\n    failWebsocketConnection,\n    websocketMessageReceived\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDcEYsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBRTdDLGdCQUFnQixHQUVoQjs7Q0FFQyxHQUNELFNBQVNLLGNBQWVDLEVBQUU7SUFDeEIscUVBQXFFO0lBQ3JFLG1FQUFtRTtJQUNuRSw2Q0FBNkM7SUFDN0MsT0FBT0EsRUFBRSxDQUFDWCxZQUFZLEtBQUtNLE9BQU9NLElBQUk7QUFDeEM7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLFVBQVdGLEVBQUU7SUFDcEIscUVBQXFFO0lBQ3JFLGlFQUFpRTtJQUNqRSxnREFBZ0Q7SUFDaEQsT0FBT0EsRUFBRSxDQUFDWCxZQUFZLEtBQUtNLE9BQU9RLE9BQU87QUFDM0M7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLFNBQVVKLEVBQUU7SUFDbkIsT0FBT0EsRUFBRSxDQUFDWCxZQUFZLEtBQUtNLE9BQU9VLE1BQU07QUFDMUM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLFVBQVdDLENBQUMsRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUJDLEtBQUssRUFBRUMsYUFBYTtJQUNwRSwyRUFBMkU7SUFFM0UsMEVBQTBFO0lBQzFFLHNDQUFzQztJQUN0Qyw2Q0FBNkM7SUFDN0MsTUFBTUMsUUFBUSxJQUFJSCxpQkFBaUJGLEdBQUdJLGVBQWUsOEJBQThCOztJQUVuRixzRUFBc0U7SUFDdEUsbUNBQW1DO0lBRW5DLDBFQUEwRTtJQUMxRSwrQkFBK0I7SUFDL0JILE9BQU9LLGFBQWEsQ0FBQ0Q7QUFDdkI7QUFFQTs7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QUNBc0I7SUFDQU07SUFDQVo7SUFDQVI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3V0aWwuanM/NWM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrUmVhZHlTdGF0ZSwga0NvbnRyb2xsZXIsIGtSZXNwb25zZSwga0JpbmFyeVR5cGUsIGtXZWJTb2NrZXRVUkwgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHN0YXRlcywgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBNZXNzYWdlRXZlbnQsIEVycm9yRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcblxuLyogZ2xvYmFscyBCbG9iICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICovXG5mdW5jdGlvbiBpc0VzdGFibGlzaGVkICh3cykge1xuICAvLyBJZiB0aGUgc2VydmVyJ3MgcmVzcG9uc2UgaXMgdmFsaWRhdGVkIGFzIHByb3ZpZGVkIGZvciBhYm92ZSwgaXQgaXNcbiAgLy8gc2FpZCB0aGF0IF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgRXN0YWJsaXNoZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBpbiB0aGUgT1BFTiBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLk9QRU5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2luZyAod3MpIHtcbiAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0lOR1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqL1xuZnVuY3Rpb24gaXNDbG9zZWQgKHdzKSB7XG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5DTE9TRURcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0V2ZW50SW5pdCB8IHVuZGVmaW5lZH0gZXZlbnRJbml0RGljdFxuICovXG5mdW5jdGlvbiBmaXJlRXZlbnQgKGUsIHRhcmdldCwgZXZlbnRDb25zdHJ1Y3RvciA9IEV2ZW50LCBldmVudEluaXREaWN0KSB7XG4gIC8vIDEuIElmIGV2ZW50Q29uc3RydWN0b3IgaXMgbm90IGdpdmVuLCB0aGVuIGxldCBldmVudENvbnN0cnVjdG9yIGJlIEV2ZW50LlxuXG4gIC8vIDIuIExldCBldmVudCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGV2ZW50IGdpdmVuIGV2ZW50Q29uc3RydWN0b3IsXG4gIC8vICAgIGluIHRoZSByZWxldmFudCByZWFsbSBvZiB0YXJnZXQuXG4gIC8vIDMuIEluaXRpYWxpemUgZXZlbnTigJlzIHR5cGUgYXR0cmlidXRlIHRvIGUuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IGV2ZW50Q29uc3RydWN0b3IoZSwgZXZlbnRJbml0RGljdCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgLy8gNC4gSW5pdGlhbGl6ZSBhbnkgb3RoZXIgSURMIGF0dHJpYnV0ZXMgb2YgZXZlbnQgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyAgICBpbnZvY2F0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXG4gIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGRpc3BhdGNoaW5nIGV2ZW50IGF0IHRhcmdldCwgd2l0aCBsZWdhY3kgdGFyZ2V0XG4gIC8vICAgIG92ZXJyaWRlIGZsYWcgc2V0IGlmIHNldC5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgT3Bjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBhcHBsaWNhdGlvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCAod3MsIHR5cGUsIGRhdGEpIHtcbiAgLy8gMS4gSWYgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgaWYgKHdzW2tSZWFkeVN0YXRlXSAhPT0gc3RhdGVzLk9QRU4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIExldCBkYXRhRm9yRXZlbnQgYmUgZGV0ZXJtaW5lZCBieSBzd2l0Y2hpbmcgb24gdHlwZSBhbmQgYmluYXJ5IHR5cGU6XG4gIGxldCBkYXRhRm9yRXZlbnRcblxuICBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBUZXh0XG4gICAgLy8gICAgICBhIG5ldyBET01TdHJpbmcgY29udGFpbmluZyBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShkYXRhKVxuICAgIH0gY2F0Y2gge1xuICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBvcGNvZGVzLkJJTkFSWSkge1xuICAgIGlmICh3c1trQmluYXJ5VHlwZV0gPT09ICdibG9iJykge1xuICAgICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBCaW5hcnkgYW5kIGJpbmFyeSB0eXBlIGlzIFwiYmxvYlwiXG4gICAgICAvLyAgICAgIGEgbmV3IEJsb2Igb2JqZWN0LCBjcmVhdGVkIGluIHRoZSByZWxldmFudCBSZWFsbSBvZiB0aGUgV2ViU29ja2V0XG4gICAgICAvLyAgICAgIG9iamVjdCwgdGhhdCByZXByZXNlbnRzIGRhdGEgYXMgaXRzIHJhdyBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgQmxvYihbZGF0YV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImFycmF5YnVmZmVyXCJcbiAgICAgIC8vICAgICAgYSBuZXcgQXJyYXlCdWZmZXIgb2JqZWN0LCBjcmVhdGVkIGluIHRoZSByZWxldmFudCBSZWFsbSBvZiB0aGVcbiAgICAgIC8vICAgICAgV2ViU29ja2V0IG9iamVjdCwgd2hvc2UgY29udGVudHMgYXJlIGRhdGFcbiAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBVaW50OEFycmF5KGRhdGEpLmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgbWVzc2FnZSBhdCB0aGUgV2ViU29ja2V0IG9iamVjdCwgdXNpbmcgTWVzc2FnZUV2ZW50LFxuICAvLyAgICB3aXRoIHRoZSBvcmlnaW4gYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBXZWJTb2NrZXRcbiAgLy8gICAgb2JqZWN04oCZcyB1cmwncyBvcmlnaW4sIGFuZCB0aGUgZGF0YSBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gZGF0YUZvckV2ZW50LlxuICBmaXJlRXZlbnQoJ21lc3NhZ2UnLCB3cywgTWVzc2FnZUV2ZW50LCB7XG4gICAgb3JpZ2luOiB3c1trV2ViU29ja2V0VVJMXS5vcmlnaW4sXG4gICAgZGF0YTogZGF0YUZvckV2ZW50XG4gIH0pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTVcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyNjE2XG4gKiBAc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5ODQwN1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdWJwcm90b2NvbCAocHJvdG9jb2wpIHtcbiAgLy8gSWYgcHJlc2VudCwgdGhpcyB2YWx1ZSBpbmRpY2F0ZXMgb25lXG4gIC8vIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHN1YnByb3RvY29sIHRoZSBjbGllbnQgd2lzaGVzIHRvIHNwZWFrLFxuICAvLyBvcmRlcmVkIGJ5IHByZWZlcmVuY2UuICBUaGUgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGlzIHZhbHVlXG4gIC8vIE1VU1QgYmUgbm9uLWVtcHR5IHN0cmluZ3Mgd2l0aCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSBVKzAwMjEgdG9cbiAgLy8gVSswMDdFIG5vdCBpbmNsdWRpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBpblxuICAvLyBbUkZDMjYxNl0gYW5kIE1VU1QgYWxsIGJlIHVuaXF1ZSBzdHJpbmdzLlxuICBpZiAocHJvdG9jb2wubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgcHJvdG9jb2wpIHtcbiAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fFxuICAgICAgY29kZSA+IDB4N0UgfHxcbiAgICAgIGNoYXIgPT09ICcoJyB8fFxuICAgICAgY2hhciA9PT0gJyknIHx8XG4gICAgICBjaGFyID09PSAnPCcgfHxcbiAgICAgIGNoYXIgPT09ICc+JyB8fFxuICAgICAgY2hhciA9PT0gJ0AnIHx8XG4gICAgICBjaGFyID09PSAnLCcgfHxcbiAgICAgIGNoYXIgPT09ICc7JyB8fFxuICAgICAgY2hhciA9PT0gJzonIHx8XG4gICAgICBjaGFyID09PSAnXFxcXCcgfHxcbiAgICAgIGNoYXIgPT09ICdcIicgfHxcbiAgICAgIGNoYXIgPT09ICcvJyB8fFxuICAgICAgY2hhciA9PT0gJ1snIHx8XG4gICAgICBjaGFyID09PSAnXScgfHxcbiAgICAgIGNoYXIgPT09ICc/JyB8fFxuICAgICAgY2hhciA9PT0gJz0nIHx8XG4gICAgICBjaGFyID09PSAneycgfHxcbiAgICAgIGNoYXIgPT09ICd9JyB8fFxuICAgICAgY29kZSA9PT0gMzIgfHwgLy8gU1BcbiAgICAgIGNvZGUgPT09IDkgLy8gSFRcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LTRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlIChjb2RlKSB7XG4gIGlmIChjb2RlID49IDEwMDAgJiYgY29kZSA8IDEwMTUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY29kZSAhPT0gMTAwNCAmJiAvLyByZXNlcnZlZFxuICAgICAgY29kZSAhPT0gMTAwNSAmJiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICAgIGNvZGUgIT09IDEwMDYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHJlYXNvblxuICovXG5mdW5jdGlvbiBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiAod3MsIHJlYXNvbikge1xuICBjb25zdCB7IFtrQ29udHJvbGxlcl06IGNvbnRyb2xsZXIsIFtrUmVzcG9uc2VdOiByZXNwb25zZSB9ID0gd3NcblxuICBjb250cm9sbGVyLmFib3J0KClcblxuICBpZiAocmVzcG9uc2U/LnNvY2tldCAmJiAhcmVzcG9uc2Uuc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIHJlc3BvbnNlLnNvY2tldC5kZXN0cm95KClcbiAgfVxuXG4gIGlmIChyZWFzb24pIHtcbiAgICBmaXJlRXZlbnQoJ2Vycm9yJywgd3MsIEVycm9yRXZlbnQsIHtcbiAgICAgIGVycm9yOiBuZXcgRXJyb3IocmVhc29uKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRXN0YWJsaXNoZWQsXG4gIGlzQ2xvc2luZyxcbiAgaXNDbG9zZWQsXG4gIGZpcmVFdmVudCxcbiAgaXNWYWxpZFN1YnByb3RvY29sLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZFxufVxuIl0sIm5hbWVzIjpbImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrUmVzcG9uc2UiLCJrQmluYXJ5VHlwZSIsImtXZWJTb2NrZXRVUkwiLCJyZXF1aXJlIiwic3RhdGVzIiwib3Bjb2RlcyIsIk1lc3NhZ2VFdmVudCIsIkVycm9yRXZlbnQiLCJpc0VzdGFibGlzaGVkIiwid3MiLCJPUEVOIiwiaXNDbG9zaW5nIiwiQ0xPU0lORyIsImlzQ2xvc2VkIiwiQ0xPU0VEIiwiZmlyZUV2ZW50IiwiZSIsInRhcmdldCIsImV2ZW50Q29uc3RydWN0b3IiLCJFdmVudCIsImV2ZW50SW5pdERpY3QiLCJldmVudCIsImRpc3BhdGNoRXZlbnQiLCJ3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQiLCJ0eXBlIiwiZGF0YSIsImRhdGFGb3JFdmVudCIsIlRFWFQiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlIiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJCSU5BUlkiLCJCbG9iIiwiVWludDhBcnJheSIsImJ1ZmZlciIsIm9yaWdpbiIsImlzVmFsaWRTdWJwcm90b2NvbCIsInByb3RvY29sIiwibGVuZ3RoIiwiY2hhciIsImNvZGUiLCJjaGFyQ29kZUF0IiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJyZWFzb24iLCJjb250cm9sbGVyIiwicmVzcG9uc2UiLCJhYm9ydCIsInNvY2tldCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJlcnJvciIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/websocket/websocket.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/websocket/websocket.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/fetch/webidl.js\");\nconst { DOMException } = __webpack_require__(/*! ../fetch/constants */ \"(rsc)/./node_modules/undici/lib/fetch/constants.js\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/dataURL */ \"(rsc)/./node_modules/undici/lib/fetch/dataURL.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ../fetch/global */ \"(rsc)/./node_modules/undici/lib/fetch/global.js\");\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/websocket/constants.js\");\nconst { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/websocket/symbols.js\");\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/websocket/util.js\");\nconst { establishWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/websocket/connection.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/websocket/frame.js\");\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/undici/lib/websocket/receiver.js\");\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../global */ \"(rsc)/./node_modules/undici/lib/global.js\");\nconst { types } = __webpack_require__(/*! util */ \"util\");\nlet experimentalWarned = false;\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n    #events;\n    #bufferedAmount;\n    #protocol;\n    #extensions;\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super();\n        this.#events = {\n            open: null,\n            error: null,\n            close: null,\n            message: null\n        };\n        this.#bufferedAmount = 0;\n        this.#protocol = \"\";\n        this.#extensions = \"\";\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket constructor\"\n        });\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning(\"WebSockets are experimental, expect them to change at any time.\", {\n                code: \"UNDICI-WS\"\n            });\n        }\n        const options = webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"](protocols);\n        url = webidl.converters.USVString(url);\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = getGlobalOrigin();\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, \"SyntaxError\");\n        }\n        // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n        if (urlRecord.protocol === \"http:\") {\n            urlRecord.protocol = \"ws:\";\n        } else if (urlRecord.protocol === \"https:\") {\n            // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n            urlRecord.protocol = \"wss:\";\n        }\n        // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== \"ws:\" && urlRecord.protocol !== \"wss:\") {\n            throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, \"SyntaxError\");\n        }\n        // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith(\"#\")) {\n            throw new DOMException(\"Got fragment\", \"SyntaxError\");\n        }\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === \"string\") {\n            protocols = [\n                protocols\n            ];\n        }\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        // 10. Set this's url to urlRecord.\n        this[kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response)=>this.#onConnectionEstablished(response), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[kReadyState] = WebSocket.CONNECTING;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[kBinaryType] = \"blob\";\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code = undefined, reason = undefined) {\n        webidl.brandCheck(this, WebSocket);\n        if (code !== undefined) {\n            code = webidl.converters[\"unsigned short\"](code, {\n                clamp: true\n            });\n        }\n        if (reason !== undefined) {\n            reason = webidl.converters.USVString(reason);\n        }\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) {\n                throw new DOMException(\"invalid code\", \"InvalidAccessError\");\n            }\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) {\n                throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, \"SyntaxError\");\n            }\n        }\n        // 3. Run the first matching steps from the following list:\n        if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n        // If this's ready state is CLOSING (2) or CLOSED (3)\n        // Do nothing.\n        } else if (!isEstablished(this)) {\n            // If the WebSocket connection is not yet established\n            // Fail the WebSocket connection and set this's ready state\n            // to CLOSING (2).\n            failWebsocketConnection(this, \"Connection was closed before it was established.\");\n            this[kReadyState] = WebSocket.CLOSING;\n        } else if (!isClosing(this)) {\n            // If the WebSocket closing handshake has not yet been started\n            // Start the WebSocket closing handshake and set this's ready\n            // state to CLOSING (2).\n            // - If neither code nor reason is present, the WebSocket Close\n            //   message must not have a body.\n            // - If code is present, then the status code to use in the\n            //   WebSocket Close message must be the integer given by code.\n            // - If reason is also present, then reasonBytes must be\n            //   provided in the Close message after the status code.\n            const frame = new WebsocketFrameSend();\n            // If neither code nor reason is present, the WebSocket Close\n            // message must not have a body.\n            // If code is present, then the status code to use in the\n            // WebSocket Close message must be the integer given by code.\n            if (code !== undefined && reason === undefined) {\n                frame.frameData = Buffer.allocUnsafe(2);\n                frame.frameData.writeUInt16BE(code, 0);\n            } else if (code !== undefined && reason !== undefined) {\n                // If reason is also present, then reasonBytes must be\n                // provided in the Close message after the status code.\n                frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n                frame.frameData.writeUInt16BE(code, 0);\n                // the body MAY contain UTF-8-encoded data with value /reason/\n                frame.frameData.write(reason, 2, \"utf-8\");\n            } else {\n                frame.frameData = emptyBuffer;\n            }\n            /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n            socket.write(frame.createFrame(opcodes.CLOSE), (err)=>{\n                if (!err) {\n                    this[kSentClose] = true;\n                }\n            });\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this[kReadyState] = states.CLOSING;\n        } else {\n            // Otherwise\n            // Set this's ready state to CLOSING (2).\n            this[kReadyState] = WebSocket.CLOSING;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        webidl.brandCheck(this, WebSocket);\n        webidl.argumentLengthCheck(arguments, 1, {\n            header: \"WebSocket.send\"\n        });\n        data = webidl.converters.WebSocketSendData(data);\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (this[kReadyState] === WebSocket.CONNECTING) {\n            throw new DOMException(\"Sent before connected.\", \"InvalidStateError\");\n        }\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!isEstablished(this) || isClosing(this)) {\n            return;\n        }\n        /** @type {import('stream').Duplex} */ const socket = this[kResponse].socket;\n        // If data is a string\n        if (typeof data === \"string\") {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.TEXT);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            const value = Buffer.from(data);\n            const frame = new WebsocketFrameSend(value);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += value.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= value.byteLength;\n            });\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of data’s buffer in bytes.\n            const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n            const frame = new WebsocketFrameSend(ab);\n            const buffer = frame.createFrame(opcodes.BINARY);\n            this.#bufferedAmount += ab.byteLength;\n            socket.write(buffer, ()=>{\n                this.#bufferedAmount -= ab.byteLength;\n            });\n        } else if (isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob object’s raw data, in bytes.\n            const frame = new WebsocketFrameSend();\n            data.arrayBuffer().then((ab)=>{\n                const value = Buffer.from(ab);\n                frame.frameData = value;\n                const buffer = frame.createFrame(opcodes.BINARY);\n                this.#bufferedAmount += value.byteLength;\n                socket.write(buffer, ()=>{\n                    this.#bufferedAmount -= value.byteLength;\n                });\n            });\n        }\n    }\n    get readyState() {\n        webidl.brandCheck(this, WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[kReadyState];\n    }\n    get bufferedAmount() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        webidl.brandCheck(this, WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return URLSerializer(this[kWebSocketURL]);\n    }\n    get extensions() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.open) {\n            this.removeEventListener(\"open\", this.#events.open);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.open = fn;\n            this.addEventListener(\"open\", fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.error) {\n            this.removeEventListener(\"error\", this.#events.error);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n    get onclose() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.close) {\n            this.removeEventListener(\"close\", this.#events.close);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.close = fn;\n            this.addEventListener(\"close\", fn);\n        } else {\n            this.#events.close = null;\n        }\n    }\n    get onmessage() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.message) {\n            this.removeEventListener(\"message\", this.#events.message);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.message = fn;\n            this.addEventListener(\"message\", fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get binaryType() {\n        webidl.brandCheck(this, WebSocket);\n        return this[kBinaryType];\n    }\n    set binaryType(type) {\n        webidl.brandCheck(this, WebSocket);\n        if (type !== \"blob\" && type !== \"arraybuffer\") {\n            this[kBinaryType] = \"blob\";\n        } else {\n            this[kBinaryType] = type;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response) {\n        // processResponse is called when the \"response’s header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[kResponse] = response;\n        const parser = new ByteParser(this);\n        parser.on(\"drain\", function onParserDrain() {\n            this.ws[kResponse].socket.resume();\n        });\n        response.socket.ws = this;\n        this[kByteParser] = parser;\n        // 1. Change the ready state to OPEN (1).\n        this[kReadyState] = states.OPEN;\n        // 2. Change the extensions attribute’s value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get(\"sec-websocket-extensions\");\n        if (extensions !== null) {\n            this.#extensions = extensions;\n        }\n        // 3. Change the protocol attribute’s value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get(\"sec-websocket-protocol\");\n        if (protocol !== null) {\n            this.#protocol = protocol;\n        }\n        // 4. Fire an event named open at the WebSocket object.\n        fireEvent(\"open\", this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors,\n    url: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    bufferedAmount: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onclose: kEnumerableProperty,\n    close: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    binaryType: kEnumerableProperty,\n    send: kEnumerableProperty,\n    extensions: kEnumerableProperty,\n    protocol: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"WebSocket\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(WebSocket, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors\n});\nwebidl.converters[\"sequence<DOMString>\"] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters[\"DOMString or sequence<DOMString>\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && Symbol.iterator in V) {\n        return webidl.converters[\"sequence<DOMString>\"](V);\n    }\n    return webidl.converters.DOMString(V);\n};\n// This implements the propsal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n    {\n        key: \"protocols\",\n        converter: webidl.converters[\"DOMString or sequence<DOMString>\"],\n        get defaultValue () {\n            return [];\n        }\n    },\n    {\n        key: \"dispatcher\",\n        converter: (V)=>V,\n        get defaultValue () {\n            return getGlobalDispatcher();\n        }\n    },\n    {\n        key: \"headers\",\n        converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n    }\n]);\nwebidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && !(Symbol.iterator in V)) {\n        return webidl.converters.WebSocketInit(V);\n    }\n    return {\n        protocols: webidl.converters[\"DOMString or sequence<DOMString>\"](V)\n    };\n};\nwebidl.converters.WebSocketSendData = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V);\n        }\n    }\n    return webidl.converters.USVString(V);\n};\nmodule.exports = {\n    WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFFRSxhQUFhLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRyxlQUFlLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFDcEMsTUFBTSxFQUFFSSx5QkFBeUIsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRSxHQUFHUCxtQkFBT0EsQ0FBQztBQUM1RSxNQUFNLEVBQ0pRLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWixHQUFHZCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRWUsYUFBYSxFQUFFQyxTQUFTLEVBQUVDLGtCQUFrQixFQUFFQyx1QkFBdUIsRUFBRUMsU0FBUyxFQUFFLEdBQUduQixtQkFBT0EsQ0FBQztBQUNyRyxNQUFNLEVBQUVvQiw0QkFBNEIsRUFBRSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDakQsTUFBTSxFQUFFcUIsa0JBQWtCLEVBQUUsR0FBR3JCLG1CQUFPQSxDQUFDO0FBQ3ZDLE1BQU0sRUFBRXNCLFVBQVUsRUFBRSxHQUFHdEIsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFdUIsbUJBQW1CLEVBQUVDLFVBQVUsRUFBRSxHQUFHeEIsbUJBQU9BLENBQUM7QUFDcEQsTUFBTSxFQUFFeUIsbUJBQW1CLEVBQUUsR0FBR3pCLG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFBRTBCLEtBQUssRUFBRSxHQUFHMUIsbUJBQU9BLENBQUM7QUFFMUIsSUFBSTJCLHFCQUFxQjtBQUV6QiwyREFBMkQ7QUFDM0QsTUFB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Q0FBQztJQUNsRixJQUFJakksT0FBT2tJLElBQUksQ0FBQ0MsSUFBSSxDQUFDRixPQUFPLFlBQVksQ0FBRVAsQ0FBQUEsT0FBT1UsUUFBUSxJQUFJSCxDQUFBQSxHQUFJO1FBQy9ELE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDb0YsYUFBYSxDQUFDSjtJQUN6QztJQUVBLE9BQU87UUFBRTVGLFdBQVdyQyxPQUFPaUQsVUFBVSxDQUFDLG1DQUFtQyxDQUFDZ0Y7SUFBRztBQUMvRTtBQUVBakksT0FBT2lELFVBQVUsQ0FBQ3VDLGlCQUFpQixHQUFHLFNBQVV5QyxDQUFDO0lBQy9DLElBQUlqSSxPQUFPa0ksSUFBSSxDQUFDQyxJQUFJLENBQUNGLE9BQU8sVUFBVTtRQUNwQyxJQUFJeEcsV0FBV3dHLElBQUk7WUFDakIsT0FBT2pJLE9BQU9pRCxVQUFVLENBQUMyRixJQUFJLENBQUNYLEdBQUc7Z0JBQUVZLFFBQVE7WUFBTTtRQUNuRDtRQUVBLElBQUk5QyxZQUFZQyxNQUFNLENBQUNpQyxNQUFNdEcsTUFBTW1ILGdCQUFnQixDQUFDYixJQUFJO1lBQ3RELE9BQU9qSSxPQUFPaUQsVUFBVSxDQUFDOEYsWUFBWSxDQUFDZDtRQUN4QztJQUNGO0lBRUEsT0FBT2pJLE9BQU9pRCxVQUFVLENBQUNDLFNBQVMsQ0FBQytFO0FBQ3JDO0FBRUFlLE9BQU9DLE9BQU8sR0FBRztJQUNmcEg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcz9hOGMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgRE9NRXhjZXB0aW9uIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9jb25zdGFudHMnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhVVJMJylcbmNvbnN0IHsgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9nbG9iYWwnKVxuY29uc3QgeyBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLCBzdGF0ZXMsIG9wY29kZXMsIGVtcHR5QnVmZmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7XG4gIGtXZWJTb2NrZXRVUkwsXG4gIGtSZWFkeVN0YXRlLFxuICBrQ29udHJvbGxlcixcbiAga0JpbmFyeVR5cGUsXG4gIGtSZXNwb25zZSxcbiAga1NlbnRDbG9zZSxcbiAga0J5dGVQYXJzZXJcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBpc0VzdGFibGlzaGVkLCBpc0Nsb3NpbmcsIGlzVmFsaWRTdWJwcm90b2NvbCwgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sIGZpcmVFdmVudCB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgQnl0ZVBhcnNlciB9ID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIGlzQmxvYkxpa2UgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uL2dsb2JhbCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCd1dGlsJylcblxubGV0IGV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1kZWZpbml0aW9uXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNldmVudHMgPSB7XG4gICAgb3BlbjogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBjbG9zZTogbnVsbCxcbiAgICBtZXNzYWdlOiBudWxsXG4gIH1cblxuICAjYnVmZmVyZWRBbW91bnQgPSAwXG4gICNwcm90b2NvbCA9ICcnXG4gICNleHRlbnNpb25zID0gJydcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBwcm90b2NvbHMgPSBbXSkge1xuICAgIHN1cGVyKClcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgeyBoZWFkZXI6ICdXZWJTb2NrZXQgY29uc3RydWN0b3InIH0pXG5cbiAgICBpZiAoIWV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgICAgZXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnV2ViU29ja2V0cyBhcmUgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLVdTJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXShwcm90b2NvbHMpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2xzXG5cbiAgICAvLyAxLiBMZXQgYmFzZVVSTCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0J3MgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVUkwgPSBnZXRHbG9iYWxPcmlnaW4oKVxuXG4gICAgLy8gMS4gTGV0IHVybFJlY29yZCBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBVUkwgcGFyc2VyIHRvIHVybCB3aXRoIGJhc2VVUkwuXG4gICAgbGV0IHVybFJlY29yZFxuXG4gICAgdHJ5IHtcbiAgICAgIHVybFJlY29yZCA9IG5ldyBVUkwodXJsLCBiYXNlVVJMKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIDMuIElmIHVybFJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oZSwgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBcImh0dHBcIiwgdGhlbiBzZXQgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgdG8gXCJ3c1wiLlxuICAgIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3czonXG4gICAgfSBlbHNlIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIFwiaHR0cHNcIiwgc2V0IHVybFJlY29yZOKAmXMgc2NoZW1lIHRvIFwid3NzXCIuXG4gICAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3NzOidcbiAgICB9XG5cbiAgICAvLyA2LiBJZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBub3QgXCJ3c1wiIG9yIFwid3NzXCIsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3czonICYmIHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzczonKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICBgRXhwZWN0ZWQgYSB3czogb3Igd3NzOiBwcm90b2NvbCwgZ290ICR7dXJsUmVjb3JkLnByb3RvY29sfWAsXG4gICAgICAgICdTeW50YXhFcnJvcidcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyA3LiBJZiB1cmxSZWNvcmTigJlzIGZyYWdtZW50IGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiXG4gICAgLy8gICAgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh1cmxSZWNvcmQuaGFzaCB8fCB1cmxSZWNvcmQuaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdHb3QgZnJhZ21lbnQnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDguIElmIHByb3RvY29scyBpcyBhIHN0cmluZywgc2V0IHByb3RvY29scyB0byBhIHNlcXVlbmNlIGNvbnNpc3RpbmdcbiAgICAvLyAgICBvZiBqdXN0IHRoYXQgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc11cbiAgICB9XG5cbiAgICAvLyA5LiBJZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiBwcm90b2NvbHMgb2NjdXIgbW9yZSB0aGFuIG9uY2Ugb3Igb3RoZXJ3aXNlXG4gICAgLy8gICAgZmFpbCB0byBtYXRjaCB0aGUgcmVxdWlyZW1lbnRzIGZvciBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoZSB2YWx1ZVxuICAgIC8vICAgIG9mIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBmaWVsZHMgYXMgZGVmaW5lZCBieSBUaGUgV2ViU29ja2V0XG4gICAgLy8gICAgcHJvdG9jb2wsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSBuZXcgU2V0KHByb3RvY29scy5tYXAocCA9PiBwLnRvTG93ZXJDYXNlKCkpKS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoID4gMCAmJiAhcHJvdG9jb2xzLmV2ZXJ5KHAgPT4gaXNWYWxpZFN1YnByb3RvY29sKHApKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyAxMC4gU2V0IHRoaXMncyB1cmwgdG8gdXJsUmVjb3JkLlxuICAgIHRoaXNba1dlYlNvY2tldFVSTF0gPSBuZXcgVVJMKHVybFJlY29yZC5ocmVmKVxuXG4gICAgLy8gMTEuIExldCBjbGllbnQgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cblxuICAgIC8vIDEyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOlxuXG4gICAgLy8gICAgMS4gRXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ2l2ZW4gdXJsUmVjb3JkLCBwcm90b2NvbHMsXG4gICAgLy8gICAgICAgYW5kIGNsaWVudC5cbiAgICB0aGlzW2tDb250cm9sbGVyXSA9IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24oXG4gICAgICB1cmxSZWNvcmQsXG4gICAgICBwcm90b2NvbHMsXG4gICAgICB0aGlzLFxuICAgICAgKHJlc3BvbnNlKSA9PiB0aGlzLiNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSksXG4gICAgICBvcHRpb25zXG4gICAgKVxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIHJlYWR5IHN0YXRlLCB3aGljaCBpcyBhXG4gICAgLy8gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uIEluaXRpYWxseSBpdCBtdXN0XG4gICAgLy8gYmUgQ09OTkVDVElORyAoMCkuXG4gICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBXZWJTb2NrZXQuQ09OTkVDVElOR1xuXG4gICAgLy8gVGhlIGV4dGVuc2lvbnMgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gVGhlIHByb3RvY29sIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBiaW5hcnkgdHlwZSwgd2hpY2ggaXMgYVxuICAgIC8vIEJpbmFyeVR5cGUuIEluaXRpYWxseSBpdCBtdXN0IGJlIFwiYmxvYlwiLlxuICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHJlYXNvblxuICAgKi9cbiAgY2xvc2UgKGNvZGUgPSB1bmRlZmluZWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvZGUgPSB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShjb2RlLCB7IGNsYW1wOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWFzb24gPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcocmVhc29uKVxuICAgIH1cblxuICAgIC8vIDEuIElmIGNvZGUgaXMgcHJlc2VudCwgYnV0IGlzIG5laXRoZXIgYW4gaW50ZWdlciBlcXVhbCB0byAxMDAwIG5vciBhblxuICAgIC8vICAgIGludGVnZXIgaW4gdGhlIHJhbmdlIDMwMDAgdG8gNDk5OSwgaW5jbHVzaXZlLCB0aHJvdyBhblxuICAgIC8vICAgIFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb2RlICE9PSAxMDAwICYmIChjb2RlIDwgMzAwMCB8fCBjb2RlID4gNDk5OSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignaW52YWxpZCBjb2RlJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlYXNvbkJ5dGVMZW5ndGggPSAwXG5cbiAgICAvLyAyLiBJZiByZWFzb24gaXMgcHJlc2VudCwgdGhlbiBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVhc29uQnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBlbmNvZGluZyByZWFzb24uXG4gICAgICAvLyAyLiBJZiByZWFzb25CeXRlcyBpcyBsb25nZXIgdGhhbiAxMjMgYnl0ZXMsIHRoZW4gdGhyb3cgYVxuICAgICAgLy8gICAgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIHJlYXNvbkJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChyZWFzb24pXG5cbiAgICAgIGlmIChyZWFzb25CeXRlTGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgYFJlYXNvbiBtdXN0IGJlIGxlc3MgdGhhbiAxMjMgYnl0ZXM7IHJlY2VpdmVkICR7cmVhc29uQnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICdTeW50YXhFcnJvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFJ1biB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAgaWYgKHRoaXNba1JlYWR5U3RhdGVdID09PSBXZWJTb2NrZXQuQ0xPU0lORyB8fCB0aGlzW2tSZWFkeVN0YXRlXSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgLy8gSWYgdGhpcydzIHJlYWR5IHN0YXRlIGlzIENMT1NJTkcgKDIpIG9yIENMT1NFRCAoMylcbiAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmICghaXNFc3RhYmxpc2hlZCh0aGlzKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgZXN0YWJsaXNoZWRcbiAgICAgIC8vIEZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGFuZCBzZXQgdGhpcydzIHJlYWR5IHN0YXRlXG4gICAgICAvLyB0byBDTE9TSU5HICgyKS5cbiAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMsICdDb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIGl0IHdhcyBlc3RhYmxpc2hlZC4nKVxuICAgICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBXZWJTb2NrZXQuQ0xPU0lOR1xuICAgIH0gZWxzZSBpZiAoIWlzQ2xvc2luZyh0aGlzKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWRcbiAgICAgIC8vIFN0YXJ0IHRoZSBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2UgYW5kIHNldCB0aGlzJ3MgcmVhZHlcbiAgICAgIC8vIHN0YXRlIHRvIENMT1NJTkcgKDIpLlxuICAgICAgLy8gLSBJZiBuZWl0aGVyIGNvZGUgbm9yIHJlYXNvbiBpcyBwcmVzZW50LCB0aGUgV2ViU29ja2V0IENsb3NlXG4gICAgICAvLyAgIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG4gICAgICAvLyAtIElmIGNvZGUgaXMgcHJlc2VudCwgdGhlbiB0aGUgc3RhdHVzIGNvZGUgdG8gdXNlIGluIHRoZVxuICAgICAgLy8gICBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgICAvLyAtIElmIHJlYXNvbiBpcyBhbHNvIHByZXNlbnQsIHRoZW4gcmVhc29uQnl0ZXMgbXVzdCBiZVxuICAgICAgLy8gICBwcm92aWRlZCBpbiB0aGUgQ2xvc2UgbWVzc2FnZSBhZnRlciB0aGUgc3RhdHVzIGNvZGUuXG5cbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCgpXG5cbiAgICAgIC8vIElmIG5laXRoZXIgY29kZSBub3IgcmVhc29uIGlzIHByZXNlbnQsIHRoZSBXZWJTb2NrZXQgQ2xvc2VcbiAgICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAgIC8vIElmIGNvZGUgaXMgcHJlc2VudCwgdGhlbiB0aGUgc3RhdHVzIGNvZGUgdG8gdXNlIGluIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IENsb3NlIG1lc3NhZ2UgbXVzdCBiZSB0aGUgaW50ZWdlciBnaXZlbiBieSBjb2RlLlxuICAgICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmcmFtZS5mcmFtZURhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlVUludDE2QkUoY29kZSwgMClcbiAgICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHJlYXNvbiBpcyBhbHNvIHByZXNlbnQsIHRoZW4gcmVhc29uQnl0ZXMgbXVzdCBiZVxuICAgICAgICAvLyBwcm92aWRlZCBpbiB0aGUgQ2xvc2UgbWVzc2FnZSBhZnRlciB0aGUgc3RhdHVzIGNvZGUuXG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgcmVhc29uQnl0ZUxlbmd0aClcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlVUludDE2QkUoY29kZSwgMClcbiAgICAgICAgLy8gdGhlIGJvZHkgTUFZIGNvbnRhaW4gVVRGLTgtZW5jb2RlZCBkYXRhIHdpdGggdmFsdWUgL3JlYXNvbi9cbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlKHJlYXNvbiwgMiwgJ3V0Zi04JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IGVtcHR5QnVmZmVyXG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KCdzdHJlYW0nKS5EdXBsZXh9ICovXG4gICAgICBjb25zdCBzb2NrZXQgPSB0aGlzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICAgIHNvY2tldC53cml0ZShmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkNMT1NFKSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHRoaXNba1NlbnRDbG9zZV0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICAgICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2VcbiAgICAgIC8vIFNldCB0aGlzJ3MgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DTE9TSU5HXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1zZW5kXG4gICAqIEBwYXJhbSB7Tm9kZUpTLlR5cGVkQXJyYXl8QXJyYXlCdWZmZXJ8QmxvYnxzdHJpbmd9IGRhdGFcbiAgICovXG4gIHNlbmQgKGRhdGEpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHsgaGVhZGVyOiAnV2ViU29ja2V0LnNlbmQnIH0pXG5cbiAgICBkYXRhID0gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEoZGF0YSlcblxuICAgIC8vIDEuIElmIHRoaXMncyByZWFkeSBzdGF0ZSBpcyBDT05ORUNUSU5HLCB0aGVuIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodGhpc1trUmVhZHlTdGF0ZV0gPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW50IGJlZm9yZSBjb25uZWN0ZWQuJywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgICB9XG5cbiAgICAvLyAyLiBSdW4gdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi02LjFcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjJcblxuICAgIGlmICghaXNFc3RhYmxpc2hlZCh0aGlzKSB8fCBpc0Nsb3NpbmcodGhpcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCdzdHJlYW0nKS5EdXBsZXh9ICovXG4gICAgY29uc3Qgc29ja2V0ID0gdGhpc1trUmVzcG9uc2VdLnNvY2tldFxuXG4gICAgLy8gSWYgZGF0YSBpcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudFxuICAgICAgLy8gbXVzdCBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIHRoZSBkYXRhIGFyZ3VtZW50XG4gICAgICAvLyB1c2luZyBhIHRleHQgZnJhbWUgb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLlxuICAgICAgLy8gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsXG4gICAgICAvLyB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYVxuICAgICAgLy8gc3RyaW5nIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2VcbiAgICAgIC8vIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG9cbiAgICAgIC8vIGV4cHJlc3MgdGhlIGFyZ3VtZW50IGFzIFVURi04LlxuXG4gICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQodmFsdWUpXG4gICAgICBjb25zdCBidWZmZXIgPSBmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLlRFWFQpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgIHNvY2tldC53cml0ZShidWZmZXIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZFxuICAgICAgLy8gdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gVGhlIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciBkZXNjcmliZWRcbiAgICAgIC8vIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QuIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYW5cbiAgICAgIC8vIEFycmF5QnVmZmVyIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3RcbiAgICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQodmFsdWUpXG4gICAgICBjb25zdCBidWZmZXIgPSBmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkJJTkFSWSlcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgc29ja2V0LndyaXRlKGJ1ZmZlciwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG9cbiAgICAgIC8vIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhlXG4gICAgICAvLyBkYXRhIHRvIGJlIHNlbnQgaXMgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBzZWN0aW9uIG9mIHRoZSBidWZmZXJcbiAgICAgIC8vIGRlc2NyaWJlZCBieSB0aGUgQXJyYXlCdWZmZXIgb2JqZWN0IHRoYXQgZGF0YSByZWZlcmVuY2VzLiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCB0aGlzIGtpbmQgb2YgYXJndW1lbnQgdGhhdCBkb2VzXG4gICAgICAvLyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZVxuICAgICAgLy8gYnkgdGhlIGxlbmd0aCBvZiBkYXRh4oCZcyBidWZmZXIgaW4gYnl0ZXMuXG5cbiAgICAgIGNvbnN0IGFiID0gQnVmZmVyLmZyb20oZGF0YSwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG5cbiAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChhYilcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQklOQVJZKVxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBhYi5ieXRlTGVuZ3RoXG4gICAgICBzb2NrZXQud3JpdGUoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGFiLmJ5dGVMZW5ndGhcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG9cbiAgICAgIC8vIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhlIGRhdGFcbiAgICAgIC8vIHRvIGJlIHNlbnQgaXMgdGhlIHJhdyBkYXRhIHJlcHJlc2VudGVkIGJ5IHRoZSBCbG9iIG9iamVjdC4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYSBCbG9iIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3dcbiAgICAgIC8vIGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIHNpemVcbiAgICAgIC8vIG9mIHRoZSBCbG9iIG9iamVjdOKAmXMgcmF3IGRhdGEsIGluIGJ5dGVzLlxuXG4gICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgICBkYXRhLmFycmF5QnVmZmVyKCkudGhlbigoYWIpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuZnJvbShhYilcbiAgICAgICAgZnJhbWUuZnJhbWVEYXRhID0gdmFsdWVcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5CSU5BUlkpXG5cbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICBzb2NrZXQud3JpdGUoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHJlYWR5U3RhdGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHJlYWR5IHN0YXRlLlxuICAgIHJldHVybiB0aGlzW2tSZWFkeVN0YXRlXVxuICB9XG5cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jYnVmZmVyZWRBbW91bnRcbiAgfVxuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHVybCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzW2tXZWJTb2NrZXRVUkxdKVxuICB9XG5cbiAgZ2V0IGV4dGVuc2lvbnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNleHRlbnNpb25zXG4gIH1cblxuICBnZXQgcHJvdG9jb2wgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNwcm90b2NvbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25jbG9zZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5jbG9zZVxuICB9XG5cbiAgc2V0IG9uY2xvc2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5jbG9zZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuI2V2ZW50cy5jbG9zZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5tZXNzYWdlXG4gIH1cblxuICBzZXQgb25tZXNzYWdlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMubWVzc2FnZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy4jZXZlbnRzLm1lc3NhZ2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBiaW5hcnlUeXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpc1trQmluYXJ5VHlwZV1cbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlICh0eXBlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHR5cGUgIT09ICdibG9iJyAmJiB0eXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9ICdibG9iJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9IHR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICAgKi9cbiAgI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIChyZXNwb25zZSkge1xuICAgIC8vIHByb2Nlc3NSZXNwb25zZSBpcyBjYWxsZWQgd2hlbiB0aGUgXCJyZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIGluaXRpYWxpemVkLlwiXG4gICAgLy8gb25jZSB0aGlzIGhhcHBlbnMsIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICB0aGlzW2tSZXNwb25zZV0gPSByZXNwb25zZVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEJ5dGVQYXJzZXIodGhpcylcbiAgICBwYXJzZXIub24oJ2RyYWluJywgZnVuY3Rpb24gb25QYXJzZXJEcmFpbiAoKSB7XG4gICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LnJlc3VtZSgpXG4gICAgfSlcblxuICAgIHJlc3BvbnNlLnNvY2tldC53cyA9IHRoaXNcbiAgICB0aGlzW2tCeXRlUGFyc2VyXSA9IHBhcnNlclxuXG4gICAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBPUEVOICgxKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5PUEVOXG5cbiAgICAvLyAyLiBDaGFuZ2UgdGhlIGV4dGVuc2lvbnMgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgZXh0ZW5zaW9ucyBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucycpXG5cbiAgICBpZiAoZXh0ZW5zaW9ucyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNcbiAgICB9XG5cbiAgICAvLyAzLiBDaGFuZ2UgdGhlIHByb3RvY29sIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIHN1YnByb3RvY29sIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tMS45XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnKVxuXG4gICAgaWYgKHByb3RvY29sICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNwcm90b2NvbCA9IHByb3RvY29sXG4gICAgfVxuXG4gICAgLy8gNC4gRmlyZSBhbiBldmVudCBuYW1lZCBvcGVuIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgIGZpcmVFdmVudCgnb3BlbicsIHRoaXMpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jb25uZWN0aW5nXG5XZWJTb2NrZXQuQ09OTkVDVElORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ09OTkVDVElORyA9IHN0YXRlcy5DT05ORUNUSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LW9wZW5cbldlYlNvY2tldC5PUEVOID0gV2ViU29ja2V0LnByb3RvdHlwZS5PUEVOID0gc3RhdGVzLk9QRU5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2luZ1xuV2ViU29ja2V0LkNMT1NJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NJTkcgPSBzdGF0ZXMuQ0xPU0lOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZWRcbldlYlNvY2tldC5DTE9TRUQgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NFRCA9IHN0YXRlcy5DTE9TRURcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYnVmZmVyZWRBbW91bnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ub3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25jbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYmluYXJ5VHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2VuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXh0ZW5zaW9uczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHJvdG9jb2w6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdXZWJTb2NrZXQnLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yc1xufSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBWKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10oVilcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoVilcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBwcm9wc2FsIG1hZGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy93ZWJzb2NrZXRzL2lzc3Vlcy80Mlxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3Byb3RvY29scycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlICgpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLFxuICAgIGNvbnZlcnRlcjogKFYpID0+IFYsXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSAoKSB7XG4gICAgICByZXR1cm4gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpXG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQpXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0J10gPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdChWKVxuICB9XG5cbiAgcmV0dXJuIHsgcHJvdG9jb2xzOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXShWKSB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHwgdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlNvY2tldFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJET01FeGNlcHRpb24iLCJVUkxTZXJpYWxpemVyIiwiZ2V0R2xvYmFsT3JpZ2luIiwic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsInN0YXRlcyIsIm9wY29kZXMiLCJlbXB0eUJ1ZmZlciIsImtXZWJTb2NrZXRVUkwiLCJrUmVhZHlTdGF0ZSIsImtDb250cm9sbGVyIiwia0JpbmFyeVR5cGUiLCJrUmVzcG9uc2UiLCJrU2VudENsb3NlIiwia0J5dGVQYXJzZXIiLCJpc0VzdGFibGlzaGVkIiwiaXNDbG9zaW5nIiwiaXNWYWxpZFN1YnByb3RvY29sIiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJmaXJlRXZlbnQiLCJlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uIiwiV2Vic29ja2V0RnJhbWVTZW5kIiwiQnl0ZVBhcnNlciIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc0Jsb2JMaWtlIiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsInR5cGVzIiwiZXhwZXJpbWVudGFsV2FybmVkIiwiV2ViU29ja2V0IiwiRXZlbnRUYXJnZXQiLCJldmVudHMiLCJidWZmZXJlZEFtb3VudCIsInByb3RvY29sIiwiZXh0ZW5zaW9ucyIsImNvbnN0cnVjdG9yIiwidXJsIiwicHJvdG9jb2xzIiwib3BlbiIsImVycm9yIiwiY2xvc2UiLCJtZXNzYWdlIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImhlYWRlciIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImNvZGUiLCJvcHRpb25zIiwiY29udmVydGVycyIsIlVTVlN0cmluZyIsImJhc2VVUkwiLCJ1cmxSZWNvcmQiLCJVUkwiLCJlIiwiaGFzaCIsImhyZWYiLCJlbmRzV2l0aCIsImxlbmd0aCIsIlNldCIsIm1hcCIsInAiLCJ0b0xvd2VyQ2FzZSIsInNpemUiLCJldmVyeSIsInJlc3BvbnNlIiwib25Db25uZWN0aW9uRXN0YWJsaXNoZWQiLCJDT05ORUNUSU5HIiwidW5kZWZpbmVkIiwicmVhc29uIiwiYnJhbmRDaGVjayIsImNsYW1wIiwicmVhc29uQnl0ZUxlbmd0aCIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJDTE9TSU5HIiwiQ0xPU0VEIiwiZnJhbWUiLCJmcmFtZURhdGEiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZSIsInNvY2tldCIsImNyZWF0ZUZyYW1lIiwiQ0xPU0UiLCJlcnIiLCJzZW5kIiwiZGF0YSIsIldlYlNvY2tldFNlbmREYXRhIiwidmFsdWUiLCJmcm9tIiwiYnVmZmVyIiwiVEVYVCIsImlzQXJyYXlCdWZmZXIiLCJCSU5BUlkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImFiIiwiYnl0ZU9mZnNldCIsImFycmF5QnVmZmVyIiwidGhlbiIsInJlYWR5U3RhdGUiLCJvbm9wZW4iLCJmbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25lcnJvciIsIm9uY2xvc2UiLCJvbm1lc3NhZ2UiLCJiaW5hcnlUeXBlIiwidHlwZSIsInBhcnNlciIsIm9uIiwib25QYXJzZXJEcmFpbiIsIndzIiwicmVzdW1lIiwiT1BFTiIsImhlYWRlcnNMaXN0IiwiZ2V0IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJET01TdHJpbmciLCJWIiwidXRpbCIsIlR5cGUiLCJpdGVyYXRvciIsIldlYlNvY2tldEluaXQiLCJkaWN0aW9uYXJ5Q29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiZGVmYXVsdFZhbHVlIiwibnVsbGFibGVDb252ZXJ0ZXIiLCJIZWFkZXJzSW5pdCIsIkJsb2IiLCJzdHJpY3QiLCJpc0FueUFycmF5QnVmZmVyIiwiQnVmZmVyU291cmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/websocket/websocket.js\n");

/***/ })

};
;